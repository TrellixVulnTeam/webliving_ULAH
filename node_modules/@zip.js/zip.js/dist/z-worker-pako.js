!function(){"use strict";const t=[];for(let e=0;e<256;e++){let s=e;for(let t=0;t<8;t++)1&s?s=s>>>1^3988292384:s>>>=1;t[e]=s}class e{constructor(t){this.crc=t||-1}append(e){let s=0|this.crc;for(let n=0,r=0|e.length;n<r;n++)s=s>>>8^t[255&(s^e[n])];this.crc=s}get(){return~this.crc}}const s={concat(t,e){if(0===t.length||0===e.length)return t.concat(e);const n=t[t.length-1],r=s.getPartial(n);return 32===r?t.concat(e):s._shiftRight(e,r,0|n,t.slice(0,t.length-1))},bitLength(t){const e=t.length;if(0===e)return 0;const n=t[e-1];return 32*(e-1)+s.getPartial(n)},clamp(t,e){if(32*t.length<e)return t;const n=(t=t.slice(0,Math.ceil(e/32))).length;return e&=31,n>0&&e&&(t[n-1]=s.partial(e,t[n-1]&2147483648>>e-1,1)),t},partial:(t,e,s)=>32===t?e:(s?0|e:e<<32-t)+1099511627776*t,getPartial:t=>Math.round(t/1099511627776)||32,_shiftRight(t,e,n,r){for(void 0===r&&(r=[]);e>=32;e-=32)r.push(n),n=0;if(0===e)return r.concat(t);for(let s=0;s<t.length;s++)r.push(n|t[s]>>>e),n=t[s]<<32-e;const i=t.length?t[t.length-1]:0,a=s.getPartial(i);return r.push(s.partial(e+a&31,e+a>32?n:r.pop(),1)),r}},n={bytes:{fromBits(t){const e=s.bitLength(t)/8,n=new Uint8Array(e);let r;for(let s=0;s<e;s++)0==(3&s)&&(r=t[s/4]),n[s]=r>>>24,r<<=8;return n},toBits(t){const e=[];let n,r=0;for(n=0;n<t.length;n++)r=r<<8|t[n],3==(3&n)&&(e.push(r),r=0);return 3&n&&e.push(s.partial(8*(3&n),r)),e}}},r={aes:class{constructor(t){const e=this;e._tables=[[[],[],[],[],[]],[[],[],[],[],[]]],e._tables[0][0][0]||e._precompute();const s=e._tables[0][4],n=e._tables[1],r=t.length;let i,a,h,c=1;if(4!==r&&6!==r&&8!==r)throw new Error("invalid aes key size");for(e._key=[a=t.slice(0),h=[]],i=r;i<4*r+28;i++){let t=a[i-1];(i%r==0||8===r&&i%r==4)&&(t=s[t>>>24]<<24^s[t>>16&255]<<16^s[t>>8&255]<<8^s[255&t],i%r==0&&(t=t<<8^t>>>24^c<<24,c=c<<1^283*(c>>7))),a[i]=a[i-r]^t}for(let t=0;i;t++,i--){const e=a[3&t?i:i-4];h[t]=i<=4||t<4?e:n[0][s[e>>>24]]^n[1][s[e>>16&255]]^n[2][s[e>>8&255]]^n[3][s[255&e]]}}encrypt(t){return this._crypt(t,0)}decrypt(t){return this._crypt(t,1)}_precompute(){const t=this._tables[0],e=this._tables[1],s=t[4],n=e[4],r=[],i=[];let a,h,c,o;for(let t=0;t<256;t++)i[(r[t]=t<<1^283*(t>>7))^t]=t;for(let l=a=0;!s[l];l^=h||1,a=i[a]||1){let i=a^a<<1^a<<2^a<<3^a<<4;i=i>>8^255&i^99,s[l]=i,n[i]=l,o=r[c=r[h=r[l]]];let p=16843009*o^65537*c^257*h^16843008*l,d=257*r[i]^16843008*i;for(let s=0;s<4;s++)t[s][l]=d=d<<24^d>>>8,e[s][i]=p=p<<24^p>>>8}for(let s=0;s<5;s++)t[s]=t[s].slice(0),e[s]=e[s].slice(0)}_crypt(t,e){if(4!==t.length)throw new Error("invalid aes block size");const s=this._key[e],n=s.length/4-2,r=[0,0,0,0],i=this._tables[e],a=i[0],h=i[1],c=i[2],o=i[3],l=i[4];let p,d,u,y=t[0]^s[0],g=t[e?3:1]^s[1],f=t[2]^s[2],w=t[e?1:3]^s[3],b=4;for(let t=0;t<n;t++)p=a[y>>>24]^h[g>>16&255]^c[f>>8&255]^o[255&w]^s[b],d=a[g>>>24]^h[f>>16&255]^c[w>>8&255]^o[255&y]^s[b+1],u=a[f>>>24]^h[w>>16&255]^c[y>>8&255]^o[255&g]^s[b+2],w=a[w>>>24]^h[y>>16&255]^c[g>>8&255]^o[255&f]^s[b+3],b+=4,y=p,g=d,f=u;for(let t=0;t<4;t++)r[e?3&-t:t]=l[y>>>24]<<24^l[g>>16&255]<<16^l[f>>8&255]<<8^l[255&w]^s[b++],p=y,y=g,g=f,f=w,w=p;return r}}},i={ctrGladman:class{constructor(t,e){this._prf=t,this._initIv=e,this._iv=e}reset(){this._iv=this._initIv}update(t){return this.calculate(this._prf,t,this._iv)}incWord(t){if(255==(t>>24&255)){let e=t>>16&255,s=t>>8&255,n=255&t;255===e?(e=0,255===s?(s=0,255===n?n=0:++n):++s):++e,t=0,t+=e<<16,t+=s<<8,t+=n}else t+=1<<24;return t}incCounter(t){0===(t[0]=this.incWord(t[0]))&&(t[1]=this.incWord(t[1]))}calculate(t,e,n){let r;if(!(r=e.length))return[];const i=s.bitLength(e);for(let s=0;s<r;s+=4){this.incCounter(n);const r=t.encrypt(n);e[s]^=r[0],e[s+1]^=r[1],e[s+2]^=r[2],e[s+3]^=r[3]}return s.clamp(e,i)}}},a="Invalid pasword",h=16,c={name:"PBKDF2"},o={name:"HMAC"},l="SHA-1",p=Object.assign({hash:o},c),d=Object.assign({iterations:1e3,hash:{name:l}},c),u=Object.assign({hash:l},o),y=["deriveBits"],g=["sign"],f=[8,12,16],w=[16,24,32],b=10,m=[0,0,0,0],A=crypto.subtle;class U{constructor(t,e,s){this.password=t,this.signed=e,this.strength=s-1,this.input=e&&new Uint8Array(0),this.pendingInput=new Uint8Array(0)}async append(t){if(this.password){const e=t.subarray(0,f[this.strength]+2);await async function(t,e,s){await C(t,s,e.subarray(0,f[t.strength]));const n=e.subarray(f[t.strength]),r=t.keys.passwordVerification;if(r[0]!=n[0]||r[1]!=n[1])throw new Error(a)}(this,e,this.password),this.password=null,this.aesCtrGladman=new i.ctrGladman(new r.aes(this.keys.key),Array.from(m)),t=t.subarray(f[this.strength]+2)}let e,s=new Uint8Array(t.length-b-(t.length-b)%h),c=t;for(this.pendingInput.length&&(c=_(this.pendingInput,t),s=v(s,c.length-b-(c.length-b)%h)),e=0;e<=c.length-b-h;e+=h){const t=c.subarray(e,e+h),r=n.bytes.toBits(t),i=this.aesCtrGladman.update(r);s.set(n.bytes.fromBits(i),e)}return this.pendingInput=c.subarray(e),this.signed&&(this.input=_(this.input,t)),s}async flush(){const t=this.pendingInput,e=this.keys,s=t.subarray(0,t.length-b),r=t.subarray(t.length-b);let i=new Uint8Array(0);if(s.length){const t=this.aesCtrGladman.update(n.bytes.toBits(s));i=n.bytes.fromBits(t)}let a=!0;if(this.signed){const t=await A.sign(o,e.authentication,this.input.subarray(0,this.input.length-b)),s=new Uint8Array(t).subarray(0,b);this.input=null;for(let t=0;t<b;t++)s[t]!=r[t]&&(a=!1)}return{valid:a,data:i}}}class k{constructor(t,e){this.password=t,this.strength=e-1,this.output=new Uint8Array(0),this.pendingInput=new Uint8Array(0)}async append(t){let e=new Uint8Array(0);this.password&&(e=await async function(t,e){const s=crypto.getRandomValues(new Uint8Array(f[t.strength]));return await C(t,e,s),_(s,t.keys.passwordVerification)}(this,this.password),this.password=null,this.aesCtrGladman=new i.ctrGladman(new r.aes(this.keys.key),Array.from(m)));let s,a=new Uint8Array(e.length+t.length-t.length%h);for(a.set(e,0),this.pendingInput.length&&(a=v(a,(t=_(this.pendingInput,t)).length-t.length%h)),s=0;s<=t.length-h;s+=h){const r=n.bytes.toBits(t.subarray(s,s+h)),i=this.aesCtrGladman.update(r);a.set(n.bytes.fromBits(i),s+e.length)}return this.pendingInput=t.subarray(s),this.output=_(this.output,a),a}async flush(){let t=new Uint8Array(0);if(this.pendingInput.length){const e=this.aesCtrGladman.update(n.bytes.toBits(this.pendingInput));t=n.bytes.fromBits(e),this.output=_(this.output,t)}const e=await A.sign(o,this.keys.authentication,this.output.subarray(f[this.strength]+2));this.output=null;const s=new Uint8Array(e).subarray(0,b);return{data:_(t,s),signature:s}}}async function C(t,e,s){const r=(new TextEncoder).encode(e),i=await A.importKey("raw",r,p,!1,y),a=await A.deriveBits(Object.assign({salt:s},d),i,8*(2*w[t.strength]+2)),h=new Uint8Array(a);t.keys={key:n.bytes.toBits(h.subarray(0,w[t.strength])),authentication:await A.importKey("raw",h.subarray(w[t.strength],2*w[t.strength]),u,!1,g),passwordVerification:h.subarray(2*w[t.strength])}}function _(t,e){let s=t;return t.length+e.length&&(s=new Uint8Array(t.length+e.length),s.set(t,0),s.set(e,t.length)),s}function v(t,e){if(e&&e>t.length){const s=t;(t=new Uint8Array(e)).set(s,0)}return t}const I=12;class D{constructor(t,e){this.password=t,this.passwordVerification=e,G(this,t)}async append(t){if(this.password){const e=z(this,t.subarray(0,I));if(this.password=null,e[11]!=this.passwordVerification)throw new Error(a);t=t.subarray(I)}return z(this,t)}async flush(){return{valid:!0,data:new Uint8Array(0)}}}class B{constructor(t,e){this.passwordVerification=e,this.password=t,G(this,t)}async append(t){let e,s;if(this.password){this.password=null;const n=crypto.getRandomValues(new Uint8Array(I));n[11]=this.passwordVerification,e=new Uint8Array(t.length+n.length),e.set(V(this,n),0),s=I}else e=new Uint8Array(t.length),s=0;return e.set(V(this,t),s),e}async flush(){return{data:new Uint8Array(0)}}}function z(t,e){const s=new Uint8Array(e.length);for(let n=0;n<e.length;n++)s[n]=M(t)^e[n],K(t,s[n]);return s}function V(t,e){const s=new Uint8Array(e.length);for(let n=0;n<e.length;n++)s[n]=M(t)^e[n],K(t,e[n]);return s}function G(t,s){t.keys=[305419896,591751049,878082192],t.crcKey0=new e(t.keys[0]),t.crcKey2=new e(t.keys[2]);for(let e=0;e<s.length;e++)K(t,s.charCodeAt(e))}function K(t,e){t.crcKey0.append([e]),t.keys[0]=~t.crcKey0.get(),t.keys[1]=W(t.keys[1]+E(t.keys[0])),t.keys[1]=W(Math.imul(t.keys[1],134775813)+1),t.crcKey2.append([t.keys[1]>>>24]),t.keys[2]=~t.crcKey2.get()}function M(t){const e=2|t.keys[2];return E(Math.imul(e,1^e)>>>8)}function E(t){return 255&t}function W(t){return 4294967295&t}const j="deflate",O="inflate",P="Invalid signature";class T{constructor(t,s){this.signature=s.signature,this.encrypted=Boolean(s.password),this.signed=s.signed,this.compressed=s.compressed,this.inflate=s.compressed&&new t,this.crc32=s.signed&&new e,this.zipCrypto=s.zipCrypto,this.decrypt=this.encrypted&&s.zipCrypto?new D(s.password,s.passwordVerification):new U(s.password,s.signed,s.encryptionStrength)}async append(t){return this.encrypted&&t.length&&(t=await this.decrypt.append(t)),this.compressed&&t.length&&(t=await this.inflate.append(t)),(!this.encrypted||this.zipCrypto)&&this.signed&&t.length&&this.crc32.append(t),t}async flush(){let t,e=new Uint8Array(0);if(this.encrypted){const t=await this.decrypt.flush();if(!t.valid)throw new Error(P);e=t.data}if((!this.encrypted||this.zipCrypto)&&this.signed){const e=new DataView(new Uint8Array(4).buffer);if(t=this.crc32.get(),e.setUint32(0,t),this.signature!=e.getUint32(0,!1))throw new Error(P)}return this.compressed&&(e=await this.inflate.append(e)||new Uint8Array(0),await this.inflate.flush()),{data:e,signature:t}}}class L{constructor(t,s){this.encrypted=s.encrypted,this.signed=s.signed,this.compressed=s.compressed,this.deflate=s.compressed&&new t({level:s.level||5}),this.crc32=s.signed&&new e,this.zipCrypto=s.zipCrypto,this.encrypt=this.encrypted&&s.zipCrypto?new B(s.password,s.passwordVerification):new k(s.password,s.encryptionStrength)}async append(t){let e=t;return this.compressed&&t.length&&(e=await this.deflate.append(t)),this.encrypted&&e.length&&(e=await this.encrypt.append(e)),(!this.encrypted||this.zipCrypto)&&this.signed&&t.length&&this.crc32.append(t),e}async flush(){let t,e=new Uint8Array(0);if(this.compressed&&(e=await this.deflate.flush()||new Uint8Array(0)),this.encrypted){e=await this.encrypt.append(e);const s=await this.encrypt.flush();t=s.signature;const n=new Uint8Array(e.length+s.data.length);n.set(e,0),n.set(s.data,e.length),e=n}return this.encrypted&&!this.zipCrypto||!this.signed||(t=this.crc32.get()),{data:e,signature:t}}}const R={init(t){t.scripts&&t.scripts.length&&importScripts.apply(void 0,t.scripts);const e=t.options;let s;self.initCodec&&self.initCodec(),e.codecType.startsWith(j)?s=self.Deflate:e.codecType.startsWith(O)&&(s=self.Inflate),S=function(t,e){return e.codecType.startsWith(j)?new L(t,e):e.codecType.startsWith(O)?new T(t,e):void 0}(s,e)},append:async t=>({data:await S.append(t.data)}),flush:()=>S.flush()};let S;addEventListener("message",(async t=>{const e=t.data,s=e.type,n=R[s];if(n)try{e.data&&(e.data=new Uint8Array(e.data));const t=await n(e)||{};if(t.type=s,t.data)try{t.data=t.data.buffer,postMessage(t,[t.data])}catch(e){postMessage(t)}else postMessage(t)}catch(t){postMessage({type:s,error:{message:t.message,stack:t.stack}})}}));function H(t,e,s){return class{constructor(n){this.codec=new t(Object.assign({},e,n)),s(this.codec,(t=>{if(this.pendingData){const e=this.pendingData;this.pendingData=new Uint8Array(e.length+t.length),this.pendingData.set(e,0),this.pendingData.set(t,e.length)}else this.pendingData=new Uint8Array(t)}))}async append(t){return this.codec.push(t),n(this)}async flush(){return this.codec.push(new Uint8Array(0),!0),n(this)}};function n(t){if(t.pendingData){const e=t.pendingData;return t.pendingData=null,e}return new Uint8Array(0)}}self.initCodec=()=>{const{Deflate:t,Inflate:e}=((t,e={},s)=>({Deflate:H(t.Deflate,e.deflate,s),Inflate:H(t.Inflate,e.inflate,s)}))(pako,{deflate:{raw:!0},inflate:{raw:!0}},((t,e)=>t.onData=e));self.Deflate=t,self.Inflate=e}}();
