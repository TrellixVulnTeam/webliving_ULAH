"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.replaceTscAliasPaths = void 0;
const console_utils_1 = require("@jfonx/console-utils");
const chokidar_1 = require("chokidar");
const fs_1 = require("fs");
const globby_1 = require("globby");
const normalizePath = require("normalize-path");
const path_1 = require("path");
const helpers_1 = require("./helpers");
function replaceTscAliasPaths(options = {
    watch: false
}) {
    console_utils_1.Output.info('=== tsc-alias starting ===');
    if (!options.configFile) {
        options.configFile = path_1.resolve(process.cwd(), 'tsconfig.json');
    }
    else {
        if (!path_1.isAbsolute(options.configFile)) {
            options.configFile = path_1.resolve(process.cwd(), options.configFile);
        }
    }
    const configFile = options.configFile;
    if (!fs_1.existsSync(configFile)) {
        console_utils_1.Output.error(`Invalid file path => ${configFile}`, true);
    }
    let { baseUrl, outDir, paths } = helpers_1.loadConfig(configFile);
    if (options.outDir) {
        outDir = options.outDir;
    }
    if (!baseUrl) {
        console_utils_1.Output.error('compilerOptions.baseUrl is not set', true);
    }
    if (!paths) {
        console_utils_1.Output.error('compilerOptions.paths is not set', true);
    }
    if (!outDir) {
        console_utils_1.Output.error('compilerOptions.outDir is not set', true);
    }
    const configDir = normalizePath(path_1.dirname(configFile));
    const outPath = normalizePath(path_1.normalize(configDir + '/' + outDir));
    const confDirParentFolderName = path_1.basename(configDir);
    let hasExtraModule = false;
    let configDirInOutPath = null;
    let relConfDirPathInOutPath;
    const aliases = Object.keys(paths)
        .map((alias) => {
        const _paths = paths[alias].map((path) => {
            path = path.replace(/\*$/, '').replace('.t', '.j');
            if (path_1.isAbsolute(path)) {
                path = path_1.relative(configDir, path);
            }
            return path;
        });
        const path = _paths[0];
        const isExtra = null;
        const basePath = null;
        if (path_1.normalize(path).includes('..')) {
            if (!configDirInOutPath) {
                configDirInOutPath = helpers_1.getProjectDirPathInOutDir(outPath, confDirParentFolderName);
                if (configDirInOutPath) {
                    hasExtraModule = true;
                }
                if (configDirInOutPath) {
                    const stepsbackPath = path_1.relative(configDirInOutPath, outPath);
                    const splitStepBackPath = normalizePath(stepsbackPath).split('/');
                    const nbOfStepBack = splitStepBackPath.length;
                    const splitConfDirInOutPath = configDirInOutPath.split('/');
                    let i = 1;
                    const splitRelPath = [];
                    while (i <= nbOfStepBack) {
                        splitRelPath.unshift(splitConfDirInOutPath[splitConfDirInOutPath.length - i]);
                        i++;
                    }
                    relConfDirPathInOutPath = splitRelPath.join('/');
                }
            }
        }
        let prefix = alias.replace(/\*$/, '');
        if (prefix[prefix.length - 1] === '/') {
            prefix = prefix.substring(0, prefix.length - 1);
        }
        return {
            prefix,
            basePath,
            path,
            paths: _paths,
            isExtra
        };
    })
        .filter(({ prefix }) => prefix);
    aliases.forEach((alias) => {
        if (path_1.normalize(alias.path).includes('..')) {
            const tempBasePath = normalizePath(path_1.normalize(`${configDir}/${outDir}/${hasExtraModule && relConfDirPathInOutPath
                ? relConfDirPathInOutPath
                : ''}/${baseUrl}`));
            const absoluteBasePath = normalizePath(path_1.normalize(`${tempBasePath}/${alias.path}`));
            if (helpers_1.existsResolvedAlias(absoluteBasePath)) {
                alias.isExtra = false;
                alias.basePath = tempBasePath;
            }
            else {
                alias.isExtra = true;
                alias.basePath = absoluteBasePath;
            }
        }
        else if (hasExtraModule) {
            alias.isExtra = false;
            alias.basePath = normalizePath(path_1.normalize(`${configDir}/${outDir}/${relConfDirPathInOutPath}/${baseUrl}`));
        }
        else {
            alias.basePath = normalizePath(path_1.normalize(`${configDir}/${outDir}`));
            alias.isExtra = false;
        }
    });
    const requireRegex = /(?:import|require)\(['"]([^'"]*)['"]\)/g;
    const importRegex = /(?:import|from) ['"]([^'"]*)['"]/g;
    const replaceImportStatement = ({ orig, file, alias }) => {
        const requiredModule = orig.split(/"|'/)[1];
        const index = orig.indexOf(alias.prefix);
        const isAlias = requiredModule.includes('/')
            ? requiredModule.startsWith(alias.prefix + '/')
            : requiredModule.startsWith(alias.prefix);
        if (index > -1 && isAlias) {
            let absoluteAliasPath = helpers_1.getAbsoluteAliasPath(alias.basePath, alias.path);
            let relativeAliasPath = normalizePath(path_1.relative(path_1.dirname(file), absoluteAliasPath));
            if (!relativeAliasPath.startsWith('.')) {
                relativeAliasPath = './' + relativeAliasPath;
            }
            const modulePath = orig.substring(0, index) +
                relativeAliasPath +
                orig.substring(index + alias.prefix.length);
            return modulePath.replace(/\/\//g, '/');
        }
        return orig;
    };
    const replaceAlias = (file) => {
        const code = fs_1.readFileSync(file, 'utf8');
        let tempCode = code;
        for (const alias of aliases) {
            const replacementParams = {
                file,
                alias
            };
            tempCode = tempCode
                .replace(requireRegex, (orig) => replaceImportStatement(Object.assign({ orig }, replacementParams)))
                .replace(importRegex, (orig) => replaceImportStatement(Object.assign({ orig }, replacementParams)));
        }
        if (code !== tempCode) {
            fs_1.writeFileSync(file, tempCode, 'utf8');
            return true;
        }
        return false;
    };
    const globPattern = [
        `${outPath}/**/*.{js,jsx,ts,tsx}`,
        `!${outPath}/**/node_modules`
    ];
    const files = globby_1.sync(globPattern, {
        dot: true,
        onlyFiles: true
    });
    const flen = files.length;
    let replaceCount = 0;
    for (let i = 0; i < flen; i += 1) {
        const file = files[i];
        if (replaceAlias(file)) {
            replaceCount++;
        }
    }
    console_utils_1.Output.info(`${replaceCount} files were affected!`);
    if (options.watch) {
        console_utils_1.Output.info('[Watching for file changes...]');
        const filesWatcher = chokidar_1.watch(globPattern);
        const tsconfigWatcher = chokidar_1.watch(configFile);
        filesWatcher.on('change', (file) => {
            replaceAlias(file);
        });
        tsconfigWatcher.on('change', (_) => {
            console_utils_1.Output.clear();
            filesWatcher.close();
            tsconfigWatcher.close();
            replaceTscAliasPaths(options);
        });
    }
}
exports.replaceTscAliasPaths = replaceTscAliasPaths;
//# sourceMappingURL=index.js.map