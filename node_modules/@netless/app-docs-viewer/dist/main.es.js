var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var styles = ".netless-app-docs-viewer-content{position:relative;height:100%;overflow:hidden}.netless-app-docs-viewer-preview-mask{display:none;position:absolute;z-index:200;top:0;left:0;width:100%;height:100%}.netless-app-docs-viewer-preview{display:flex;flex-direction:column;align-items:center;position:absolute;z-index:300;top:0;left:0;width:33%;max-width:200px;height:100%;padding-top:10px;transform:translate(-100%);background:rgba(237,237,240,.9);box-shadow:inset -1px 0 #0000001c;transition:transform .4s}.netless-app-docs-viewer-preview-active .netless-app-docs-viewer-preview-mask{display:block}.netless-app-docs-viewer-preview-active .netless-app-docs-viewer-preview{transform:translate(0)}.netless-app-docs-viewer-preview-page{position:relative;display:block;width:55%;margin-bottom:10px;font-size:0;color:transparent;outline:none;border:7px solid transparent;border-radius:4px;transition:border-color .3s;user-select:none}.netless-app-docs-viewer-preview-page:hover,.netless-app-docs-viewer-preview-page.netless-app-docs-viewer-preview-page-active{border-color:#444e601a}.netless-app-docs-viewer-preview-page>img{width:100%;height:auto;box-sizing:border-box;border:1px solid rgba(0,0,0,.5);border-radius:1px;background-color:#fff;box-shadow:0 2px 8px #0000004d}.netless-app-docs-viewer-preview-page-name{position:absolute;top:1px;left:-10px;transform:translate(-100%);text-align:right;font-size:12px;color:#5f5f5f;user-select:none}.netless-app-docs-viewer-footer{box-sizing:border-box;height:26px;display:flex;align-items:center;padding:0 16px;border-top:1px solid #eeeef7;color:#191919}.netless-app-docs-viewer-float-footer{width:100%;min-height:26px;position:absolute;left:0;bottom:0;z-index:2000;background:rgba(249,249,252,.9);transition:opacity .4s}.netless-app-docs-viewer-footer-btn{box-sizing:border-box;width:26px;height:26px;font-size:0;margin:0;padding:3px;border:none;border-radius:1px;outline:none;color:currentColor;background:transparent;transition:background .4s;cursor:pointer;user-select:none;-webkit-tap-highlight-color:rgba(0,0,0,0)}.netless-app-docs-viewer-footer-btn:hover{background:rgba(237,237,240,.9)}@media (hover: none){.netless-app-docs-viewer-footer-btn:hover{background:transparent!important}}.netless-app-docs-viewer-footer-btn>svg{width:100%;height:100%}.netless-app-docs-viewer-footer-btn>svg:nth-of-type(2){display:none}.netless-app-docs-viewer-footer-btn.netless-app-docs-viewer-footer-btn-playing>svg:nth-of-type(1){display:none}.netless-app-docs-viewer-footer-btn.netless-app-docs-viewer-footer-btn-playing>svg:nth-of-type(2){display:initial}.netless-app-docs-viewer-footer-btn~.netless-app-docs-viewer-footer-btn{margin-left:15px}.netless-app-docs-viewer-page-jumps{flex:1;display:flex;justify-content:center;align-items:center}.netless-app-docs-viewer-page-number{margin-left:auto;font-size:13px;user-select:none;white-space:nowrap;word-break:keep-all}.netless-app-docs-viewer-page-number-input{border:none;outline:none;width:1.5em;margin:0;padding:0 2px;text-align:right;font-size:13px;line-height:1;font-weight:400;font-family:inherit;border-radius:2px;color:currentColor;background:transparent;transition:background .4s;user-select:text;-webkit-tap-highlight-color:rgba(0,0,0,0)}.netless-app-docs-viewer-page-number-input:hover,.netless-app-docs-viewer-page-number-input:focus,.netless-app-docs-viewer-page-number-input:active{background:#fff;box-shadow:#63636333 0 2px 8px}.netless-app-docs-viewer-readonly .netless-app-docs-viewer-footer-btn{cursor:not-allowed}.netless-app-docs-viewer-readonly .netless-app-docs-viewer-footer-btn:hover{background:transparent}.netless-app-docs-viewer-readonly .netless-app-docs-viewer-page-number-input{cursor:not-allowed}.netless-app-docs-viewer-readonly .netless-app-docs-viewer-page-number-input:hover,.netless-app-docs-viewer-readonly .netless-app-docs-viewer-page-number-input:focus,.netless-app-docs-viewer-readonly .netless-app-docs-viewer-page-number-input:active{background:transparent;box-shadow:none}.netless-app-docs-viewer-readonly .netless-app-docs-viewer-page-number-input:disabled{color:inherit}.netless-app-docs-viewer-readonly.netless-app-docs-viewer-float-footer{display:none}.telebox-color-scheme-dark .netless-app-docs-viewer-page-number-input{color:#a6a6a8}.telebox-color-scheme-dark .netless-app-docs-viewer-page-number-input:active,.telebox-color-scheme-dark .netless-app-docs-viewer-page-number-input:focus,.telebox-color-scheme-dark .netless-app-docs-viewer-page-number-input:hover{color:#222}.telebox-color-scheme-dark .netless-app-docs-viewer-footer{color:#a6a6a8;background:#2d2d33;border-top:none}.telebox-color-scheme-dark .netless-app-docs-viewer-footer-btn:hover{background:#212126}.telebox-color-scheme-dark .netless-app-docs-viewer-preview{background:rgba(50,50,50,.9)}.netless-app-docs-viewer-static-pages{overflow:hidden;position:relative;height:100%;user-select:none}.netless-app-docs-viewer-static-pages:hover .netless-app-docs-viewer-static-scrollbar{opacity:1}.netless-app-docs-viewer-static-page{display:block;width:100%;height:auto;user-select:none}.netless-app-docs-viewer-static-wb-view{position:absolute;top:0;left:0;width:100%;height:100%;z-index:100;overflow:hidden}.netless-app-docs-viewer-static-scrollbar{position:absolute;top:0;right:0;z-index:2147483647;width:8px;min-height:30px;margin:0;padding:0;border:none;outline:none;border-radius:4px;background:rgba(68,78,96,.1);opacity:0;transition:background .4s,opacity .4s,transform .2s;will-change:transform,height;user-select:none}.netless-app-docs-viewer-static-scrollbar.netless-app-docs-viewer-static-scrollbar-dragging{background:rgba(68,78,96,.2);opacity:1;transition:background .4s,opacity .4s}.netless-app-docs-viewer-static-scrollbar:hover,.netless-app-docs-viewer-static-scrollbar:focus{background:rgba(68,78,96,.2)}.netless-app-docs-viewer-static-scrollbar:active{background:rgba(68,78,96,.2)}.netless-app-docs-viewer-content:hover .netless-app-docs-viewer-static-scrollbar{opacity:1}.netless-app-docs-viewer-readonly .netless-app-docs-viewer-static-scrollbar{display:none}.netless-app-docs-viewer-dynamic-wb-view{position:absolute;top:0;left:0;width:100%;height:100%;z-index:100;overflow:hidden}.netless-app-docs-viewer-dynamic-wb-view .cursor-clicker .ppt-event-source{cursor:pointer}\n";
const runningOnBrowser = typeof window !== "undefined";
const isBot = runningOnBrowser && !("onscroll" in window) || typeof navigator !== "undefined" && /(gle|ing|ro)bot|crawl|spider/i.test(navigator.userAgent);
const supportsIntersectionObserver = runningOnBrowser && "IntersectionObserver" in window;
const supportsClassList = runningOnBrowser && "classList" in document.createElement("p");
const isHiDpi = runningOnBrowser && window.devicePixelRatio > 1;
const defaultSettings = {
  elements_selector: ".lazy",
  container: isBot || runningOnBrowser ? document : null,
  threshold: 300,
  thresholds: null,
  data_src: "src",
  data_srcset: "srcset",
  data_sizes: "sizes",
  data_bg: "bg",
  data_bg_hidpi: "bg-hidpi",
  data_bg_multi: "bg-multi",
  data_bg_multi_hidpi: "bg-multi-hidpi",
  data_poster: "poster",
  class_applied: "applied",
  class_loading: "loading",
  class_loaded: "loaded",
  class_error: "error",
  class_entered: "entered",
  class_exited: "exited",
  unobserve_completed: true,
  unobserve_entered: false,
  cancel_on_exit: true,
  callback_enter: null,
  callback_exit: null,
  callback_applied: null,
  callback_loading: null,
  callback_loaded: null,
  callback_error: null,
  callback_finish: null,
  callback_cancel: null,
  use_native: false
};
const getExtendedSettings = (customSettings) => {
  return Object.assign({}, defaultSettings, customSettings);
};
const createInstance = function(classObj, options) {
  let event;
  const eventString = "LazyLoad::Initialized";
  const instance = new classObj(options);
  try {
    event = new CustomEvent(eventString, { detail: { instance } });
  } catch (err) {
    event = document.createEvent("CustomEvent");
    event.initCustomEvent(eventString, false, false, { instance });
  }
  window.dispatchEvent(event);
};
const autoInitialize = (classObj, options) => {
  if (!options) {
    return;
  }
  if (!options.length) {
    createInstance(classObj, options);
  } else {
    for (let i = 0, optionsItem; optionsItem = options[i]; i += 1) {
      createInstance(classObj, optionsItem);
    }
  }
};
const SRC = "src";
const SRCSET = "srcset";
const SIZES = "sizes";
const POSTER = "poster";
const ORIGINALS = "llOriginalAttrs";
const statusLoading = "loading";
const statusLoaded = "loaded";
const statusApplied = "applied";
const statusEntered = "entered";
const statusError = "error";
const statusNative = "native";
const dataPrefix = "data-";
const statusDataName = "ll-status";
const getData = (element, attribute) => {
  return element.getAttribute(dataPrefix + attribute);
};
const setData = (element, attribute, value) => {
  var attrName = dataPrefix + attribute;
  if (value === null) {
    element.removeAttribute(attrName);
    return;
  }
  element.setAttribute(attrName, value);
};
const getStatus = (element) => getData(element, statusDataName);
const setStatus = (element, status) => setData(element, statusDataName, status);
const resetStatus = (element) => setStatus(element, null);
const hasEmptyStatus = (element) => getStatus(element) === null;
const hasStatusLoading = (element) => getStatus(element) === statusLoading;
const hasStatusError = (element) => getStatus(element) === statusError;
const hasStatusNative = (element) => getStatus(element) === statusNative;
const statusesAfterLoading = [statusLoading, statusLoaded, statusApplied, statusError];
const hadStartedLoading = (element) => statusesAfterLoading.indexOf(getStatus(element)) >= 0;
const safeCallback = (callback, arg1, arg2, arg3) => {
  if (!callback) {
    return;
  }
  if (arg3 !== void 0) {
    callback(arg1, arg2, arg3);
    return;
  }
  if (arg2 !== void 0) {
    callback(arg1, arg2);
    return;
  }
  callback(arg1);
};
const addClass = (element, className) => {
  if (supportsClassList) {
    element.classList.add(className);
    return;
  }
  element.className += (element.className ? " " : "") + className;
};
const removeClass = (element, className) => {
  if (supportsClassList) {
    element.classList.remove(className);
    return;
  }
  element.className = element.className.replace(new RegExp("(^|\\s+)" + className + "(\\s+|$)"), " ").replace(/^\s+/, "").replace(/\s+$/, "");
};
const addTempImage = (element) => {
  element.llTempImage = document.createElement("IMG");
};
const deleteTempImage = (element) => {
  delete element.llTempImage;
};
const getTempImage = (element) => element.llTempImage;
const unobserve = (element, instance) => {
  if (!instance)
    return;
  const observer = instance._observer;
  if (!observer)
    return;
  observer.unobserve(element);
};
const resetObserver = (observer) => {
  observer.disconnect();
};
const unobserveEntered = (element, settings, instance) => {
  if (settings.unobserve_entered)
    unobserve(element, instance);
};
const updateLoadingCount = (instance, delta) => {
  if (!instance)
    return;
  instance.loadingCount += delta;
};
const decreaseToLoadCount = (instance) => {
  if (!instance)
    return;
  instance.toLoadCount -= 1;
};
const setToLoadCount = (instance, value) => {
  if (!instance)
    return;
  instance.toLoadCount = value;
};
const isSomethingLoading = (instance) => instance.loadingCount > 0;
const haveElementsToLoad = (instance) => instance.toLoadCount > 0;
const getSourceTags = (parentTag) => {
  let sourceTags = [];
  for (let i = 0, childTag; childTag = parentTag.children[i]; i += 1) {
    if (childTag.tagName === "SOURCE") {
      sourceTags.push(childTag);
    }
  }
  return sourceTags;
};
const forEachPictureSource = (element, fn) => {
  const parent = element.parentNode;
  if (!parent || parent.tagName !== "PICTURE") {
    return;
  }
  let sourceTags = getSourceTags(parent);
  sourceTags.forEach(fn);
};
const forEachVideoSource = (element, fn) => {
  let sourceTags = getSourceTags(element);
  sourceTags.forEach(fn);
};
const attrsSrc = [SRC];
const attrsSrcPoster = [SRC, POSTER];
const attrsSrcSrcsetSizes = [SRC, SRCSET, SIZES];
const hasOriginalAttrs = (element) => !!element[ORIGINALS];
const getOriginalAttrs = (element) => element[ORIGINALS];
const deleteOriginalAttrs = (element) => delete element[ORIGINALS];
const setOriginalsObject = (element, attributes) => {
  if (hasOriginalAttrs(element)) {
    return;
  }
  const originals = {};
  attributes.forEach((attribute) => {
    originals[attribute] = element.getAttribute(attribute);
  });
  element[ORIGINALS] = originals;
};
const saveOriginalBackgroundStyle = (element) => {
  if (hasOriginalAttrs(element)) {
    return;
  }
  element[ORIGINALS] = { backgroundImage: element.style.backgroundImage };
};
const setOrResetAttribute = (element, attrName, value) => {
  if (!value) {
    element.removeAttribute(attrName);
    return;
  }
  element.setAttribute(attrName, value);
};
const restoreOriginalAttrs = (element, attributes) => {
  if (!hasOriginalAttrs(element)) {
    return;
  }
  const originals = getOriginalAttrs(element);
  attributes.forEach((attribute) => {
    setOrResetAttribute(element, attribute, originals[attribute]);
  });
};
const restoreOriginalBgImage = (element) => {
  if (!hasOriginalAttrs(element)) {
    return;
  }
  const originals = getOriginalAttrs(element);
  element.style.backgroundImage = originals.backgroundImage;
};
const manageApplied = (element, settings, instance) => {
  addClass(element, settings.class_applied);
  setStatus(element, statusApplied);
  if (!instance)
    return;
  if (settings.unobserve_completed) {
    unobserve(element, settings);
  }
  safeCallback(settings.callback_applied, element, instance);
};
const manageLoading = (element, settings, instance) => {
  addClass(element, settings.class_loading);
  setStatus(element, statusLoading);
  if (!instance)
    return;
  updateLoadingCount(instance, 1);
  safeCallback(settings.callback_loading, element, instance);
};
const setAttributeIfValue = (element, attrName, value) => {
  if (!value) {
    return;
  }
  element.setAttribute(attrName, value);
};
const setImageAttributes = (element, settings) => {
  setAttributeIfValue(element, SIZES, getData(element, settings.data_sizes));
  setAttributeIfValue(element, SRCSET, getData(element, settings.data_srcset));
  setAttributeIfValue(element, SRC, getData(element, settings.data_src));
};
const setSourcesImg = (imgEl, settings) => {
  forEachPictureSource(imgEl, (sourceTag) => {
    setOriginalsObject(sourceTag, attrsSrcSrcsetSizes);
    setImageAttributes(sourceTag, settings);
  });
  setOriginalsObject(imgEl, attrsSrcSrcsetSizes);
  setImageAttributes(imgEl, settings);
};
const setSourcesIframe = (iframe, settings) => {
  setOriginalsObject(iframe, attrsSrc);
  setAttributeIfValue(iframe, SRC, getData(iframe, settings.data_src));
};
const setSourcesVideo = (videoEl, settings) => {
  forEachVideoSource(videoEl, (sourceEl) => {
    setOriginalsObject(sourceEl, attrsSrc);
    setAttributeIfValue(sourceEl, SRC, getData(sourceEl, settings.data_src));
  });
  setOriginalsObject(videoEl, attrsSrcPoster);
  setAttributeIfValue(videoEl, POSTER, getData(videoEl, settings.data_poster));
  setAttributeIfValue(videoEl, SRC, getData(videoEl, settings.data_src));
  videoEl.load();
};
const setBackground = (element, settings, instance) => {
  const bg1xValue = getData(element, settings.data_bg);
  const bgHiDpiValue = getData(element, settings.data_bg_hidpi);
  const bgDataValue = isHiDpi && bgHiDpiValue ? bgHiDpiValue : bg1xValue;
  if (!bgDataValue)
    return;
  element.style.backgroundImage = `url("${bgDataValue}")`;
  getTempImage(element).setAttribute(SRC, bgDataValue);
  manageLoading(element, settings, instance);
};
const setMultiBackground = (element, settings, instance) => {
  const bg1xValue = getData(element, settings.data_bg_multi);
  const bgHiDpiValue = getData(element, settings.data_bg_multi_hidpi);
  const bgDataValue = isHiDpi && bgHiDpiValue ? bgHiDpiValue : bg1xValue;
  if (!bgDataValue) {
    return;
  }
  element.style.backgroundImage = bgDataValue;
  manageApplied(element, settings, instance);
};
const setSourcesFunctions = {
  IMG: setSourcesImg,
  IFRAME: setSourcesIframe,
  VIDEO: setSourcesVideo
};
const setSourcesNative = (element, settings) => {
  const setSourcesFunction = setSourcesFunctions[element.tagName];
  if (!setSourcesFunction) {
    return;
  }
  setSourcesFunction(element, settings);
};
const setSources = (element, settings, instance) => {
  const setSourcesFunction = setSourcesFunctions[element.tagName];
  if (!setSourcesFunction) {
    return;
  }
  setSourcesFunction(element, settings);
  manageLoading(element, settings, instance);
};
const elementsWithLoadEvent = ["IMG", "IFRAME", "VIDEO"];
const hasLoadEvent = (element) => elementsWithLoadEvent.indexOf(element.tagName) > -1;
const checkFinish = (settings, instance) => {
  if (instance && !isSomethingLoading(instance) && !haveElementsToLoad(instance)) {
    safeCallback(settings.callback_finish, instance);
  }
};
const addEventListener = (element, eventName, handler) => {
  element.addEventListener(eventName, handler);
  element.llEvLisnrs[eventName] = handler;
};
const removeEventListener = (element, eventName, handler) => {
  element.removeEventListener(eventName, handler);
};
const hasEventListeners = (element) => {
  return !!element.llEvLisnrs;
};
const addEventListeners = (element, loadHandler2, errorHandler2) => {
  if (!hasEventListeners(element))
    element.llEvLisnrs = {};
  const loadEventName = element.tagName === "VIDEO" ? "loadeddata" : "load";
  addEventListener(element, loadEventName, loadHandler2);
  addEventListener(element, "error", errorHandler2);
};
const removeEventListeners = (element) => {
  if (!hasEventListeners(element)) {
    return;
  }
  const eventListeners = element.llEvLisnrs;
  for (let eventName in eventListeners) {
    const handler = eventListeners[eventName];
    removeEventListener(element, eventName, handler);
  }
  delete element.llEvLisnrs;
};
const doneHandler = (element, settings, instance) => {
  deleteTempImage(element);
  updateLoadingCount(instance, -1);
  decreaseToLoadCount(instance);
  removeClass(element, settings.class_loading);
  if (settings.unobserve_completed) {
    unobserve(element, instance);
  }
};
const loadHandler = (event, element, settings, instance) => {
  const goingNative = hasStatusNative(element);
  doneHandler(element, settings, instance);
  addClass(element, settings.class_loaded);
  setStatus(element, statusLoaded);
  safeCallback(settings.callback_loaded, element, instance);
  if (!goingNative)
    checkFinish(settings, instance);
};
const errorHandler = (event, element, settings, instance) => {
  const goingNative = hasStatusNative(element);
  doneHandler(element, settings, instance);
  addClass(element, settings.class_error);
  setStatus(element, statusError);
  safeCallback(settings.callback_error, element, instance);
  if (!goingNative)
    checkFinish(settings, instance);
};
const addOneShotEventListeners = (element, settings, instance) => {
  const elementToListenTo = getTempImage(element) || element;
  if (hasEventListeners(elementToListenTo)) {
    return;
  }
  const _loadHandler = (event) => {
    loadHandler(event, element, settings, instance);
    removeEventListeners(elementToListenTo);
  };
  const _errorHandler = (event) => {
    errorHandler(event, element, settings, instance);
    removeEventListeners(elementToListenTo);
  };
  addEventListeners(elementToListenTo, _loadHandler, _errorHandler);
};
const loadBackground = (element, settings, instance) => {
  addTempImage(element);
  addOneShotEventListeners(element, settings, instance);
  saveOriginalBackgroundStyle(element);
  setBackground(element, settings, instance);
  setMultiBackground(element, settings, instance);
};
const loadRegular = (element, settings, instance) => {
  addOneShotEventListeners(element, settings, instance);
  setSources(element, settings, instance);
};
const load = (element, settings, instance) => {
  if (hasLoadEvent(element)) {
    loadRegular(element, settings, instance);
  } else {
    loadBackground(element, settings, instance);
  }
};
const loadNative = (element, settings, instance) => {
  element.setAttribute("loading", "lazy");
  addOneShotEventListeners(element, settings, instance);
  setSourcesNative(element, settings);
  setStatus(element, statusNative);
};
const removeImageAttributes = (element) => {
  element.removeAttribute(SRC);
  element.removeAttribute(SRCSET);
  element.removeAttribute(SIZES);
};
const resetSourcesImg = (element) => {
  forEachPictureSource(element, (sourceTag) => {
    removeImageAttributes(sourceTag);
  });
  removeImageAttributes(element);
};
const restoreImg = (imgEl) => {
  forEachPictureSource(imgEl, (sourceEl) => {
    restoreOriginalAttrs(sourceEl, attrsSrcSrcsetSizes);
  });
  restoreOriginalAttrs(imgEl, attrsSrcSrcsetSizes);
};
const restoreVideo = (videoEl) => {
  forEachVideoSource(videoEl, (sourceEl) => {
    restoreOriginalAttrs(sourceEl, attrsSrc);
  });
  restoreOriginalAttrs(videoEl, attrsSrcPoster);
  videoEl.load();
};
const restoreIframe = (iframeEl) => {
  restoreOriginalAttrs(iframeEl, attrsSrc);
};
const restoreFunctions = {
  IMG: restoreImg,
  IFRAME: restoreIframe,
  VIDEO: restoreVideo
};
const restoreAttributes = (element) => {
  const restoreFunction = restoreFunctions[element.tagName];
  if (!restoreFunction) {
    restoreOriginalBgImage(element);
    return;
  }
  restoreFunction(element);
};
const resetClasses = (element, settings) => {
  if (hasEmptyStatus(element) || hasStatusNative(element)) {
    return;
  }
  removeClass(element, settings.class_entered);
  removeClass(element, settings.class_exited);
  removeClass(element, settings.class_applied);
  removeClass(element, settings.class_loading);
  removeClass(element, settings.class_loaded);
  removeClass(element, settings.class_error);
};
const restore = (element, settings) => {
  restoreAttributes(element);
  resetClasses(element, settings);
  resetStatus(element);
  deleteOriginalAttrs(element);
};
const cancelLoading = (element, entry, settings, instance) => {
  if (!settings.cancel_on_exit)
    return;
  if (!hasStatusLoading(element))
    return;
  if (element.tagName !== "IMG")
    return;
  removeEventListeners(element);
  resetSourcesImg(element);
  restoreImg(element);
  removeClass(element, settings.class_loading);
  updateLoadingCount(instance, -1);
  resetStatus(element);
  safeCallback(settings.callback_cancel, element, entry, instance);
};
const onEnter = (element, entry, settings, instance) => {
  const dontLoad = hadStartedLoading(element);
  setStatus(element, statusEntered);
  addClass(element, settings.class_entered);
  removeClass(element, settings.class_exited);
  unobserveEntered(element, settings, instance);
  safeCallback(settings.callback_enter, element, entry, instance);
  if (dontLoad)
    return;
  load(element, settings, instance);
};
const onExit = (element, entry, settings, instance) => {
  if (hasEmptyStatus(element))
    return;
  addClass(element, settings.class_exited);
  cancelLoading(element, entry, settings, instance);
  safeCallback(settings.callback_exit, element, entry, instance);
};
const tagsWithNativeLazy = ["IMG", "IFRAME", "VIDEO"];
const shouldUseNative = (settings) => settings.use_native && "loading" in HTMLImageElement.prototype;
const loadAllNative = (elements, settings, instance) => {
  elements.forEach((element) => {
    if (tagsWithNativeLazy.indexOf(element.tagName) === -1) {
      return;
    }
    loadNative(element, settings, instance);
  });
  setToLoadCount(instance, 0);
};
const isIntersecting = (entry) => entry.isIntersecting || entry.intersectionRatio > 0;
const getObserverSettings = (settings) => ({
  root: settings.container === document ? null : settings.container,
  rootMargin: settings.thresholds || settings.threshold + "px"
});
const intersectionHandler = (entries, settings, instance) => {
  entries.forEach((entry) => isIntersecting(entry) ? onEnter(entry.target, entry, settings, instance) : onExit(entry.target, entry, settings, instance));
};
const observeElements = (observer, elements) => {
  elements.forEach((element) => {
    observer.observe(element);
  });
};
const updateObserver = (observer, elementsToObserve) => {
  resetObserver(observer);
  observeElements(observer, elementsToObserve);
};
const setObserver = (settings, instance) => {
  if (!supportsIntersectionObserver || shouldUseNative(settings)) {
    return;
  }
  instance._observer = new IntersectionObserver((entries) => {
    intersectionHandler(entries, settings, instance);
  }, getObserverSettings(settings));
};
const toArray = (nodeSet) => Array.prototype.slice.call(nodeSet);
const queryElements = (settings) => settings.container.querySelectorAll(settings.elements_selector);
const excludeManagedElements = (elements) => toArray(elements).filter(hasEmptyStatus);
const hasError = (element) => hasStatusError(element);
const filterErrorElements = (elements) => toArray(elements).filter(hasError);
const getElementsToLoad = (elements, settings) => excludeManagedElements(elements || queryElements(settings));
const retryLazyLoad = (settings, instance) => {
  const errorElements = filterErrorElements(queryElements(settings));
  errorElements.forEach((element) => {
    removeClass(element, settings.class_error);
    resetStatus(element);
  });
  instance.update();
};
const setOnlineCheck = (settings, instance) => {
  if (!runningOnBrowser) {
    return;
  }
  window.addEventListener("online", () => {
    retryLazyLoad(settings, instance);
  });
};
const LazyLoad = function(customSettings, elements) {
  const settings = getExtendedSettings(customSettings);
  this._settings = settings;
  this.loadingCount = 0;
  setObserver(settings, this);
  setOnlineCheck(settings, this);
  this.update(elements);
};
LazyLoad.prototype = {
  update: function(givenNodeset) {
    const settings = this._settings;
    const elementsToLoad = getElementsToLoad(givenNodeset, settings);
    setToLoadCount(this, elementsToLoad.length);
    if (isBot || !supportsIntersectionObserver) {
      this.loadAll(elementsToLoad);
      return;
    }
    if (shouldUseNative(settings)) {
      loadAllNative(elementsToLoad, settings, this);
      return;
    }
    updateObserver(this._observer, elementsToLoad);
  },
  destroy: function() {
    if (this._observer) {
      this._observer.disconnect();
    }
    queryElements(this._settings).forEach((element) => {
      deleteOriginalAttrs(element);
    });
    delete this._observer;
    delete this._settings;
    delete this.loadingCount;
    delete this.toLoadCount;
  },
  loadAll: function(elements) {
    const settings = this._settings;
    const elementsToLoad = getElementsToLoad(elements, settings);
    elementsToLoad.forEach((element) => {
      unobserve(element, this);
      load(element, settings, this);
    });
  },
  restoreAll: function() {
    const settings = this._settings;
    queryElements(settings).forEach((element) => {
      restore(element, settings);
    });
  }
};
LazyLoad.load = (element, customSettings) => {
  const settings = getExtendedSettings(customSettings);
  load(element, settings);
};
LazyLoad.resetStatus = (element) => {
  resetStatus(element);
};
if (runningOnBrowser) {
  autoInitialize(LazyLoad, window.lazyLoadOptions);
}
const copyProperty = (to, from, property, ignoreNonConfigurable) => {
  if (property === "length" || property === "prototype") {
    return;
  }
  if (property === "arguments" || property === "caller") {
    return;
  }
  const toDescriptor = Object.getOwnPropertyDescriptor(to, property);
  const fromDescriptor = Object.getOwnPropertyDescriptor(from, property);
  if (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {
    return;
  }
  Object.defineProperty(to, property, fromDescriptor);
};
const canCopyProperty = function(toDescriptor, fromDescriptor) {
  return toDescriptor === void 0 || toDescriptor.configurable || toDescriptor.writable === fromDescriptor.writable && toDescriptor.enumerable === fromDescriptor.enumerable && toDescriptor.configurable === fromDescriptor.configurable && (toDescriptor.writable || toDescriptor.value === fromDescriptor.value);
};
const changePrototype = (to, from) => {
  const fromPrototype = Object.getPrototypeOf(from);
  if (fromPrototype === Object.getPrototypeOf(to)) {
    return;
  }
  Object.setPrototypeOf(to, fromPrototype);
};
const wrappedToString = (withName, fromBody) => `/* Wrapped ${withName}*/
${fromBody}`;
const toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, "toString");
const toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, "name");
const changeToString = (to, from, name) => {
  const withName = name === "" ? "" : `with ${name.trim()}() `;
  const newToString = wrappedToString.bind(null, withName, from.toString());
  Object.defineProperty(newToString, "name", toStringName);
  Object.defineProperty(to, "toString", __spreadProps(__spreadValues({}, toStringDescriptor), { value: newToString }));
};
const mimicFn = (to, from, { ignoreNonConfigurable = false } = {}) => {
  const { name } = to;
  for (const property of Reflect.ownKeys(from)) {
    copyProperty(to, from, property, ignoreNonConfigurable);
  }
  changePrototype(to, from);
  changeToString(to, from, name);
  return to;
};
var mimicFn_1 = mimicFn;
const debounceFn = (inputFunction, options = {}) => {
  if (typeof inputFunction !== "function") {
    throw new TypeError(`Expected the first argument to be a function, got \`${typeof inputFunction}\``);
  }
  const {
    wait = 0,
    maxWait = Number.Infinity,
    before = false,
    after = true
  } = options;
  if (!before && !after) {
    throw new Error("Both `before` and `after` are false, function wouldn't be called.");
  }
  let timeout;
  let maxTimeout;
  let result;
  const debouncedFunction = function(...arguments_) {
    const context = this;
    const later = () => {
      timeout = void 0;
      if (maxTimeout) {
        clearTimeout(maxTimeout);
        maxTimeout = void 0;
      }
      if (after) {
        result = inputFunction.apply(context, arguments_);
      }
    };
    const maxLater = () => {
      maxTimeout = void 0;
      if (timeout) {
        clearTimeout(timeout);
        timeout = void 0;
      }
      if (after) {
        result = inputFunction.apply(context, arguments_);
      }
    };
    const shouldCallNow = before && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (maxWait > 0 && maxWait !== Number.Infinity && !maxTimeout) {
      maxTimeout = setTimeout(maxLater, maxWait);
    }
    if (shouldCallNow) {
      result = inputFunction.apply(context, arguments_);
    }
    return result;
  };
  mimicFn_1(debouncedFunction, inputFunction);
  debouncedFunction.cancel = () => {
    if (timeout) {
      clearTimeout(timeout);
      timeout = void 0;
    }
    if (maxTimeout) {
      clearTimeout(maxTimeout);
      maxTimeout = void 0;
    }
  };
  return debouncedFunction;
};
const e = "!#%()*+,-./:;=?@[]^_`{|}~ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", s = e.length, t = Array(20), r = () => {
  for (let r2 = 0; r2 < 20; r2++)
    t[r2] = e.charAt(Math.random() * s);
  return t.join("");
};
class o {
  constructor() {
    this.disposers = new Map();
  }
  add(e2, s2 = r()) {
    return this.flush(s2), this.disposers.set(s2, e2()), s2;
  }
  addDisposer(e2, s2 = r()) {
    return this.flush(s2), this.disposers.set(s2, e2), s2;
  }
  addEventListener(e2, s2, t2, o2, i = r()) {
    return this.add(() => (e2.addEventListener(s2, t2, o2), () => e2.removeEventListener(s2, t2, o2)), i), i;
  }
  setTimeout(e2, s2, t2 = r()) {
    return this.add(() => {
      const r2 = window.setTimeout(() => {
        this.remove(t2), e2();
      }, s2);
      return () => window.clearTimeout(r2);
    }, t2);
  }
  setInterval(e2, s2, t2 = r()) {
    return this.add(() => {
      const t3 = window.setInterval(e2, s2);
      return () => window.clearInterval(t3);
    }, t2);
  }
  remove(e2) {
    const s2 = this.disposers.get(e2);
    return this.disposers.delete(e2), s2;
  }
  flush(e2) {
    const s2 = this.remove(e2);
    if (s2)
      try {
        s2();
      } catch (t2) {
        console.error(t2);
      }
  }
  flushAll() {
    this.disposers.forEach((e2) => {
      try {
        e2();
      } catch (s2) {
        console.error(s2);
      }
    }), this.disposers.clear();
  }
}
function sidebarSVG(namespace) {
  const NS = "http://www.w3.org/2000/svg";
  const $svg = document.createElementNS(NS, "svg");
  $svg.setAttribute("class", `${namespace}-footer-icon-sidebar`);
  $svg.setAttribute("viewBox", "0 0 64 64");
  const $path = document.createElementNS(NS, "path");
  $path.setAttribute("fill", "currentColor");
  $path.setAttribute("d", "M50 8H14c-3.309 0-6 2.691-6 6v36c0 3.309 2.691 6 6 6h36c3.309 0 6-2.691 6-6V14c0-3.309-2.691-6-6-6zM12 50V14c0-1.103.897-2 2-2h8v40h-8c-1.103 0-2-.897-2-2zm40 0c0 1.103-.897 2-2 2H26V12h24c1.103 0 2 .897 2 2z");
  $svg.appendChild($path);
  return $svg;
}
function arrowLeftSVG(namespace) {
  const NS = "http://www.w3.org/2000/svg";
  const $svg = document.createElementNS(NS, "svg");
  $svg.setAttribute("class", `${namespace}-footer-icon-arrow-left`);
  $svg.setAttribute("viewBox", "0 0 500 500");
  const $path = document.createElementNS(NS, "path");
  $path.setAttribute("fill", "currentColor");
  $path.setAttribute("d", "M177.81 249.959L337.473 90.295c2.722-2.865 2.651-7.378-.143-10.1-2.793-2.65-7.163-2.65-9.956 0l-164.75 164.75c-2.793 2.793-2.793 7.306 0 10.1l164.75 164.75c2.865 2.722 7.378 2.65 10.099-.143 2.651-2.794 2.651-7.163 0-9.957L177.809 249.959z");
  $svg.appendChild($path);
  return $svg;
}
function arrowRightSVG(namespace) {
  const NS = "http://www.w3.org/2000/svg";
  const $svg = document.createElementNS(NS, "svg");
  $svg.setAttribute("class", `${namespace}-footer-icon-arrow-right`);
  $svg.setAttribute("viewBox", "0 0 500 500");
  const $path = document.createElementNS(NS, "path");
  $path.setAttribute("fill", "currentColor");
  $path.setAttribute("d", "M322.19 250.041L162.527 409.705c-2.722 2.865-2.651 7.378.143 10.1 2.793 2.65 7.163 2.65 9.956 0l164.75-164.75c2.793-2.793 2.793-7.306 0-10.1l-164.75-164.75c-2.865-2.722-7.378-2.65-10.099.143-2.651 2.794-2.651 7.163 0 9.957l159.664 159.736z");
  $svg.appendChild($path);
  return $svg;
}
function playSVG(namespace) {
  const NS = "http://www.w3.org/2000/svg";
  const $svg = document.createElementNS(NS, "svg");
  $svg.setAttribute("class", `${namespace}-footer-icon-play`);
  $svg.setAttribute("viewBox", "0 0 500 500");
  const $path = document.createElementNS(NS, "path");
  $path.setAttribute("fill", "currentColor");
  $path.setAttribute("d", "M418.158 257.419L174.663 413.33c-6.017 3.919-15.708 3.772-21.291-.29-2.791-2.018-4.295-4.483-4.295-7.084V94.109c0-5.65 6.883-10.289 15.271-10.289 4.298 0 8.391 1.307 11.181 3.332l242.629 155.484c6.016 3.917 6.451 10.292.649 14.491-.216.154-.432.154-.649.292zM170.621 391.288l223.116-141.301L170.71 107.753l-.089 283.535z");
  $svg.appendChild($path);
  return $svg;
}
function pauseSVG(namespace) {
  const NS = "http://www.w3.org/2000/svg";
  const $svg = document.createElementNS(NS, "svg");
  $svg.setAttribute("class", `${namespace}-footer-icon-pause`);
  $svg.setAttribute("viewBox", "0 0 500 500");
  const $path = document.createElementNS(NS, "path");
  $path.setAttribute("fill", "currentColor");
  $path.setAttribute("d", "M312.491 78.261c0-6.159 4.893-11.213 11.04-11.213 6.158 0 11.211 5.054 11.211 11.213v343.478c0 6.159-5.053 11.213-11.211 11.213-6.147 0-11.04-5.054-11.04-11.213V78.261zM165.257 78.261c0-6.159 4.893-11.213 11.04-11.213 6.158 0 11.211 5.054 11.211 11.213v343.478c0 6.159-5.053 11.213-11.211 11.213-6.147 0-11.04-5.054-11.04-11.213V78.261z");
  $svg.appendChild($path);
  return $svg;
}
class DocsViewer {
  constructor({ readonly, box, pages, onNewPageIndex, onPlay }) {
    this.pageIndex = 0;
    this.namespace = "netless-app-docs-viewer";
    this.isShowPreview = false;
    this.isSmallBox = false;
    this.sideEffect = new o();
    if (pages.length <= 0) {
      throw new Error("[DocsViewer] Empty pages.");
    }
    this.readonly = readonly;
    this.box = box;
    this.pages = pages;
    this.onNewPageIndex = onNewPageIndex;
    this.onPlay = onPlay;
    this.render();
  }
  mount() {
    this.box.mountContent(this.$content);
    this.box.mountFooter(this.$footer);
    this.sideEffect.add(() => {
      const previewLazyLoad = new LazyLoad({
        container: this.$preview,
        elements_selector: `.${this.wrapClassName("preview-page>img")}`
      });
      return () => previewLazyLoad.destroy();
    }, "preview-lazyload");
  }
  unmount() {
    this.$content.remove();
    this.$footer.remove();
  }
  setReadonly(readonly) {
    if (this.readonly !== readonly) {
      this.readonly = readonly;
      this.$content.classList.toggle(this.wrapClassName("readonly"), readonly);
      this.$footer.classList.toggle(this.wrapClassName("readonly"), readonly);
      this.$pageNumberInput.disabled = readonly;
    }
  }
  destroy() {
    this.sideEffect.flushAll();
    this.unmount();
  }
  setPageIndex(pageIndex) {
    if (!Number.isNaN(pageIndex)) {
      this.pageIndex = pageIndex;
      this.$pageNumberInput.value = String(pageIndex + 1);
    }
  }
  setSmallBox(isSmallBox) {
    if (this.isSmallBox !== isSmallBox) {
      this.isSmallBox = isSmallBox;
      this.$footer.classList.toggle(this.wrapClassName("float-footer"), isSmallBox);
    }
  }
  render() {
    this.renderContent();
    this.renderFooter();
    return this.$content;
  }
  renderContent() {
    if (!this.$content) {
      const $content = document.createElement("div");
      $content.className = this.wrapClassName("content");
      this.$content = $content;
      if (this.readonly) {
        $content.classList.add(this.wrapClassName("readonly"));
      }
      $content.appendChild(this.renderPreviewMask());
      $content.appendChild(this.renderPreview());
    }
    return this.$content;
  }
  renderPreview() {
    if (!this.$preview) {
      const $preview = document.createElement("div");
      $preview.className = this.wrapClassName("preview") + " tele-fancy-scrollbar";
      this.$preview = $preview;
      const pageClassName = this.wrapClassName("preview-page");
      const pageNameClassName = this.wrapClassName("preview-page-name");
      this.pages.forEach((page, i) => {
        var _a;
        const previewSRC = (_a = page.thumbnail) != null ? _a : page.src.startsWith("ppt") ? void 0 : page.src;
        if (!previewSRC) {
          return;
        }
        const pageIndex = String(i);
        const $page = document.createElement("a");
        $page.className = pageClassName + " " + this.wrapClassName(`preview-page-${i}`);
        $page.setAttribute("href", "#");
        $page.dataset.pageIndex = pageIndex;
        const $name = document.createElement("span");
        $name.className = pageNameClassName;
        $name.textContent = String(i + 1);
        $name.dataset.pageIndex = pageIndex;
        const $img = document.createElement("img");
        $img.width = page.width;
        $img.height = page.height;
        $img.dataset.src = previewSRC;
        $img.dataset.pageIndex = pageIndex;
        $page.appendChild($img);
        $page.appendChild($name);
        $preview.appendChild($page);
      });
      this.sideEffect.addEventListener($preview, "click", (ev) => {
        var _a;
        if (this.readonly) {
          return;
        }
        const pageIndex = (_a = ev.target.dataset) == null ? void 0 : _a.pageIndex;
        if (pageIndex) {
          ev.preventDefault();
          ev.stopPropagation();
          ev.stopImmediatePropagation();
          this.onNewPageIndex(Number(pageIndex));
          this.togglePreview(false);
        }
      });
    }
    return this.$preview;
  }
  renderPreviewMask() {
    if (!this.$previewMask) {
      this.$previewMask = document.createElement("div");
      this.$previewMask.className = this.wrapClassName("preview-mask");
      this.sideEffect.addEventListener(this.$previewMask, "click", (ev) => {
        if (this.readonly) {
          return;
        }
        if (ev.target === this.$previewMask) {
          this.togglePreview(false);
        }
      });
    }
    return this.$previewMask;
  }
  renderFooter() {
    if (!this.$footer) {
      const $footer = document.createElement("div");
      $footer.className = this.wrapClassName("footer");
      this.$footer = $footer;
      if (this.readonly) {
        $footer.classList.add(this.wrapClassName("readonly"));
      }
      if (this.isSmallBox) {
        $footer.classList.add(this.wrapClassName("float-footer"));
      }
      if (this.pages.some((page) => page.thumbnail || !page.src.startsWith("ppt"))) {
        const $btnSidebar = this.renderFooterBtn("btn-sidebar", sidebarSVG(this.namespace));
        this.sideEffect.addEventListener($btnSidebar, "click", () => {
          if (this.readonly) {
            return;
          }
          this.togglePreview();
        });
        this.$footer.appendChild($btnSidebar);
      }
      const $pageJumps = document.createElement("div");
      $pageJumps.className = this.wrapClassName("page-jumps");
      const $btnPageBack = this.renderFooterBtn("btn-page-back", arrowLeftSVG(this.namespace));
      this.sideEffect.addEventListener($btnPageBack, "click", () => {
        if (this.readonly) {
          return;
        }
        this.onNewPageIndex(this.pageIndex - 1);
      });
      $pageJumps.appendChild($btnPageBack);
      if (this.onPlay) {
        const $btnPlay = this.renderFooterBtn("btn-page-play", playSVG(this.namespace), pauseSVG(this.namespace));
        const returnPlay = () => {
          this.sideEffect.setTimeout(() => {
            $btnPlay.classList.toggle(this.wrapClassName("footer-btn-playing"), false);
          }, 500, "returnPlay");
        };
        this.sideEffect.addEventListener($btnPlay, "click", () => {
          if (this.readonly) {
            return;
          }
          $btnPlay.classList.toggle(this.wrapClassName("footer-btn-playing"), true);
          if (this.onPlay) {
            this.onPlay();
          }
          returnPlay();
        });
        $pageJumps.appendChild($btnPlay);
      }
      const $btnPageNext = this.renderFooterBtn("btn-page-next", arrowRightSVG(this.namespace));
      this.sideEffect.addEventListener($btnPageNext, "click", () => {
        if (this.readonly) {
          return;
        }
        this.onNewPageIndex(this.pageIndex + 1);
      });
      $pageJumps.appendChild($btnPageNext);
      const $pageNumber = document.createElement("div");
      $pageNumber.className = this.wrapClassName("page-number");
      const $pageNumberInput = document.createElement("input");
      $pageNumberInput.className = this.wrapClassName("page-number-input");
      $pageNumberInput.value = String(this.pageIndex + 1);
      if (this.readonly) {
        $pageNumberInput.disabled = true;
      }
      this.$pageNumberInput = $pageNumberInput;
      this.sideEffect.addEventListener($pageNumberInput, "change", () => {
        if (this.readonly) {
          return;
        }
        if ($pageNumberInput.value) {
          this.onNewPageIndex(Number($pageNumberInput.value) - 1);
        }
      });
      const $totalPage = document.createElement("span");
      $totalPage.textContent = " / " + this.pages.length;
      $pageNumber.appendChild($pageNumberInput);
      $pageNumber.appendChild($totalPage);
      this.$footer.appendChild($pageJumps);
      this.$footer.appendChild($pageNumber);
    }
    return this.$footer;
  }
  renderFooterBtn(className, $icon, $iconActive) {
    const $btn = document.createElement("button");
    $btn.className = this.wrapClassName("footer-btn") + " " + this.wrapClassName(className);
    $btn.appendChild($icon);
    if ($iconActive) {
      $btn.appendChild($iconActive);
    }
    return $btn;
  }
  togglePreview(isShowPreview) {
    this.isShowPreview = isShowPreview != null ? isShowPreview : !this.isShowPreview;
    this.$content.classList.toggle(this.wrapClassName("preview-active"), this.isShowPreview);
    if (this.isShowPreview) {
      const $previewPage = this.$preview.querySelector("." + this.wrapClassName(`preview-page-${this.pageIndex}`));
      if ($previewPage) {
        this.$preview.scrollTo({
          top: $previewPage.offsetTop - 16
        });
      }
    }
  }
  wrapClassName(className) {
    return `${this.namespace}-${className}`;
  }
}
function clamp(value, min, max) {
  return Math.min(Math.max(value, min), max);
}
function flattenEvent(ev) {
  return ev.touches ? ev.touches[0] : ev;
}
function preventEvent(ev) {
  ev.stopPropagation();
  if (ev.cancelable) {
    ev.preventDefault();
  }
}
const SCROLLBAR_MIN_HEIGHT = 30;
const RATIO_BASE_CONTAINER_HEIGHT = 640;
class StaticDocsViewer {
  constructor({
    whiteboardView,
    readonly,
    box,
    pages,
    pagesSize,
    pageScrollTop = 0,
    mountWhiteboard,
    onUserScroll
  }) {
    this.onNewPageIndex = (index) => {
      this.scrollToPage(index);
    };
    this.sideEffect = new o();
    this.scrollbarHeight = SCROLLBAR_MIN_HEIGHT;
    this.whiteboardView = whiteboardView;
    this.readonly = readonly;
    this.box = box;
    this.pages = pages;
    this.pageScrollTop = pageScrollTop;
    this.pagesSize = pagesSize;
    this.mountWhiteboard = mountWhiteboard;
    this.onUserScroll = onUserScroll;
    this.viewer = new DocsViewer({
      readonly,
      box,
      pages,
      onNewPageIndex: this.onNewPageIndex
    });
    this.render();
  }
  mount() {
    this.viewer.mount();
    this.sideEffect.add(() => {
      const contentLazyLoad = new LazyLoad({
        container: this.$pages,
        elements_selector: `.${this.wrapClassName("page")}`
      });
      return () => contentLazyLoad.destroy();
    }, "page-lazyload");
    this.setupWhiteboardCamera();
    this.sideEffect.setTimeout(() => {
      if (this.pageScrollTop !== 0) {
        this.pageScrollTo(this.pageScrollTop);
      }
    }, 1e3);
    this.setupScrollTopEvent();
    this.sideEffect.add(() => {
      const handler = this.renderRatioHeight.bind(this);
      this.box.events.on("visual_resize", handler);
      return () => this.box.events.off("visual_resize", handler);
    });
    return this;
  }
  unmount() {
    this.viewer.unmount();
    return this;
  }
  setReadonly(readonly) {
    if (this.readonly !== readonly) {
      this.readonly = readonly;
      this.viewer.setReadonly(readonly);
    }
  }
  destroy() {
    this.sideEffect.flushAll();
    this.onUserScroll = void 0;
    this.unmount();
    this.viewer.destroy();
  }
  syncPageScrollTop(pageScrollTop) {
    if (pageScrollTop >= 0 && Math.abs(this.pageScrollTop - pageScrollTop) > 10) {
      this.pageScrollTo(pageScrollTop);
    }
  }
  render() {
    this.viewer.$content.appendChild(this.renderPages());
    this.viewer.$content.appendChild(this.renderWhiteboardView());
    this.viewer.$content.appendChild(this.renderScrollbar());
    this.renderRatioHeight();
  }
  renderRatioHeight() {
    const boxHeight = this.box.absoluteHeight;
    const isSmallBox = boxHeight <= RATIO_BASE_CONTAINER_HEIGHT;
    this.viewer.setSmallBox(isSmallBox);
    if (isSmallBox) {
      const titleBarSupposedHeight = 26 / RATIO_BASE_CONTAINER_HEIGHT;
      const titleBarActualHeight = 26 / boxHeight;
      const footerSupposedHeight = 26 / RATIO_BASE_CONTAINER_HEIGHT;
      const footerActualHeight = 0;
      const emptySpace = Math.max((titleBarSupposedHeight + footerSupposedHeight - (titleBarActualHeight + footerActualHeight)) / 2, 0);
      if (this.box.$titleBar) {
        const titleBarHeight = titleBarActualHeight + emptySpace;
        this.box.$titleBar.style.height = `${titleBarHeight * 100}%`;
      }
      if (this.box.$footer) {
        const footerHeight = footerActualHeight + emptySpace;
        this.box.$footer.style.height = `${footerHeight * 100}%`;
      }
    } else {
      if (this.box.$titleBar) {
        const titleBarHeight = Math.max(26 / RATIO_BASE_CONTAINER_HEIGHT, 26 / boxHeight);
        this.box.$titleBar.style.height = `${titleBarHeight * 100}%`;
      }
      if (this.box.$footer) {
        const footerHeight = Math.max(26 / RATIO_BASE_CONTAINER_HEIGHT, 26 / boxHeight);
        this.box.$footer.style.height = `${footerHeight * 100}%`;
      }
    }
  }
  renderPages() {
    if (!this.$pages) {
      const $pages = document.createElement("div");
      $pages.className = this.wrapClassName("pages");
      this.$pages = $pages;
      const pageClassName = this.wrapClassName("page");
      this.pages.forEach((page, i) => {
        const $img = document.createElement("img");
        $img.className = pageClassName + " " + this.wrapClassName(`page-${i}`);
        $img.draggable = false;
        $img.width = page.width;
        $img.height = page.height;
        $img.dataset.src = page.src;
        $img.dataset.pageIndex = String(i);
        $pages.appendChild($img);
      });
    }
    return this.$pages;
  }
  renderWhiteboardView() {
    if (!this.$whiteboardView) {
      this.$whiteboardView = document.createElement("div");
      this.$whiteboardView.className = this.wrapClassName("wb-view");
      this.mountWhiteboard(this.$whiteboardView);
      this.sideEffect.addEventListener(this.$whiteboardView, "wheel", (ev) => {
        preventEvent(ev);
        if (!this.readonly) {
          this.pageScrollTo(this.pageScrollTop + ev.deltaY);
          this.updateUserScroll();
        }
      }, { passive: false, capture: true });
      this.sideEffect.addEventListener(this.$whiteboardView, "touchmove", (ev) => {
        if (this.readonly || ev.touches.length <= 1) {
          return;
        }
        this.updateUserScroll();
      }, { passive: true, capture: true });
    }
    return this.$whiteboardView;
  }
  renderScrollbar() {
    if (!this.$scrollbar) {
      const $scrollbar = document.createElement("button");
      this.$scrollbar = $scrollbar;
      $scrollbar.className = this.wrapClassName("scrollbar");
      $scrollbar.style.minHeight = `${SCROLLBAR_MIN_HEIGHT}px`;
      const trackStart = (ev) => {
        if (this.readonly) {
          return;
        }
        if (ev.button != null && ev.button !== 0) {
          return;
        }
        preventEvent(ev);
        this.$scrollbar.classList.toggle(this.wrapClassName("scrollbar-dragging"), true);
        const startTop = this.scrollTopPageToEl(this.pageScrollTop);
        const elScrollHeight = this.whiteboardView.size.width / this.pagesSize.width * this.pagesSize.height;
        const { clientY: startY } = flattenEvent(ev);
        const tracking = (ev2) => {
          const { clientY } = flattenEvent(ev2);
          const { height: wbHeight } = this.whiteboardView.size;
          this.elScrollTo(startTop + (clientY - startY) * (elScrollHeight / wbHeight));
        };
        const trackEnd = () => {
          this.$scrollbar.classList.toggle(this.wrapClassName("scrollbar-dragging"), false);
          window.removeEventListener("mousemove", tracking, true);
          window.removeEventListener("touchmove", tracking, true);
          window.removeEventListener("mouseup", trackEnd, true);
          window.removeEventListener("touchend", trackEnd, true);
          window.removeEventListener("touchcancel", trackEnd, true);
        };
        window.addEventListener("mousemove", tracking, true);
        window.addEventListener("touchmove", tracking, true);
        window.addEventListener("mouseup", trackEnd, true);
        window.addEventListener("touchend", trackEnd, true);
        window.addEventListener("touchcancel", trackEnd, true);
      };
      this.sideEffect.addEventListener($scrollbar, "mousedown", trackStart);
      this.sideEffect.addEventListener($scrollbar, "touchstart", trackStart);
    }
    return this.$scrollbar;
  }
  scrollTopPageToEl(pageScrollTop) {
    return pageScrollTop * (this.whiteboardView.size.width / this.pagesSize.width);
  }
  scrollTopElToPage(elScrollTop) {
    return elScrollTop / (this.whiteboardView.size.width / this.pagesSize.width);
  }
  elScrollTo(elScrollTop) {
    this.pageScrollTo(this.scrollTopElToPage(elScrollTop));
  }
  pageScrollTo(pageScrollTop) {
    const halfWbHeight = this.scrollTopElToPage(this.whiteboardView.size.height / 2);
    this.whiteboardView.moveCamera({
      centerY: clamp(pageScrollTop + halfWbHeight, halfWbHeight, this.pagesSize.height - halfWbHeight),
      animationMode: "immediately"
    });
  }
  scrollToPage(index) {
    if (!this.readonly && this.$pages && !Number.isNaN(index)) {
      index = clamp(index, 0, this.pages.length - 1);
      const $page = this.$pages.querySelector("." + this.wrapClassName(`page-${index}`));
      if ($page) {
        const elOffsetTop = $page.offsetTop + 5;
        this.elScrollTo(elOffsetTop);
        this.updateUserScroll();
      }
    }
  }
  setupScrollTopEvent() {
    const updatePageIndex = this.debounce(() => {
      if (this.pages.length > 0 && this.$pages) {
        const pagesWidth = this.$pages.getBoundingClientRect().width;
        if (pagesWidth > 0) {
          let pageTop = 0;
          for (let i = 0; i < this.pages.length; i += 1) {
            pageTop += this.pages[i].height;
            if (this.pageScrollTop <= pageTop) {
              this.viewer.setPageIndex(i);
              return;
            }
          }
          this.viewer.setPageIndex(this.pages.length - 1);
        }
      }
    }, { wait: 5, maxWait: 100 }, "debounce-updatePageIndex");
    this.sideEffect.add(() => {
      const handleCameraUpdate = (camera) => {
        const { width: wbWidth, height: wbHeight } = this.whiteboardView.size;
        const { width: pageWidth, height: pageHeight } = this.pagesSize;
        const elScrollHeight = wbWidth / pageWidth * pageHeight;
        const elScrollTop = this.scrollTopPageToEl(camera.centerY) - wbHeight / 2;
        const pageScrollTop = this.scrollTopElToPage(elScrollTop);
        this.pageScrollTop = pageScrollTop;
        this.$pages.scrollTo({ top: elScrollTop });
        this.setScrollbarHeight(wbHeight / elScrollHeight * wbHeight);
        this.$scrollbar.style.transform = `translateY(${elScrollTop / (elScrollHeight - wbHeight) * (wbHeight - this.scrollbarHeight)}px)`;
        updatePageIndex();
      };
      this.whiteboardView.callbacks.on("onCameraUpdated", handleCameraUpdate);
      return () => this.whiteboardView.callbacks.off("onCameraUpdated", handleCameraUpdate);
    });
  }
  setupWhiteboardCamera() {
    this.sideEffect.add(() => {
      const handleSizeUpdate = ({ width, height }) => {
        if (width > 0 && height > 0) {
          const elScrollTop = this.$pages.scrollTop;
          const pageWidth = this.pagesSize.width;
          const ratio = pageWidth / width;
          this.whiteboardView.moveCameraToContain({
            originX: 0,
            originY: elScrollTop * ratio,
            width: pageWidth,
            height: height * ratio,
            animationMode: "immediately"
          });
          this.whiteboardView.setCameraBound({
            damping: 1,
            maxContentMode: () => width / pageWidth,
            minContentMode: () => width / pageWidth,
            centerX: this.pagesSize.width / 2,
            centerY: this.pagesSize.height / 2,
            width: this.pagesSize.width,
            height: this.pagesSize.height
          });
          this.elScrollTo(elScrollTop);
        }
      };
      this.whiteboardView.callbacks.on("onSizeUpdated", handleSizeUpdate);
      return () => {
        this.whiteboardView.callbacks.off("onSizeUpdated", handleSizeUpdate);
      };
    }, "whiteboard-size-update");
  }
  updateUserScroll() {
    window.requestAnimationFrame(() => {
      if (this.onUserScroll) {
        this.onUserScroll(this.pageScrollTop);
      }
    });
  }
  debounce(fn, options, disposerID) {
    const dFn = debounceFn(fn, options);
    this.sideEffect.add(() => () => dFn.cancel(), disposerID);
    return dFn;
  }
  wrapClassName(className) {
    return "netless-app-docs-viewer-static-" + className;
  }
  setScrollbarHeight(elScrollbarHeight) {
    elScrollbarHeight = clamp(elScrollbarHeight, SCROLLBAR_MIN_HEIGHT, this.whiteboardView.size.height);
    if (this.scrollbarHeight !== elScrollbarHeight) {
      this.scrollbarHeight = elScrollbarHeight;
      this.$scrollbar.style.height = `${elScrollbarHeight}px`;
    }
  }
}
class DynamicDocsViewer {
  constructor({
    displayer,
    whiteboardView,
    getRoom,
    readonly,
    box,
    pages,
    mountWhiteboard
  }) {
    this.sideEffect = new o();
    this.onPlayPPT = () => {
      const room = this.getWhiteboardRoom();
      if (room) {
        room.pptNextStep();
      }
    };
    this._scaleDocsToFitImpl = () => {
      const page = this.pages[this.getPageIndex()];
      if (page) {
        this.whiteboardView.moveCameraToContain({
          originX: -page.width / 2,
          originY: -page.height / 2,
          width: page.width,
          height: page.height,
          animationMode: "immediately"
        });
      }
    };
    this._scaleDocsToFitDebounced = () => {
      this.sideEffect.setTimeout(this._scaleDocsToFitImpl, 1e3, "_scaleDocsToFitDebounced");
    };
    this.scaleDocsToFit = () => {
      this._scaleDocsToFitImpl();
      this._scaleDocsToFitDebounced();
    };
    this.onNewPageIndex = (index) => {
      this.jumpToPage(index, true);
    };
    this.whiteboardView = whiteboardView;
    this.readonly = readonly;
    this.box = box;
    this.pages = pages;
    this.displayer = displayer;
    this.getWhiteboardRoom = getRoom;
    this.mountWhiteboard = mountWhiteboard;
    this.viewer = new DocsViewer({
      readonly,
      box,
      pages,
      onNewPageIndex: this.onNewPageIndex,
      onPlay: this.onPlayPPT
    });
    this.render();
  }
  mount() {
    this.viewer.mount();
    const pageIndex = this.getPageIndex();
    if (pageIndex !== 0) {
      this.jumpToPage(pageIndex);
    }
    this.scaleDocsToFit();
    this.sideEffect.add(() => {
      this.whiteboardView.callbacks.on("onSizeUpdated", this.scaleDocsToFit);
      return () => {
        this.whiteboardView.callbacks.off("onSizeUpdated", this.scaleDocsToFit);
      };
    });
    return this;
  }
  unmount() {
    this.viewer.unmount();
    return this;
  }
  setReadonly(readonly) {
    if (this.readonly !== readonly) {
      this.readonly = readonly;
      this.viewer.setReadonly(readonly);
    }
  }
  destroy() {
    this.sideEffect.flushAll();
    this.unmount();
    this.viewer.destroy();
  }
  getPageIndex() {
    return this.displayer.state.sceneState.index;
  }
  jumpToPage(index, reset) {
    index = clamp(index, 0, this.pages.length - 1);
    if (index !== this.getPageIndex()) {
      const room = this.getWhiteboardRoom();
      if (room) {
        room.setSceneIndex(index);
        this.scaleDocsToFit();
      }
    }
    if (index !== this.viewer.pageIndex) {
      this.viewer.setPageIndex(index);
    }
    if (reset) {
      const room = this.getWhiteboardRoom();
      if (room) {
        room.setGlobalState({ __pptState: void 0 });
      }
    }
  }
  render() {
    this.viewer.$content.appendChild(this.renderMask());
    this.viewer.$content.appendChild(this.renderWhiteboardView());
    this.sideEffect.addEventListener(window, "keydown", (ev) => {
      var _a;
      if (this.box.focus) {
        switch (ev.key) {
          case "ArrowUp":
          case "ArrowLeft": {
            this.jumpToPage(this.getPageIndex() - 1, true);
            break;
          }
          case "ArrowRight":
          case "ArrowDown": {
            (_a = this.getWhiteboardRoom()) == null ? void 0 : _a.pptNextStep();
            break;
          }
        }
      }
    });
  }
  renderMask() {
    if (!this.$mask) {
      const $mask = document.createElement("div");
      $mask.className = this.wrapClassName("mask");
      this.$mask = $mask;
      const $back = document.createElement("button");
      $back.className = this.wrapClassName("back");
      const $next = document.createElement("button");
      $next.className = this.wrapClassName("next");
    }
    return this.$mask;
  }
  renderWhiteboardView() {
    if (!this.$whiteboardView) {
      this.$whiteboardView = document.createElement("div");
      this.$whiteboardView.className = this.wrapClassName("wb-view");
      this.sideEffect.addEventListener(this.$whiteboardView, "click", (ev) => {
        var _a;
        const room = this.getWhiteboardRoom();
        if (room && room.state.memberState.currentApplianceName === "clicker") {
          for (let el = ev.target; el; el = el.parentElement) {
            if ((_a = el.classList) == null ? void 0 : _a.contains("ppt-event-source")) {
              return;
            }
          }
          room.pptNextStep();
        }
      });
      this.mountWhiteboard(this.$whiteboardView);
    }
    return this.$whiteboardView;
  }
  wrapClassName(className) {
    return "netless-app-docs-viewer-dynamic-" + className;
  }
}
const kind = "DocsViewer";
const NetlessAppDocsViewer = {
  kind,
  setup(context) {
    const box = context.getBox();
    const scenes = context.getScenes();
    if (!scenes) {
      throw new Error("[Docs Viewer]: scenes not found.");
    }
    const whiteboardView = context.getView();
    if (!whiteboardView) {
      throw new Error("[Docs Viewer]: no whiteboard view.");
    }
    const pages = scenes.map(({ ppt }) => ppt ? {
      width: ppt.width,
      height: ppt.height,
      src: ppt.src,
      thumbnail: ppt.previewURL
    } : null).filter((page) => Boolean(page));
    if (pages.length <= 0) {
      throw new Error("[Docs Viewer]: empty scenes.");
    }
    box.mountStyles(styles);
    if (pages[0].src.startsWith("ppt")) {
      setupDynamicDocsViewer(context, whiteboardView, box, pages);
    } else {
      setupStaticDocsViewer(context, whiteboardView, box, pages);
    }
  }
};
function setupStaticDocsViewer(context, whiteboardView, box, pages) {
  var _a;
  const pagesSize = {
    width: pages[0].width,
    height: pages.reduce((height, page) => height + page.height * (pages[0].width / page.width), 0)
  };
  const docsViewer = new StaticDocsViewer({
    whiteboardView,
    readonly: box.readonly,
    box,
    pages,
    pagesSize,
    pageScrollTop: (_a = context.getAttributes()) == null ? void 0 : _a.pageScrollTop,
    mountWhiteboard: context.mountView.bind(context),
    onUserScroll: (pageScrollTop) => {
      var _a2;
      if (((_a2 = context.getAttributes()) == null ? void 0 : _a2.pageScrollTop) !== pageScrollTop && !box.readonly) {
        context.updateAttributes(["pageScrollTop"], pageScrollTop);
      }
    }
  }).mount();
  context.emitter.on("attributesUpdate", (attributes) => {
    if (attributes) {
      if (attributes.pageScrollTop != null) {
        docsViewer.syncPageScrollTop(attributes.pageScrollTop);
      }
    }
  });
  box.events.on("readonly", (readonly) => {
    docsViewer.setReadonly(readonly);
  });
}
function setupDynamicDocsViewer(context, whiteboardView, box, pages) {
  whiteboardView.disableCameraTransform = true;
  const displayer = context.getDisplayer();
  const docsViewer = new DynamicDocsViewer({
    displayer,
    whiteboardView,
    getRoom: () => context.getIsWritable() ? context.getDisplayer() : void 0,
    readonly: box.readonly,
    box,
    pages,
    mountWhiteboard: context.mountView.bind(context)
  }).mount();
  context.mountView(docsViewer.$whiteboardView);
  if (context.isAddApp) {
    whiteboardView.callbacks.once("onSizeUpdated", ({ width: contentWidth, height: contentHeight }) => {
      if (pages.length > 0 && box.state !== "maximized") {
        const { width: pageWidth, height: pageHeight } = pages[0];
        const preferHeight = pageHeight / pageWidth * contentWidth;
        const diff = preferHeight - contentHeight;
        if (diff !== 0 && context.getIsWritable()) {
          context.emitter.emit("setBoxSize", {
            width: box.width,
            height: box.height + diff / box.containerRect.height
          });
        }
      }
    });
  }
  context.emitter.on("sceneStateChange", (sceneState) => {
    docsViewer.jumpToPage(sceneState.index);
  });
  box.events.on("readonly", (readonly) => {
    docsViewer.setReadonly(readonly);
  });
}
export { NetlessAppDocsViewer as default };
//# sourceMappingURL=main.es.js.map
