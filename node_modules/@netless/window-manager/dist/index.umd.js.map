{"version":3,"file":"index.umd.js","sources":["../src/constants.ts","../src/Register/storage.ts","../src/Register/loader.ts","../src/Register/index.ts","../src/Utils/Common.ts","../src/AppListener.ts","../src/Utils/error.ts","../src/AppContext.ts","../src/AttributesDelegate.ts","../src/Utils/log.ts","../src/Base/Context.ts","../src/Base/index.ts","../src/AppProxy.ts","../src/BoxManager.ts","../src/Utils/CameraStore.ts","../src/ViewManager.ts","../src/MainView.ts","../src/Utils/Reactive.ts","../src/ReconnectRefresher.ts","../src/AppManager.ts","../node_modules/svelte/internal/index.mjs","../src/Cursor/Cursor.svelte","../src/Cursor/icons.ts","../src/image/pencil-cursor.png","../src/image/selector-cursor.png","../src/image/eraser-cursor.png","../src/image/shape-cursor.svg","../src/image/text-cursor.svg","../src/Cursor/Cursor.ts","../src/Cursor/index.ts","../src/index.ts","../src/Utils/RoomHacker.ts","../src/sdk.ts"],"sourcesContent":["export enum Events {\n    AppMove = \"AppMove\",\n    AppFocus = \"AppFocus\",\n    AppResize = \"AppResize\",\n    AppBoxStateChange = \"AppBoxStateChange\",\n    GetAttributes = \"GetAttributes\",\n    UpdateWindowManagerWrapper = \"UpdateWindowManagerWrapper\",\n    InitReplay = \"InitReplay\",\n    WindowCreated = \"WindowCreated\",\n    SetMainViewScenePath = \"SetMainViewScenePath\",\n    SetMainViewSceneIndex = \"SetMainViewSceneIndex\",\n    SwitchViewsToFreedom = \"SwitchViewsToFreedom\",\n}\n\nexport const MagixEventName = \"__WindowManger\";\n\nexport enum AppAttributes {\n    Size = \"size\",\n    Position = \"position\",\n    SnapshotRect = \"SnapshotRect\",\n    SceneIndex = \"SceneIndex\",\n}\n\nexport enum AppEvents {\n    setBoxSize = \"setBoxSize\",\n    setBoxMinSize = \"setBoxMinSize\",\n    destroy = \"destroy\",\n}\n\nexport enum AppStatus {\n    StartCreate = \"StartCreate\",\n}\n\nexport enum CursorState {\n    Leave = \"leave\",\n    Normal = \"normal\",\n}\n\nexport const REQUIRE_VERSION = \"2.13.16\";\n\nexport const MIN_WIDTH = 340 / 720;\nexport const MIN_HEIGHT = 340 / 720;\n\nexport const SET_SCENEPATH_DELAY = 100; // 设置 scenePath 的延迟事件\n\nexport const DEFAULT_COLLECTOR_STYLE = { right: \"10px\", bottom: \"15px\", position: \"absolute\" };\n\nexport const DEFAULT_CONTAINER_RATIO = 9 / 16;\n","const DatabaseName = \"__WindowManagerAppCache\";\n\nlet db: IDBDatabase;\nlet store: IDBObjectStore;\n\nexport const initDb = async () => {\n    db = await createDb();\n}\n\nexport const setItem = (key: string, val: any) => {\n    if (!db) return;\n    return addRecord(db, { kind: key, sourceCode: val })\n};\n\nexport const getItem = async (key: string): Promise<string | null> => {\n    if (!db) return null;\n    return await query(db, key);\n};\n\nexport const removeItem = (key: string) => {\n    if (!db) return;\n    return deleteRecord(db, key);\n};\n\nfunction createDb(): Promise<IDBDatabase> {\n    return new Promise((resolve, reject) => {\n        const request = indexedDB.open(DatabaseName, 2);\n        request.onerror = (e) => {\n            reject(e);\n        }\n\n        request.onupgradeneeded = (event: any) => {\n            const db = event.target.result as IDBDatabase;\n            if (!db.objectStoreNames.contains(\"apps\")) {\n                store = db.createObjectStore(\"apps\", { keyPath: \"kind\" });\n                store.createIndex(\"kind\", \"kind\", { unique: true });\n            }\n        }\n\n        request.onsuccess = () => {\n            const db = request.result;\n            resolve(db);\n        }\n    })\n}\n\nfunction query<T>(db: IDBDatabase, val: string): Promise<T | null> {\n    return new Promise((resolve, reject) => {\n        const index = db.transaction([\"apps\"]).objectStore(\"apps\").index(\"kind\");\n        const request = index.get(val);\n        request.onerror = (e) => reject(e);\n        request.onsuccess = () => {\n            if (request.result) {\n                resolve(request.result);\n            } else {\n                resolve(null);\n            }\n        }\n    })\n}\n\nfunction addRecord(db: IDBDatabase, payload: any): Promise<void> {\n    return new Promise((resolve, reject) => {\n        const request = db.transaction([\"apps\"], \"readwrite\").objectStore(\"apps\").add(payload);\n        request.onsuccess = () => resolve();\n        request.onerror = () => reject();\n    })\n}\n\nfunction deleteRecord(db: IDBDatabase, key: string): Promise<void> {\n    return new Promise((resolve, reject) => {\n        const request = db.transaction([\"apps\"], \"readwrite\").objectStore(\"apps\").delete(key);\n        request.onsuccess = () => resolve();\n        request.onerror = () => reject();\n    })\n}\n","import { getItem, setItem } from \"./storage\";\nimport type { NetlessApp } from \"../typings\";\n\nconst Prefix = \"NetlessApp\";\n\nconst TIMEOUT = 10000; // 10 秒超时\n\nexport const getScript = async (url: string): Promise<string> => {\n    const item = await getItem(url);\n    if (item) {\n        return item;\n    } else {\n        const result = await fetchWithTimeout(url, { timeout: TIMEOUT });\n        const text = await result.text();\n        await setItem(url, text);\n        return text;\n    }\n};\n\nexport const executeScript = (text: string, appName: string): NetlessApp => {\n    let result = Function(text + `;return ${appName}`)();\n    if (typeof result === \"undefined\") {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        result = window[appName];\n    }\n    return result;\n};\n\nexport const loadApp = async (\n    url: string,\n    key: string,\n    name?: string\n): Promise<NetlessApp | undefined> => {\n    const appName = name || Prefix + key;\n    const text = await getScript(url);\n    try {\n        return executeScript(text, appName);\n    } catch (error: any) {\n        if (error.message.includes(\"Can only have one anonymous define call per script file\")) {\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            const define = window.define;\n            if (\"function\" == typeof define && define.amd) {\n                delete define.amd;\n            }\n            return executeScript(text, appName);\n        }\n    }\n};\n\nasync function fetchWithTimeout(resource: string, options: RequestInit & { timeout: number }) {\n    const { timeout = 10000 } = options;\n\n    const controller = new AbortController();\n    const id = setTimeout(() => controller.abort(), timeout);\n\n    const response = await fetch(resource, {\n        ...options,\n        signal: controller.signal,\n        headers: {\n            \"content-type\": \"text/plain\",\n        },\n    });\n    clearTimeout(id);\n\n    return response;\n}\n","import Emittery from \"emittery\";\nimport type { NetlessApp, RegisterEvents, RegisterParams } from \"../typings\";\nimport { loadApp } from \"./loader\";\n\nclass AppRegister {\n    public kindEmitters: Map<string, Emittery<RegisterEvents>> = new Map();\n    public registered: Map<string, RegisterParams> = new Map();\n    public appClassesCache: Map<string, Promise<NetlessApp>> = new Map();\n    public appClasses: Map<string, () => Promise<NetlessApp>> = new Map();\n\n    public async register(params: RegisterParams): Promise<void> {\n        this.registered.set(params.kind, params);\n        \n        const srcOrAppOrFunction = params.src\n        let downloadApp: () => Promise<NetlessApp>\n        \n        if (typeof srcOrAppOrFunction === \"string\") {\n            downloadApp = async () => {\n                const appClass = await loadApp(srcOrAppOrFunction, params.kind);\n                if (appClass) {\n                    return appClass\n                } else {\n                    throw new Error(`[WindowManager]: load remote script failed, ${srcOrAppOrFunction}`);\n                }\n            }\n        } else if (typeof srcOrAppOrFunction === \"function\") {\n            downloadApp = srcOrAppOrFunction\n        } else {\n            downloadApp = async () => srcOrAppOrFunction\n        }\n\n        this.appClasses.set(params.kind, async () => {\n            let app = this.appClassesCache.get(params.kind)\n            if (!app) {\n                app = downloadApp()\n                this.appClassesCache.set(params.kind, app)\n            }\n            return app\n        });\n        \n        if (params.addHooks) {\n            const emitter = this.createKindEmitter(params.kind);\n            if (emitter) {\n                params.addHooks(emitter);\n            }\n        }\n    }\n\n    public async notifyApp<T extends keyof RegisterEvents>(kind: string, event: T, payload: RegisterEvents[T]) {\n        const emitter = this.kindEmitters.get(kind);\n        await emitter?.emit(event, payload);\n    }\n\n    private createKindEmitter(kind: string) {\n        if (!this.kindEmitters.has(kind)) {\n            const emitter = new Emittery<RegisterEvents>();\n            this.kindEmitters.set(kind, emitter);\n        }\n        return this.kindEmitters.get(kind);\n    }\n}\n\nexport const appRegister = new AppRegister();\n","import { appRegister } from '../Register';\nimport { debounce } from 'lodash';\nimport { emitter } from '../index';\nimport { v4 } from 'uuid';\nimport type { PublicEvent } from \"../index\";\nimport type { Displayer, ViewVisionMode, Room, View } from \"white-web-sdk\";\nimport type Emittery from \"emittery\";\n\nexport const genAppId = async (kind: string) => {\n    const impl = await appRegister.appClasses.get(kind)?.();\n    if (impl && impl.config?.singleton) {\n        return kind;\n    }\n    return `${kind}-${v4().replace(\"-\", \"\").slice(0, 8)}`;\n};\n\nexport const setViewFocusScenePath = (view: View, focusScenePath: string) => {\n    if (view.focusScenePath !== focusScenePath) {\n        view.focusScenePath = focusScenePath;\n    }\n};\n\nexport const setScenePath = (room: Room | undefined, scenePath: string) => {\n    if (room && room.isWritable) {\n        if (room.state.sceneState.scenePath !== scenePath) {\n            room.setScenePath(scenePath);\n        }\n    }\n}\n\nexport const setViewMode = (view: View, mode: ViewVisionMode) => {\n    if (!(view as any).didRelease && view.mode !== mode) {\n        view.mode = mode;\n    }\n};\n\nexport const emitError = (error: Error) => {\n    if (emitter.listenerCount(\"error\") > 0) {\n        emitter.emit(\"error\", error);\n    } else {\n        console.log(\"[WindowManager]:\", error);\n    }\n};\n\nexport const addEmitterOnceListener = (event: any, listener: any) => {\n    emitter.once(event).then(listener);\n}\n\nexport const notifyMainViewModeChange = debounce(\n    (callbacks: Emittery<PublicEvent>, mode: ViewVisionMode) => {\n        callbacks.emit(\"mainViewModeChange\", mode);\n    },\n    200\n);\n\nexport const makeValidScenePath = (displayer: Displayer, scenePath: string) => {\n    const scenes = displayer.entireScenes()[scenePath];\n    const firstSceneName = scenes[0].name;\n    if (scenePath === \"/\") {\n        return `/${firstSceneName}`;\n    } else {\n        return `${scenePath}/${firstSceneName}`;\n    }\n};\n\nexport const isValidScenePath = (scenePath: string) => {\n    return scenePath.startsWith(\"/\");\n}\n\nexport const ensureValidScenePath = (scenePath: string) => {\n    if (scenePath.endsWith(\"/\")) {\n        return scenePath.slice(0, -1);\n    } else {\n        return scenePath;\n    }\n}\n\nexport const getVersionNumber = (version: string) => {\n    const versionString = version.split(\".\").map(s => s.padStart(2, \"0\")).join(\"\");\n    return parseInt(versionString);\n};\n\nexport const wait = (time: number) => new Promise((resolve) => setTimeout(resolve, time));\n","import { callbacks } from './index';\nimport { Events, MagixEventName } from './constants';\nimport type { Event } from \"white-web-sdk\";\nimport type { AppManager } from \"./AppManager\";\nimport type { TeleBoxState } from \"@netless/telebox-insider\";\nimport { setViewFocusScenePath } from './Utils/Common';\n\nexport class AppListeners {\n    private displayer = this.manager.displayer;\n    private boxManager = this.manager.boxManager;\n\n    constructor(private manager: AppManager) {}\n\n    public addListeners() {\n        this.displayer.addMagixEventListener(MagixEventName, this.mainMagixEventListener);\n    }\n\n    public removeListeners() {\n        this.displayer.removeMagixEventListener(MagixEventName, this.mainMagixEventListener);\n    }\n\n    private mainMagixEventListener = (event: Event) => {\n        if (event.authorId !== this.displayer.observerId) {\n            const data = event.payload;\n            switch (data.eventName) {\n                case Events.AppMove: {\n                    this.appMoveHandler(data.payload);\n                    break;\n                }\n                case Events.AppResize: {\n                    this.appResizeHandler(data.payload);\n                    break;\n                }\n                case Events.SwitchViewsToFreedom: {\n                    this.switchViewsToFreedomHandler();\n                    break;\n                }\n                case Events.AppBoxStateChange: {\n                    this.boxStateChangeHandler(data.payload);\n                    break;\n                }\n                case Events.SetMainViewScenePath: {\n                    this.setMainViewScenePathHandler(data.payload);\n                    break;\n                }\n                default:\n                    break;\n            }\n        }\n    };\n\n    private appMoveHandler = (payload: any) => {\n        this.boxManager.moveBox(payload);\n    };\n\n    private appResizeHandler = (payload: any) => {\n        this.boxManager.resizeBox(Object.assign(payload, { skipUpdate: true }));\n        this.manager.room?.refreshViewSize();\n    };\n\n    private switchViewsToFreedomHandler = () => {\n        this.manager.viewManager.freedomAllViews();\n    };\n\n    private boxStateChangeHandler = (state: TeleBoxState) => {\n        callbacks.emit(\"boxStateChange\", state);\n    }\n\n    private setMainViewScenePathHandler = ({ nextScenePath }: { nextScenePath: string }) => {\n        setViewFocusScenePath(this.manager.mainView, nextScenePath);\n    }\n}\n","export class AppCreateError extends Error {\n    override message = \"[WindowManager]: app duplicate exists and cannot be created again\";\n}\n\nexport class AppNotRegisterError extends Error {\n    constructor(kind: string) {\n        super(`[WindowManager]: app ${kind} need register or provide src`);\n    }\n}\n\nexport class AppManagerNotInitError extends Error {\n    override message = \"[WindowManager]: AppManager must be initialized\";\n}\n\nexport class WhiteWebSDKInvalidError extends Error {\n    constructor(version: string) {\n        super(`[WindowManager]: white-web-sdk version must large than ${version}`);\n    }\n}\n\nexport class ParamsInvalidError extends Error {\n    override message = \"[WindowManager]: kind must be a valid string\";\n}\n\nexport class BoxNotCreatedError extends Error {\n    override message = \"[WindowManager]: box need created\";\n}\n\nexport class InvalidScenePath extends Error {\n    override message = `[WindowManager]: ScenePath should start with \"/\"`;\n}","import {\n    autorun,\n    listenDisposed,\n    listenUpdated,\n    reaction,\n    unlistenDisposed,\n    unlistenUpdated,\n    toJS\n    } from 'white-web-sdk';\nimport { BoxNotCreatedError } from './Utils/error';\nimport type { Room, SceneDefinition, View } from \"white-web-sdk\";\nimport type { ReadonlyTeleBox } from \"@netless/telebox-insider\";\nimport type Emittery from \"emittery\";\nimport type { BoxManager } from \"./BoxManager\";\nimport type { AppEmitterEvent } from \"./index\";\nimport type { AppManager } from \"./AppManager\";\nimport type { AppProxy } from \"./AppProxy\";\n\nexport class AppContext<TAttrs extends Record<string, any>, AppOptions = any> {\n    public readonly emitter: Emittery<AppEmitterEvent<TAttrs>>;\n    public readonly mobxUtils = {\n        autorun,\n        reaction,\n        toJS\n    };\n    public readonly objectUtils = {\n        listenUpdated,\n        unlistenUpdated,\n        listenDisposed,\n        unlistenDisposed\n    };\n    private boxManager: BoxManager;\n    private store = this.manager.store;\n    public readonly isAddApp: boolean;\n    public readonly isReplay = this.manager.isReplay;\n\n    constructor(\n        private manager: AppManager,\n        public appId: string,\n        private appProxy: AppProxy,\n        private appOptions?: AppOptions | (() => AppOptions),\n    ) {\n        this.emitter = appProxy.appEmitter;\n        this.boxManager = this.manager.boxManager;\n        this.isAddApp = appProxy.isAddApp;\n    }\n\n    public getDisplayer() {\n        return this.manager.displayer;\n    }\n\n    public getAttributes(): TAttrs | undefined {\n        return this.appProxy.attributes;\n    }\n\n    public getScenes(): SceneDefinition[] | undefined {\n        const appAttr = this.store.getAppAttributes(this.appId);\n        if (appAttr?.isDynamicPPT) {\n            const appProxy = this.manager.appProxies.get(this.appId);\n            if (appProxy) {\n                return appProxy.scenes;\n            }\n        } else {\n            return appAttr?.options[\"scenes\"];\n        }\n    }\n\n    public getView(): View | undefined {\n        return this.appProxy.view;\n    }\n\n    public getInitScenePath() {\n        return this.manager.getAppInitPath(this.appId);\n    }\n\n    public getIsWritable(): boolean {\n        return this.manager.canOperate;\n    }\n\n    public getBox(): ReadonlyTeleBox {\n        const box = this.boxManager.getBox(this.appId);\n        if (box) {\n            return box;\n        } else {\n            throw new BoxNotCreatedError();\n        }\n    }\n\n    public getRoom(): Room | undefined {\n        return this.manager.room;\n    }\n\n    public setAttributes(attributes: TAttrs) {\n        this.manager.safeSetAttributes({ [this.appId]: attributes });\n    }\n\n    public updateAttributes(keys: string[], value: any) {\n        if (this.manager.attributes[this.appId]) {\n            this.manager.safeUpdateAttributes([this.appId, ...keys], value);\n        }\n    }\n\n    public async setScenePath(scenePath: string): Promise<void> {\n        if (!this.appProxy.box) return;\n        this.appProxy.setFullPath(scenePath);\n        this.appProxy.context.switchAppToWriter(this.appId);\n    }\n\n    public mountView(dom: HTMLDivElement): void {\n        const view = this.getView();\n        if (view) {\n            view.divElement = dom;\n            setTimeout(() => {\n                // 渲染需要时间，延迟 refresh\n                this.getRoom()?.refreshViewSize();\n            }, 1000);\n        }\n    }\n\n    public getAppOptions(): AppOptions | undefined {\n        return typeof this.appOptions === 'function' ? (this.appOptions as () => AppOptions)() : this.appOptions\n    }\n}\n","import { AppAttributes } from \"./constants\";\nimport { get, pick } from \"lodash\";\nimport { setViewFocusScenePath } from \"./Utils/Common\";\nimport type { AddAppParams, AppSyncAttributes } from \"./index\";\nimport type { Camera, Size } from \"white-web-sdk\";\nimport type { AppManager } from \"./AppManager\";\nimport type { Cursor } from \"./Cursor/Cursor\";\n\nexport enum Fields {\n    Apps = \"apps\",\n    Focus = \"focus\",\n    State = \"state\",\n    BoxState = \"boxState\",\n    MainViewCamera = \"mainViewCamera\",\n    MainViewSize = \"mainViewSize\",\n    Broadcaster = \"broadcaster\",\n    Cursors = \"cursors\",\n    Position = \"position\",\n    CursorState = \"cursorState\",\n    FullPath = \"fullPath\"\n}\n\nexport type Apps = {\n    [key: string]: AppSyncAttributes;\n};\n\nexport type Position = {\n    x: number;\n    y: number;\n    type: PositionType;\n    id?: string;\n};\n\nexport type PositionType = \"main\" | \"app\";\n\nexport class AttributesDelegate {\n    constructor(private manager: AppManager) {}\n\n    public apps(): Apps {\n        return get(this.manager.attributes, [Fields.Apps]);\n    }\n\n    public get focus(): string | undefined {\n        return get(this.manager.attributes, [Fields.Focus]);\n    }\n\n    public getAppAttributes(id: string): AppSyncAttributes {\n        return get(this.apps(), [id]);\n    }\n\n    public getAppState(id: string) {\n        return get(this.apps(), [id, Fields.State]);\n    }\n\n    public getMaximized() {\n        return get(this.manager.attributes, [\"maximized\"])\n    }\n\n    public setupAppAttributes(params: AddAppParams, id: string, isDynamicPPT: boolean) {\n        const attributes = this.manager.attributes;\n        if (!attributes.apps) {\n            this.manager.safeSetAttributes({ apps: {} });\n        }\n        const attrNames = [\"scenePath\", \"title\"];\n        if (!isDynamicPPT) {\n            attrNames.push(\"scenes\");\n        }\n        const options = pick(params.options, attrNames);\n        const attrs: AppSyncAttributes = { kind: params.kind, options, isDynamicPPT };\n        if (typeof params.src === \"string\") {\n            attrs.src = params.src;\n        }\n        this.manager.safeUpdateAttributes([Fields.Apps, id], attrs);\n        this.manager.safeUpdateAttributes([Fields.Apps, id, Fields.State], {\n            [AppAttributes.Size]: {},\n            [AppAttributes.Position]: {},\n            [AppAttributes.SnapshotRect]: {},\n            [AppAttributes.SceneIndex]: 0,\n        });\n    }\n\n    public updateAppState(appId: string, stateName: AppAttributes, state: any) {\n        if (get(this.manager.attributes, [Fields.Apps, appId, Fields.State])) {\n            this.manager.safeUpdateAttributes([Fields.Apps, appId, Fields.State, stateName], state);\n        }\n    }\n\n    public cleanAppAttributes(id: string) {\n        this.manager.safeUpdateAttributes([Fields.Apps, id], undefined);\n        this.manager.safeSetAttributes({ [id]: undefined });\n        const focus = this.manager.attributes[Fields.Focus];\n        if (focus === id) {\n            this.cleanFocus();\n        }\n    }\n\n    public cleanFocus() {\n        this.manager.safeSetAttributes({ [Fields.Focus]: undefined });\n    }\n\n    public getAppSceneIndex(id: string) {\n        return this.getAppState(id)?.[AppAttributes.SceneIndex];\n    }\n\n    public getAppScenePath(id: string) {\n        return this.getAppAttributes(id)?.options?.scenePath;\n    }\n\n    public getMainViewScenePath() {\n        return this.manager.attributes[\"_mainScenePath\"];\n    }\n\n    public getMainViewSceneIndex() {\n        return this.manager.attributes[\"_mainSceneIndex\"];\n    }\n\n    public getBoxState() {\n        return this.manager.attributes[Fields.BoxState];\n    }\n\n    public setMainViewScenePath(scenePath: string) {\n        this.manager.safeSetAttributes({ _mainScenePath: scenePath });\n    }\n\n    public setMainViewSceneIndex(index: number) {\n        this.manager.safeSetAttributes({ _mainSceneIndex: index });\n    }\n\n    public getMainViewCamera(): MainViewCamera {\n        return get(this.manager.attributes, [Fields.MainViewCamera]);\n    }\n\n    public getMainViewSize(): MainViewSize {\n        return get(this.manager.attributes, [Fields.MainViewSize]);\n    }\n\n    public setMainViewCamera(camera: Camera & { id: string } | undefined) {\n        this.manager.safeSetAttributes({ [Fields.MainViewCamera]: { ...camera } });\n    }\n\n    public setMainViewSize(size: Size & { id: string } | undefined) {\n        this.manager.safeSetAttributes({ [Fields.MainViewSize]: { ...size } });\n    }\n\n    public setAppFocus(appId: string, focus: boolean) {\n        if (focus) {\n            this.manager.safeSetAttributes({ [Fields.Focus]: appId });\n        } else {\n            this.manager.safeSetAttributes({ [Fields.Focus]: undefined });\n        }\n    }\n\n    public updateCursor(uid: string, position: Position) {\n        if (!get(this.manager.attributes, [Fields.Cursors])) {\n            this.manager.safeUpdateAttributes([Fields.Cursors], {});\n        }\n        if (!get(this.manager.attributes, [Fields.Cursors, uid])) {\n            this.manager.safeUpdateAttributes([Fields.Cursors, uid], {});\n        }\n        this.manager.safeUpdateAttributes([Fields.Cursors, uid, Fields.Position], position);\n    }\n\n    public updateCursorState(uid: string, cursorState: string | undefined) {\n        if (!get(this.manager.attributes, [Fields.Cursors, uid])) {\n            this.manager.safeUpdateAttributes([Fields.Cursors, uid], {});\n        }\n        this.manager.safeUpdateAttributes(\n            [Fields.Cursors, uid, Fields.CursorState],\n            cursorState\n        );\n    }\n\n    public getCursorState(uid: string) {\n        return get(this.manager.attributes, [Fields.Cursors, uid, Fields.CursorState]);\n    }\n\n    public cleanCursor(uid: string) {\n        this.manager.safeUpdateAttributes([Fields.Cursors, uid], undefined);\n    }\n\n    // TODO 状态中保存一个 SceneName 优化性能\n    public setMainViewFocusPath() {\n        const scenePath = this.getMainViewScenePath();\n        if (scenePath) {\n            setViewFocusScenePath(this.manager.mainView, scenePath);\n        }\n    }\n}\n\nexport type MainViewSize = {\n    id: string;\n    width: number;\n    height: number;\n}\n\nexport type MainViewCamera = {\n    id: string;\n    centerX: number;\n    centerY: number;\n    scale: number;\n}\n\nexport type Cursors = {\n    [key: string]: Cursor;\n}\n","import { WindowManager } from \"../index\";\n\nexport const log = (...args: any[]): void => {\n    if (WindowManager.debug) {\n        console.log(`[WindowManager]:`, ...args);\n    }\n};\n","import { emitter } from \"../index\";\nimport type { AppManager } from \"../AppManager\";\n\nexport class Context {\n    public observerId: number;\n\n    constructor(private manager: AppManager) {\n        this.observerId = manager.displayer.observerId;\n\n        emitter.on(\"observerIdChange\", id => {\n            this.observerId = id;\n        });\n    };\n\n    public get uid() {\n        return this.manager.room?.uid || \"\";\n    }\n\n    public findMember = (memberId: number) => {\n        const roomMembers = this.manager.room?.state.roomMembers;\n        return roomMembers?.find(member => member.memberId === memberId);\n    }\n\n    public findMemberByUid = (uid: string) => {\n        const roomMembers = this.manager.room?.state.roomMembers;\n        return roomMembers?.find(member => member.payload?.uid === uid);\n    }\n\n    public updateManagerRect() {\n        this.manager.boxManager.updateManagerRect();\n    }\n\n    public blurFocusBox() {\n        this.manager.boxManager.blurFocusBox();\n    }\n\n    public switchAppToWriter(id: string) {\n        this.manager.viewManager.switchAppToWriter(id);\n    }\n}\n\nlet context: Context;\n\nexport const createContext = (manager: AppManager) => {\n    if (!context) {\n        context = new Context(manager);\n    }\n    return context;\n};\n","import type { AppManager } from \"../AppManager\";\nimport { AttributesDelegate } from \"../AttributesDelegate\";\nimport { createContext } from \"./Context\";\n\nexport class Base {\n    public store = new AttributesDelegate(this.manager);\n    public context = createContext(this.manager);\n\n    constructor(public manager: AppManager) {}\n}\n","import Emittery from \"emittery\";\nimport { AppAttributes, AppEvents, Events } from \"./constants\";\nimport { AppContext } from \"./AppContext\";\nimport { appRegister } from \"./Register\";\nimport { autorun, ViewVisionMode } from \"white-web-sdk\";\nimport { callbacks, emitter } from \"./index\";\nimport { Fields } from \"./AttributesDelegate\";\nimport { get } from \"lodash\";\nimport { log } from \"./Utils/log\";\nimport {\n    notifyMainViewModeChange,\n    setScenePath,\n    setViewFocusScenePath,\n    setViewMode,\n} from \"./Utils/Common\";\nimport type {\n    AppEmitterEvent,\n    AppInitState,\n    BaseInsertParams,\n    setAppOptions,\n    AppListenerKeys,\n} from \"./index\";\nimport type { SceneState, View, SceneDefinition } from \"white-web-sdk\";\nimport type { AppManager } from \"./AppManager\";\nimport type { NetlessApp } from \"./typings\";\nimport type { ReadonlyTeleBox } from \"@netless/telebox-insider\";\nimport { Base } from \"./Base\";\n\nexport class AppProxy extends Base {\n    public id: string;\n    public scenePath?: string;\n    public appEmitter: Emittery<AppEmitterEvent>;\n    public scenes?: SceneDefinition[];\n\n    private appListener: any;\n    private boxManager = this.manager.boxManager;\n    private appProxies = this.manager.appProxies;\n    private viewManager = this.manager.viewManager;\n    private cameraStore = this.manager.cameraStore;\n    private kind: string;\n    public isAddApp: boolean;\n    private status: \"normal\" | \"destroyed\" = \"normal\";\n\n    constructor(\n        private params: BaseInsertParams,\n        manager: AppManager,\n        appId: string,\n        isAddApp: boolean\n    ) {\n        super(manager);\n        this.kind = params.kind;\n        this.id = appId;\n        this.appProxies.set(this.id, this);\n        this.appEmitter = new Emittery();\n        this.appListener = this.makeAppEventListener(this.id);\n        this.isAddApp = isAddApp;\n\n        this.initScenes();\n\n        if (this.params.options?.scenePath) {\n            // 只有传入了 scenePath 的 App 才会创建 View\n            this.createView();\n        }\n    }\n\n    private initScenes() {\n        const options = this.params.options;\n        if (options) {\n            this.scenePath = options.scenePath;\n            if (this.appAttributes?.isDynamicPPT && this.scenePath) {\n                this.scenes = this.manager.displayer.entireScenes()[this.scenePath];\n            } else {\n                this.scenes = options.scenes;\n            }\n        }\n    }\n\n    public get view(): View | undefined {\n        return this.manager.viewManager.getView(this.id);\n    }\n\n    public get isWritable(): boolean {\n        return this.manager.canOperate && !this.box?.readonly;\n    }\n\n    public get attributes() {\n        return this.manager.attributes[this.id];\n    }\n\n    public get appAttributes() {\n        return this.store.getAppAttributes(this.id);\n    }\n\n    public getFullScenePath(): string | undefined {\n        if (this.scenePath) {\n            return get(this.appAttributes, [Fields.FullPath], this.scenePath);\n        }\n    }\n\n    public setFullPath(path: string) {\n        this.manager.safeUpdateAttributes([\"apps\", this.id, Fields.FullPath], path);\n    }\n\n    public async baseInsertApp(\n        skipUpdate = false,\n        focus?: boolean\n    ): Promise<{ appId: string; app: NetlessApp }> {\n        const params = this.params;\n        if (!params.kind) {\n            throw new Error(\"[WindowManager]: kind require\");\n        }\n        const appImpl = await appRegister.appClasses.get(params.kind)?.();\n        const appParams = appRegister.registered.get(params.kind);\n        if (appImpl) {\n            await this.setupApp(this.id, skipUpdate, appImpl, params.options, appParams?.appOptions);\n        } else {\n            throw new Error(`[WindowManager]: app load failed ${params.kind} ${params.src}`);\n        }\n        this.context.updateManagerRect();\n        if (focus) {\n            this.focusApp();\n        }\n        return {\n            appId: this.id,\n            app: appImpl,\n        };\n    }\n\n    private focusApp() {\n        this.focusBox();\n        this.context.switchAppToWriter(this.id);\n        this.store.setMainViewFocusPath();\n    }\n\n    public get box(): ReadonlyTeleBox | undefined {\n        return this.boxManager.getBox(this.id);\n    }\n\n    public focusBox() {\n        this.boxManager.focusBox({ appId: this.id });\n    }\n\n    private async setupApp(\n        appId: string,\n        skipUpdate: boolean,\n        app: NetlessApp,\n        options?: setAppOptions,\n        appOptions?: any\n    ) {\n        log(\"setupApp\", appId, app, options);\n        const context = new AppContext(this.manager, appId, this, appOptions);\n        try {\n            emitter.once(`${appId}${Events.WindowCreated}` as any).then(async () => {\n                let boxInitState: AppInitState | undefined;\n                if (!skipUpdate) {\n                    boxInitState = this.getAppInitState(appId);\n                    this.boxManager.updateBoxState(boxInitState);\n                }\n                this.appEmitter.onAny(this.appListener);\n                this.appAttributesUpdateListener(appId);\n                this.setViewFocusScenePath();\n                setTimeout(async () => {\n                    // 延迟执行 setup, 防止初始化的属性没有更新成功\n                    const result = await app.setup(context);\n                    appRegister.notifyApp(app.kind, \"created\", { appId, result });\n                    this.afterSetupApp(boxInitState);\n                    this.fixMobileSize();\n                }, 50);\n            });\n            this.boxManager.createBox({\n                appId: appId,\n                app,\n                options,\n                canOperate: this.manager.canOperate,\n            });\n        } catch (error: any) {\n            console.error(error);\n            throw new Error(`[WindowManager]: app setup error: ${error.message}`);\n        }\n    }\n\n    // 兼容移动端创建时会出现 PPT 不适配的问题\n    private fixMobileSize() {\n        const box = this.boxManager.getBox(this.id);\n        if (box) {\n            this.boxManager.resizeBox({\n                appId: this.id,\n                width: box.intrinsicWidth + 0.001,\n                height: box.intrinsicHeight + 0.001,\n                skipUpdate: true,\n            });\n        }\n    }\n\n    private afterSetupApp(boxInitState: AppInitState | undefined): void {\n        if (boxInitState) {\n            if (boxInitState.focus && this.scenePath) {\n                this.context.switchAppToWriter(this.id);\n            }\n            if (!boxInitState?.x || !boxInitState.y) {\n                this.boxManager.setBoxInitState(this.id);\n            }\n        }\n    }\n\n    public onSeek(time: number) {\n        this.appEmitter.emit(\"seek\", time);\n        const boxInitState = this.getAppInitState(this.id);\n        this.boxManager.updateBoxState(boxInitState);\n    }\n\n    public async onReconnected() {\n        this.appEmitter.emit(\"reconnected\", undefined);\n        const currentAppState = this.getAppInitState(this.id);\n        await this.destroy(true, false, true);\n        const params = this.params;\n        const appProxy = new AppProxy(params, this.manager, this.id, this.isAddApp);\n        await appProxy.baseInsertApp(true, this.store.focus === this.id);\n        this.boxManager.updateBoxState(currentAppState);\n    }\n\n    public switchToWritable() {\n        appRegister.notifyApp(this.kind, \"focus\", { appId: this.id });\n        this.cameraStore.switchView(this.id, this.view, () => {\n            if (this.view) {\n                if (this.view.mode === ViewVisionMode.Writable) return;\n                try {\n                    if (this.manager.mainView.mode === ViewVisionMode.Writable) {\n                        this.store.setMainViewFocusPath();\n                        notifyMainViewModeChange(callbacks, ViewVisionMode.Freedom);\n                        setViewMode(this.manager.mainView, ViewVisionMode.Freedom);\n                    }\n                    setViewMode(this.view, ViewVisionMode.Writable);\n                } catch (error) {\n                    log(\"switch view failed\", error);\n                }\n            }\n        });\n    }\n\n    public getAppInitState = (id: string) => {\n        const attrs = this.store.getAppState(id);\n        if (!attrs) return;\n        const position = attrs?.[AppAttributes.Position];\n        const focus = this.store.focus;\n        const size = attrs?.[AppAttributes.Size];\n        const sceneIndex = attrs?.[AppAttributes.SceneIndex];\n        const maximized = this.attributes?.[\"maximized\"];\n        const minimized = this.attributes?.[\"minimized\"];\n        let payload = { maximized, minimized } as AppInitState;\n        if (position) {\n            payload = { ...payload, id: id, x: position.x, y: position.y };\n        }\n        if (focus === id) {\n            payload = { ...payload, focus: true };\n        }\n        if (size) {\n            payload = { ...payload, width: size.width, height: size.height };\n        }\n        if (sceneIndex) {\n            payload = { ...payload, sceneIndex };\n        }\n        return payload;\n    };\n\n    public emitAppSceneStateChange(sceneState: SceneState) {\n        this.appEmitter.emit(\"sceneStateChange\", sceneState);\n    }\n\n    public emitAppIsWritableChange() {\n        this.appEmitter.emit(\"writableChange\", this.isWritable);\n    }\n\n    private makeAppEventListener(appId: string) {\n        return (eventName: AppListenerKeys, data: any) => {\n            if (!this.manager.canOperate) return;\n            switch (eventName) {\n                case \"setBoxSize\": {\n                    this.boxManager.resizeBox({\n                        appId,\n                        width: data.width,\n                        height: data.height,\n                        skipUpdate: false,\n                    });\n                    break;\n                }\n                case \"setBoxMinSize\": {\n                    this.boxManager.setBoxMinSize({\n                        appId,\n                        minWidth: data.minwidth,\n                        minHeight: data.minheight,\n                    });\n                    break;\n                }\n                case \"setBoxTitle\": {\n                    this.boxManager.setBoxTitle({ appId, title: data.title });\n                    break;\n                }\n                case AppEvents.destroy: {\n                    if (this.status === \"destroyed\") return;\n                    this.destroy(true, false, true, data?.error);\n                    if (data?.error) {\n                        console.error(data?.error);\n                    }\n                    break;\n                }\n                case \"focus\": {\n                    this.boxManager.focusBox({ appId: this.id });\n                    emitter.emit(\"focus\", { appId: this.id });\n                    break;\n                }\n                default: {\n                    break;\n                }\n            }\n        };\n    }\n\n    private appAttributesUpdateListener = (appId: string) => {\n        this.manager.refresher?.add(appId, () => {\n            return autorun(() => {\n                const attrs = this.manager.attributes[appId];\n                if (attrs) {\n                    this.appEmitter.emit(\"attributesUpdate\", attrs);\n                }\n            });\n        });\n    };\n\n    public setScenePath(): void {\n        if (!this.manager.canOperate) return;\n        const fullScenePath = this.getFullScenePath();\n        if (this.manager.room && fullScenePath && this.view) {\n            setScenePath(this.manager.room, fullScenePath);\n        }\n    }\n\n    public setViewFocusScenePath() {\n        const fullPath = this.getFullScenePath();\n        if (fullPath && this.view) {\n            setViewFocusScenePath(this.view, fullPath);\n        }\n    }\n\n    private async createView(): Promise<View> {\n        const view = await this.viewManager.createView(this.id);\n        this.cameraStore.register(this.id, view);\n        this.setViewFocusScenePath();\n        return view;\n    }\n\n    public async destroy(\n        needCloseBox: boolean,\n        cleanAttrs: boolean,\n        skipUpdate: boolean,\n        error?: Error\n    ) {\n        if (this.status === \"destroyed\") return;\n        this.status = \"destroyed\";\n        await appRegister.notifyApp(this.kind, \"destroy\", { appId: this.id });\n        await this.appEmitter.emit(\"destroy\", { error });\n        this.appEmitter.clearListeners();\n        emitter.emit(`destroy-${this.id}` as any, { error });\n        if (needCloseBox) {\n            this.boxManager.closeBox(this.id, skipUpdate);\n        }\n        if (cleanAttrs) {\n            this.store.cleanAppAttributes(this.id);\n        }\n        this.appProxies.delete(this.id);\n        this.cameraStore.unregister(this.id, this.view);\n\n        this.viewManager.destroyView(this.id);\n        this.manager.appStatus.delete(this.id);\n        this.manager.refresher?.remove(this.id);\n    }\n\n    public close(): Promise<void> {\n        return this.destroy(true, true, false);\n    }\n}\n","import { callbacks, emitter, WindowManager } from \"./index\";\nimport { debounce, maxBy } from \"lodash\";\nimport { DEFAULT_COLLECTOR_STYLE, Events, MIN_HEIGHT, MIN_WIDTH } from \"./constants\";\nimport {\n    TELE_BOX_MANAGER_EVENT,\n    TELE_BOX_STATE,\n    TeleBoxCollector,\n    TeleBoxManager,\n} from \"@netless/telebox-insider\";\nimport type { AddAppOptions, AppInitState } from \"./index\";\nimport type {\n    TeleBoxManagerUpdateConfig,\n    TeleBoxManagerCreateConfig,\n    ReadonlyTeleBox,\n    TeleBoxManagerConfig,\n    TeleBoxColorScheme,\n} from \"@netless/telebox-insider\";\nimport type Emittery from \"emittery\";\nimport type { AppManager } from \"./AppManager\";\nimport type { NetlessApp } from \"./typings\";\nimport type { View } from \"white-web-sdk\";\n\nexport { TELE_BOX_STATE };\n\nexport type CreateBoxParams = {\n    appId: string;\n    app: NetlessApp;\n    view?: View;\n    emitter?: Emittery;\n    options?: AddAppOptions;\n    canOperate?: boolean;\n};\n\ntype AppId = { appId: string };\n\ntype MoveBoxParams = AppId & { x: number; y: number };\n\ntype ResizeBoxParams = AppId & { width: number; height: number; skipUpdate: boolean };\n\ntype SetBoxMinSizeParams = AppId & { minWidth: number; minHeight: number };\n\ntype SetBoxTitleParams = AppId & { title: string };\n\nexport type CreateTeleBoxManagerConfig = {\n    collectorContainer?: HTMLElement;\n    collectorStyles?: Partial<CSSStyleDeclaration>;\n    prefersColorScheme?: TeleBoxColorScheme;\n};\n\nexport class BoxManager {\n    public teleBoxManager: TeleBoxManager;\n    public appBoxMap: Map<string, string> = new Map();\n    private mainView = this.manager.mainView;\n\n    constructor(\n        private manager: AppManager,\n        createTeleBoxManagerConfig?: CreateTeleBoxManagerConfig\n    ) {\n        this.teleBoxManager = this.setupBoxManager(createTeleBoxManagerConfig);\n        this.teleBoxManager.events.on(TELE_BOX_MANAGER_EVENT.State, state => {\n            if (state) {\n                callbacks.emit(\"boxStateChange\", state);\n                emitter.emit(\"boxStateChange\", state);\n            }\n        });\n        this.teleBoxManager.events.on(\"minimized\", minimized => {\n            this.manager.safeSetAttributes({ minimized });\n        });\n        this.teleBoxManager.events.on(\"maximized\", maximized => {\n            this.manager.safeSetAttributes({ maximized });\n        });\n        this.teleBoxManager.events.on(\"removed\", boxes => {\n            boxes.forEach(box => {\n                emitter.emit(\"close\", { appId: box.id });\n            });\n        });\n        this.teleBoxManager.events.on(\n            \"intrinsic_move\",\n            debounce((box: ReadonlyTeleBox): void => {\n                emitter.emit(\"move\", { appId: box.id, x: box.intrinsicX, y: box.intrinsicY });\n            }, 50)\n        );\n        this.teleBoxManager.events.on(\n            \"intrinsic_resize\",\n            debounce((box: ReadonlyTeleBox): void => {\n                emitter.emit(\"resize\", {\n                    appId: box.id,\n                    width: box.intrinsicWidth,\n                    height: box.intrinsicHeight,\n                });\n            }, 200)\n        );\n        this.teleBoxManager.events.on(\"focused\", box => {\n            if (box) {\n                if (this.manager.canOperate) {\n                    emitter.emit(\"focus\", { appId: box.id });\n                } else {\n                    this.teleBoxManager.update(box.id, { focus: false });\n                }\n            } else {\n                this.blurFocusBox();\n            }\n        });\n        this.teleBoxManager.events.on(\"dark_mode\", darkMode => {\n            callbacks.emit(\"darkModeChange\", darkMode);\n        });\n        this.teleBoxManager.events.on(\"prefers_color_scheme\", colorScheme => {\n            callbacks.emit(\"prefersColorSchemeChange\", colorScheme);\n        });\n    }\n\n    public get boxState() {\n        return this.teleBoxManager.state;\n    }\n\n    public get maximized() {\n        return this.teleBoxManager.maximized;\n    }\n\n    public get minimized() {\n        return this.teleBoxManager.minimized;\n    }\n\n    public get darkMode() {\n        return this.teleBoxManager.darkMode;\n    }\n\n    public get prefersColorScheme(): TeleBoxColorScheme {\n        return this.teleBoxManager.prefersColorScheme;\n    }\n\n    public createBox(params: CreateBoxParams): void {\n        if (!this.teleBoxManager) return;\n        let { minwidth = MIN_WIDTH, minheight = MIN_HEIGHT } = params.app.config ?? {};\n        const { width, height } = params.app.config ?? {};\n        const title = params.options?.title || params.appId;\n        const rect = this.teleBoxManager.containerRect;\n\n        if (minwidth > 1) {\n            minwidth = minwidth / rect.width;\n        }\n\n        if (minheight > 1) {\n            minheight = minheight / rect.height;\n        }\n\n        const createBoxConfig: TeleBoxManagerCreateConfig = {\n            title,\n            minWidth: minwidth,\n            minHeight: minheight,\n            width,\n            height,\n            id: params.appId,\n        };\n        this.teleBoxManager.create(createBoxConfig);\n        emitter.emit(`${params.appId}${Events.WindowCreated}` as any);\n    }\n\n    public setBoxInitState(appId: string): void {\n        const box = this.teleBoxManager.queryOne({ id: appId });\n        if (box) {\n            if (box.state === TELE_BOX_STATE.Maximized) {\n                emitter.emit(\"resize\", {\n                    appId: appId,\n                    x: box.x,\n                    y: box.y,\n                    width: box.intrinsicWidth,\n                    height: box.intrinsicHeight,\n                });\n            }\n        }\n    }\n\n    public setupBoxManager(\n        createTeleBoxManagerConfig?: CreateTeleBoxManagerConfig\n    ): TeleBoxManager {\n        const root = WindowManager.wrapper ? WindowManager.wrapper : document.body;\n        const rect = root.getBoundingClientRect();\n        const initManagerState: TeleBoxManagerConfig = {\n            root: root,\n            containerRect: {\n                x: 0,\n                y: 0,\n                width: rect.width,\n                height: rect.height,\n            },\n            fence: false,\n            prefersColorScheme: createTeleBoxManagerConfig?.prefersColorScheme,\n        };\n        const container = createTeleBoxManagerConfig?.collectorContainer || WindowManager.wrapper;\n        const styles = {\n            ...DEFAULT_COLLECTOR_STYLE,\n            ...createTeleBoxManagerConfig?.collectorStyles,\n        };\n        const teleBoxCollector = new TeleBoxCollector({\n            styles: styles,\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        }).mount(container!);\n        initManagerState.collector = teleBoxCollector;\n        const manager = new TeleBoxManager(initManagerState);\n        if (this.teleBoxManager) {\n            this.teleBoxManager.destroy();\n        }\n        this.teleBoxManager = manager;\n        return manager;\n    }\n\n    public getBox(appId: string): ReadonlyTeleBox | undefined {\n        return this.teleBoxManager.queryOne({ id: appId });\n    }\n\n    public closeBox(appId: string, skipUpdate = false): ReadonlyTeleBox | undefined {\n        return this.teleBoxManager.remove(appId, skipUpdate);\n    }\n\n    public boxIsFocus(appId: string): boolean | undefined {\n        const box = this.getBox(appId);\n        return box?.focus;\n    }\n\n    public getFocusBox(): ReadonlyTeleBox | undefined {\n        const boxes = this.teleBoxManager.query({ focus: true });\n        return boxes[0];\n    }\n\n    public getTopBox(): ReadonlyTeleBox | undefined {\n        const boxes = this.teleBoxManager.query();\n        return maxBy(boxes, \"zIndex\");\n    }\n\n    public updateBoxState(state?: AppInitState): void {\n        if (!state) return;\n        const box = this.getBox(state.id);\n        if (box) {\n            this.teleBoxManager.update(\n                box.id,\n                {\n                    x: state.x,\n                    y: state.y,\n                    width: state.width || 0.5,\n                    height: state.height || 0.5,\n                },\n                true\n            );\n            if (state.maximized != null) {\n                this.teleBoxManager.setMaximized(Boolean(state.maximized), true);\n                this.teleBoxManager.setMinimized(Boolean(state.minimized), true);\n            }\n            setTimeout(() => {\n                if (state.focus) {\n                    this.teleBoxManager.update(box.id, { focus: true }, true);\n                }\n            }, 50);\n            callbacks.emit(\"boxStateChange\", this.teleBoxManager.state);\n        }\n    }\n\n    public updateManagerRect(): void {\n        const rect = this.mainView.divElement?.getBoundingClientRect();\n        if (rect && rect.width > 0 && rect.height > 0) {\n            const containerRect = { x: 0, y: 0, width: rect.width, height: rect.height };\n            this.teleBoxManager.setContainerRect(containerRect);\n            this.manager.notifyContainerRectUpdate(this.teleBoxManager.containerRect);\n        }\n    }\n\n    public moveBox({ appId, x, y }: MoveBoxParams): void {\n        this.teleBoxManager.update(appId, { x, y }, true);\n    }\n\n    public focusBox({ appId }: AppId, skipUpdate = true): void {\n        this.teleBoxManager.update(appId, { focus: true }, skipUpdate);\n    }\n\n    public resizeBox({ appId, width, height, skipUpdate }: ResizeBoxParams): void {\n        this.teleBoxManager.update(appId, { width, height }, skipUpdate);\n    }\n\n    public setBoxMinSize(params: SetBoxMinSizeParams): void {\n        this.teleBoxManager.update(\n            params.appId,\n            {\n                minWidth: params.minWidth,\n                minHeight: params.minHeight,\n            },\n            true\n        );\n    }\n\n    public setBoxTitle(params: SetBoxTitleParams): void {\n        this.teleBoxManager.update(params.appId, { title: params.title }, true);\n    }\n\n    public blurAllBox(): void {\n        this.teleBoxManager.updateAll({ focus: false });\n    }\n\n    public blurFocusBox(): void {\n        const focusBoxes = this.teleBoxManager.query({ focus: true });\n        if (focusBoxes.length) {\n            const box = focusBoxes[0];\n            this.teleBoxManager.update(box.id, { focus: false });\n        }\n    }\n\n    public updateAll(config: TeleBoxManagerUpdateConfig): void {\n        this.teleBoxManager.updateAll(config);\n    }\n\n    public setMaximized(maximized: boolean) {\n        this.teleBoxManager.setMaximized(maximized, true);\n    }\n\n    public setMinimized(minimized: boolean, skipUpdate = true) {\n        this.teleBoxManager.setMinimized(minimized, skipUpdate);\n    }\n\n    public focusTopBox(): void {\n        const boxes = this.teleBoxManager.query();\n        if (boxes.length >= 1) {\n            const box = this.getTopBox();\n            if (box) {\n                this.focusBox({ appId: box.id }, false);\n            }\n        }\n    }\n\n    public setReadonly(readonly: boolean) {\n        this.teleBoxManager.setReadonly(readonly);\n    }\n\n    public setPrefersColorScheme(colorScheme: TeleBoxColorScheme) {\n        this.teleBoxManager.setPrefersColorScheme(colorScheme);\n    }\n\n    public destroy() {\n        this.teleBoxManager.destroy();\n    }\n}\n","import { AnimationMode } from \"white-web-sdk\";\nimport type { Camera, View } from \"white-web-sdk\";\n\nexport class CameraStore {\n    private cameras: Map<string, Camera> = new Map();\n    private listeners: Map<string, any> = new Map();\n\n    public setCamera(id: string, camera: Camera) {\n        this.cameras.set(id, camera);\n    }\n\n    public getCamera(id: string) {\n        return this.cameras.get(id);\n    }\n\n    public deleteCamera(id: string) {\n        this.cameras.delete(id);\n    }\n\n    public recoverCamera(id: string, view?: View) {\n        const camera = this.cameras.get(id);\n        if (camera && view) {\n            view.moveCamera({\n                ...camera,\n                animationMode: AnimationMode.Immediately,\n            });\n        }\n    }\n\n    public register(id: string, view: View) {\n        this.onListener(id, view);\n        this.setCamera(id, view.camera);\n    }\n\n    public unregister(id: string, view?: View) {\n        if (view) {\n            this.offListener(id, view);\n        }\n        this.listeners.delete(id);\n        this.deleteCamera(id);\n    }\n\n    private onListener = (id: string, view: View) => {\n        view.callbacks.on(\"onCameraUpdated\", this.getOrCreateListener(id));\n    };\n\n    private offListener = (id: string, view: View) => {\n        view.callbacks.off(\"onCameraUpdated\", this.getOrCreateListener(id));\n    };\n\n    public async switchView(id: string, view: View | undefined, callback: () => void) {\n        if (view) {\n            this.offListener(id, view);\n            await callback();\n            this.recoverCamera(id, view);\n            this.onListener(id, view);\n        }\n    }\n\n    private getOrCreateListener(id: string) {\n        let listener = this.listeners.get(id);\n        if (listener) {\n            return listener;\n        } else {\n            listener = (camera: Camera) => {\n                this.setCamera(id, camera);\n            };\n            this.listeners.set(id, listener);\n            return listener;\n        }\n    }\n}\n","import { Base } from \"./Base\";\nimport { callbacks, WindowManager } from \"./index\";\nimport { reaction, ViewVisionMode } from \"white-web-sdk\";\nimport { SET_SCENEPATH_DELAY } from \"./constants\";\nimport { notifyMainViewModeChange, setScenePath, setViewMode } from \"./Utils/Common\";\nimport type { View, Displayer } from \"white-web-sdk\";\nimport type { AppManager } from \"./AppManager\";\n\nexport class ViewManager extends Base {\n    private views: Map<string, View> = new Map();\n    private timer?: number;\n    private appTimer?: number;\n\n    private mainViewProxy = this.manager.mainViewProxy;\n    private displayer = this.manager.displayer;\n\n    constructor(manager: AppManager) {\n        super(manager);\n        setTimeout(() => {\n            // 延迟初始化 focus 的 reaction\n            this.manager.refresher?.add(\"focus\", () => {\n                return reaction(\n                    () => this.store.focus,\n                    focus => {\n                        if (focus) {\n                            this.switchAppToWriter(focus);\n                        } else {\n                            this.switchMainViewToWriter();\n                            this.context.blurFocusBox();\n                        }\n                    },\n                    { fireImmediately: true }\n                );\n            });\n        }, 100);\n    }\n\n    public get currentScenePath(): string {\n        return this.displayer.state.sceneState.scenePath;\n    }\n\n    public get mainView(): View {\n        return this.mainViewProxy.view;\n    }\n\n    public createView(appId: string): View {\n        const view = createView(this.displayer);\n        setViewMode(view, ViewVisionMode.Freedom);\n        this.views.set(appId, view);\n        return view;\n    }\n\n    public destroyView(appId: string): void {\n        const view = this.views.get(appId);\n        if (view) {\n            this.releaseView(view);\n            this.views.delete(appId);\n        }\n    }\n\n    private releaseView(view: View) {\n        if (!(view as any).didRelease) {\n            view.release();\n        }\n    }\n\n    public getView(appId: string): View | undefined {\n        return this.views.get(appId);\n    }\n\n    public switchMainViewToWriter(): Promise<boolean> | undefined {\n        if (this.timer) {\n            clearTimeout(this.timer);\n        }\n        if (this.mainView.mode === ViewVisionMode.Writable) return;\n        this.freedomAllViews();\n        return new Promise((resolve, reject) => {\n            this.timer = window.setTimeout(() => {\n                try {\n                    const mainViewScenePath = this.store.getMainViewScenePath();\n                    if (mainViewScenePath) {\n                        this.freedomAllViews();\n                        setScenePath(this.manager.room, mainViewScenePath);\n                        this.mainViewProxy.switchViewModeToWriter();\n                    }\n                    resolve(true);\n                } catch (error) {\n                    reject(error);\n                }\n            }, SET_SCENEPATH_DELAY);\n        });\n    }\n\n    public freedomAllViews(): void {\n        this.manager.appProxies.forEach(appProxy => {\n            appProxy.setViewFocusScenePath();\n            if (appProxy.view) {\n                setViewMode(appProxy.view, ViewVisionMode.Freedom);\n            }\n        });\n        if (this.mainView.mode === ViewVisionMode.Writable) {\n            notifyMainViewModeChange(callbacks, ViewVisionMode.Freedom);\n            setViewMode(this.mainView, ViewVisionMode.Freedom);\n        }\n        if (!this.mainView.focusScenePath) {\n            this.store.setMainViewFocusPath();\n        }\n    }\n\n    public switchAppToWriter(id: string): void {\n        if (this.appTimer) {\n            clearTimeout(this.appTimer);\n        }\n        this.freedomAllViews();\n        // 为了同步端不闪烁, 需要给 room setScenePath 一个延迟\n        this.appTimer = setTimeout(() => {\n            const appProxy = this.manager.appProxies.get(id);\n            if (appProxy) {\n                if (this.manager.boxManager.minimized) return;\n                appProxy.setScenePath();\n                appProxy.switchToWritable();\n                appProxy.focusBox();\n            }\n        }, SET_SCENEPATH_DELAY);\n    }\n\n    public destroy(): void {\n        this.mainViewProxy.removeMainViewListener();\n        if (WindowManager.wrapper) {\n            WindowManager.wrapper.parentNode?.removeChild(WindowManager.wrapper);\n            WindowManager.wrapper = undefined;\n        }\n        this.releaseView(this.mainView);\n    }\n}\n\nexport const createView = (displayer: Displayer): View => {\n    const view = displayer.views.createView();\n    setDefaultCameraBound(view);\n    return view;\n};\n\nexport const setDefaultCameraBound = (view: View) => {\n    view.setCameraBound({\n        maxContentMode: () => 10,\n        minContentMode: () => 0.1,\n    });\n};\n\nexport const setupWrapper = (\n    root: HTMLElement\n): {\n    playground: HTMLDivElement;\n    wrapper: HTMLDivElement;\n    sizer: HTMLDivElement;\n    mainViewElement: HTMLDivElement;\n} => {\n    const playground = document.createElement(\"div\");\n    playground.className = \"netless-window-manager-playground\";\n\n    const sizer = document.createElement(\"div\");\n    sizer.className = \"netless-window-manager-sizer\";\n\n    const wrapper = document.createElement(\"div\");\n    wrapper.className = \"netless-window-manager-wrapper\";\n\n    const mainViewElement = document.createElement(\"div\");\n    mainViewElement.className = \"netless-window-manager-main-view\";\n\n    playground.appendChild(sizer);\n    sizer.appendChild(wrapper);\n    wrapper.appendChild(mainViewElement);\n    root.appendChild(playground);\n    WindowManager.wrapper = wrapper;\n\n    return { playground, wrapper, sizer, mainViewElement };\n};\n","import { AnimationMode, reaction, ViewVisionMode } from \"white-web-sdk\";\nimport { Base } from \"./Base\";\nimport { callbacks, emitter } from \"./index\";\nimport { createView } from \"./ViewManager\";\nimport { debounce, isEmpty, isEqual } from \"lodash\";\nimport { Fields } from \"./AttributesDelegate\";\nimport { notifyMainViewModeChange, setViewFocusScenePath, setViewMode } from \"./Utils/Common\";\nimport type { Camera, Size, View } from \"white-web-sdk\";\nimport type { AppManager } from \"./AppManager\";\n\nexport class MainViewProxy extends Base {\n    private scale?: number;\n    private cameraStore = this.manager.cameraStore;\n    private started = false;\n    private mainViewIsAddListener = false;\n    private mainView: View;\n    private viewId = \"mainView\";\n\n    constructor(manager: AppManager) {\n        super(manager);\n        this.mainView = this.createMainView();\n        this.moveCameraSizeByAttributes();\n        this.cameraStore.register(this.viewId, this.mainView);\n        emitter.once(\"mainViewMounted\").then(() => {\n            setTimeout(() => {\n                this.start();\n                if (!this.mainViewCamera || !this.mainViewSize) {\n                    this.setCameraAndSize();\n                }\n            }, 200); // 等待 mainView 挂载完毕再进行监听，否则会触发不必要的 onSizeUpdated\n        });\n        emitter.on(\"playgroundSizeChange\", () => {\n            this.sizeChangeHandler(this.mainViewSize);\n        });\n    }\n\n    private get mainViewCamera() {\n        return this.store.getMainViewCamera();\n    }\n\n    private get mainViewSize() {\n        return this.store.getMainViewSize();\n    }\n\n    private moveCameraSizeByAttributes() {\n        this.moveCameraToContian(this.mainViewSize);\n        this.moveCamera(this.mainViewCamera);\n    }\n\n    public start() {\n        if (this.started) return;\n        this.sizeChangeHandler(this.mainViewSize);\n        this.addCameraListener();\n        this.manager.refresher?.add(Fields.MainViewCamera, this.cameraReaction);\n        this.started = true;\n    }\n\n    public setCameraAndSize(): void {\n        this.store.setMainViewCamera({ ...this.mainView.camera, id: this.context.uid });\n        this.store.setMainViewSize({ ...this.mainView.size, id: this.context.uid });\n    }\n\n    private cameraReaction = () => {\n        return reaction(\n            () => this.mainViewCamera,\n            camera => {\n                if (camera && camera.id !== this.context.uid) {\n                    this.moveCameraToContian(this.mainViewSize);\n                    this.moveCamera(camera);\n                }\n            },\n            {\n                fireImmediately: true,\n            }\n        );\n    };\n\n    private sizeChangeHandler =  debounce((size: Size) => {\n        if (size) {\n            this.moveCameraToContian(size);\n            this.moveCamera(this.mainViewCamera);\n        }\n    }, 30);\n\n    public get view(): View {\n        return this.mainView;\n    }\n\n    public get cameraState() {\n        return { ...this.view.camera, ...this.view.size };\n    }\n\n    public createMainView(): View {\n        const mainView = createView(this.manager.displayer);\n        const mainViewScenePath = this.store.getMainViewScenePath();\n        if (mainViewScenePath) {\n            setViewFocusScenePath(mainView, mainViewScenePath);\n        }\n        if (!this.store.focus) {\n            this.switchViewModeToWriter();\n        }\n        return mainView;\n    }\n\n    private onCameraUpdatedByDevice = (camera: Camera) => {\n        this.store.setMainViewCamera({ ...camera, id: this.context.uid });\n        if (!isEqual(this.mainViewSize, {...this.mainView.size, id: this.context.uid})) {\n            this.setMainViewSize(this.view.size);\n        }\n    };\n\n    public addMainViewListener(): void {\n        if (this.mainViewIsAddListener) return;\n        if (this.view.divElement) {\n            this.view.divElement.addEventListener(\"click\", this.mainViewClickListener);\n            this.view.divElement.addEventListener(\"touchend\", this.mainViewClickListener);\n            this.mainViewIsAddListener = true;\n        }\n    }\n\n    public removeMainViewListener(): void {\n        if (this.view.divElement) {\n            this.view.divElement.removeEventListener(\"click\", this.mainViewClickListener);\n            this.view.divElement.removeEventListener(\"touchend\", this.mainViewClickListener);\n        }\n    }\n\n    private mainViewClickListener = () => {\n        this.mainViewClickHandler();\n    };\n\n    public async mainViewClickHandler(): Promise<void> {\n        if (!this.manager.canOperate) return;\n        if (this.view.mode === ViewVisionMode.Writable) return;\n        this.store.cleanFocus();\n        this.context.blurFocusBox();\n    }\n\n    public setMainViewSize = debounce(size => {\n        this.store.setMainViewSize({ ...size, id: this.context.uid });\n    }, 50);\n\n    private addCameraListener() {\n        this.view.callbacks.on(\"onCameraUpdatedByDevice\", this.onCameraUpdatedByDevice);\n        this.view.callbacks.on(\"onCameraUpdated\", this.onCameraOrSizeUpdated);\n        this.view.callbacks.on(\"onSizeUpdated\", this.onCameraOrSizeUpdated);\n    }\n\n    private removeCameraListener() {\n        this.view.callbacks.off(\"onCameraUpdatedByDevice\", this.onCameraUpdatedByDevice);\n        this.view.callbacks.off(\"onCameraUpdated\", this.onCameraOrSizeUpdated);\n        this.view.callbacks.off(\"onSizeUpdated\", this.onCameraOrSizeUpdated);\n    }\n\n    private onCameraOrSizeUpdated = () => {\n        callbacks.emit(\"cameraStateChange\", this.cameraState);\n    };\n\n    public switchViewModeToWriter(): void {\n        if (!this.manager.canOperate) return;\n        if (this.view) {\n            if (this.view.mode === ViewVisionMode.Writable) return;\n            this.cameraStore.switchView(this.viewId, this.mainView, () => {\n                notifyMainViewModeChange(callbacks, ViewVisionMode.Writable);\n                setViewMode(this.view, ViewVisionMode.Writable);\n            });\n        }\n    }\n\n    public moveCameraToContian(size: Size): void {\n        if (!isEmpty(size)) {\n            this.view.moveCameraToContain({\n                width: size.width,\n                height: size.height,\n                originX: -size.width / 2,\n                originY: -size.height / 2,\n                animationMode: AnimationMode.Immediately,\n            });\n            this.scale = this.view.camera.scale;\n        }\n    }\n\n    public moveCamera(camera: Camera): void {\n        if (!isEmpty(camera)) {\n            if (isEqual(camera, this.view.camera)) return;\n            const { centerX, centerY, scale } = camera;\n            const needScale = scale * (this.scale || 1);\n            this.view.moveCamera({\n                centerX: centerX,\n                centerY: centerY,\n                scale: needScale,\n                animationMode: AnimationMode.Immediately,\n            });\n        }\n    }\n\n    public stop() {\n        this.removeCameraListener();\n        this.manager.refresher?.remove(Fields.MainViewCamera);\n        this.manager.refresher?.remove(Fields.MainViewSize);\n        this.started = false;\n    }\n\n    public destroy() {\n        this.stop();\n        this.cameraStore.unregister(this.viewId, this.mainView);\n    }\n}\n","import { listenUpdated, unlistenUpdated, reaction, UpdateEventKind } from \"white-web-sdk\";\nimport type { AkkoObjectUpdatedProperty , AkkoObjectUpdatedListener } from \"white-web-sdk\";\n\n// 兼容 13 和 14 版本 SDK\nexport const onObjectByEvent = (event: UpdateEventKind) => {\n    return (object: any, func: () => void) => {\n        if (object === undefined) return;\n        if (listenUpdated) {\n            const listener = (events: readonly AkkoObjectUpdatedProperty<any>[]) => {\n                const kinds = events.map(e => e.kind);\n                if (kinds.includes(event)) {\n                    func();\n                }\n            }\n            listenUpdated(object, listener);\n            func();\n            return () => unlistenUpdated(object, listener);\n        } else {\n            return reaction(\n                () => object,\n                () => {\n                    func();\n                }, {\n                    fireImmediately: true,\n                }\n            )\n        }\n    }\n}\n\nexport const safeListenPropsUpdated = <T>(\n    getProps: () => T,\n    callback: AkkoObjectUpdatedListener<T>\n  ) => {\n    let disposeListenUpdated: (() => void) | null = null;\n    const disposeReaction = reaction(\n      getProps,\n      () => {\n        if (disposeListenUpdated) {\n          disposeListenUpdated();\n          disposeListenUpdated = null;\n        }\n        const props = getProps();\n        disposeListenUpdated = () => unlistenUpdated(props, callback);\n        listenUpdated(props, callback);\n      },\n      { fireImmediately: true }\n    );\n\n    return () => {\n      disposeListenUpdated?.();\n      disposeReaction();\n    };\n}\n\nexport const onObjectRemoved = onObjectByEvent(UpdateEventKind.Removed);\nexport const onObjectInserted = onObjectByEvent(UpdateEventKind.Inserted);\n","import { isFunction } from 'lodash';\nimport { RoomPhase } from 'white-web-sdk';\nimport type { Room } from \"white-web-sdk\";\nimport type { AppManager } from './AppManager';\nimport { log } from './Utils/log';\n\n// 白板重连之后会刷新所有的对象，导致 listener 失效, 所以这里在重连之后重新对所有对象进行监听\nexport class ReconnectRefresher {\n    private phase?: RoomPhase;\n    private room: Room | undefined;\n    private reactors: Map<string, any> = new Map();\n    private disposers: Map<string, any> = new Map();\n\n    constructor(room: Room | undefined, private manager: AppManager) {\n        this.room = room;\n        this.phase = room?.phase;\n        room?.callbacks.on(\"onPhaseChanged\", this.onPhaseChanged);\n    }\n\n    private onPhaseChanged = (phase: RoomPhase) => {\n        if (phase === RoomPhase.Connected && this.phase === RoomPhase.Reconnecting) {\n            this.onReconnected();\n        }\n        this.phase = phase;\n    }\n\n    private onReconnected = () => {\n        log(\"onReconnected refresh reactors\");\n        this.releaseDisposers();\n        this.reactors.forEach((func, id) => {\n            if (isFunction(func)) {\n                this.disposers.set(id, func());\n            }\n        });\n        this.manager.notifyReconnected();\n    }\n\n    private releaseDisposers() {\n        this.disposers.forEach(disposer => {\n            if (isFunction(disposer)) {\n                disposer();\n            }\n        })\n        this.disposers.clear();\n    }\n\n    public add(id: string, func: any) {\n        if (isFunction(func)) {\n            this.reactors.set(id, func);\n            this.disposers.set(id, func());\n        }\n    }\n\n    public remove(id: string) {\n        if (this.reactors.has(id)) {\n            this.reactors.delete(id);\n        }\n        const disposer = this.disposers.get(id);\n        if (disposer) {\n            if (isFunction(disposer)) {\n                disposer();\n            }\n            this.disposers.delete(id);\n        }\n    }\n\n    public destroy() {\n        this.room?.callbacks.off(\"onPhaseChanged\", this.onPhaseChanged);\n        this.releaseDisposers();\n    }\n}\n","import pRetry from \"p-retry\";\nimport {\n    AppAttributes,\n    AppStatus,\n    Events,\n    MagixEventName\n    } from \"./constants\";\nimport { AppListeners } from \"./AppListener\";\nimport { AppProxy } from \"./AppProxy\";\nimport { AttributesDelegate } from \"./AttributesDelegate\";\nimport {\n    autorun,\n    isPlayer,\n    isRoom,\n    ScenePathType,\n    ViewVisionMode\n    } from \"white-web-sdk\";\nimport { BoxManager } from \"./BoxManager\";\nimport { callbacks, emitter } from \"./index\";\nimport { CameraStore } from \"./Utils/CameraStore\";\nimport { genAppId, makeValidScenePath, setScenePath } from \"./Utils/Common\";\nimport { log } from \"./Utils/log\";\nimport { MainViewProxy } from \"./MainView\";\nimport { onObjectRemoved, safeListenPropsUpdated } from \"./Utils/Reactive\";\nimport { ReconnectRefresher } from \"./ReconnectRefresher\";\nimport { ViewManager } from \"./ViewManager\";\nimport type { Displayer, DisplayerState, Room } from \"white-web-sdk\";\nimport type { CreateTeleBoxManagerConfig } from \"./BoxManager\";\nimport type {\n    AddAppParams,\n    BaseInsertParams,\n    WindowManager,\n    TeleBoxRect,\n    EmitterEvent,\n} from \"./index\";\nexport class AppManager {\n    public displayer: Displayer;\n    public boxManager: BoxManager;\n    public cameraStore: CameraStore;\n    public viewManager: ViewManager;\n    public appProxies: Map<string, AppProxy> = new Map();\n    public appStatus: Map<string, AppStatus> = new Map();\n    public store = new AttributesDelegate(this);\n    public mainViewProxy: MainViewProxy;\n    public refresher?: ReconnectRefresher;\n    public isReplay = this.windowManger.isReplay;\n\n    private appListeners: AppListeners;\n\n    constructor(public windowManger: WindowManager, options: CreateTeleBoxManagerConfig) {\n        this.displayer = windowManger.displayer;\n        this.cameraStore = new CameraStore();\n        this.mainViewProxy = new MainViewProxy(this);\n        this.viewManager = new ViewManager(this);\n        this.boxManager = new BoxManager(this, options);\n        this.appListeners = new AppListeners(this);\n        this.displayer.callbacks.on(this.eventName, this.displayerStateListener);\n        this.appListeners.addListeners();\n\n        this.refresher = new ReconnectRefresher(this.room, this);\n\n        emitter.once(\"onCreated\").then(() => this.onCreated());\n\n        if (isPlayer(this.displayer)) {\n            emitter.on(\"seek\", time => {\n                this.appProxies.forEach(appProxy => {\n                    appProxy.onSeek(time);\n                });\n                this.attributesUpdateCallback(this.attributes.apps);\n                this.onAppDelete(this.attributes.apps);\n            });\n        }\n    }\n\n    private async onCreated() {\n        await this.attributesUpdateCallback(this.attributes.apps);\n        this.boxManager.updateManagerRect();\n        emitter.onAny(this.boxEventListener);\n        this.refresher?.add(\"apps\", () => {\n            return safeListenPropsUpdated(() => this.attributes.apps, () => {\n                this.attributesUpdateCallback(this.attributes.apps);\n            });\n        });\n        this.refresher?.add(\"appsClose\", () => {\n            return onObjectRemoved(this.attributes.apps, () => {\n                this.onAppDelete(this.attributes.apps);\n            });\n        });\n        this.refresher?.add(\"maximized\", () => {\n            return autorun(() => {\n                const maximized = this.attributes.maximized;\n                if (this.boxManager.maximized !== maximized) {\n                    this.boxManager.setMaximized(Boolean(maximized));\n                }\n            });\n        });\n        this.refresher?.add(\"minimized\", () => {\n            return autorun(() => {\n                const minimized = this.attributes.minimized;\n                if (this.boxManager.minimized !== minimized) {\n                    if (minimized === true && this.store.focus !== undefined) {\n                        this.store.cleanFocus();\n                        this.boxManager.blurFocusBox();\n                    }\n                    this.boxManager.setMinimized(Boolean(minimized));\n                }\n            });\n        });\n        if (!this.attributes.apps || Object.keys(this.attributes.apps).length === 0) {\n            const mainScenePath = this.store.getMainViewScenePath();\n            if (!mainScenePath) return;\n            const sceneState = this.displayer.state.sceneState;\n            if (sceneState.scenePath !== mainScenePath) {\n                setScenePath(this.room, mainScenePath);\n            }\n        }\n        this.displayerWritableListener(!this.room?.isWritable);\n        this.displayer.callbacks.on(\"onEnableWriteNowChanged\", this.displayerWritableListener);\n    }\n\n    /**\n     * 插件更新 attributes 时的回调\n     *\n     * @param {*} attributes\n     * @memberof WindowManager\n     */\n    public async attributesUpdateCallback(apps: any) {\n        if (apps) {\n            for (const id in apps) {\n                if (!this.appProxies.has(id) && !this.appStatus.has(id)) {\n                    const app = apps[id];\n\n                    pRetry(async () => {\n                        this.appStatus.set(id, AppStatus.StartCreate);\n                        // 防御 appAttributes 有可能为 undefined 的情况，这里做一个重试\n                        const appAttributes = this.attributes[id];\n                        if (!appAttributes) {\n                            throw new Error(\"appAttributes is undefined\");\n                        }\n                        await this.baseInsertApp(\n                            {\n                                kind: app.kind,\n                                options: app.options,\n                                isDynamicPPT: app.isDynamicPPT,\n                            },\n                            id,\n                            false\n                        );\n                        this.focusByAttributes(apps);\n                    }, { retries: 3 }).catch(err => {\n                        console.warn(`[WindowManager]: Insert App Error`, err);\n                        this.appStatus.delete(id);\n                    });\n                }\n            }\n        }\n    }\n\n    private onAppDelete = (apps: any) => {\n        const ids = Object.keys(apps);\n        this.appProxies.forEach((appProxy, id) => {\n            if (!ids.includes(id)) {\n                appProxy.destroy(true, false, true);\n            }\n        });\n    };\n\n    public bindMainView(divElement: HTMLDivElement, disableCameraTransform: boolean) {\n        const mainView = this.mainViewProxy.view;\n        mainView.disableCameraTransform = disableCameraTransform;\n        mainView.divElement = divElement;\n        if (!mainView.focusScenePath) {\n            this.store.setMainViewFocusPath();\n        }\n        if (this.store.focus === undefined && mainView.mode !== ViewVisionMode.Writable) {\n            this.viewManager.switchMainViewToWriter();\n        }\n        this.mainViewProxy.addMainViewListener();\n        emitter.emit(\"mainViewMounted\");\n    }\n\n    public async addApp(params: AddAppParams, isDynamicPPT: boolean): Promise<string | undefined> {\n        log(\"addApp\", params);\n        const { appId, needFocus } = await this.beforeAddApp(params, isDynamicPPT);\n        const appProxy = await this.baseInsertApp(params, appId, true, needFocus);\n        this.afterAddApp(appProxy);\n        return appProxy?.id;\n    }\n\n    private async beforeAddApp(params: AddAppParams, isDynamicPPT: boolean) {\n        const appId = await genAppId(params.kind);\n        this.appStatus.set(appId, AppStatus.StartCreate);\n        const attrs = params.attributes ?? {};\n        this.safeUpdateAttributes([appId], attrs);\n        this.store.setupAppAttributes(params, appId, isDynamicPPT);\n        const needFocus = !this.boxManager.minimized;\n        if (needFocus) {\n            this.store.setAppFocus(appId, true);\n        }\n        return { appId, needFocus };\n    }\n\n    private afterAddApp(appProxy: AppProxy | undefined) {\n        if (appProxy && appProxy.box) {\n            const box = appProxy.box;\n            emitter.emit(\"move\", {\n                appId: appProxy.id,\n                x: box?.intrinsicX,\n                y: box?.intrinsicY,\n            });\n        }\n        if (this.boxManager.minimized) {\n            this.boxManager.setMinimized(false, false);\n        }\n    }\n\n    public async closeApp(appId: string) {\n        const appProxy = this.appProxies.get(appId);\n        if (appProxy) {\n            appProxy.destroy(true, true, false);\n        }\n    }\n\n    private async baseInsertApp(\n        params: BaseInsertParams,\n        appId: string,\n        isAddApp: boolean,\n        focus?: boolean\n    ) {\n        if (this.appProxies.has(appId)) {\n            console.warn(\"[WindowManager]: app duplicate exists and cannot be created again\");\n            return;\n        }\n        const appProxy = new AppProxy(params, this, appId, isAddApp);\n        if (appProxy) {\n            await appProxy.baseInsertApp(focus);\n            this.appStatus.delete(appId);\n            return appProxy;\n        } else {\n            this.appStatus.delete(appId);\n            throw new Error(\"[WindowManger]: initialize AppProxy failed\");\n        }\n    }\n\n    private displayerStateListener = (state: Partial<DisplayerState>) => {\n        const sceneState = state.sceneState;\n        if (sceneState) {\n            const scenePath = sceneState.scenePath;\n            this.appProxies.forEach(appProxy => {\n                if (appProxy.scenePath && scenePath.startsWith(appProxy.scenePath)) {\n                    appProxy.emitAppSceneStateChange(sceneState);\n                    appProxy.setFullPath(scenePath);\n                }\n            });\n        }\n        if (state.roomMembers) {\n            this.windowManger.cursorManager?.setRoomMembers(state.roomMembers);\n            this.windowManger.cursorManager?.cleanMemberAttributes(state.roomMembers);\n        }\n        this.appProxies.forEach(appProxy => {\n            appProxy.appEmitter.emit(\"roomStateChange\", state);\n        });\n        emitter.emit(\"observerIdChange\", this.displayer.observerId);\n    };\n\n    private displayerWritableListener = (isReadonly: boolean) => {\n        const isWritable = !isReadonly;\n        const isManualWritable =\n            this.windowManger.readonly === undefined || this.windowManger.readonly === false;\n        if (this.windowManger.readonly === undefined) {\n            this.boxManager.setReadonly(isReadonly);\n        } else {\n            this.boxManager.setReadonly(!(isWritable && isManualWritable));\n        }\n        this.appProxies.forEach(appProxy => {\n            appProxy.emitAppIsWritableChange();\n        });\n        if (isWritable === true) {\n            if (!this.store.focus) {\n                this.mainViewProxy.switchViewModeToWriter();\n            }\n            this.mainView.disableCameraTransform = false;\n        } else {\n            this.mainView.disableCameraTransform = true;\n        }\n    };\n\n    private get eventName() {\n        return isRoom(this.displayer) ? \"onRoomStateChanged\" : \"onPlayerStateChanged\";\n    }\n\n    public get attributes() {\n        return this.windowManger.attributes;\n    }\n\n    public get canOperate() {\n        return this.windowManger.canOperate;\n    }\n\n    public get room() {\n        return isRoom(this.displayer) ? (this.displayer as Room) : undefined;\n    }\n\n    public get mainView() {\n        return this.mainViewProxy.view;\n    }\n\n    public get focusApp() {\n        if (this.store.focus) {\n            return this.appProxies.get(this.store.focus);\n        }\n    }\n\n    public safeSetAttributes(attributes: any) {\n        this.windowManger.safeSetAttributes(attributes);\n    }\n\n    public safeUpdateAttributes(keys: string[], value: any) {\n        this.windowManger.safeUpdateAttributes(keys, value);\n    }\n\n    public async setMainViewScenePath(scenePath: string) {\n        if (this.room) {\n            const scenePathType = this.displayer.scenePathType(scenePath);\n            if (scenePathType === ScenePathType.None) {\n                throw new Error(`[WindowManager]: ${scenePath} not valid scene`);\n            } else if (scenePathType === ScenePathType.Page) {\n                await this._setMainViewScenePath(scenePath);\n            } else if (scenePathType === ScenePathType.Dir) {\n                const validScenePath = makeValidScenePath(this.displayer, scenePath);\n                await this._setMainViewScenePath(validScenePath);\n            }\n        }\n    }\n\n    private async _setMainViewScenePath(scenePath: string) {\n        this.safeSetAttributes({ _mainScenePath: scenePath });\n        await this.viewManager.switchMainViewToWriter();\n        setScenePath(this.room, scenePath);\n        this.store.setMainViewFocusPath();\n        this.dispatchInternalEvent(Events.SetMainViewScenePath, { nextScenePath: scenePath });\n    }\n\n    public async setMainViewSceneIndex(index: number) {\n        if (this.room) {\n            this.safeSetAttributes({ _mainSceneIndex: index });\n            await this.viewManager.switchMainViewToWriter();\n            this.room.setSceneIndex(index);\n            const nextScenePath = this.room.state.sceneState.scenePath;\n            this.store.setMainViewScenePath(nextScenePath);\n            this.store.setMainViewFocusPath();\n            this.dispatchInternalEvent(Events.SetMainViewScenePath, { nextScenePath });\n        }\n    }\n\n    public getAppInitPath(appId: string): string | undefined {\n        const attrs = this.store.getAppAttributes(appId);\n        if (attrs) {\n            return attrs?.options?.scenePath;\n        }\n    }\n\n    public safeDispatchMagixEvent(event: string, payload: any) {\n        if (this.canOperate) {\n            (this.displayer as Room).dispatchMagixEvent(event, payload);\n        }\n    }\n\n    private boxEventListener = (eventName: keyof EmitterEvent, payload: any) => {\n        switch (eventName) {\n            case \"move\": {\n                this.dispatchInternalEvent(Events.AppMove, payload);\n                this.store.updateAppState(payload.appId, AppAttributes.Position, {\n                    x: payload.x,\n                    y: payload.y,\n                });\n                break;\n            }\n            case \"focus\": {\n                this.windowManger.safeSetAttributes({ focus: payload.appId });\n                break;\n            }\n            case \"resize\": {\n                if (payload.width && payload.height) {\n                    this.dispatchInternalEvent(Events.AppResize, payload);\n                    this.store.updateAppState(payload.appId, AppAttributes.Size, {\n                        width: payload.width,\n                        height: payload.height,\n                    });\n                }\n                break;\n            }\n            case \"close\": {\n                const appProxy = this.appProxies.get(payload.appId);\n                if (appProxy) {\n                    appProxy.destroy(false, true, payload.error);\n                }\n                if (this.boxManager.maximized) {\n                    this.boxManager.focusTopBox();\n                }\n                break;\n            }\n            case \"boxStateChange\": {\n                this.dispatchInternalEvent(Events.AppBoxStateChange, payload);\n                break;\n            }\n            default:\n                break;\n        }\n    };\n\n    public focusByAttributes(apps: any) {\n        if (apps && Object.keys(apps).length === this.boxManager.appBoxMap.size) {\n            const focusAppId = this.store.focus;\n            if (focusAppId) {\n                this.boxManager.focusBox({ appId: focusAppId });\n            }\n        }\n    }\n\n    public async notifyReconnected() {\n        const appProxies = Array.from(this.appProxies.values());\n        const reconnected = appProxies.map(appProxy => {\n            return appProxy.onReconnected();\n        });\n        await Promise.all(reconnected);\n    }\n\n    public notifyContainerRectUpdate(rect: TeleBoxRect) {\n        this.appProxies.forEach(appProxy => {\n            appProxy.appEmitter.emit(\"containerRectUpdate\", rect);\n        });\n    }\n\n    public dispatchInternalEvent(event: Events, payload: any) {\n        this.safeDispatchMagixEvent(MagixEventName, {\n            eventName: event,\n            payload: payload,\n        });\n    }\n\n    public destroy() {\n        this.displayer.callbacks.off(this.eventName, this.displayerStateListener);\n        this.displayer.callbacks.off(\"onEnableWriteNowChanged\", this.displayerWritableListener);\n        this.appListeners.removeListeners();\n        emitter.offAny(this.boxEventListener);\n        emitter.clearListeners();\n        if (this.appProxies.size) {\n            this.appProxies.forEach(appProxy => {\n                appProxy.destroy(true, false, true);\n            });\n        }\n        this.viewManager.destroy();\n        this.boxManager.destroy();\n        this.refresher?.destroy();\n        this.mainViewProxy.destroy();\n        callbacks.clearListeners();\n    }\n}\n","function noop() { }\nconst identity = x => x;\nfunction assign(tar, src) {\n    // @ts-ignore\n    for (const k in src)\n        tar[k] = src[k];\n    return tar;\n}\nfunction is_promise(value) {\n    return value && typeof value === 'object' && typeof value.then === 'function';\n}\nfunction add_location(element, file, line, column, char) {\n    element.__svelte_meta = {\n        loc: { file, line, column, char }\n    };\n}\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\nfunction is_function(thing) {\n    return typeof thing === 'function';\n}\nfunction safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n}\nlet src_url_equal_anchor;\nfunction src_url_equal(element_src, url) {\n    if (!src_url_equal_anchor) {\n        src_url_equal_anchor = document.createElement('a');\n    }\n    src_url_equal_anchor.href = url;\n    return element_src === src_url_equal_anchor.href;\n}\nfunction not_equal(a, b) {\n    return a != a ? b == b : a !== b;\n}\nfunction is_empty(obj) {\n    return Object.keys(obj).length === 0;\n}\nfunction validate_store(store, name) {\n    if (store != null && typeof store.subscribe !== 'function') {\n        throw new Error(`'${name}' is not a store with a 'subscribe' method`);\n    }\n}\nfunction subscribe(store, ...callbacks) {\n    if (store == null) {\n        return noop;\n    }\n    const unsub = store.subscribe(...callbacks);\n    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\nfunction get_store_value(store) {\n    let value;\n    subscribe(store, _ => value = _)();\n    return value;\n}\nfunction component_subscribe(component, store, callback) {\n    component.$$.on_destroy.push(subscribe(store, callback));\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n    if (definition) {\n        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n        return definition[0](slot_ctx);\n    }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n    return definition[1] && fn\n        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))\n        : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n    if (definition[2] && fn) {\n        const lets = definition[2](fn(dirty));\n        if ($$scope.dirty === undefined) {\n            return lets;\n        }\n        if (typeof lets === 'object') {\n            const merged = [];\n            const len = Math.max($$scope.dirty.length, lets.length);\n            for (let i = 0; i < len; i += 1) {\n                merged[i] = $$scope.dirty[i] | lets[i];\n            }\n            return merged;\n        }\n        return $$scope.dirty | lets;\n    }\n    return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n    if (slot_changes) {\n        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n        slot.p(slot_context, slot_changes);\n    }\n}\nfunction update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {\n    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n    update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);\n}\nfunction get_all_dirty_from_scope($$scope) {\n    if ($$scope.ctx.length > 32) {\n        const dirty = [];\n        const length = $$scope.ctx.length / 32;\n        for (let i = 0; i < length; i++) {\n            dirty[i] = -1;\n        }\n        return dirty;\n    }\n    return -1;\n}\nfunction exclude_internal_props(props) {\n    const result = {};\n    for (const k in props)\n        if (k[0] !== '$')\n            result[k] = props[k];\n    return result;\n}\nfunction compute_rest_props(props, keys) {\n    const rest = {};\n    keys = new Set(keys);\n    for (const k in props)\n        if (!keys.has(k) && k[0] !== '$')\n            rest[k] = props[k];\n    return rest;\n}\nfunction compute_slots(slots) {\n    const result = {};\n    for (const key in slots) {\n        result[key] = true;\n    }\n    return result;\n}\nfunction once(fn) {\n    let ran = false;\n    return function (...args) {\n        if (ran)\n            return;\n        ran = true;\n        fn.call(this, ...args);\n    };\n}\nfunction null_to_empty(value) {\n    return value == null ? '' : value;\n}\nfunction set_store_value(store, ret, value) {\n    store.set(value);\n    return ret;\n}\nconst has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nfunction action_destroyer(action_result) {\n    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\nconst is_client = typeof window !== 'undefined';\nlet now = is_client\n    ? () => window.performance.now()\n    : () => Date.now();\nlet raf = is_client ? cb => requestAnimationFrame(cb) : noop;\n// used internally for testing\nfunction set_now(fn) {\n    now = fn;\n}\nfunction set_raf(fn) {\n    raf = fn;\n}\n\nconst tasks = new Set();\nfunction run_tasks(now) {\n    tasks.forEach(task => {\n        if (!task.c(now)) {\n            tasks.delete(task);\n            task.f();\n        }\n    });\n    if (tasks.size !== 0)\n        raf(run_tasks);\n}\n/**\n * For testing purposes only!\n */\nfunction clear_loops() {\n    tasks.clear();\n}\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n */\nfunction loop(callback) {\n    let task;\n    if (tasks.size === 0)\n        raf(run_tasks);\n    return {\n        promise: new Promise(fulfill => {\n            tasks.add(task = { c: callback, f: fulfill });\n        }),\n        abort() {\n            tasks.delete(task);\n        }\n    };\n}\n\n// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n// at the end of hydration without touching the remaining nodes.\nlet is_hydrating = false;\nfunction start_hydrating() {\n    is_hydrating = true;\n}\nfunction end_hydrating() {\n    is_hydrating = false;\n}\nfunction upper_bound(low, high, key, value) {\n    // Return first index of value larger than input value in the range [low, high)\n    while (low < high) {\n        const mid = low + ((high - low) >> 1);\n        if (key(mid) <= value) {\n            low = mid + 1;\n        }\n        else {\n            high = mid;\n        }\n    }\n    return low;\n}\nfunction init_hydrate(target) {\n    if (target.hydrate_init)\n        return;\n    target.hydrate_init = true;\n    // We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\n    let children = target.childNodes;\n    // If target is <head>, there may be children without claim_order\n    if (target.nodeName === 'HEAD') {\n        const myChildren = [];\n        for (let i = 0; i < children.length; i++) {\n            const node = children[i];\n            if (node.claim_order !== undefined) {\n                myChildren.push(node);\n            }\n        }\n        children = myChildren;\n    }\n    /*\n    * Reorder claimed children optimally.\n    * We can reorder claimed children optimally by finding the longest subsequence of\n    * nodes that are already claimed in order and only moving the rest. The longest\n    * subsequence subsequence of nodes that are claimed in order can be found by\n    * computing the longest increasing subsequence of .claim_order values.\n    *\n    * This algorithm is optimal in generating the least amount of reorder operations\n    * possible.\n    *\n    * Proof:\n    * We know that, given a set of reordering operations, the nodes that do not move\n    * always form an increasing subsequence, since they do not move among each other\n    * meaning that they must be already ordered among each other. Thus, the maximal\n    * set of nodes that do not move form a longest increasing subsequence.\n    */\n    // Compute longest increasing subsequence\n    // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n    const m = new Int32Array(children.length + 1);\n    // Predecessor indices + 1\n    const p = new Int32Array(children.length);\n    m[0] = -1;\n    let longest = 0;\n    for (let i = 0; i < children.length; i++) {\n        const current = children[i].claim_order;\n        // Find the largest subsequence length such that it ends in a value less than our current value\n        // upper_bound returns first greater value, so we subtract one\n        // with fast path for when we are on the current longest subsequence\n        const seqLen = ((longest > 0 && children[m[longest]].claim_order <= current) ? longest + 1 : upper_bound(1, longest, idx => children[m[idx]].claim_order, current)) - 1;\n        p[i] = m[seqLen] + 1;\n        const newLen = seqLen + 1;\n        // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n        m[newLen] = i;\n        longest = Math.max(newLen, longest);\n    }\n    // The longest increasing subsequence of nodes (initially reversed)\n    const lis = [];\n    // The rest of the nodes, nodes that will be moved\n    const toMove = [];\n    let last = children.length - 1;\n    for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n        lis.push(children[cur - 1]);\n        for (; last >= cur; last--) {\n            toMove.push(children[last]);\n        }\n        last--;\n    }\n    for (; last >= 0; last--) {\n        toMove.push(children[last]);\n    }\n    lis.reverse();\n    // We sort the nodes being moved to guarantee that their insertion order matches the claim order\n    toMove.sort((a, b) => a.claim_order - b.claim_order);\n    // Finally, we move the nodes\n    for (let i = 0, j = 0; i < toMove.length; i++) {\n        while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {\n            j++;\n        }\n        const anchor = j < lis.length ? lis[j] : null;\n        target.insertBefore(toMove[i], anchor);\n    }\n}\nfunction append(target, node) {\n    target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n    const append_styles_to = get_root_for_style(target);\n    if (!append_styles_to.getElementById(style_sheet_id)) {\n        const style = element('style');\n        style.id = style_sheet_id;\n        style.textContent = styles;\n        append_stylesheet(append_styles_to, style);\n    }\n}\nfunction get_root_for_style(node) {\n    if (!node)\n        return document;\n    const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n    if (root && root.host) {\n        return root;\n    }\n    return node.ownerDocument;\n}\nfunction append_empty_stylesheet(node) {\n    const style_element = element('style');\n    append_stylesheet(get_root_for_style(node), style_element);\n    return style_element;\n}\nfunction append_stylesheet(node, style) {\n    append(node.head || node, style);\n}\nfunction append_hydration(target, node) {\n    if (is_hydrating) {\n        init_hydrate(target);\n        if ((target.actual_end_child === undefined) || ((target.actual_end_child !== null) && (target.actual_end_child.parentElement !== target))) {\n            target.actual_end_child = target.firstChild;\n        }\n        // Skip nodes of undefined ordering\n        while ((target.actual_end_child !== null) && (target.actual_end_child.claim_order === undefined)) {\n            target.actual_end_child = target.actual_end_child.nextSibling;\n        }\n        if (node !== target.actual_end_child) {\n            // We only insert if the ordering of this node should be modified or the parent node is not target\n            if (node.claim_order !== undefined || node.parentNode !== target) {\n                target.insertBefore(node, target.actual_end_child);\n            }\n        }\n        else {\n            target.actual_end_child = node.nextSibling;\n        }\n    }\n    else if (node.parentNode !== target || node.nextSibling !== null) {\n        target.appendChild(node);\n    }\n}\nfunction insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n}\nfunction insert_hydration(target, node, anchor) {\n    if (is_hydrating && !anchor) {\n        append_hydration(target, node);\n    }\n    else if (node.parentNode !== target || node.nextSibling != anchor) {\n        target.insertBefore(node, anchor || null);\n    }\n}\nfunction detach(node) {\n    node.parentNode.removeChild(node);\n}\nfunction destroy_each(iterations, detaching) {\n    for (let i = 0; i < iterations.length; i += 1) {\n        if (iterations[i])\n            iterations[i].d(detaching);\n    }\n}\nfunction element(name) {\n    return document.createElement(name);\n}\nfunction element_is(name, is) {\n    return document.createElement(name, { is });\n}\nfunction object_without_properties(obj, exclude) {\n    const target = {};\n    for (const k in obj) {\n        if (has_prop(obj, k)\n            // @ts-ignore\n            && exclude.indexOf(k) === -1) {\n            // @ts-ignore\n            target[k] = obj[k];\n        }\n    }\n    return target;\n}\nfunction svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\nfunction text(data) {\n    return document.createTextNode(data);\n}\nfunction space() {\n    return text(' ');\n}\nfunction empty() {\n    return text('');\n}\nfunction listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return () => node.removeEventListener(event, handler, options);\n}\nfunction prevent_default(fn) {\n    return function (event) {\n        event.preventDefault();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_propagation(fn) {\n    return function (event) {\n        event.stopPropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction self(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.target === this)\n            fn.call(this, event);\n    };\n}\nfunction trusted(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.isTrusted)\n            fn.call(this, event);\n    };\n}\nfunction attr(node, attribute, value) {\n    if (value == null)\n        node.removeAttribute(attribute);\n    else if (node.getAttribute(attribute) !== value)\n        node.setAttribute(attribute, value);\n}\nfunction set_attributes(node, attributes) {\n    // @ts-ignore\n    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (const key in attributes) {\n        if (attributes[key] == null) {\n            node.removeAttribute(key);\n        }\n        else if (key === 'style') {\n            node.style.cssText = attributes[key];\n        }\n        else if (key === '__value') {\n            node.value = node[key] = attributes[key];\n        }\n        else if (descriptors[key] && descriptors[key].set) {\n            node[key] = attributes[key];\n        }\n        else {\n            attr(node, key, attributes[key]);\n        }\n    }\n}\nfunction set_svg_attributes(node, attributes) {\n    for (const key in attributes) {\n        attr(node, key, attributes[key]);\n    }\n}\nfunction set_custom_element_data(node, prop, value) {\n    if (prop in node) {\n        node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;\n    }\n    else {\n        attr(node, prop, value);\n    }\n}\nfunction xlink_attr(node, attribute, value) {\n    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\nfunction get_binding_group_value(group, __value, checked) {\n    const value = new Set();\n    for (let i = 0; i < group.length; i += 1) {\n        if (group[i].checked)\n            value.add(group[i].__value);\n    }\n    if (!checked) {\n        value.delete(__value);\n    }\n    return Array.from(value);\n}\nfunction to_number(value) {\n    return value === '' ? null : +value;\n}\nfunction time_ranges_to_array(ranges) {\n    const array = [];\n    for (let i = 0; i < ranges.length; i += 1) {\n        array.push({ start: ranges.start(i), end: ranges.end(i) });\n    }\n    return array;\n}\nfunction children(element) {\n    return Array.from(element.childNodes);\n}\nfunction init_claim_info(nodes) {\n    if (nodes.claim_info === undefined) {\n        nodes.claim_info = { last_index: 0, total_claimed: 0 };\n    }\n}\nfunction claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {\n    // Try to find nodes in an order such that we lengthen the longest increasing subsequence\n    init_claim_info(nodes);\n    const resultNode = (() => {\n        // We first try to find an element after the previous one\n        for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                return node;\n            }\n        }\n        // Otherwise, we try to find one before\n        // We iterate in reverse so that we don't go too far back\n        for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                else if (replacement === undefined) {\n                    // Since we spliced before the last_index, we decrease it\n                    nodes.claim_info.last_index--;\n                }\n                return node;\n            }\n        }\n        // If we can't find any matching node, we create a new one\n        return createNode();\n    })();\n    resultNode.claim_order = nodes.claim_info.total_claimed;\n    nodes.claim_info.total_claimed += 1;\n    return resultNode;\n}\nfunction claim_element_base(nodes, name, attributes, create_element) {\n    return claim_node(nodes, (node) => node.nodeName === name, (node) => {\n        const remove = [];\n        for (let j = 0; j < node.attributes.length; j++) {\n            const attribute = node.attributes[j];\n            if (!attributes[attribute.name]) {\n                remove.push(attribute.name);\n            }\n        }\n        remove.forEach(v => node.removeAttribute(v));\n        return undefined;\n    }, () => create_element(name));\n}\nfunction claim_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, element);\n}\nfunction claim_svg_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, svg_element);\n}\nfunction claim_text(nodes, data) {\n    return claim_node(nodes, (node) => node.nodeType === 3, (node) => {\n        const dataStr = '' + data;\n        if (node.data.startsWith(dataStr)) {\n            if (node.data.length !== dataStr.length) {\n                return node.splitText(dataStr.length);\n            }\n        }\n        else {\n            node.data = dataStr;\n        }\n    }, () => text(data), true // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n    );\n}\nfunction claim_space(nodes) {\n    return claim_text(nodes, ' ');\n}\nfunction find_comment(nodes, text, start) {\n    for (let i = start; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {\n            return i;\n        }\n    }\n    return nodes.length;\n}\nfunction claim_html_tag(nodes) {\n    // find html opening tag\n    const start_index = find_comment(nodes, 'HTML_TAG_START', 0);\n    const end_index = find_comment(nodes, 'HTML_TAG_END', start_index);\n    if (start_index === end_index) {\n        return new HtmlTagHydration();\n    }\n    init_claim_info(nodes);\n    const html_tag_nodes = nodes.splice(start_index, end_index + 1);\n    detach(html_tag_nodes[0]);\n    detach(html_tag_nodes[html_tag_nodes.length - 1]);\n    const claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);\n    for (const n of claimed_nodes) {\n        n.claim_order = nodes.claim_info.total_claimed;\n        nodes.claim_info.total_claimed += 1;\n    }\n    return new HtmlTagHydration(claimed_nodes);\n}\nfunction set_data(text, data) {\n    data = '' + data;\n    if (text.wholeText !== data)\n        text.data = data;\n}\nfunction set_input_value(input, value) {\n    input.value = value == null ? '' : value;\n}\nfunction set_input_type(input, type) {\n    try {\n        input.type = type;\n    }\n    catch (e) {\n        // do nothing\n    }\n}\nfunction set_style(node, key, value, important) {\n    node.style.setProperty(key, value, important ? 'important' : '');\n}\nfunction select_option(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        if (option.__value === value) {\n            option.selected = true;\n            return;\n        }\n    }\n    select.selectedIndex = -1; // no option should be selected\n}\nfunction select_options(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        option.selected = ~value.indexOf(option.__value);\n    }\n}\nfunction select_value(select) {\n    const selected_option = select.querySelector(':checked') || select.options[0];\n    return selected_option && selected_option.__value;\n}\nfunction select_multiple_value(select) {\n    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\nlet crossorigin;\nfunction is_crossorigin() {\n    if (crossorigin === undefined) {\n        crossorigin = false;\n        try {\n            if (typeof window !== 'undefined' && window.parent) {\n                void window.parent.document;\n            }\n        }\n        catch (error) {\n            crossorigin = true;\n        }\n    }\n    return crossorigin;\n}\nfunction add_resize_listener(node, fn) {\n    const computed_style = getComputedStyle(node);\n    if (computed_style.position === 'static') {\n        node.style.position = 'relative';\n    }\n    const iframe = element('iframe');\n    iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +\n        'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');\n    iframe.setAttribute('aria-hidden', 'true');\n    iframe.tabIndex = -1;\n    const crossorigin = is_crossorigin();\n    let unsubscribe;\n    if (crossorigin) {\n        iframe.src = \"data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>\";\n        unsubscribe = listen(window, 'message', (event) => {\n            if (event.source === iframe.contentWindow)\n                fn();\n        });\n    }\n    else {\n        iframe.src = 'about:blank';\n        iframe.onload = () => {\n            unsubscribe = listen(iframe.contentWindow, 'resize', fn);\n        };\n    }\n    append(node, iframe);\n    return () => {\n        if (crossorigin) {\n            unsubscribe();\n        }\n        else if (unsubscribe && iframe.contentWindow) {\n            unsubscribe();\n        }\n        detach(iframe);\n    };\n}\nfunction toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n}\nfunction custom_event(type, detail, bubbles = false) {\n    const e = document.createEvent('CustomEvent');\n    e.initCustomEvent(type, bubbles, false, detail);\n    return e;\n}\nfunction query_selector_all(selector, parent = document.body) {\n    return Array.from(parent.querySelectorAll(selector));\n}\nclass HtmlTag {\n    constructor() {\n        this.e = this.n = null;\n    }\n    c(html) {\n        this.h(html);\n    }\n    m(html, target, anchor = null) {\n        if (!this.e) {\n            this.e = element(target.nodeName);\n            this.t = target;\n            this.c(html);\n        }\n        this.i(anchor);\n    }\n    h(html) {\n        this.e.innerHTML = html;\n        this.n = Array.from(this.e.childNodes);\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert(this.t, this.n[i], anchor);\n        }\n    }\n    p(html) {\n        this.d();\n        this.h(html);\n        this.i(this.a);\n    }\n    d() {\n        this.n.forEach(detach);\n    }\n}\nclass HtmlTagHydration extends HtmlTag {\n    constructor(claimed_nodes) {\n        super();\n        this.e = this.n = null;\n        this.l = claimed_nodes;\n    }\n    c(html) {\n        if (this.l) {\n            this.n = this.l;\n        }\n        else {\n            super.c(html);\n        }\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert_hydration(this.t, this.n[i], anchor);\n        }\n    }\n}\nfunction attribute_to_object(attributes) {\n    const result = {};\n    for (const attribute of attributes) {\n        result[attribute.name] = attribute.value;\n    }\n    return result;\n}\nfunction get_custom_elements_slots(element) {\n    const result = {};\n    element.childNodes.forEach((node) => {\n        result[node.slot || 'default'] = true;\n    });\n    return result;\n}\n\nconst active_docs = new Set();\nlet active = 0;\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str) {\n    let hash = 5381;\n    let i = str.length;\n    while (i--)\n        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n    return hash >>> 0;\n}\nfunction create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n    const step = 16.666 / duration;\n    let keyframes = '{\\n';\n    for (let p = 0; p <= 1; p += step) {\n        const t = a + (b - a) * ease(p);\n        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n    }\n    const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n    const name = `__svelte_${hash(rule)}_${uid}`;\n    const doc = get_root_for_style(node);\n    active_docs.add(doc);\n    const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = append_empty_stylesheet(node).sheet);\n    const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});\n    if (!current_rules[name]) {\n        current_rules[name] = true;\n        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n    }\n    const animation = node.style.animation || '';\n    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;\n    active += 1;\n    return name;\n}\nfunction delete_rule(node, name) {\n    const previous = (node.style.animation || '').split(', ');\n    const next = previous.filter(name\n        ? anim => anim.indexOf(name) < 0 // remove specific animation\n        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n    );\n    const deleted = previous.length - next.length;\n    if (deleted) {\n        node.style.animation = next.join(', ');\n        active -= deleted;\n        if (!active)\n            clear_rules();\n    }\n}\nfunction clear_rules() {\n    raf(() => {\n        if (active)\n            return;\n        active_docs.forEach(doc => {\n            const stylesheet = doc.__svelte_stylesheet;\n            let i = stylesheet.cssRules.length;\n            while (i--)\n                stylesheet.deleteRule(i);\n            doc.__svelte_rules = {};\n        });\n        active_docs.clear();\n    });\n}\n\nfunction create_animation(node, from, fn, params) {\n    if (!from)\n        return noop;\n    const to = node.getBoundingClientRect();\n    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)\n        return noop;\n    const { delay = 0, duration = 300, easing = identity, \n    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n    start: start_time = now() + delay, \n    // @ts-ignore todo:\n    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);\n    let running = true;\n    let started = false;\n    let name;\n    function start() {\n        if (css) {\n            name = create_rule(node, 0, 1, duration, delay, easing, css);\n        }\n        if (!delay) {\n            started = true;\n        }\n    }\n    function stop() {\n        if (css)\n            delete_rule(node, name);\n        running = false;\n    }\n    loop(now => {\n        if (!started && now >= start_time) {\n            started = true;\n        }\n        if (started && now >= end) {\n            tick(1, 0);\n            stop();\n        }\n        if (!running) {\n            return false;\n        }\n        if (started) {\n            const p = now - start_time;\n            const t = 0 + 1 * easing(p / duration);\n            tick(t, 1 - t);\n        }\n        return true;\n    });\n    start();\n    tick(0, 1);\n    return stop;\n}\nfunction fix_position(node) {\n    const style = getComputedStyle(node);\n    if (style.position !== 'absolute' && style.position !== 'fixed') {\n        const { width, height } = style;\n        const a = node.getBoundingClientRect();\n        node.style.position = 'absolute';\n        node.style.width = width;\n        node.style.height = height;\n        add_transform(node, a);\n    }\n}\nfunction add_transform(node, a) {\n    const b = node.getBoundingClientRect();\n    if (a.left !== b.left || a.top !== b.top) {\n        const style = getComputedStyle(node);\n        const transform = style.transform === 'none' ? '' : style.transform;\n        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n    }\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nfunction get_current_component() {\n    if (!current_component)\n        throw new Error('Function called outside component initialization');\n    return current_component;\n}\nfunction beforeUpdate(fn) {\n    get_current_component().$$.before_update.push(fn);\n}\nfunction onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n}\nfunction afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n}\nfunction onDestroy(fn) {\n    get_current_component().$$.on_destroy.push(fn);\n}\nfunction createEventDispatcher() {\n    const component = get_current_component();\n    return (type, detail) => {\n        const callbacks = component.$$.callbacks[type];\n        if (callbacks) {\n            // TODO are there situations where events could be dispatched\n            // in a server (non-DOM) environment?\n            const event = custom_event(type, detail);\n            callbacks.slice().forEach(fn => {\n                fn.call(component, event);\n            });\n        }\n    };\n}\nfunction setContext(key, context) {\n    get_current_component().$$.context.set(key, context);\n}\nfunction getContext(key) {\n    return get_current_component().$$.context.get(key);\n}\nfunction getAllContexts() {\n    return get_current_component().$$.context;\n}\nfunction hasContext(key) {\n    return get_current_component().$$.context.has(key);\n}\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\nfunction bubble(component, event) {\n    const callbacks = component.$$.callbacks[event.type];\n    if (callbacks) {\n        // @ts-ignore\n        callbacks.slice().forEach(fn => fn.call(this, event));\n    }\n}\n\nconst dirty_components = [];\nconst intros = { enabled: false };\nconst binding_callbacks = [];\nconst render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = Promise.resolve();\nlet update_scheduled = false;\nfunction schedule_update() {\n    if (!update_scheduled) {\n        update_scheduled = true;\n        resolved_promise.then(flush);\n    }\n}\nfunction tick() {\n    schedule_update();\n    return resolved_promise;\n}\nfunction add_render_callback(fn) {\n    render_callbacks.push(fn);\n}\nfunction add_flush_callback(fn) {\n    flush_callbacks.push(fn);\n}\nlet flushing = false;\nconst seen_callbacks = new Set();\nfunction flush() {\n    if (flushing)\n        return;\n    flushing = true;\n    do {\n        // first, call beforeUpdate functions\n        // and update components\n        for (let i = 0; i < dirty_components.length; i += 1) {\n            const component = dirty_components[i];\n            set_current_component(component);\n            update(component.$$);\n        }\n        set_current_component(null);\n        dirty_components.length = 0;\n        while (binding_callbacks.length)\n            binding_callbacks.pop()();\n        // then, once components are updated, call\n        // afterUpdate functions. This may cause\n        // subsequent updates...\n        for (let i = 0; i < render_callbacks.length; i += 1) {\n            const callback = render_callbacks[i];\n            if (!seen_callbacks.has(callback)) {\n                // ...so guard against infinite loops\n                seen_callbacks.add(callback);\n                callback();\n            }\n        }\n        render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n        flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    flushing = false;\n    seen_callbacks.clear();\n}\nfunction update($$) {\n    if ($$.fragment !== null) {\n        $$.update();\n        run_all($$.before_update);\n        const dirty = $$.dirty;\n        $$.dirty = [-1];\n        $$.fragment && $$.fragment.p($$.ctx, dirty);\n        $$.after_update.forEach(add_render_callback);\n    }\n}\n\nlet promise;\nfunction wait() {\n    if (!promise) {\n        promise = Promise.resolve();\n        promise.then(() => {\n            promise = null;\n        });\n    }\n    return promise;\n}\nfunction dispatch(node, direction, kind) {\n    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\nconst outroing = new Set();\nlet outros;\nfunction group_outros() {\n    outros = {\n        r: 0,\n        c: [],\n        p: outros // parent group\n    };\n}\nfunction check_outros() {\n    if (!outros.r) {\n        run_all(outros.c);\n    }\n    outros = outros.p;\n}\nfunction transition_in(block, local) {\n    if (block && block.i) {\n        outroing.delete(block);\n        block.i(local);\n    }\n}\nfunction transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n        if (outroing.has(block))\n            return;\n        outroing.add(block);\n        outros.c.push(() => {\n            outroing.delete(block);\n            if (callback) {\n                if (detach)\n                    block.d(1);\n                callback();\n            }\n        });\n        block.o(local);\n    }\n}\nconst null_transition = { duration: 0 };\nfunction create_in_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = false;\n    let animation_name;\n    let task;\n    let uid = 0;\n    function cleanup() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n        tick(0, 1);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        if (task)\n            task.abort();\n        running = true;\n        add_render_callback(() => dispatch(node, true, 'start'));\n        task = loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(1, 0);\n                    dispatch(node, true, 'end');\n                    cleanup();\n                    return running = false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(t, 1 - t);\n                }\n            }\n            return running;\n        });\n    }\n    let started = false;\n    return {\n        start() {\n            if (started)\n                return;\n            started = true;\n            delete_rule(node);\n            if (is_function(config)) {\n                config = config();\n                wait().then(go);\n            }\n            else {\n                go();\n            }\n        },\n        invalidate() {\n            started = false;\n        },\n        end() {\n            if (running) {\n                cleanup();\n                running = false;\n            }\n        }\n    };\n}\nfunction create_out_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = true;\n    let animation_name;\n    const group = outros;\n    group.r += 1;\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        add_render_callback(() => dispatch(node, false, 'start'));\n        loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(0, 1);\n                    dispatch(node, false, 'end');\n                    if (!--group.r) {\n                        // this will result in `end()` being called,\n                        // so we don't need to clean up here\n                        run_all(group.c);\n                    }\n                    return false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(1 - t, t);\n                }\n            }\n            return running;\n        });\n    }\n    if (is_function(config)) {\n        wait().then(() => {\n            // @ts-ignore\n            config = config();\n            go();\n        });\n    }\n    else {\n        go();\n    }\n    return {\n        end(reset) {\n            if (reset && config.tick) {\n                config.tick(1, 0);\n            }\n            if (running) {\n                if (animation_name)\n                    delete_rule(node, animation_name);\n                running = false;\n            }\n        }\n    };\n}\nfunction create_bidirectional_transition(node, fn, params, intro) {\n    let config = fn(node, params);\n    let t = intro ? 0 : 1;\n    let running_program = null;\n    let pending_program = null;\n    let animation_name = null;\n    function clear_animation() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function init(program, duration) {\n        const d = (program.b - t);\n        duration *= Math.abs(d);\n        return {\n            a: t,\n            b: program.b,\n            d,\n            duration,\n            start: program.start,\n            end: program.start + duration,\n            group: program.group\n        };\n    }\n    function go(b) {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        const program = {\n            start: now() + delay,\n            b\n        };\n        if (!b) {\n            // @ts-ignore todo: improve typings\n            program.group = outros;\n            outros.r += 1;\n        }\n        if (running_program || pending_program) {\n            pending_program = program;\n        }\n        else {\n            // if this is an intro, and there's a delay, we need to do\n            // an initial tick and/or apply CSS animation immediately\n            if (css) {\n                clear_animation();\n                animation_name = create_rule(node, t, b, duration, delay, easing, css);\n            }\n            if (b)\n                tick(0, 1);\n            running_program = init(program, duration);\n            add_render_callback(() => dispatch(node, b, 'start'));\n            loop(now => {\n                if (pending_program && now > pending_program.start) {\n                    running_program = init(pending_program, duration);\n                    pending_program = null;\n                    dispatch(node, running_program.b, 'start');\n                    if (css) {\n                        clear_animation();\n                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n                    }\n                }\n                if (running_program) {\n                    if (now >= running_program.end) {\n                        tick(t = running_program.b, 1 - t);\n                        dispatch(node, running_program.b, 'end');\n                        if (!pending_program) {\n                            // we're done\n                            if (running_program.b) {\n                                // intro — we can tidy up immediately\n                                clear_animation();\n                            }\n                            else {\n                                // outro — needs to be coordinated\n                                if (!--running_program.group.r)\n                                    run_all(running_program.group.c);\n                            }\n                        }\n                        running_program = null;\n                    }\n                    else if (now >= running_program.start) {\n                        const p = now - running_program.start;\n                        t = running_program.a + running_program.d * easing(p / running_program.duration);\n                        tick(t, 1 - t);\n                    }\n                }\n                return !!(running_program || pending_program);\n            });\n        }\n    }\n    return {\n        run(b) {\n            if (is_function(config)) {\n                wait().then(() => {\n                    // @ts-ignore\n                    config = config();\n                    go(b);\n                });\n            }\n            else {\n                go(b);\n            }\n        },\n        end() {\n            clear_animation();\n            running_program = pending_program = null;\n        }\n    };\n}\n\nfunction handle_promise(promise, info) {\n    const token = info.token = {};\n    function update(type, index, key, value) {\n        if (info.token !== token)\n            return;\n        info.resolved = value;\n        let child_ctx = info.ctx;\n        if (key !== undefined) {\n            child_ctx = child_ctx.slice();\n            child_ctx[key] = value;\n        }\n        const block = type && (info.current = type)(child_ctx);\n        let needs_flush = false;\n        if (info.block) {\n            if (info.blocks) {\n                info.blocks.forEach((block, i) => {\n                    if (i !== index && block) {\n                        group_outros();\n                        transition_out(block, 1, 1, () => {\n                            if (info.blocks[i] === block) {\n                                info.blocks[i] = null;\n                            }\n                        });\n                        check_outros();\n                    }\n                });\n            }\n            else {\n                info.block.d(1);\n            }\n            block.c();\n            transition_in(block, 1);\n            block.m(info.mount(), info.anchor);\n            needs_flush = true;\n        }\n        info.block = block;\n        if (info.blocks)\n            info.blocks[index] = block;\n        if (needs_flush) {\n            flush();\n        }\n    }\n    if (is_promise(promise)) {\n        const current_component = get_current_component();\n        promise.then(value => {\n            set_current_component(current_component);\n            update(info.then, 1, info.value, value);\n            set_current_component(null);\n        }, error => {\n            set_current_component(current_component);\n            update(info.catch, 2, info.error, error);\n            set_current_component(null);\n            if (!info.hasCatch) {\n                throw error;\n            }\n        });\n        // if we previously had a then/catch block, destroy it\n        if (info.current !== info.pending) {\n            update(info.pending, 0);\n            return true;\n        }\n    }\n    else {\n        if (info.current !== info.then) {\n            update(info.then, 1, info.value, promise);\n            return true;\n        }\n        info.resolved = promise;\n    }\n}\nfunction update_await_block_branch(info, ctx, dirty) {\n    const child_ctx = ctx.slice();\n    const { resolved } = info;\n    if (info.current === info.then) {\n        child_ctx[info.value] = resolved;\n    }\n    if (info.current === info.catch) {\n        child_ctx[info.error] = resolved;\n    }\n    info.block.p(child_ctx, dirty);\n}\n\nconst globals = (typeof window !== 'undefined'\n    ? window\n    : typeof globalThis !== 'undefined'\n        ? globalThis\n        : global);\n\nfunction destroy_block(block, lookup) {\n    block.d(1);\n    lookup.delete(block.key);\n}\nfunction outro_and_destroy_block(block, lookup) {\n    transition_out(block, 1, 1, () => {\n        lookup.delete(block.key);\n    });\n}\nfunction fix_and_destroy_block(block, lookup) {\n    block.f();\n    destroy_block(block, lookup);\n}\nfunction fix_and_outro_and_destroy_block(block, lookup) {\n    block.f();\n    outro_and_destroy_block(block, lookup);\n}\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n    let o = old_blocks.length;\n    let n = list.length;\n    let i = o;\n    const old_indexes = {};\n    while (i--)\n        old_indexes[old_blocks[i].key] = i;\n    const new_blocks = [];\n    const new_lookup = new Map();\n    const deltas = new Map();\n    i = n;\n    while (i--) {\n        const child_ctx = get_context(ctx, list, i);\n        const key = get_key(child_ctx);\n        let block = lookup.get(key);\n        if (!block) {\n            block = create_each_block(key, child_ctx);\n            block.c();\n        }\n        else if (dynamic) {\n            block.p(child_ctx, dirty);\n        }\n        new_lookup.set(key, new_blocks[i] = block);\n        if (key in old_indexes)\n            deltas.set(key, Math.abs(i - old_indexes[key]));\n    }\n    const will_move = new Set();\n    const did_move = new Set();\n    function insert(block) {\n        transition_in(block, 1);\n        block.m(node, next);\n        lookup.set(block.key, block);\n        next = block.first;\n        n--;\n    }\n    while (o && n) {\n        const new_block = new_blocks[n - 1];\n        const old_block = old_blocks[o - 1];\n        const new_key = new_block.key;\n        const old_key = old_block.key;\n        if (new_block === old_block) {\n            // do nothing\n            next = new_block.first;\n            o--;\n            n--;\n        }\n        else if (!new_lookup.has(old_key)) {\n            // remove old block\n            destroy(old_block, lookup);\n            o--;\n        }\n        else if (!lookup.has(new_key) || will_move.has(new_key)) {\n            insert(new_block);\n        }\n        else if (did_move.has(old_key)) {\n            o--;\n        }\n        else if (deltas.get(new_key) > deltas.get(old_key)) {\n            did_move.add(new_key);\n            insert(new_block);\n        }\n        else {\n            will_move.add(old_key);\n            o--;\n        }\n    }\n    while (o--) {\n        const old_block = old_blocks[o];\n        if (!new_lookup.has(old_block.key))\n            destroy(old_block, lookup);\n    }\n    while (n)\n        insert(new_blocks[n - 1]);\n    return new_blocks;\n}\nfunction validate_each_keys(ctx, list, get_context, get_key) {\n    const keys = new Set();\n    for (let i = 0; i < list.length; i++) {\n        const key = get_key(get_context(ctx, list, i));\n        if (keys.has(key)) {\n            throw new Error('Cannot have duplicate keys in a keyed each');\n        }\n        keys.add(key);\n    }\n}\n\nfunction get_spread_update(levels, updates) {\n    const update = {};\n    const to_null_out = {};\n    const accounted_for = { $$scope: 1 };\n    let i = levels.length;\n    while (i--) {\n        const o = levels[i];\n        const n = updates[i];\n        if (n) {\n            for (const key in o) {\n                if (!(key in n))\n                    to_null_out[key] = 1;\n            }\n            for (const key in n) {\n                if (!accounted_for[key]) {\n                    update[key] = n[key];\n                    accounted_for[key] = 1;\n                }\n            }\n            levels[i] = n;\n        }\n        else {\n            for (const key in o) {\n                accounted_for[key] = 1;\n            }\n        }\n    }\n    for (const key in to_null_out) {\n        if (!(key in update))\n            update[key] = undefined;\n    }\n    return update;\n}\nfunction get_spread_object(spread_props) {\n    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n\n// source: https://html.spec.whatwg.org/multipage/indices.html\nconst boolean_attributes = new Set([\n    'allowfullscreen',\n    'allowpaymentrequest',\n    'async',\n    'autofocus',\n    'autoplay',\n    'checked',\n    'controls',\n    'default',\n    'defer',\n    'disabled',\n    'formnovalidate',\n    'hidden',\n    'ismap',\n    'loop',\n    'multiple',\n    'muted',\n    'nomodule',\n    'novalidate',\n    'open',\n    'playsinline',\n    'readonly',\n    'required',\n    'reversed',\n    'selected'\n]);\n\nconst invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nfunction spread(args, classes_to_add) {\n    const attributes = Object.assign({}, ...args);\n    if (classes_to_add) {\n        if (attributes.class == null) {\n            attributes.class = classes_to_add;\n        }\n        else {\n            attributes.class += ' ' + classes_to_add;\n        }\n    }\n    let str = '';\n    Object.keys(attributes).forEach(name => {\n        if (invalid_attribute_name_character.test(name))\n            return;\n        const value = attributes[name];\n        if (value === true)\n            str += ' ' + name;\n        else if (boolean_attributes.has(name.toLowerCase())) {\n            if (value)\n                str += ' ' + name;\n        }\n        else if (value != null) {\n            str += ` ${name}=\"${value}\"`;\n        }\n    });\n    return str;\n}\nconst escaped = {\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;'\n};\nfunction escape(html) {\n    return String(html).replace(/[\"'&<>]/g, match => escaped[match]);\n}\nfunction escape_attribute_value(value) {\n    return typeof value === 'string' ? escape(value) : value;\n}\nfunction escape_object(obj) {\n    const result = {};\n    for (const key in obj) {\n        result[key] = escape_attribute_value(obj[key]);\n    }\n    return result;\n}\nfunction each(items, fn) {\n    let str = '';\n    for (let i = 0; i < items.length; i += 1) {\n        str += fn(items[i], i);\n    }\n    return str;\n}\nconst missing_component = {\n    $$render: () => ''\n};\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === 'svelte:component')\n            name += ' this={...}';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);\n    }\n    return component;\n}\nfunction debug(file, line, column, values) {\n    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n    console.log(values); // eslint-disable-line no-console\n    return '';\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots, context) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(parent_component ? parent_component.$$.context : context || []),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {\n            on_destroy = [];\n            const result = { title: '', head: '', css: new Set() };\n            const html = $$render(result, props, {}, $$slots, context);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.title + result.head\n            };\n        },\n        $$render\n    };\n}\nfunction add_attribute(name, value, boolean) {\n    if (value == null || (boolean && !value))\n        return '';\n    return ` ${name}${value === true ? '' : `=${typeof value === 'string' ? JSON.stringify(escape(value)) : `\"${value}\"`}`}`;\n}\nfunction add_classes(classes) {\n    return classes ? ` class=\"${classes}\"` : '';\n}\n\nfunction bind(component, name, callback) {\n    const index = component.$$.props[name];\n    if (index !== undefined) {\n        component.$$.bound[index] = callback;\n        callback(component.$$.ctx[index]);\n    }\n}\nfunction create_component(block) {\n    block && block.c();\n}\nfunction claim_component(block, parent_nodes) {\n    block && block.l(parent_nodes);\n}\nfunction mount_component(component, target, anchor, customElement) {\n    const { fragment, on_mount, on_destroy, after_update } = component.$$;\n    fragment && fragment.m(target, anchor);\n    if (!customElement) {\n        // onMount happens before the initial afterUpdate\n        add_render_callback(() => {\n            const new_on_destroy = on_mount.map(run).filter(is_function);\n            if (on_destroy) {\n                on_destroy.push(...new_on_destroy);\n            }\n            else {\n                // Edge case - component was destroyed immediately,\n                // most likely as a result of a binding initialising\n                run_all(new_on_destroy);\n            }\n            component.$$.on_mount = [];\n        });\n    }\n    after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n    const $$ = component.$$;\n    if ($$.fragment !== null) {\n        run_all($$.on_destroy);\n        $$.fragment && $$.fragment.d(detaching);\n        // TODO null out other refs, including component.$$ (but need to\n        // preserve final state?)\n        $$.on_destroy = $$.fragment = null;\n        $$.ctx = [];\n    }\n}\nfunction make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n        dirty_components.push(component);\n        schedule_update();\n        component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const $$ = component.$$ = {\n        fragment: null,\n        ctx: null,\n        // state\n        props,\n        update: noop,\n        not_equal,\n        bound: blank_object(),\n        // lifecycle\n        on_mount: [],\n        on_destroy: [],\n        on_disconnect: [],\n        before_update: [],\n        after_update: [],\n        context: new Map(parent_component ? parent_component.$$.context : options.context || []),\n        // everything else\n        callbacks: blank_object(),\n        dirty,\n        skip_bound: false,\n        root: options.target || parent_component.$$.root\n    };\n    append_styles && append_styles($$.root);\n    let ready = false;\n    $$.ctx = instance\n        ? instance(component, options.props || {}, (i, ret, ...rest) => {\n            const value = rest.length ? rest[0] : ret;\n            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                if (!$$.skip_bound && $$.bound[i])\n                    $$.bound[i](value);\n                if (ready)\n                    make_dirty(component, i);\n            }\n            return ret;\n        })\n        : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    // `false` as a special case of no DOM component\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n        if (options.hydrate) {\n            start_hydrating();\n            const nodes = children(options.target);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.l(nodes);\n            nodes.forEach(detach);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.c();\n        }\n        if (options.intro)\n            transition_in(component.$$.fragment);\n        mount_component(component, options.target, options.anchor, options.customElement);\n        end_hydrating();\n        flush();\n    }\n    set_current_component(parent_component);\n}\nlet SvelteElement;\nif (typeof HTMLElement === 'function') {\n    SvelteElement = class extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n        }\n        connectedCallback() {\n            const { on_mount } = this.$$;\n            this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n            // @ts-ignore todo: improve typings\n            for (const key in this.$$.slotted) {\n                // @ts-ignore todo: improve typings\n                this.appendChild(this.$$.slotted[key]);\n            }\n        }\n        attributeChangedCallback(attr, _oldValue, newValue) {\n            this[attr] = newValue;\n        }\n        disconnectedCallback() {\n            run_all(this.$$.on_disconnect);\n        }\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            // TODO should this delegate to addEventListener?\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set($$props) {\n            if (this.$$set && !is_empty($$props)) {\n                this.$$.skip_bound = true;\n                this.$$set($$props);\n                this.$$.skip_bound = false;\n            }\n        }\n    };\n}\n/**\n * Base class for Svelte components. Used when dev=false.\n */\nclass SvelteComponent {\n    $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n    }\n    $on(type, callback) {\n        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n        callbacks.push(callback);\n        return () => {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1)\n                callbacks.splice(index, 1);\n        };\n    }\n    $set($$props) {\n        if (this.$$set && !is_empty($$props)) {\n            this.$$.skip_bound = true;\n            this.$$set($$props);\n            this.$$.skip_bound = false;\n        }\n    }\n}\n\nfunction dispatch_dev(type, detail) {\n    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.42.4' }, detail), true));\n}\nfunction append_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append(target, node);\n}\nfunction append_hydration_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append_hydration(target, node);\n}\nfunction insert_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert(target, node, anchor);\n}\nfunction insert_hydration_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert_hydration(target, node, anchor);\n}\nfunction detach_dev(node) {\n    dispatch_dev('SvelteDOMRemove', { node });\n    detach(node);\n}\nfunction detach_between_dev(before, after) {\n    while (before.nextSibling && before.nextSibling !== after) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction detach_before_dev(after) {\n    while (after.previousSibling) {\n        detach_dev(after.previousSibling);\n    }\n}\nfunction detach_after_dev(before) {\n    while (before.nextSibling) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {\n    const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];\n    if (has_prevent_default)\n        modifiers.push('preventDefault');\n    if (has_stop_propagation)\n        modifiers.push('stopPropagation');\n    dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });\n    const dispose = listen(node, event, handler, options);\n    return () => {\n        dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });\n        dispose();\n    };\n}\nfunction attr_dev(node, attribute, value) {\n    attr(node, attribute, value);\n    if (value == null)\n        dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });\n    else\n        dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });\n}\nfunction prop_dev(node, property, value) {\n    node[property] = value;\n    dispatch_dev('SvelteDOMSetProperty', { node, property, value });\n}\nfunction dataset_dev(node, property, value) {\n    node.dataset[property] = value;\n    dispatch_dev('SvelteDOMSetDataset', { node, property, value });\n}\nfunction set_data_dev(text, data) {\n    data = '' + data;\n    if (text.wholeText === data)\n        return;\n    dispatch_dev('SvelteDOMSetData', { node: text, data });\n    text.data = data;\n}\nfunction validate_each_argument(arg) {\n    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {\n        let msg = '{#each} only iterates over array-like objects.';\n        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {\n            msg += ' You can use a spread to convert this iterable into an array.';\n        }\n        throw new Error(msg);\n    }\n}\nfunction validate_slots(name, slot, keys) {\n    for (const slot_key of Object.keys(slot)) {\n        if (!~keys.indexOf(slot_key)) {\n            console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n        }\n    }\n}\n/**\n * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.\n */\nclass SvelteComponentDev extends SvelteComponent {\n    constructor(options) {\n        if (!options || (!options.target && !options.$$inline)) {\n            throw new Error(\"'target' is a required option\");\n        }\n        super();\n    }\n    $destroy() {\n        super.$destroy();\n        this.$destroy = () => {\n            console.warn('Component was already destroyed'); // eslint-disable-line no-console\n        };\n    }\n    $capture_state() { }\n    $inject_state() { }\n}\n/**\n * Base class to create strongly typed Svelte components.\n * This only exists for typing purposes and should be used in `.d.ts` files.\n *\n * ### Example:\n *\n * You have component library on npm called `component-library`, from which\n * you export a component called `MyComponent`. For Svelte+TypeScript users,\n * you want to provide typings. Therefore you create a `index.d.ts`:\n * ```ts\n * import { SvelteComponentTyped } from \"svelte\";\n * export class MyComponent extends SvelteComponentTyped<{foo: string}> {}\n * ```\n * Typing this makes it possible for IDEs like VS Code with the Svelte extension\n * to provide intellisense and to use the component like this in a Svelte file\n * with TypeScript:\n * ```svelte\n * <script lang=\"ts\">\n * \timport { MyComponent } from \"component-library\";\n * </script>\n * <MyComponent foo={'bar'} />\n * ```\n *\n * #### Why not make this part of `SvelteComponent(Dev)`?\n * Because\n * ```ts\n * class ASubclassOfSvelteComponent extends SvelteComponent<{foo: string}> {}\n * const component: typeof SvelteComponent = ASubclassOfSvelteComponent;\n * ```\n * will throw a type error, so we need to separate the more strictly typed class.\n */\nclass SvelteComponentTyped extends SvelteComponentDev {\n    constructor(options) {\n        super(options);\n    }\n}\nfunction loop_guard(timeout) {\n    const start = Date.now();\n    return () => {\n        if (Date.now() - start > timeout) {\n            throw new Error('Infinite loop detected');\n        }\n    };\n}\n\nexport { HtmlTag, HtmlTagHydration, SvelteComponent, SvelteComponentDev, SvelteComponentTyped, SvelteElement, action_destroyer, add_attribute, add_classes, add_flush_callback, add_location, add_render_callback, add_resize_listener, add_transform, afterUpdate, append, append_dev, append_empty_stylesheet, append_hydration, append_hydration_dev, append_styles, assign, attr, attr_dev, attribute_to_object, beforeUpdate, bind, binding_callbacks, blank_object, bubble, check_outros, children, claim_component, claim_element, claim_html_tag, claim_space, claim_svg_element, claim_text, clear_loops, component_subscribe, compute_rest_props, compute_slots, createEventDispatcher, create_animation, create_bidirectional_transition, create_component, create_in_transition, create_out_transition, create_slot, create_ssr_component, current_component, custom_event, dataset_dev, debug, destroy_block, destroy_component, destroy_each, detach, detach_after_dev, detach_before_dev, detach_between_dev, detach_dev, dirty_components, dispatch_dev, each, element, element_is, empty, end_hydrating, escape, escape_attribute_value, escape_object, escaped, exclude_internal_props, fix_and_destroy_block, fix_and_outro_and_destroy_block, fix_position, flush, getAllContexts, getContext, get_all_dirty_from_scope, get_binding_group_value, get_current_component, get_custom_elements_slots, get_root_for_style, get_slot_changes, get_spread_object, get_spread_update, get_store_value, globals, group_outros, handle_promise, hasContext, has_prop, identity, init, insert, insert_dev, insert_hydration, insert_hydration_dev, intros, invalid_attribute_name_character, is_client, is_crossorigin, is_empty, is_function, is_promise, listen, listen_dev, loop, loop_guard, missing_component, mount_component, noop, not_equal, now, null_to_empty, object_without_properties, onDestroy, onMount, once, outro_and_destroy_block, prevent_default, prop_dev, query_selector_all, raf, run, run_all, safe_not_equal, schedule_update, select_multiple_value, select_option, select_options, select_value, self, setContext, set_attributes, set_current_component, set_custom_element_data, set_data, set_data_dev, set_input_type, set_input_value, set_now, set_raf, set_store_value, set_style, set_svg_attributes, space, spread, src_url_equal, start_hydrating, stop_propagation, subscribe, svg_element, text, tick, time_ranges_to_array, to_number, toggle_class, transition_in, transition_out, trusted, update_await_block_branch, update_keyed_each, update_slot, update_slot_base, validate_component, validate_each_argument, validate_each_keys, validate_slots, validate_store, xlink_attr };\n","<script lang=\"ts\">\n    import { isEmpty } from \"lodash\";\n\n    export let cursorName: string;\n    export let tagName: string;\n    export let backgroundColor: string;\n    export let appliance: string;\n    export let x: number;\n    export let y: number;\n    export let src: string;\n    export let visible: boolean;\n    export let avatar: string;\n    export let theme: string;\n    export let color: string;\n    export let cursorTagBackgroundColor: string;\n    export let opacity: number;\n\n    $: hasName = !isEmpty(cursorName);\n    $: hasTagName = !isEmpty(tagName);\n    $: hasAvatar = !isEmpty(avatar);\n    $: display = visible ? \"initial\" : \"none\";\n\n    const computedAvatarStyle = () => {\n        return Object.entries({\n            width: (hasName ? 19 : 28) + \"px\",\n            height: (hasName ? 19 : 28) + \"px\",\n            position: hasName ? \"initial\" : \"absolute\",\n            \"border-color\": hasName ? \"white\" : backgroundColor,\n            \"margin-right\": (hasName ? 4 : 0) + \"px\",\n        })\n            .map(([key, v]) => `${key}: ${v}`)\n            .join(\";\");\n    };\n</script>\n\n<div\n    class=\"netless-window-manager-cursor-mid\"\n    style=\"transform: translateX({x}px) translateY({y}px);display: {display}\"\n>\n    <div class=\"netless-window-manager-cursor-name\">\n        <div\n            class={theme}\n            style=\"background-color: {backgroundColor};color: {color};opacity: {opacity}\"\n        >\n            {#if hasAvatar}\n                <img\n                    class=\"netless-window-manager-cursor-selector-avatar\"\n                    style={computedAvatarStyle()}\n                    src={avatar}\n                    alt=\"avatar\"\n                />\n            {/if}\n            <span style=\"overflow: hidden;white-space: nowrap;text-overflow: ellipsis;max-width: 80px\">{cursorName}</span>\n            {#if hasTagName}\n                <span class=\"netless-window-manager-cursor-tag-name\" style=\"background-color: {cursorTagBackgroundColor}\">\n                    {tagName}\n                </span>\n            {/if}\n        </div>\n    </div>\n    <div class=\"cursor-image-wrapper\">\n        <img class=\"netless-window-manager-cursor-{appliance}-image\" {src} alt={appliance} />\n    </div>\n</div>\n","import { ApplianceNames } from \"white-web-sdk\";\nimport pencil from \"../image/pencil-cursor.png\";\nimport selector from \"../image/selector-cursor.png\";\nimport eraser from \"../image/eraser-cursor.png\";\nimport shape from \"../image/shape-cursor.svg\";\nimport text from \"../image/text-cursor.svg\";\n\nexport const ApplianceMap: {\n    [key: string]: string;\n} = {\n    [ApplianceNames.pencil]: pencil,\n    [ApplianceNames.selector]: selector,\n    [ApplianceNames.eraser]: eraser,\n    [ApplianceNames.shape]: shape,\n    [ApplianceNames.text]: text,\n};\n","export default \"data:image/png;base64,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\"","export default \"data:image/png;base64,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\"","export default \"data:image/png;base64,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\"","export default \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iNDBweCIgaGVpZ2h0PSI0MHB4IiB2aWV3Qm94PSIwIDAgNDAgNDAiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDYwLjEgKDg4MTMzKSAtIGh0dHBzOi8vc2tldGNoLmNvbSAtLT4KICAgIDx0aXRsZT5zaGFwZS1jdXJzb3I8L3RpdGxlPgogICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+CiAgICA8ZGVmcz4KICAgICAgICA8cGF0aCBkPSJNMjAsMjEuNSBDMjAuMjQ1NDU5OSwyMS41IDIwLjQ0OTYwODQsMjEuNjc2ODc1MiAyMC40OTE5NDQzLDIxLjkxMDEyNDQgTDIwLjUsMjIgTDIwLjUsMjcgQzIwLjUsMjcuMjc2MTQyNCAyMC4yNzYxNDI0LDI3LjUgMjAsMjcuNSBDMTkuNzU0NTQwMSwyNy41IDE5LjU1MDM5MTYsMjcuMzIzMTI0OCAxOS41MDgwNTU3LDI3LjA4OTg3NTYgTDE5LjUsMjcgTDE5LjUsMjIgQzE5LjUsMjEuNzIzODU3NiAxOS43MjM4NTc2LDIxLjUgMjAsMjEuNSBaIE0yNywxOS41IEMyNy4yNzYxNDI0LDE5LjUgMjcuNSwxOS43MjM4NTc2IDI3LjUsMjAgQzI3LjUsMjAuMjQ1NDU5OSAyNy4zMjMxMjQ4LDIwLjQ0OTYwODQgMjcuMDg5ODc1NiwyMC40OTE5NDQzIEwyNywyMC41IEwyMiwyMC41IEMyMS43MjM4NTc2LDIwLjUgMjEuNSwyMC4yNzYxNDI0IDIxLjUsMjAgQzIxLjUsMTkuNzU0NTQwMSAyMS42NzY4NzUyLDE5LjU1MDM5MTYgMjEuOTEwMTI0NCwxOS41MDgwNTU3IEwyMiwxOS41IEwyNywxOS41IFogTTE4LDE5LjUgQzE4LjI3NjE0MjQsMTkuNSAxOC41LDE5LjcyMzg1NzYgMTguNSwyMCBDMTguNSwyMC4yNDU0NTk5IDE4LjMyMzEyNDgsMjAuNDQ5NjA4NCAxOC4wODk4NzU2LDIwLjQ5MTk0NDMgTDE4LDIwLjUgTDEzLDIwLjUgQzEyLjcyMzg1NzYsMjAuNSAxMi41LDIwLjI3NjE0MjQgMTIuNSwyMCBDMTIuNSwxOS43NTQ1NDAxIDEyLjY3Njg3NTIsMTkuNTUwMzkxNiAxMi45MTAxMjQ0LDE5LjUwODA1NTcgTDEzLDE5LjUgTDE4LDE5LjUgWiBNMjAsMTIuNSBDMjAuMjQ1NDU5OSwxMi41IDIwLjQ0OTYwODQsMTIuNjc2ODc1MiAyMC40OTE5NDQzLDEyLjkxMDEyNDQgTDIwLjUsMTMgTDIwLjUsMTggQzIwLjUsMTguMjc2MTQyNCAyMC4yNzYxNDI0LDE4LjUgMjAsMTguNSBDMTkuNzU0NTQwMSwxOC41IDE5LjU1MDM5MTYsMTguMzIzMTI0OCAxOS41MDgwNTU3LDE4LjA4OTg3NTYgTDE5LjUsMTggTDE5LjUsMTMgQzE5LjUsMTIuNzIzODU3NiAxOS43MjM4NTc2LDEyLjUgMjAsMTIuNSBaIiBpZD0icGF0aC0xIj48L3BhdGg+CiAgICAgICAgPGZpbHRlciB4PSItNjQuNiUiIHk9Ii01OS41JSIgd2lkdGg9IjIyOS4zJSIgaGVpZ2h0PSIyNDYuMSUiIGZpbHRlclVuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgaWQ9ImZpbHRlci0yIj4KICAgICAgICAgICAgPGZlTW9ycGhvbG9neSByYWRpdXM9IjEiIG9wZXJhdG9yPSJkaWxhdGUiIGluPSJTb3VyY2VBbHBoYSIgcmVzdWx0PSJzaGFkb3dTcHJlYWRPdXRlcjEiPjwvZmVNb3JwaG9sb2d5PgogICAgICAgICAgICA8ZmVPZmZzZXQgZHg9IjAiIGR5PSIyIiBpbj0ic2hhZG93U3ByZWFkT3V0ZXIxIiByZXN1bHQ9InNoYWRvd09mZnNldE91dGVyMSI+PC9mZU9mZnNldD4KICAgICAgICAgICAgPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iMyIgaW49InNoYWRvd09mZnNldE91dGVyMSIgcmVzdWx0PSJzaGFkb3dCbHVyT3V0ZXIxIj48L2ZlR2F1c3NpYW5CbHVyPgogICAgICAgICAgICA8ZmVDb21wb3NpdGUgaW49InNoYWRvd0JsdXJPdXRlcjEiIGluMj0iU291cmNlQWxwaGEiIG9wZXJhdG9yPSJvdXQiIHJlc3VsdD0ic2hhZG93Qmx1ck91dGVyMSI+PC9mZUNvbXBvc2l0ZT4KICAgICAgICAgICAgPGZlQ29sb3JNYXRyaXggdmFsdWVzPSIwIDAgMCAwIDAgICAwIDAgMCAwIDAgICAwIDAgMCAwIDAgIDAgMCAwIDAuMTYgMCIgdHlwZT0ibWF0cml4IiBpbj0ic2hhZG93Qmx1ck91dGVyMSI+PC9mZUNvbG9yTWF0cml4PgogICAgICAgIDwvZmlsdGVyPgogICAgPC9kZWZzPgogICAgPGcgaWQ9Iumhtemdoi00IiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4KICAgICAgICA8ZyBpZD0iV2hpdGVib2FyZC1HdWlkZWxpbmVzIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMzQ0LjAwMDAwMCwgLTc1MS4wMDAwMDApIj4KICAgICAgICAgICAgPGcgaWQ9InNoYXBlLWN1cnNvciIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMzQ0LjAwMDAwMCwgNzUxLjAwMDAwMCkiPgogICAgICAgICAgICAgICAgPHJlY3QgaWQ9IuefqeW9ouWkh+S7vS00NCIgZmlsbD0iI0ZGRkZGRiIgb3BhY2l0eT0iMC4wMSIgeD0iMCIgeT0iMCIgd2lkdGg9IjQwIiBoZWlnaHQ9IjQwIiByeD0iMiI+PC9yZWN0PgogICAgICAgICAgICAgICAgPGcgaWQ9IuW9oueKtue7k+WQiCIgZmlsbC1ydWxlPSJub256ZXJvIj4KICAgICAgICAgICAgICAgICAgICA8dXNlIGZpbGw9ImJsYWNrIiBmaWxsLW9wYWNpdHk9IjEiIGZpbHRlcj0idXJsKCNmaWx0ZXItMikiIHhsaW5rOmhyZWY9IiNwYXRoLTEiPjwvdXNlPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIxIiBkPSJNMjAsMjEgQzIwLjQ4NTQxMDMsMjEgMjAuODk4MDg1LDIxLjM0Nzk5OTMgMjAuOTg5OTQ3OSwyMS44NjU0ODc3IEwyMSwyMiBMMjEsMjcgQzIxLDI3LjU1MjI4NDcgMjAuNTUyMjg0NywyOCAyMCwyOCBDMTkuNTE0NTg5NywyOCAxOS4xMDE5MTUsMjcuNjUyMDAwNyAxOS4wMTAwNTIxLDI3LjEzNDUxMjMgTDE5LDI3IEwxOSwyMiBDMTksMjEuNDQ3NzE1MyAxOS40NDc3MTUzLDIxIDIwLDIxIFogTTI3LDE5IEMyNy41NTIyODQ3LDE5IDI4LDE5LjQ0NzcxNTMgMjgsMjAgQzI4LDIwLjQ4NTQxMDMgMjcuNjUyMDAwNywyMC44OTgwODUgMjcuMTM0NTEyMywyMC45ODk5NDc5IEwyNywyMSBMMjIsMjEgQzIxLjQ0NzcxNTMsMjEgMjEsMjAuNTUyMjg0NyAyMSwyMCBDMjEsMTkuNTE0NTg5NyAyMS4zNDc5OTkzLDE5LjEwMTkxNSAyMS44NjU0ODc3LDE5LjAxMDA1MjEgTDIyLDE5IEwyNywxOSBaIE0xOCwxOSBDMTguNTUyMjg0NywxOSAxOSwxOS40NDc3MTUzIDE5LDIwIEMxOSwyMC40ODU0MTAzIDE4LjY1MjAwMDcsMjAuODk4MDg1IDE4LjEzNDUxMjMsMjAuOTg5OTQ3OSBMMTgsMjEgTDEzLDIxIEMxMi40NDc3MTUzLDIxIDEyLDIwLjU1MjI4NDcgMTIsMjAgQzEyLDE5LjUxNDU4OTcgMTIuMzQ3OTk5MywxOS4xMDE5MTUgMTIuODY1NDg3NywxOS4wMTAwNTIxIEwxMywxOSBMMTgsMTkgWiBNMjAsMTIgQzIwLjQ4NTQxMDMsMTIgMjAuODk4MDg1LDEyLjM0Nzk5OTMgMjAuOTg5OTQ3OSwxMi44NjU0ODc3IEwyMSwxMyBMMjEsMTggQzIxLDE4LjU1MjI4NDcgMjAuNTUyMjg0NywxOSAyMCwxOSBDMTkuNTE0NTg5NywxOSAxOS4xMDE5MTUsMTguNjUyMDAwNyAxOS4wMTAwNTIxLDE4LjEzNDUxMjMgTDE5LDE4IEwxOSwxMyBDMTksMTIuNDQ3NzE1MyAxOS40NDc3MTUzLDEyIDIwLDEyIFoiIGZpbGw9IiMyMTIzMjQiIGZpbGwtcnVsZT0iZXZlbm9kZCI+PC9wYXRoPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPHJlY3QgaWQ9IuefqeW9oiIgZmlsbD0iI0ZGRkZGRiIgeD0iMTguNSIgeT0iMTciIHdpZHRoPSIzIiBoZWlnaHQ9IjYiPjwvcmVjdD4KICAgICAgICAgICAgICAgIDxyZWN0IGlkPSLnn6nlvaIiIGZpbGw9IiNGRkZGRkYiIHg9IjE3IiB5PSIxOC41IiB3aWR0aD0iNiIgaGVpZ2h0PSIzIj48L3JlY3Q+CiAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMjAsMjEuNSBDMjAuMjQ1NDU5OSwyMS41IDIwLjQ0OTYwODQsMjEuNjc2ODc1MiAyMC40OTE5NDQzLDIxLjkxMDEyNDQgTDIwLjUsMjIgTDIwLjUsMjcgQzIwLjUsMjcuMjc2MTQyNCAyMC4yNzYxNDI0LDI3LjUgMjAsMjcuNSBDMTkuNzU0NTQwMSwyNy41IDE5LjU1MDM5MTYsMjcuMzIzMTI0OCAxOS41MDgwNTU3LDI3LjA4OTg3NTYgTDE5LjUsMjcgTDE5LjUsMjIgQzE5LjUsMjEuNzIzODU3NiAxOS43MjM4NTc2LDIxLjUgMjAsMjEuNSBaIE0yNywxOS41IEMyNy4yNzYxNDI0LDE5LjUgMjcuNSwxOS43MjM4NTc2IDI3LjUsMjAgQzI3LjUsMjAuMjQ1NDU5OSAyNy4zMjMxMjQ4LDIwLjQ0OTYwODQgMjcuMDg5ODc1NiwyMC40OTE5NDQzIEwyNywyMC41IEwyMiwyMC41IEMyMS43MjM4NTc2LDIwLjUgMjEuNSwyMC4yNzYxNDI0IDIxLjUsMjAgQzIxLjUsMTkuNzU0NTQwMSAyMS42NzY4NzUyLDE5LjU1MDM5MTYgMjEuOTEwMTI0NCwxOS41MDgwNTU3IEwyMiwxOS41IEwyNywxOS41IFogTTE4LDE5LjUgQzE4LjI3NjE0MjQsMTkuNSAxOC41LDE5LjcyMzg1NzYgMTguNSwyMCBDMTguNSwyMC4yNDU0NTk5IDE4LjMyMzEyNDgsMjAuNDQ5NjA4NCAxOC4wODk4NzU2LDIwLjQ5MTk0NDMgTDE4LDIwLjUgTDEzLDIwLjUgQzEyLjcyMzg1NzYsMjAuNSAxMi41LDIwLjI3NjE0MjQgMTIuNSwyMCBDMTIuNSwxOS43NTQ1NDAxIDEyLjY3Njg3NTIsMTkuNTUwMzkxNiAxMi45MTAxMjQ0LDE5LjUwODA1NTcgTDEzLDE5LjUgTDE4LDE5LjUgWiBNMjAsMTIuNSBDMjAuMjQ1NDU5OSwxMi41IDIwLjQ0OTYwODQsMTIuNjc2ODc1MiAyMC40OTE5NDQzLDEyLjkxMDEyNDQgTDIwLjUsMTMgTDIwLjUsMTggQzIwLjUsMTguMjc2MTQyNCAyMC4yNzYxNDI0LDE4LjUgMjAsMTguNSBDMTkuNzU0NTQwMSwxOC41IDE5LjU1MDM5MTYsMTguMzIzMTI0OCAxOS41MDgwNTU3LDE4LjA4OTg3NTYgTDE5LjUsMTggTDE5LjUsMTMgQzE5LjUsMTIuNzIzODU3NiAxOS43MjM4NTc2LDEyLjUgMjAsMTIuNSBaIiBpZD0i5b2i54q257uT5ZCIIiBmaWxsPSIjMjEyMzI0IiBmaWxsLXJ1bGU9Im5vbnplcm8iPjwvcGF0aD4KICAgICAgICAgICAgPC9nPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+\"","export default \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iNDdweCIgaGVpZ2h0PSI0MHB4IiB2aWV3Qm94PSIwIDAgNDcgNDAiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDYwLjEgKDg4MTMzKSAtIGh0dHBzOi8vc2tldGNoLmNvbSAtLT4KICAgIDx0aXRsZT50ZXh0LWN1cnNvcjwvdGl0bGU+CiAgICA8ZGVzYz5DcmVhdGVkIHdpdGggU2tldGNoLjwvZGVzYz4KICAgIDxkZWZzPgogICAgICAgIDxwYXRoIGQ9Ik0xNiwyNi41IEMxNS43MjM4NTc2LDI2LjUgMTUuNSwyNi4yNzYxNDI0IDE1LjUsMjYgQzE1LjUsMjUuNzU0NTQwMSAxNS42NzY4NzUyLDI1LjU1MDM5MTYgMTUuOTEwMTI0NCwyNS41MDgwNTU3IEwxNiwyNS41IEwxOS41LDI1LjUgTDE5LjUsMTQuNSBMMTYsMTQuNSBDMTUuNzIzODU3NiwxNC41IDE1LjUsMTQuMjc2MTQyNCAxNS41LDE0IEMxNS41LDEzLjc1NDU0MDEgMTUuNjc2ODc1MiwxMy41NTAzOTE2IDE1LjkxMDEyNDQsMTMuNTA4MDU1NyBMMTYsMTMuNSBMMjQsMTMuNSBDMjQuMjc2MTQyNCwxMy41IDI0LjUsMTMuNzIzODU3NiAyNC41LDE0IEMyNC41LDE0LjI0NTQ1OTkgMjQuMzIzMTI0OCwxNC40NDk2MDg0IDI0LjA4OTg3NTYsMTQuNDkxOTQ0MyBMMjQsMTQuNSBMMjAuNSwxNC41IEwyMC41LDI1LjUgTDI0LDI1LjUgQzI0LjI3NjE0MjQsMjUuNSAyNC41LDI1LjcyMzg1NzYgMjQuNSwyNiBDMjQuNSwyNi4yNDU0NTk5IDI0LjMyMzEyNDgsMjYuNDQ5NjA4NCAyNC4wODk4NzU2LDI2LjQ5MTk0NDMgTDI0LDI2LjUgTDE2LDI2LjUgWiIgaWQ9InBhdGgtMSI+PC9wYXRoPgogICAgICAgIDxmaWx0ZXIgeD0iLTI4NC4wJSIgeT0iLTgxLjUlIiB3aWR0aD0iNjY4LjElIiBoZWlnaHQ9IjI5My45JSIgZmlsdGVyVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94IiBpZD0iZmlsdGVyLTIiPgogICAgICAgICAgICA8ZmVNb3JwaG9sb2d5IHJhZGl1cz0iMSIgb3BlcmF0b3I9ImRpbGF0ZSIgaW49IlNvdXJjZUFscGhhIiByZXN1bHQ9InNoYWRvd1NwcmVhZE91dGVyMSI+PC9mZU1vcnBob2xvZ3k+CiAgICAgICAgICAgIDxmZU9mZnNldCBkeD0iMCIgZHk9IjIiIGluPSJzaGFkb3dTcHJlYWRPdXRlcjEiIHJlc3VsdD0ic2hhZG93T2Zmc2V0T3V0ZXIxIj48L2ZlT2Zmc2V0PgogICAgICAgICAgICA8ZmVHYXVzc2lhbkJsdXIgc3RkRGV2aWF0aW9uPSIzIiBpbj0ic2hhZG93T2Zmc2V0T3V0ZXIxIiByZXN1bHQ9InNoYWRvd0JsdXJPdXRlcjEiPjwvZmVHYXVzc2lhbkJsdXI+CiAgICAgICAgICAgIDxmZUNvbXBvc2l0ZSBpbj0ic2hhZG93Qmx1ck91dGVyMSIgaW4yPSJTb3VyY2VBbHBoYSIgb3BlcmF0b3I9Im91dCIgcmVzdWx0PSJzaGFkb3dCbHVyT3V0ZXIxIj48L2ZlQ29tcG9zaXRlPgogICAgICAgICAgICA8ZmVDb2xvck1hdHJpeCB2YWx1ZXM9IjAgMCAwIDAgMCAgIDAgMCAwIDAgMCAgIDAgMCAwIDAgMCAgMCAwIDAgMC4xNiAwIiB0eXBlPSJtYXRyaXgiIGluPSJzaGFkb3dCbHVyT3V0ZXIxIj48L2ZlQ29sb3JNYXRyaXg+CiAgICAgICAgPC9maWx0ZXI+CiAgICA8L2RlZnM+CiAgICA8ZyBpZD0i6aG16Z2iLTQiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPgogICAgICAgIDxnIGlkPSJXaGl0ZWJvYXJkLUd1aWRlbGluZXMiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0zODguMDAwMDAwLCAtNjcyLjAwMDAwMCkiPgogICAgICAgICAgICA8ZyBpZD0idGV4dC1jdXJzb3IiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDM5Mi4wMDAwMDAsIDY3Mi4wMDAwMDApIj4KICAgICAgICAgICAgICAgIDxyZWN0IGlkPSLnn6nlvaLlpIfku70tNDAiIGZpbGw9IiNGRkZGRkYiIG9wYWNpdHk9IjAuMDEiIHg9IjAiIHk9IjAiIHdpZHRoPSI0MCIgaGVpZ2h0PSI0MCIgcng9IjIiPjwvcmVjdD4KICAgICAgICAgICAgICAgIDxnIGlkPSLlvaLnirbnu5PlkIgiIGZpbGwtcnVsZT0ibm9uemVybyI+CiAgICAgICAgICAgICAgICAgICAgPHVzZSBmaWxsPSJibGFjayIgZmlsbC1vcGFjaXR5PSIxIiBmaWx0ZXI9InVybCgjZmlsdGVyLTIpIiB4bGluazpocmVmPSIjcGF0aC0xIj48L3VzZT4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMSIgZD0iTTE5LDI1IEwxOSwxNSBMMTYsMTUgQzE1LjQ0NzcxNTMsMTUgMTUsMTQuNTUyMjg0NyAxNSwxNCBDMTUsMTMuNTE0NTg5NyAxNS4zNDc5OTkzLDEzLjEwMTkxNSAxNS44NjU0ODc3LDEzLjAxMDA1MjEgTDE2LDEzIEwyNCwxMyBDMjQuNTUyMjg0NywxMyAyNSwxMy40NDc3MTUzIDI1LDE0IEMyNSwxNC40ODU0MTAzIDI0LjY1MjAwMDcsMTQuODk4MDg1IDI0LjEzNDUxMjMsMTQuOTg5OTQ3OSBMMjQsMTUgTDIxLDE1IEwyMSwyNSBMMjQsMjUgQzI0LjU1MjI4NDcsMjUgMjUsMjUuNDQ3NzE1MyAyNSwyNiBDMjUsMjYuNDg1NDEwMyAyNC42NTIwMDA3LDI2Ljg5ODA4NSAyNC4xMzQ1MTIzLDI2Ljk4OTk0NzkgTDI0LDI3IEwxNiwyNyBDMTUuNDQ3NzE1MywyNyAxNSwyNi41NTIyODQ3IDE1LDI2IEMxNSwyNS41MTQ1ODk3IDE1LjM0Nzk5OTMsMjUuMTAxOTE1IDE1Ljg2NTQ4NzcsMjUuMDEwMDUyMSBMMTYsMjUgTDE5LDI1IFoiIGZpbGw9IiMyMTIzMjQiIGZpbGwtcnVsZT0iZXZlbm9kZCI+PC9wYXRoPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICA8L2c+CiAgICAgICAgPC9nPgogICAgPC9nPgo8L3N2Zz4=\"","import App from './Cursor.svelte';\nimport pRetry from 'p-retry';\nimport { ApplianceMap } from './icons';\nimport { ApplianceNames, autorun } from 'white-web-sdk';\nimport { CursorState } from '../constants';\nimport { Fields } from '../AttributesDelegate';\nimport { get, omit } from 'lodash';\nimport type { Position } from '../AttributesDelegate';\nimport type { RoomMember } from \"white-web-sdk\";\nimport type { CursorManager } from \"./index\";\nimport type { SvelteComponent } from \"svelte\";\nimport { Base } from '../Base';\nimport type { AppManager } from '../AppManager';\n\nexport type Payload = {\n    [key: string]: any\n}\n\n\nexport class Cursor extends Base {\n    private member?: RoomMember;\n    private disposer: any;\n    private timer?: number;\n    private component?: SvelteComponent;\n\n    constructor(\n        manager: AppManager,\n        private cursors: any,\n        private memberId: string,\n        private cursorManager: CursorManager,\n        private wrapper?: HTMLElement\n    ) {\n        super(manager);\n        this.setMember();\n        this.createCursor();\n        pRetry(() => {\n            this.disposer && this.disposer();\n            if (!this.cursorPosition) {\n                console.warn(`${memberId} not exist`);\n            }\n            this.startReaction();\n        }, { retries: 3 });\n        this.autoHidden();\n    }\n\n    private startReaction() {\n        this.disposer = autorun(() => {\n            const cursor = this.cursorPosition;\n            const state = this.cursorState;\n            if (!cursor) return;\n            if (cursor.type === \"main\") {\n                const rect = this.cursorManager.wrapperRect;\n                if (this.component && rect) {\n                    this.autoHidden();\n                    this.moveCursor(cursor, rect, this.manager.mainView);\n                }\n            } else {\n                const focusView = this.cursorManager.focusView;\n                const viewRect = focusView?.divElement?.getBoundingClientRect();\n                const viewCamera = focusView?.camera;\n                if (focusView && viewRect && viewCamera && this.component) {\n                    this.autoHidden();\n                    this.moveCursor(cursor, viewRect, focusView);\n                }\n            }\n            if (state && state === CursorState.Leave) {\n                this.hide();\n            }\n        });\n    }\n\n    private moveCursor(cursor: Position, rect: DOMRect, view: any) {\n        const { x, y } = cursor;\n        const point = view?.screen.convertPointToScreen(x, y);\n        if (point) {\n            const translateX = point.x + rect.x - 2;\n            const translateY = point.y + rect.y - 18;\n            if (point.x < 0 || point.x > rect.width || point.y < 0 || point.y > rect.height) {\n                this.component?.$set({ visible: false });\n            } else {\n                this.component?.$set({ visible: true, x: translateX, y: translateY });\n            }\n        }\n    }\n\n    public get memberApplianceName() {\n        return this.member?.memberState?.currentApplianceName;\n    }\n\n    public get memberColor() {\n        const rgb = this.member?.memberState?.strokeColor.join(\",\");\n        return `rgb(${rgb})`;\n    }\n\n    private get payload(): Payload | undefined {\n        return this.member?.payload;\n    }\n\n    public get memberCursorName() {\n        return this.payload?.nickName || this.payload?.cursorName || this.memberId;\n    }\n\n    private get memberTheme() {\n        if (this.payload?.theme) {\n            return \"netless-window-manager-cursor-inner-mellow\";\n        } else {\n            return \"netless-window-manager-cursor-inner\";\n        }\n    }\n\n    private get memberCursorTextColor() {\n        return this.payload?.cursorTextColor || \"#FFFFFF\";\n    }\n\n    private get memberCursorTagBackgroundColor() {\n        return this.payload?.cursorTagBackgroundColor || this.memberColor;\n    }\n\n    private get memberAvatar() {\n        return this.payload?.avatar;\n    }\n\n    private get memberOpacity() {\n        if (!this.memberCursorName && !this.memberAvatar) {\n            return 0;\n        } else {\n            return 1;\n        }\n    }\n\n    public get cursorState(): CursorState | undefined {\n        return get(this.cursors, [this.memberId, Fields.CursorState]);\n    }\n\n    public get cursorPosition(): Position | undefined {\n        return get(this.cursors, [this.memberId, Fields.Position]);\n    }\n\n    private autoHidden() {\n        if (this.timer) {\n            clearTimeout(this.timer);\n        }\n        this.timer = window.setTimeout(() => {\n            this.hide();\n            this.store.updateCursorState(this.memberId, CursorState.Leave);\n        }, 1000 * 10); // 10 秒钟自动隐藏\n    }\n\n    private async createCursor() {\n        if (this.member && this.wrapper) {\n            this.component = new App({\n                target: document.documentElement,\n                props: this.initProps(),\n            });\n        }\n    }\n\n    private initProps() {\n        return {\n            x: 0,\n            y: 0,\n            appliance: this.memberApplianceName,\n            avatar: this.memberAvatar,\n            src: this.getIcon(),\n            visible: false,\n            backgroundColor: this.memberColor,\n            cursorName: this.memberCursorName,\n            theme: this.memberTheme,\n            color: this.memberCursorTextColor,\n            cursorTagBackgroundColor: this.memberCursorTagBackgroundColor,\n            opacity: this.memberOpacity,\n        };\n    }\n\n    private getIcon() {\n        if (this.member) {\n            const applianceSrc = ApplianceMap[this.memberApplianceName || ApplianceNames.shape];\n            return applianceSrc || ApplianceMap[ApplianceNames.shape];\n        }\n    }\n\n    public setMember() {\n        this.member = this.context.findMemberByUid(this.memberId);\n        this.updateComponent();\n    }\n\n    private updateComponent() {\n        this.component?.$set(omit(this.initProps(), [\"x\", \"y\"]));\n    }\n\n    public destroy() {\n        this.disposer && this.disposer();\n        if (this.component) {\n            this.component.$destroy();\n        }\n        this.cursorManager.cursorInstances.delete(this.memberId);\n    }\n\n    public hide() {\n        if (this.component) {\n            this.component.$set({ visible: false });\n        }\n    }\n}\n","import { Base } from '../Base';\nimport { Cursor } from './Cursor';\nimport { CursorState } from '../constants';\nimport { compact, debounce, uniq } from 'lodash';\nimport { Fields } from '../AttributesDelegate';\nimport { onObjectInserted } from '../Utils/Reactive';\nimport { WindowManager } from '../index';\nimport type { PositionType } from \"../AttributesDelegate\";\nimport type { Point, RoomMember, View } from \"white-web-sdk\";\nimport type { AppManager } from \"../AppManager\";\n\nexport type EventType = {\n    type: PositionType;\n    id?: string;\n};\n\nexport type MoveCursorParams = {\n    uid: string;\n    x: number;\n    y: number;\n}\nexport class CursorManager extends Base {\n    public containerRect?: DOMRect;\n    public wrapperRect?: DOMRect;\n    public cursorInstances: Map<string, Cursor> = new Map();\n    public roomMembers?: readonly RoomMember[];\n    private mainViewElement?: HTMLDivElement;\n\n    constructor(private appManager: AppManager) {\n        super(appManager);\n        this.roomMembers = this.appManager.room?.state.roomMembers;\n        const wrapper = WindowManager.wrapper;\n        if (wrapper) {\n            wrapper.addEventListener(\"mousemove\", this.mouseMoveListener);\n            wrapper.addEventListener(\"touchstart\", this.touchMoveListener);\n            wrapper.addEventListener(\"touchmove\", this.touchMoveListener);\n            wrapper.addEventListener(\"mouseleave\", this.mouseLeaveListener);\n            wrapper.addEventListener(\"touchend\", this.mouseLeaveListener);\n            this.initCursorAttributes();\n            this.wrapperRect = wrapper.getBoundingClientRect();\n            this.startReaction(wrapper);\n        }\n    }\n\n    public setMainViewDivElement(div: HTMLDivElement) {\n        this.mainViewElement = div;\n    }\n\n    private startReaction(wrapper: HTMLElement) {\n        this.manager.refresher?.add(\"cursors\", () => {\n            return onObjectInserted(this.cursors, () => {\n                this.handleRoomMembersChange(wrapper);\n            });\n        })\n    }\n\n    private getUids = (members: readonly RoomMember[] | undefined) => {\n        return compact(uniq(members?.map(member => member.payload?.uid)));\n    }\n\n    private handleRoomMembersChange = debounce((wrapper: HTMLElement) => {\n        const uids = this.getUids(this.roomMembers);\n        const cursors = Object.keys(this.cursors);\n        if (uids?.length) {\n            cursors.map(uid => {\n                if (\n                    uids.includes(uid) &&\n                    !this.cursorInstances.has(uid)\n                ) {\n                    if (uid === this.context.uid) {\n                        return;\n                    }\n                    const component = new Cursor(\n                        this.appManager,\n                        this.cursors,\n                        uid,\n                        this,\n                        wrapper\n                    );\n                    this.cursorInstances.set(uid, component);\n                }\n            })\n        }\n    }, 100);\n\n    public get cursors() {\n        return this.manager.attributes?.[Fields.Cursors];\n    }\n\n    public get boxState() {\n        return this.store.getBoxState();\n    }\n\n    public get focusView() {\n        return this.appManager.focusApp?.view;\n    }\n\n    private mouseMoveListener = debounce((event: MouseEvent) => {\n        this.updateCursor(this.getType(event), event.clientX, event.clientY);\n    }, 5);\n\n    private touchMoveListener = debounce((event: TouchEvent) => {\n        if (event.touches.length === 1) {\n            const touchEvent = event.touches[0];\n            this.updateCursor(this.getType(touchEvent), touchEvent.clientX, touchEvent.clientY);\n        }\n    }, 5);\n\n    private updateCursor(event: EventType, clientX: number, clientY: number) {\n        if (this.wrapperRect && this.manager.canOperate) {\n            const view = event.type === \"main\" ? this.appManager.mainView : this.focusView;\n            const point = this.getPoint(view, clientX, clientY);\n            if (point) {\n                this.setNormalCursorState();\n                this.store.updateCursor(this.context.uid, {\n                    x: point.x,\n                    y: point.y,\n                    ...event,\n                });\n            }\n        }\n    }\n\n    private getPoint = (view: View | undefined, clientX: number, clientY: number): Point | undefined => {\n        const rect = view?.divElement?.getBoundingClientRect();\n        if (rect) {\n            const point = view?.convertToPointInWorld({\n                x: clientX - rect.x,\n                y: clientY - rect.y,\n            });\n            return point;\n        }\n    }\n\n    /**\n     *  因为窗口内框在不同分辨率下的大小不一样，所以这里通过来鼠标事件的 target 来判断是在主白板还是在 APP 中\n     */\n    private getType = (event: MouseEvent | Touch): EventType => {\n        const target = event.target as HTMLElement;\n        const focusApp = this.appManager.focusApp;\n        switch (target.parentElement) {\n            case this.mainViewElement: {\n                return { type: \"main\" }; \n            }\n            case focusApp?.view?.divElement: {\n                return { type: \"app\" };\n            }\n            default: {\n                return { type: \"main\" };\n            }\n        }\n    };\n\n    private initCursorAttributes() {\n        this.store.updateCursor(this.context.uid, {\n            x: 0,\n            y: 0,\n            type: \"main\",\n        });\n        this.store.updateCursorState(this.context.uid, CursorState.Leave);\n    }\n\n    private setNormalCursorState() {\n        const cursorState = this.store.getCursorState(this.context.uid);\n        if (cursorState !== CursorState.Normal) {\n            this.store.updateCursorState(this.context.uid, CursorState.Normal);\n        }\n    }\n\n    private mouseLeaveListener = () => {\n        this.hideCursor(this.context.uid);\n        this.store.updateCursorState(this.context.uid, CursorState.Leave);\n    };\n\n    public updateContainerRect() {\n        this.containerRect = WindowManager.container?.getBoundingClientRect();\n        this.wrapperRect = WindowManager.wrapper?.getBoundingClientRect();\n    }\n\n    public setRoomMembers(members: readonly RoomMember[]) {\n        this.roomMembers = members;\n        this.cursorInstances.forEach(cursor => {\n            cursor.setMember();\n        });\n        if (WindowManager.wrapper) {\n            this.handleRoomMembersChange(WindowManager.wrapper);\n        }\n    }\n\n    public deleteCursor(uid: string) {\n        this.store.cleanCursor(uid);\n        const cursor = this.cursorInstances.get(uid);\n        if (cursor) {\n            cursor.destroy();\n        }\n    }\n\n    public hideCursor(uid: string) {\n        const cursor = this.cursorInstances.get(uid);\n        if (cursor) {\n            cursor.hide();\n        }\n    }\n\n    public cleanMemberAttributes(members: readonly RoomMember[]) {\n        const uids = this.getUids(members);\n        const needDeleteIds: string[] = [];\n        const cursors = Object.keys(this.cursors);\n        cursors.map(cursorId => {\n            const index = uids.findIndex(id => id === cursorId);\n            if (index === -1) {\n                needDeleteIds.push(cursorId);\n            }\n        });\n        needDeleteIds.forEach(uid => {\n            this.deleteCursor(uid);\n        });\n    }\n\n    public destroy() {\n        const wrapper = WindowManager.wrapper;\n        if (wrapper) {\n            wrapper.removeEventListener(\"mousemove\", this.mouseMoveListener);\n            wrapper.removeEventListener(\"touchstart\", this.touchMoveListener);\n            wrapper.removeEventListener(\"touchmove\", this.touchMoveListener);\n            wrapper.removeEventListener(\"mouseleave\", this.mouseLeaveListener);\n            wrapper.removeEventListener(\"touchend\", this.mouseLeaveListener);\n        }\n        if (this.cursorInstances.size) {\n            this.cursorInstances.forEach(cursor => cursor.destroy());\n            this.cursorInstances.clear();\n        }\n        this.manager.refresher?.remove(\"cursors\");\n    }\n}\n","import AppDocsViewer from \"@netless/app-docs-viewer\";\nimport AppMediaPlayer, { setOptions } from \"@netless/app-media-player\";\nimport Emittery from \"emittery\";\nimport pRetry from \"p-retry\";\nimport { AppManager } from \"./AppManager\";\nimport { appRegister } from \"./Register\";\nimport { CursorManager } from \"./Cursor\";\nimport { DEFAULT_CONTAINER_RATIO, REQUIRE_VERSION } from \"./constants\";\nimport { Fields } from \"./AttributesDelegate\";\nimport { initDb } from \"./Register/storage\";\nimport { isNull, isObject } from \"lodash\";\nimport { log } from \"./Utils/log\";\nimport { replaceRoomFunction } from \"./Utils/RoomHacker\";\nimport { ResizeObserver as ResizeObserverPolyfill } from \"@juggle/resize-observer\";\nimport { setupWrapper } from \"./ViewManager\";\nimport \"./style.css\";\nimport \"@netless/telebox-insider/dist/style.css\";\nimport {\n    addEmitterOnceListener,\n    ensureValidScenePath,\n    getVersionNumber,\n    isValidScenePath,\n    wait,\n} from \"./Utils/Common\";\nimport type { TELE_BOX_STATE } from \"./BoxManager\";\nimport {\n    AppCreateError,\n    AppManagerNotInitError,\n    InvalidScenePath,\n    ParamsInvalidError,\n    WhiteWebSDKInvalidError,\n} from \"./Utils/error\";\nimport type { Apps } from \"./AttributesDelegate\";\nimport {\n    InvisiblePlugin,\n    isPlayer,\n    isRoom,\n    RoomPhase,\n    ViewMode,\n    WhiteVersion,\n} from \"white-web-sdk\";\nimport type {\n    Displayer,\n    SceneDefinition,\n    View,\n    Room,\n    InvisiblePluginContext,\n    Camera,\n    AnimationMode,\n    CameraBound,\n    Point,\n    Rectangle,\n    ViewVisionMode,\n    CameraState,\n} from \"white-web-sdk\";\nimport type { AppListeners } from \"./AppListener\";\nimport type { NetlessApp, RegisterParams } from \"./typings\";\nimport type { TeleBoxColorScheme, TeleBoxState } from \"@netless/telebox-insider\";\nimport type { AppProxy } from \"./AppProxy\";\n\nconst ResizeObserver = window.ResizeObserver || ResizeObserverPolyfill;\n\nexport type WindowMangerAttributes = {\n    modelValue?: string;\n    boxState: TELE_BOX_STATE;\n    maximized?: boolean;\n    minimized?: boolean;\n    [key: string]: any;\n};\n\nexport type apps = {\n    [key: string]: NetlessApp;\n};\n\nexport type AddAppOptions = {\n    scenePath?: string;\n    title?: string;\n    scenes?: SceneDefinition[];\n};\n\nexport type setAppOptions = AddAppOptions & { appOptions?: any };\n\nexport type AddAppParams = {\n    kind: string;\n    // app 地址(本地 app 不需要传)\n    src?: string;\n    // 窗口配置\n    options?: AddAppOptions;\n    // 初始化 attributes\n    attributes?: any;\n};\n\nexport type BaseInsertParams = {\n    kind: string;\n    // app 地址(本地 app 不需要传)\n    src?: string;\n    // 窗口配置\n    options?: AddAppOptions;\n    // 初始化 attributes\n    attributes?: any;\n    isDynamicPPT?: boolean;\n};\n\nexport type AppSyncAttributes = {\n    kind: string;\n    src?: string;\n    options: any;\n    state?: any;\n    isDynamicPPT?: boolean;\n    fullPath?: string;\n};\n\nexport type AppInitState = {\n    id: string;\n    x?: number;\n    y?: number;\n    width?: number;\n    height?: number;\n    focus?: boolean;\n    maximized?: boolean;\n    minimized?: boolean;\n    sceneIndex?: number;\n    boxState?: TeleBoxState; // 兼容旧版 telebox\n};\n\nexport type EmitterEvent = {\n    onCreated: undefined;\n    InitReplay: AppInitState;\n    move: { appId: string; x: number; y: number };\n    focus: { appId: string };\n    close: { appId: string };\n    resize: { appId: string; width: number; height: number; x?: number; y?: number };\n    error: Error;\n    seek: number;\n    mainViewMounted: undefined;\n    observerIdChange: number;\n    boxStateChange: string;\n    playgroundSizeChange: DOMRect;\n};\n\nexport const emitter: Emittery<EmitterEvent> = new Emittery();\n\nexport type PublicEvent = {\n    mainViewModeChange: ViewVisionMode;\n    boxStateChange: `${TELE_BOX_STATE}`;\n    darkModeChange: boolean;\n    prefersColorSchemeChange: TeleBoxColorScheme;\n    cameraStateChange: CameraState;\n};\n\nexport type MountParams = {\n    room: Room;\n    container: HTMLElement;\n    /** 白板高宽比例, 默认为 9 / 16 */\n    containerSizeRatio?: number;\n    /** 显示 PS 透明背景，默认 true */\n    chessboard?: boolean;\n    collectorContainer?: HTMLElement;\n    collectorStyles?: Partial<CSSStyleDeclaration>;\n    overwriteStyles?: string;\n    cursor?: boolean;\n    debug?: boolean;\n    disableCameraTransform?: boolean;\n    prefersColorScheme?: TeleBoxColorScheme;\n};\n\nexport const callbacks: Emittery<PublicEvent> = new Emittery();\n\nexport class WindowManager extends InvisiblePlugin<WindowMangerAttributes> {\n    public static kind = \"WindowManager\";\n    public static displayer: Displayer;\n    public static wrapper?: HTMLElement;\n    public static playground?: HTMLElement;\n    public static container?: HTMLElement;\n    public static debug = false;\n    public static containerSizeRatio = DEFAULT_CONTAINER_RATIO;\n    private static isCreated = false;\n\n    public version = \"0.3.16\";\n\n    public appListeners?: AppListeners;\n\n    public readonly?: boolean;\n    public emitter: Emittery<PublicEvent> = callbacks;\n    public appManager?: AppManager;\n    public cursorManager?: CursorManager;\n    public viewMode = ViewMode.Broadcaster;\n    public isReplay = isPlayer(this.displayer);\n\n    constructor(context: InvisiblePluginContext) {\n        super(context);\n    }\n\n    /**\n     * 挂载 WindowManager\n     * @deprecated\n     */\n    public static async mount(\n        room: Room,\n        container: HTMLElement,\n        collectorContainer?: HTMLElement,\n        options?: {\n            chessboard: boolean;\n            containerSizeRatio: number;\n            collectorStyles?: Partial<CSSStyleDeclaration>;\n            debug?: boolean;\n            overwriteStyles?: string;\n        }\n    ): Promise<WindowManager>;\n\n    public static async mount(params: MountParams): Promise<WindowManager>;\n\n    public static async mount(\n        params: MountParams | Room,\n        container?: HTMLElement,\n        collectorContainer?: HTMLElement,\n        options?: {\n            chessboard?: boolean;\n            containerSizeRatio: number;\n            collectorStyles?: Partial<CSSStyleDeclaration>;\n            debug?: boolean;\n            overwriteStyles?: string;\n            disableCameraTransform?: boolean;\n        }\n    ): Promise<WindowManager> {\n        let room: Room;\n        let containerSizeRatio: number | undefined;\n        let collectorStyles: Partial<CSSStyleDeclaration> | undefined;\n        let debug: boolean | undefined;\n        let chessboard = true;\n        let overwriteStyles: string | undefined;\n        let cursor: boolean | undefined;\n        let disableCameraTransform = false;\n        let prefersColorScheme: TeleBoxColorScheme | undefined = \"light\";\n        if (\"room\" in params) {\n            room = params.room;\n            container = params.container;\n            collectorContainer = params.collectorContainer;\n            containerSizeRatio = params.containerSizeRatio;\n            collectorStyles = params.collectorStyles;\n            debug = params.debug;\n            if (params.chessboard != null) {\n                chessboard = params.chessboard;\n            }\n            overwriteStyles = params.overwriteStyles;\n            cursor = params.cursor;\n            disableCameraTransform = Boolean(params?.disableCameraTransform);\n            prefersColorScheme = params.prefersColorScheme;\n        } else {\n            room = params;\n            containerSizeRatio = options?.containerSizeRatio;\n            collectorStyles = options?.collectorStyles;\n            debug = options?.debug;\n            if (options?.chessboard != null) {\n                chessboard = options.chessboard;\n            }\n            overwriteStyles = options?.overwriteStyles;\n        }\n\n        this.checkVersion();\n        if (isRoom(room)) {\n            if (room.phase !== RoomPhase.Connected) {\n                throw new Error(\"[WindowManager]: Room only Connected can be mount\");\n            }\n        }\n        if (!container) {\n            throw new Error(\"[WindowManager]: Container must provide\");\n        }\n        if (WindowManager.isCreated) {\n            throw new Error(\"[WindowManager]: Already created cannot be created again\");\n        }\n        let manager = await this.initManager(room);\n        this.debug = Boolean(debug);\n        if (this.debug) {\n            setOptions({ verbose: true });\n        }\n        log(\"Already insert room\", manager);\n\n        if (isRoom(this.displayer)) {\n            if (!manager) {\n                throw new Error(\"[WindowManager]: init InvisiblePlugin failed\");\n            }\n        } else {\n            await pRetry(\n                async count => {\n                    manager = await this.initManager(room);\n                    if (!manager) {\n                        log(`manager is empty. retrying ${count}`);\n                        throw new Error();\n                    }\n                },\n                { retries: 10 }\n            );\n        }\n\n        if (containerSizeRatio) {\n            WindowManager.containerSizeRatio = containerSizeRatio;\n        }\n        WindowManager.container = container;\n        const { playground, wrapper, sizer, mainViewElement } = setupWrapper(container);\n        WindowManager.playground = playground;\n        if (chessboard) {\n            sizer.classList.add(\"netless-window-manager-chess-sizer\");\n        }\n        if (overwriteStyles) {\n            const style = document.createElement(\"style\");\n            style.textContent = overwriteStyles;\n            playground.appendChild(style);\n        }\n        await manager.ensureAttributes();\n        manager.appManager = new AppManager(manager, {\n            collectorContainer: collectorContainer,\n            collectorStyles: collectorStyles,\n            prefersColorScheme: prefersColorScheme,\n        });\n        manager.observePlaygroundSize(playground, sizer, wrapper);\n        if (cursor) {\n            manager.cursorManager = new CursorManager(manager.appManager);\n        }\n        manager.bindMainView(mainViewElement, disableCameraTransform);\n        replaceRoomFunction(room, manager.appManager);\n        emitter.emit(\"onCreated\");\n        WindowManager.isCreated = true;\n        try {\n            await initDb();\n        } catch (error) {\n            console.warn(\"[WindowManager]: indexedDB open failed\");\n            console.log(error);\n        }\n        return manager;\n    }\n\n    private static async initManager(room: Room): Promise<WindowManager> {\n        let manager = room.getInvisiblePlugin(WindowManager.kind) as WindowManager;\n        if (!manager) {\n            if (isRoom(room)) {\n                if (room.isWritable === false) {\n                    try {\n                        await room.setWritable(true);\n                    } catch (error) {\n                        throw new Error(\"[WindowManger]: room must be switched to be writable\");\n                    }\n                    manager = (await room.createInvisiblePlugin(\n                        WindowManager,\n                        {}\n                    )) as WindowManager;\n                    manager.ensureAttributes();\n                    await wait(500);\n                    await room.setWritable(false);\n                } else {\n                    manager = (await room.createInvisiblePlugin(\n                        WindowManager,\n                        {}\n                    )) as WindowManager;\n                }\n            }\n        }\n        return manager;\n    }\n\n    /**\n     * 注册插件\n     */\n    public static register<AppOptions = any, SetupResult = any, Attributes = any>(\n        params: RegisterParams<AppOptions, SetupResult, Attributes>\n    ): Promise<void> {\n        return appRegister.register(params);\n    }\n\n    /**\n     * 创建一个 app 至白板\n     */\n    public async addApp(params: AddAppParams): Promise<string | undefined> {\n        if (this.appManager) {\n            if (!params.kind || typeof params.kind !== \"string\") {\n                throw new ParamsInvalidError();\n            }\n            const appImpl = await appRegister.appClasses.get(params.kind)?.();\n            if (appImpl && appImpl.config?.singleton) {\n                if (this.appManager.appProxies.has(params.kind)) {\n                    throw new AppCreateError();\n                }\n            }\n            const isDynamicPPT = this.setupScenePath(params, this.appManager);\n            if (isDynamicPPT === undefined) {\n                return;\n            }\n            if (params?.options?.scenePath) {\n                params.options.scenePath = ensureValidScenePath(params.options.scenePath);\n            }\n            const appId = await this.appManager.addApp(params, Boolean(isDynamicPPT));\n            return appId;\n        } else {\n            throw new AppManagerNotInitError();\n        }\n    }\n\n    private setupScenePath(params: AddAppParams, appManager: AppManager): boolean | undefined {\n        let isDynamicPPT = false;\n        if (params.options) {\n            const { scenePath, scenes } = params.options;\n            if (scenePath) {\n                if (!isValidScenePath(scenePath)) {\n                    throw new InvalidScenePath();\n                }\n                const apps = Object.keys(this.apps || {});\n                for (const appId of apps) {\n                    const appScenePath = appManager.store.getAppScenePath(appId);\n                    if (appScenePath && appScenePath === scenePath) {\n                        console.warn(`[WindowManager]: ScenePath ${scenePath} Already opened`);\n                        return;\n                    }\n                }\n            }\n            if (scenePath && scenes && scenes.length > 0) {\n                if (this.isDynamicPPT(scenes)) {\n                    isDynamicPPT = true;\n                    if (!this.displayer.entireScenes()[scenePath]) {\n                        this.room?.putScenes(scenePath, scenes);\n                    }\n                } else {\n                    if (!this.displayer.entireScenes()[scenePath]) {\n                        this.room?.putScenes(scenePath, [{ name: scenes[0].name }]);\n                    }\n                }\n            }\n            if (scenePath && scenes === undefined) {\n                this.room?.putScenes(scenePath, [{}]);\n            }\n        }\n        return isDynamicPPT;\n    }\n\n    /**\n     * 设置 mainView 的 ScenePath, 并且切换白板为可写状态\n     */\n    public async setMainViewScenePath(scenePath: string): Promise<void> {\n        if (this.appManager) {\n            await this.appManager.setMainViewScenePath(scenePath);\n        }\n    }\n\n    /**\n     * 设置 mainView 的 SceneIndex, 并且切换白板为可写状态\n     */\n    public async setMainViewSceneIndex(index: number): Promise<void> {\n        if (this.appManager) {\n            await this.appManager.setMainViewSceneIndex(index);\n        }\n    }\n\n    /**\n     * 返回 mainView 的 ScenePath\n     */\n    public getMainViewScenePath(): string {\n        return this.appManager?.store.getMainViewScenePath();\n    }\n\n    /**\n     * 返回 mainView 的 SceneIndex\n     */\n    public getMainViewSceneIndex(): number {\n        return this.appManager?.store.getMainViewSceneIndex();\n    }\n\n    /**\n     * 设置所有 app 的 readonly 模式\n     */\n    public setReadonly(readonly: boolean): void {\n        if (this.room?.isWritable) {\n            this.readonly = readonly;\n            this.appManager?.boxManager.setReadonly(readonly);\n        }\n    }\n\n    /**\n     * 切换 mainView 为可写\n     */\n    public switchMainViewToWriter(): Promise<void> | undefined {\n        return this.appManager?.mainViewProxy.mainViewClickHandler();\n    }\n\n    /**\n     * app destroy 回调\n     */\n    public onAppDestroy(kind: string, listener: (error: Error) => void): void {\n        addEmitterOnceListener(`destroy-${kind}`, listener);\n    }\n\n    /**\n     * 设置 ViewMode\n     */\n    public setViewMode(mode: ViewMode): void {\n        if (!this.canOperate) return;\n        if (mode === ViewMode.Broadcaster) {\n            this.appManager?.mainViewProxy.setCameraAndSize();\n            this.appManager?.mainViewProxy.start();\n        }\n        if (mode === ViewMode.Freedom) {\n            this.appManager?.mainViewProxy.stop();\n        }\n        this.viewMode = mode;\n    }\n\n    public get mainView(): View {\n        if (this.appManager) {\n            return this.appManager.mainViewProxy.view;\n        } else {\n            throw new AppManagerNotInitError();\n        }\n    }\n\n    public get camera(): Camera {\n        if (this.appManager) {\n            return this.appManager.mainViewProxy.view.camera;\n        } else {\n            throw new AppManagerNotInitError();\n        }\n    }\n\n    public get cameraState(): CameraState {\n        if (this.appManager) {\n            return this.appManager.mainViewProxy.cameraState;\n        } else {\n            throw new AppManagerNotInitError();\n        }\n    }\n\n    public get apps(): Apps | undefined {\n        return this.appManager?.store.apps();\n    }\n\n    public get boxState(): TeleBoxState {\n        if (this.appManager) {\n            return this.appManager.boxManager.boxState;\n        } else {\n            throw new AppManagerNotInitError();\n        }\n    }\n\n    public get darkMode(): boolean {\n        return Boolean(this.appManager?.boxManager.darkMode);\n    }\n\n    public get prefersColorScheme(): TeleBoxColorScheme {\n        if (this.appManager) {\n            return this.appManager.boxManager.prefersColorScheme;\n        } else {\n            throw new AppManagerNotInitError();\n        }\n    }\n\n    /**\n     * 查询所有的 App\n     */\n    public queryAll(): AppProxy[] {\n        return Array.from(this.appManager?.appProxies.values() || []);\n    }\n\n    /**\n     * 查询单个 App\n     */\n    public queryOne(appId: string): AppProxy | undefined {\n        return this.appManager?.appProxies.get(appId);\n    }\n\n    /**\n     * 关闭 APP\n     */\n    public async closeApp(appId: string): Promise<void> {\n        return this.appManager?.closeApp(appId);\n    }\n\n    public moveCamera(\n        camera: Partial<Camera> & { animationMode?: AnimationMode | undefined }\n    ): void {\n        this.mainView.moveCamera(camera);\n    }\n\n    public moveCameraToContain(\n        rectangle: Rectangle &\n            Readonly<{\n                animationMode?: AnimationMode;\n            }>\n    ): void {\n        this.mainView.moveCameraToContain(rectangle);\n    }\n\n    public convertToPointInWorld(point: Point): Point {\n        return this.mainView.convertToPointInWorld(point);\n    }\n\n    public setCameraBound(cameraBound: CameraBound): void {\n        this.mainView.setCameraBound(cameraBound);\n    }\n\n    public override onDestroy(): void {\n        this._destroy();\n    }\n\n    public override destroy(): void {\n        this._destroy();\n    }\n\n    private _destroy() {\n        this.containerResizeObserver?.disconnect();\n        this.appManager?.destroy();\n        this.cursorManager?.destroy();\n        WindowManager.container = undefined;\n        WindowManager.wrapper = undefined;\n        WindowManager.isCreated = false;\n        if (WindowManager.playground) {\n            WindowManager.playground.parentNode?.removeChild(WindowManager.playground);\n        }\n        log(\"Destroyed\");\n    }\n\n    private bindMainView(divElement: HTMLDivElement, disableCameraTransform: boolean) {\n        if (this.appManager) {\n            this.appManager.bindMainView(divElement, disableCameraTransform);\n            this.cursorManager?.setMainViewDivElement(divElement);\n        }\n    }\n\n    public get canOperate(): boolean {\n        if (isRoom(this.displayer)) {\n            return (\n                (this.displayer as Room).isWritable &&\n                (this.displayer as Room).phase === RoomPhase.Connected\n            );\n        } else {\n            return false;\n        }\n    }\n\n    public get room(): Room {\n        return this.displayer as Room;\n    }\n\n    public safeSetAttributes(attributes: any): void {\n        if (this.canOperate) {\n            this.setAttributes(attributes);\n        }\n    }\n\n    public safeUpdateAttributes(keys: string[], value: any): void {\n        if (this.canOperate) {\n            this.updateAttributes(keys, value);\n        }\n    }\n\n    public setPrefersColorScheme(scheme: TeleBoxColorScheme): void {\n        this.appManager?.boxManager.setPrefersColorScheme(scheme);\n    }\n\n    private isDynamicPPT(scenes: SceneDefinition[]) {\n        const sceneSrc = scenes[0]?.ppt?.src;\n        return sceneSrc?.startsWith(\"pptx://\");\n    }\n\n    private static checkVersion() {\n        const version = getVersionNumber(WhiteVersion);\n        if (version < getVersionNumber(REQUIRE_VERSION)) {\n            throw new WhiteWebSDKInvalidError(REQUIRE_VERSION);\n        }\n    }\n\n    private async ensureAttributes() {\n        if (isNull(this.attributes)) {\n            await wait(50);\n        }\n        if (isObject(this.attributes)) {\n            if (!this.attributes[Fields.Apps]) {\n                this.safeSetAttributes({ [Fields.Apps]: {} });\n            }\n            if (!this.attributes[Fields.Cursors]) {\n                this.safeSetAttributes({ [Fields.Cursors]: {} });\n            }\n            const sceneState = this.displayer.state.sceneState;\n            if (!this.attributes[\"_mainScenePath\"]) {\n                this.safeSetAttributes({ _mainScenePath: sceneState.scenePath });\n            }\n            if (!this.attributes[\"_mainSceneIndex\"]) {\n                this.safeSetAttributes({ _mainSceneIndex: sceneState.index });\n            }\n        }\n    }\n\n    private containerResizeObserver?: ResizeObserver;\n\n    private observePlaygroundSize(\n        container: HTMLElement,\n        sizer: HTMLElement,\n        wrapper: HTMLDivElement\n    ) {\n        this.updateSizer(container.getBoundingClientRect(), sizer, wrapper);\n\n        this.containerResizeObserver = new ResizeObserver(entries => {\n            const containerRect = entries[0]?.contentRect;\n            if (containerRect) {\n                this.updateSizer(containerRect, sizer, wrapper);\n                this.cursorManager?.updateContainerRect();\n                this.appManager?.boxManager.updateManagerRect();\n                emitter.emit(\"playgroundSizeChange\", containerRect);\n            }\n        });\n\n        this.containerResizeObserver.observe(container);\n    }\n\n    private updateSizer(\n        { width, height }: DOMRectReadOnly,\n        sizer: HTMLElement,\n        wrapper: HTMLDivElement\n    ) {\n        if (width && height) {\n            if (height / width > WindowManager.containerSizeRatio) {\n                height = width * WindowManager.containerSizeRatio;\n                sizer.classList.toggle(\"netless-window-manager-sizer-horizontal\", true);\n            } else {\n                width = height / WindowManager.containerSizeRatio;\n                sizer.classList.toggle(\"netless-window-manager-sizer-horizontal\", false);\n            }\n            wrapper.style.width = `${width}px`;\n            wrapper.style.height = `${height}px`;\n        }\n    }\n}\n\nWindowManager.register({\n    kind: AppDocsViewer.kind,\n    src: AppDocsViewer,\n});\nWindowManager.register({\n    kind: AppMediaPlayer.kind,\n    src: AppMediaPlayer,\n});\n\nexport const BuiltinApps = {\n    DocsViewer: AppDocsViewer.kind as string,\n    MediaPlayer: AppMediaPlayer.kind as string,\n};\n\nexport * from \"./typings\";\n\nexport { WhiteWindowSDK } from \"./sdk\";\n","import { emitter } from '../index';\nimport { isPlayer } from 'white-web-sdk';\nimport type { Camera, Room , Player , PlayerSeekingResult } from \"white-web-sdk\";\nimport type { AppManager } from \"../AppManager\";\n\n// 修改多窗口状态下一些失效的方法实现到 manager 的 mainview 上, 降低迁移成本\nexport const replaceRoomFunction = (room: Room, manager: AppManager) => {\n    if (isPlayer(room)) {\n        const player = room as unknown as Player;\n        const originSeek = player.seekToProgressTime;\n        // eslint-disable-next-line no-inner-declarations\n        async function newSeek(time: number): Promise<PlayerSeekingResult> {\n            const seekResult = await originSeek.call(player, time);\n            if (seekResult === \"success\") {\n                emitter.emit(\"seek\", time);\n            }\n            return seekResult;\n        }\n        player.seekToProgressTime = newSeek;\n    } else {\n        const descriptor = Object.getOwnPropertyDescriptor(room, \"disableCameraTransform\");\n        if (descriptor) return;\n        Object.defineProperty(room, \"disableCameraTransform\", {\n            get() {\n                return manager.mainView.disableCameraTransform;\n            },\n            set(disable: boolean) {\n                manager.mainView.disableCameraTransform = disable;\n            },\n        });\n\n        room.moveCamera = (camera: Camera) => manager.mainView.moveCamera(camera);\n        room.moveCameraToContain = (...args) => manager.mainView.moveCameraToContain(...args);\n        room.convertToPointInWorld = (...args) => manager.mainView.convertToPointInWorld(...args);\n        room.setCameraBound = (...args) => manager.mainView.setCameraBound(...args);\n        room.scenePreview = (...args) => manager.mainView.scenePreview(...args);\n        room.fillSceneSnapshot = (...args) => manager.mainView.fillSceneSnapshot(...args);\n        room.generateScreenshot = (...args) => manager.mainView.generateScreenshot(...args);\n    }\n\n};","import { isBoolean } from 'lodash';\nimport { WhiteWebSdk } from 'white-web-sdk';\nimport { WindowManager } from './index';\nimport type { MountParams } from \"./index\";\nimport type { WhiteWebSdkConfiguration, JoinRoomParams } from \"white-web-sdk\";\n\n\n\ntype WhiteWindowSDKConfiguration = Omit<WhiteWebSdkConfiguration, \"useMobXState\">\ntype WindowJoinRoomParams = {\n    joinRoomParams: Omit<JoinRoomParams, \"useMultiViews\" | \"disableMagixEventDispatchLimit\">,\n    mountParams: Omit<MountParams, \"room\">,\n}\n\nexport class WhiteWindowSDK {\n    private sdk: WhiteWebSdk;\n\n    constructor(params: WhiteWindowSDKConfiguration) {\n        this.sdk = new WhiteWebSdk({ ...params, useMobXState: true });\n    }\n\n    public async mount(params: WindowJoinRoomParams): Promise<WindowManager> {\n        const invisiblePlugins = params.joinRoomParams.invisiblePlugins || [];\n        const room = await this.sdk.joinRoom({\n            ...params.joinRoomParams,\n            useMultiViews: true,\n            invisiblePlugins: [...invisiblePlugins, WindowManager],\n            disableMagixEventDispatchLimit: true,\n        });\n        const manager = await WindowManager.mount({\n            room,\n            ...params.mountParams\n        });\n        if (isBoolean(params.joinRoomParams.disableCameraTransform)) {\n            manager.mainView.disableCameraTransform = params.joinRoomParams.disableCameraTransform;\n        }\n        return manager;\n    }\n}\n"],"names":["Events","Events2","MagixEventName","AppAttributes","AppAttributes2","AppEvents","AppEvents2","AppStatus","CursorState","CursorState2","REQUIRE_VERSION","MIN_WIDTH","MIN_HEIGHT","DEFAULT_COLLECTOR_STYLE","right","bottom","position","DatabaseName","db","store","initDb","async","Promise","resolve","reject","request","indexedDB","open","onerror","e","onupgradeneeded","event","db2","target","result","objectStoreNames","contains","createObjectStore","keyPath","createIndex","unique","onsuccess","setItem","key","val","payload","kind","sourceCode","transaction","objectStore","add","getItem","index","get","getScript","url","item","resource","options","timeout","controller","AbortController","id","setTimeout","abort","response","fetch","__spreadProps","signal","headers","fetchWithTimeout","text2","text","executeScript","appName","Function","window","appRegister","constructor","Map","params","registered","set","srcOrAppOrFunction","src","downloadApp","appClass","name","error","message","includes","define2","define","amd","loadApp","Error","appClasses","app","this","appClassesCache","addHooks","emitter2","createKindEmitter","kindEmitters","emit","has","Emittery","setViewFocusScenePath","view","focusScenePath","setScenePath","room","scenePath","isWritable","state","sceneState","setViewMode","mode","didRelease","notifyMainViewModeChange","debounce","callbacks2","getVersionNumber","version","versionString","split","map","s","padStart","join","parseInt","wait","time","manager","displayer","boxManager","authorId","observerId","data","eventName","AppMove","appMoveHandler","AppResize","appResizeHandler","SwitchViewsToFreedom","switchViewsToFreedomHandler","AppBoxStateChange","boxStateChangeHandler","SetMainViewScenePath","setMainViewScenePathHandler","moveBox","resizeBox","Object","assign","skipUpdate","refreshViewSize","viewManager","freedomAllViews","nextScenePath","mainView","addListeners","addMagixEventListener","mainMagixEventListener","removeListeners","removeMagixEventListener","appId","appProxy","appOptions","autorun","reaction","toJS","listenUpdated","unlistenUpdated","listenDisposed","unlistenDisposed","isReplay","emitter","appEmitter","isAddApp","getDisplayer","getAttributes","attributes","getScenes","appAttr","getAppAttributes","isDynamicPPT","appProxies","scenes","getView","getInitScenePath","getAppInitPath","getIsWritable","canOperate","getBox","box","BoxNotCreatedError","getRoom","setAttributes","safeSetAttributes","updateAttributes","keys","value","safeUpdateAttributes","setFullPath","context","switchAppToWriter","mountView","dom","divElement","getAppOptions","Fields","Fields2","apps","Apps","Focus","getAppState","State","getMaximized","setupAppAttributes","attrNames","push","pick","attrs","Size","Position","SnapshotRect","SceneIndex","updateAppState","stateName","cleanAppAttributes","cleanFocus","getAppSceneIndex","getAppScenePath","getMainViewScenePath","getMainViewSceneIndex","getBoxState","BoxState","setMainViewScenePath","_mainScenePath","setMainViewSceneIndex","_mainSceneIndex","getMainViewCamera","MainViewCamera","getMainViewSize","MainViewSize","setMainViewCamera","camera","__spreadValues","setMainViewSize","size","setAppFocus","focus","updateCursor","uid","Cursors","updateCursorState","cursorState","getCursorState","cleanCursor","setMainViewFocusPath","log","args","WindowManager","debug","memberId","roomMembers","find","member","on","updateManagerRect","blurFocusBox","AttributesDelegate","Context","createContext","Base","cameraStore","sceneIndex","maximized","minimized","x","y","width","height","appId2","refresher","appListener","makeAppEventListener","initScenes","createView","appAttributes","entireScenes","readonly","getFullScenePath","FullPath","path","appImpl","appParams","setupApp","focusApp","focusBox","context2","AppContext","once","WindowCreated","then","boxInitState","getAppInitState","updateBoxState","onAny","appAttributesUpdateListener","setup","notifyApp","afterSetupApp","fixMobileSize","createBox","intrinsicWidth","intrinsicHeight","setBoxInitState","onSeek","currentAppState","destroy","AppProxy","baseInsertApp","switchToWritable","switchView","ViewVisionMode","Writable","callbacks","Freedom","emitAppSceneStateChange","emitAppIsWritableChange","setBoxMinSize","minWidth","minwidth","minHeight","minheight","setBoxTitle","title","status","fullScenePath","fullPath","register","needCloseBox","cleanAttrs","clearListeners","closeBox","delete","unregister","destroyView","appStatus","remove","close","createTeleBoxManagerConfig","teleBoxManager","setupBoxManager","events","TELE_BOX_MANAGER_EVENT","forEach","intrinsicX","intrinsicY","update","darkMode","colorScheme","prefersColorScheme","config","rect","containerRect","createBoxConfig","create","queryOne","TELE_BOX_STATE","Maximized","root","wrapper","document","body","getBoundingClientRect","initManagerState","fence","container","collectorContainer","styles","collectorStyles","teleBoxCollector","TeleBoxCollector","mount","collector","TeleBoxManager","boxIsFocus","getFocusBox","query","getTopBox","boxes","maxBy","setMaximized","Boolean","setMinimized","setContainerRect","notifyContainerRectUpdate","blurAllBox","updateAll","focusBoxes","length","focusTopBox","setReadonly","setPrefersColorScheme","getOrCreateListener","off","setCamera","cameras","getCamera","deleteCamera","recoverCamera","moveCamera","animationMode","AnimationMode","Immediately","onListener","offListener","listeners","callback","listener","mainViewProxy","switchMainViewToWriter","fireImmediately","views","releaseView","release","timer","mainViewScenePath","switchViewModeToWriter","appTimer","removeMainViewListener","parentNode","removeChild","setDefaultCameraBound","setCameraBound","maxContentMode","minContentMode","mainViewCamera","moveCameraToContian","mainViewSize","isEqual","mainViewClickHandler","cameraState","createMainView","moveCameraSizeByAttributes","viewId","start","setCameraAndSize","sizeChangeHandler","started","addCameraListener","cameraReaction","addMainViewListener","mainViewIsAddListener","addEventListener","mainViewClickListener","removeEventListener","onCameraUpdatedByDevice","onCameraOrSizeUpdated","removeCameraListener","isEmpty","moveCameraToContain","originX","originY","scale","centerX","centerY","needScale","stop","onObjectByEvent","object","func","onObjectRemoved","UpdateEventKind","Removed","onObjectInserted","Inserted","phase","RoomPhase","Connected","Reconnecting","onReconnected","releaseDisposers","reactors","isFunction","disposers","notifyReconnected","onPhaseChanged","disposer","clear","windowManger","ids","startsWith","cursorManager","setRoomMembers","cleanMemberAttributes","isReadonly","isManualWritable","disableCameraTransform","dispatchInternalEvent","CameraStore","MainViewProxy","ViewManager","BoxManager","appListeners","AppListeners","displayerStateListener","ReconnectRefresher","onCreated","isPlayer","attributesUpdateCallback","onAppDelete","boxEventListener","getProps","disposeListenUpdated","disposeReaction","props","safeListenPropsUpdated","mainScenePath","displayerWritableListener","StartCreate","focusByAttributes","retries","catch","warn","err","bindMainView","needFocus","beforeAddApp","afterAddApp","impl","singleton","v4","replace","slice","genAppId","isRoom","scenePathType","ScenePathType","None","Page","_setMainViewScenePath","Dir","validScenePath","firstSceneName","makeValidScenePath","setSceneIndex","safeDispatchMagixEvent","dispatchMagixEvent","appBoxMap","focusAppId","reconnected","Array","from","values","all","offAny","fn","fns","run","thing","a","b","src_url_equal_anchor","current_component","element_src","createElement","href","node","appendChild","anchor","insertBefore","createTextNode","attribute","removeAttribute","getAttribute","setAttribute","wholeText","important","style","setProperty","component","dirty_components","binding_callbacks","render_callbacks","flush_callbacks","resolved_promise","update_scheduled","flushing","seen_callbacks","Set","i","$$","pop","fragment","before_update","dirty","p","ctx","after_update","add_render_callback","outroing","flush","fill","instance2","create_fragment2","not_equal","append_styles","parent_component","noop","bound","blank_object","on_mount","on_destroy","on_disconnect","skip_bound","ready","ret","rest","hydrate","nodes","element2","childNodes","l","detach","c","intro","block","local","customElement","m","new_on_destroy","filter","is_function","cursorName","tagName","backgroundColor","appliance","visible","avatar","theme","color","cursorTagBackgroundColor","opacity","hasTagName","hasAvatar","display","entries","hasName","v","$destroy","detaching","d","$on","type","indexOf","splice","$set","$$props","obj","$$set","ApplianceMap","ApplianceNames","pencil","selector","eraser","shape","cursors","setMember","createCursor","cursorPosition","startReaction","autoHidden","cursor","wrapperRect","moveCursor","focusView","viewRect","viewCamera","Leave","hide","point","screen","convertPointToScreen","translateX","translateY","memberState","currentApplianceName","strokeColor","nickName","cursorTextColor","memberColor","memberCursorName","memberAvatar","App","documentElement","initProps","memberApplianceName","getIcon","memberTheme","memberCursorTextColor","memberCursorTagBackgroundColor","memberOpacity","findMemberByUid","updateComponent","omit","cursorInstances","appManager","members","compact","uniq","wrapper2","uids","getUids","Cursor","getType","clientX","clientY","touches","touchEvent","convertToPointInWorld","parentElement","mainViewElement","hideCursor","mouseMoveListener","touchMoveListener","mouseLeaveListener","initCursorAttributes","setMainViewDivElement","div","handleRoomMembersChange","getPoint","setNormalCursorState","Normal","updateContainerRect","deleteCursor","needDeleteIds","findIndex","cursorId","ResizeObserver","ResizeObserverPolyfill","InvisiblePlugin","ViewMode","Broadcaster","containerSizeRatio","overwriteStyles","chessboard","checkVersion","_WindowManager","isCreated","initManager","verbose","pRetry","count","playground","sizer","className","setupWrapper","classList","style2","textContent","ensureAttributes","AppManager","observePlaygroundSize","CursorManager","player","originSeek","seekToProgressTime","seekResult","call","newSeek","getOwnPropertyDescriptor","defineProperty","disable","scenePreview","fillSceneSnapshot","generateScreenshot","getInvisiblePlugin","setWritable","createInvisiblePlugin","ParamsInvalidError","AppCreateError","setupScenePath","endsWith","addApp","AppManagerNotInitError","isValidScenePath","InvalidScenePath","appScenePath","putScenes","onAppDestroy","viewMode","boxState","queryAll","closeApp","rectangle","cameraBound","onDestroy","_destroy","containerResizeObserver","disconnect","scheme","sceneSrc","ppt","WhiteVersion","WhiteWebSDKInvalidError","isNull","isObject","updateSizer","contentRect","observe","toggle","AppDocsViewer","AppMediaPlayer","BuiltinApps","DocsViewer","MediaPlayer","sdk","WhiteWebSdk","useMobXState","invisiblePlugins","joinRoomParams","joinRoom","useMultiViews","disableMagixEventDispatchLimit","mountParams","isBoolean"],"mappings":"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"}