var WhiteWebSdkVideoJsPlugin = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    __markAsModule(target);
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __reExport = (target, module, desc) => {
    if (module && typeof module === "object" || typeof module === "function") {
      for (let key of __getOwnPropNames(module))
        if (!__hasOwnProp.call(target, key) && key !== "default")
          __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
    }
    return target;
  };
  var __toModule = (module) => {
    return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
  };
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };

  // external-global:react
  var require_react = __commonJS({
    "external-global:react"(exports, module) {
      module.exports = React;
    }
  });

  // external-global:video.js
  var require_video = __commonJS({
    "external-global:video.js"(exports, module) {
      module.exports = videojs;
    }
  });

  // external-global:white-web-sdk
  var require_white_web_sdk = __commonJS({
    "external-global:white-web-sdk"(exports, module) {
      module.exports = WhiteWebSdk;
    }
  });

  // src/index.ts
  var src_exports = {};
  __export(src_exports, {
    PluginId: () => PluginId,
    Version: () => Version,
    videoJsPlugin: () => videoJsPlugin
  });

  // src/components/VideoJsPlugin.tsx
  var import_react4 = __toModule(require_react());
  var import_video = __toModule(require_video());
  var import_white_web_sdk = __toModule(require_white_web_sdk());

  // src/options.ts
  var defaultOptions = {
    currentTimeMaxError: 1,
    syncInterval: 500,
    retryInterval: 15e3
  };
  var options = defaultOptions;
  function setOptions(userDefined) {
    options = { ...defaultOptions, ...userDefined };
  }

  // package.json
  var version = "0.3.2";

  // src/constants.ts
  var Version = version;
  var PluginId = "video.js";

  // src/utils.ts
  function checkWhiteWebSdkVersion(room) {
    if (!room.calibrationTimestamp) {
      throw new Error(`@netless/video-js-plugin@${Version} requires white-web-sdk@^2.13.8 to work properly.`);
    }
  }
  function nextFrame() {
    return new Promise((r) => (window.requestAnimationFrame || window.setTimeout)(r));
  }
  function getCurrentTime(attributes, props) {
    if (attributes.paused) {
      return attributes.currentTime;
    }
    const now2 = getTimestamp(props);
    if (now2) {
      return attributes.currentTime + (now2 - attributes.hostTime) / 1e3;
    } else {
      return attributes.currentTime;
    }
  }
  function getTimestamp(props) {
    if (props.player) {
      return props.player.beginTimestamp + props.plugin.playerTimestamp;
    }
    if (props.room) {
      return props.room.calibrationTimestamp;
    }
  }

  // node_modules/lodash-es/_freeGlobal.js
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  var freeGlobal_default = freeGlobal;

  // node_modules/lodash-es/_root.js
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal_default || freeSelf || Function("return this")();
  var root_default = root;

  // node_modules/lodash-es/_Symbol.js
  var Symbol = root_default.Symbol;
  var Symbol_default = Symbol;

  // node_modules/lodash-es/_getRawTag.js
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var nativeObjectToString = objectProto.toString;
  var symToStringTag = Symbol_default ? Symbol_default.toStringTag : void 0;
  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
    try {
      value[symToStringTag] = void 0;
      var unmasked = true;
    } catch (e) {
    }
    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }
  var getRawTag_default = getRawTag;

  // node_modules/lodash-es/_objectToString.js
  var objectProto2 = Object.prototype;
  var nativeObjectToString2 = objectProto2.toString;
  function objectToString(value) {
    return nativeObjectToString2.call(value);
  }
  var objectToString_default = objectToString;

  // node_modules/lodash-es/_baseGetTag.js
  var nullTag = "[object Null]";
  var undefinedTag = "[object Undefined]";
  var symToStringTag2 = Symbol_default ? Symbol_default.toStringTag : void 0;
  function baseGetTag(value) {
    if (value == null) {
      return value === void 0 ? undefinedTag : nullTag;
    }
    return symToStringTag2 && symToStringTag2 in Object(value) ? getRawTag_default(value) : objectToString_default(value);
  }
  var baseGetTag_default = baseGetTag;

  // node_modules/lodash-es/isObjectLike.js
  function isObjectLike(value) {
    return value != null && typeof value == "object";
  }
  var isObjectLike_default = isObjectLike;

  // node_modules/lodash-es/isSymbol.js
  var symbolTag = "[object Symbol]";
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike_default(value) && baseGetTag_default(value) == symbolTag;
  }
  var isSymbol_default = isSymbol;

  // node_modules/lodash-es/_trimmedEndIndex.js
  var reWhitespace = /\s/;
  function trimmedEndIndex(string) {
    var index = string.length;
    while (index-- && reWhitespace.test(string.charAt(index))) {
    }
    return index;
  }
  var trimmedEndIndex_default = trimmedEndIndex;

  // node_modules/lodash-es/_baseTrim.js
  var reTrimStart = /^\s+/;
  function baseTrim(string) {
    return string ? string.slice(0, trimmedEndIndex_default(string) + 1).replace(reTrimStart, "") : string;
  }
  var baseTrim_default = baseTrim;

  // node_modules/lodash-es/isObject.js
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == "object" || type == "function");
  }
  var isObject_default = isObject;

  // node_modules/lodash-es/toNumber.js
  var NAN = 0 / 0;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  function toNumber(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol_default(value)) {
      return NAN;
    }
    if (isObject_default(value)) {
      var other = typeof value.valueOf == "function" ? value.valueOf() : value;
      value = isObject_default(other) ? other + "" : other;
    }
    if (typeof value != "string") {
      return value === 0 ? value : +value;
    }
    value = baseTrim_default(value);
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }
  var toNumber_default = toNumber;

  // node_modules/lodash-es/now.js
  var now = function() {
    return root_default.Date.now();
  };
  var now_default = now;

  // node_modules/lodash-es/debounce.js
  var FUNC_ERROR_TEXT = "Expected a function";
  var nativeMax = Math.max;
  var nativeMin = Math.min;
  function debounce(func, wait, options2) {
    var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    wait = toNumber_default(wait) || 0;
    if (isObject_default(options2)) {
      leading = !!options2.leading;
      maxing = "maxWait" in options2;
      maxWait = maxing ? nativeMax(toNumber_default(options2.maxWait) || 0, wait) : maxWait;
      trailing = "trailing" in options2 ? !!options2.trailing : trailing;
    }
    function invokeFunc(time) {
      var args = lastArgs, thisArg = lastThis;
      lastArgs = lastThis = void 0;
      lastInvokeTime = time;
      result = func.apply(thisArg, args);
      return result;
    }
    function leadingEdge(time) {
      lastInvokeTime = time;
      timerId = setTimeout(timerExpired, wait);
      return leading ? invokeFunc(time) : result;
    }
    function remainingWait(time) {
      var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
      return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
    }
    function shouldInvoke(time) {
      var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
      return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
    }
    function timerExpired() {
      var time = now_default();
      if (shouldInvoke(time)) {
        return trailingEdge(time);
      }
      timerId = setTimeout(timerExpired, remainingWait(time));
    }
    function trailingEdge(time) {
      timerId = void 0;
      if (trailing && lastArgs) {
        return invokeFunc(time);
      }
      lastArgs = lastThis = void 0;
      return result;
    }
    function cancel() {
      if (timerId !== void 0) {
        clearTimeout(timerId);
      }
      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = void 0;
    }
    function flush() {
      return timerId === void 0 ? result : trailingEdge(now_default());
    }
    function debounced() {
      var time = now_default(), isInvoking = shouldInvoke(time);
      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time;
      if (isInvoking) {
        if (timerId === void 0) {
          return leadingEdge(lastCallTime);
        }
        if (maxing) {
          clearTimeout(timerId);
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (timerId === void 0) {
        timerId = setTimeout(timerExpired, wait);
      }
      return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }
  var debounce_default = debounce;

  // src/components/PlayerController.tsx
  var import_react2 = __toModule(require_react());

  // svgo:src/components/icons/video_pause.svg
  var video_pause_default = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjIiIGhlaWdodD0iMjIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iI0ZGRiIgZmlsbC1ydWxlPSJub256ZXJvIj48cGF0aCBmaWxsLW9wYWNpdHk9Ii4wMSIgZD0iTTAgMGgyMnYyMkgweiIvPjxyZWN0IHg9IjciIHk9IjYiIHdpZHRoPSIyIiBoZWlnaHQ9IjEwIiByeD0iMSIvPjxyZWN0IHg9IjEzIiB5PSI2IiB3aWR0aD0iMiIgaGVpZ2h0PSIxMCIgcng9IjEiLz48L2c+PC9zdmc+";

  // svgo:src/components/icons/video_play.svg
  var video_play_default = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjIiIGhlaWdodD0iMjIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iI0ZGRiIgZmlsbC1ydWxlPSJub256ZXJvIj48cGF0aCBmaWxsLW9wYWNpdHk9Ii4wMSIgZD0iTTAgMGgyMnYyMkgweiIvPjxwYXRoIGQ9Im03LjUxNCA1LjkwOSA3LjA1NyA0LjIzNGExIDEgMCAwIDEgMCAxLjcxNGwtNy4wNTcgNC4yMzRBMSAxIDAgMCAxIDYgMTUuMjM0VjYuNzY2YTEgMSAwIDAgMSAxLjUxNC0uODU3eiIvPjwvZz48L3N2Zz4=";

  // svgo:src/components/icons/volume0.svg
  var volume0_default = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjIiIGhlaWdodD0iMjIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iI0ZGRiIgZmlsbC1ydWxlPSJub256ZXJvIj48cGF0aCBkPSJNNy4wOCA4LjQ0NUg1YS45NjIuOTYyIDAgMCAwLTEgLjkyNHYzLjkwN2EuOTYzLjk2MyAwIDAgMCAuOTYuOTY2bC4wNDYtLjAwMWgyLjAxbDMuMjI3IDIuMjc0Yy41MDIuMzQ0LjkzMi4xMzguOTMyLS4zNDVWNi41MTZjLS4wMDQtLjQ4My0uNDM2LS42OS0uODY2LS4zNDVMNy4wOCA4LjQ0NXoiLz48cGF0aCBmaWxsLW9wYWNpdHk9Ii4wMSIgZD0iTTAgMGgyMnYyMkgweiIvPjwvZz48L3N2Zz4=";

  // svgo:src/components/icons/volume1.svg
  var volume1_default = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjIiIGhlaWdodD0iMjIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iI0ZGRiIgZmlsbC1ydWxlPSJub256ZXJvIj48cGF0aCBkPSJNNy4wOCA4LjQ0NUg1YS45NjIuOTYyIDAgMCAwLTEgLjkyNHYzLjkwN2EuOTYzLjk2MyAwIDAgMCAuOTYuOTY2bC4wNDYtLjAwMWgyLjAxbDMuMjI3IDIuMjc0Yy41MDIuMzQ0LjkzMi4xMzguOTMyLS4zNDVWNi41MTZjLS4wMDQtLjQ4My0uNDM2LS42OS0uODY2LS4zNDVMNy4wOCA4LjQ0NXptNS43NDUgNC40MTNhLjU3Ni41NzYgMCAwIDAgMCAuODk4LjgwNS44MDUgMCAwIDAgMS4wNzggMCAyLjk0MyAyLjk0MyAwIDAgMC0uMDA0LTQuNTVoLjAwNGEuODA1LjgwNSAwIDAgMC0xLjA3OCAwIC41NzYuNTc2IDAgMCAwIDAgLjg5NiAxLjc5NCAxLjc5NCAwIDAgMSAwIDIuNzU2eiIvPjxwYXRoIGZpbGwtb3BhY2l0eT0iLjAxIiBkPSJNMCAwaDIydjIySDB6Ii8+PC9nPjwvc3ZnPg==";

  // svgo:src/components/icons/volume2.svg
  var volume2_default = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjIiIGhlaWdodD0iMjIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iI0ZGRiIgZmlsbC1ydWxlPSJub256ZXJvIj48cGF0aCBkPSJNNy4wOCA4LjQ0NUg1YS45NjIuOTYyIDAgMCAwLTEgLjkyNHYzLjkwN2EuOTYzLjk2MyAwIDAgMCAuOTYuOTY2bC4wNDYtLjAwMWgyLjAxbDMuMjI3IDIuMjc0Yy41MDIuMzQ0LjkzMi4xMzguOTMyLS4zNDVWNi41MTZjLS4wMDQtLjQ4My0uNDM2LS42OS0uODY2LS4zNDVMNy4wOCA4LjQ0NXptNS43NDUgNC40MTNhLjU3Ni41NzYgMCAwIDAgMCAuODk4LjgwNS44MDUgMCAwIDAgMS4wNzggMCAyLjk0MyAyLjk0MyAwIDAgMC0uMDA0LTQuNTVoLjAwNGEuODA1LjgwNSAwIDAgMC0xLjA3OCAwIC41NzYuNTc2IDAgMCAwIDAgLjg5NiAxLjc5NCAxLjc5NCAwIDAgMSAwIDIuNzU2eiIvPjxwYXRoIGQ9Ik0xNC45MDYgNy40MTJhLjU3Ni41NzYgMCAwIDAgMCAuODk4IDQuMDcyIDQuMDcyIDAgMCAxIDAgNi40MTIuNTc2LjU3NiAwIDAgMCAwIC44OTYuODAzLjgwMyAwIDAgMCAxLjA3NiAwIDUuMjIzIDUuMjIzIDAgMCAwLS4wMDMtOC4yMDhoLjAwM2EuODA0LjgwNCAwIDAgMC0xLjA3Ni4wMDJ6Ii8+PHBhdGggZmlsbC1vcGFjaXR5PSIuMDEiIGQ9Ik0wIDBoMjJ2MjJIMHoiLz48L2c+PC9zdmc+";

  // style-helper:__style_helper__
  function injectStyle(text) {
    const style = document.createElement("style");
    const node = document.createTextNode(text);
    style.appendChild(node);
    document.head.appendChild(style);
  }

  // style-content:src/components/PlayerController.css
  var PlayerController_default = ".vjs-p .player-controller{position:absolute;z-index:100;bottom:0px;left:0;width:100%;display:flex;flex-direction:column;justify-content:center;align-items:stretch;height:64px;background-image:linear-gradient(0deg,#000,transparent);transition:opacity .2s}.vjs-p .player-menu-box{display:flex;align-items:center;justify-content:center;flex-direction:column;margin-bottom:40px}.vjs-p .player-menu-cell{width:100%;text-align:center;font-size:12px;color:#7a7b7c}.vjs-p .player-multiple-play{width:64px;height:120px}.vjs-p .player-controller-actions-left{display:flex;justify-content:center;align-items:center;flex-shrink:0}.vjs-p .player-right-box{font-size:14px;color:#7a7b7c;cursor:pointer;margin-right:12px}.vjs-p .player-controller-actions{display:flex;flex-direction:row;justify-content:space-between;align-items:center;padding-left:8px;padding-right:8px;margin-top:2px}.vjs-p .player-mid-box-time{font-size:9px;display:flex;justify-content:center;align-items:center;color:#fff;flex-shrink:0;margin-right:8px;font-family:monospace}.vjs-p .player-controller-play{display:flex;align-items:center;justify-content:center;cursor:pointer;padding-right:4px}.vjs-p .player-controller-progress{width:calc(100% - 28px);margin-left:14px;display:flex;align-items:center;justify-content:center;margin-top:8px}.vjs-p .player-volume{display:flex;align-items:center;justify-content:center;cursor:pointer;margin-right:16px;margin-left:16px}.vjs-p .player-volume-slider{width:60px;margin-right:12px;display:flex;align-items:center}.vjs-p .player-volume-box{display:flex;flex-direction:row}\n";

  // style-stub:src/components/PlayerController.css
  injectStyle(PlayerController_default);

  // src/components/SeekSlider.tsx
  var import_react = __toModule(require_react());

  // style-content:src/components/SeekSlider.css
  var SeekSlider_default = ".vjs-p .seek-slider{position:relative;width:100%}.vjs-p .seek-slider:focus{outline:none}.vjs-p .seek-slider .track{padding:10px 0;cursor:pointer;outline:none}.vjs-p .seek-slider .track:focus{border:0;outline:none}.vjs-p .seek-slider .track .main{width:100%;height:3px;background-color:#ffffff4d;border-radius:30px;position:absolute;left:0;top:8.5px;transition:transform .4s;outline:none}.vjs-p .seek-slider .track .main:focus{border:0;outline:none}.vjs-p .seek-slider .track .main .buffered{position:absolute;background-color:#ffffff4d;width:100%;height:100%;transform:scaleX(.8);z-index:2;transform-origin:0 0}.vjs-p .seek-slider .track .main .seek-hover{position:absolute;background-color:#ffffff80;width:100%;height:100%;z-index:1;transform:scaleX(.6);transform-origin:0 0;opacity:0;transition:opacity .4s}.vjs-p .seek-slider .track .main .connect{position:absolute;background-color:#fff;width:100%;height:100%;z-index:3;left:0;transform:scaleX(.13);transform-origin:0 0}.vjs-p .seek-slider .track.active .main{transform:scaleY(2)}.vjs-p .seek-slider .thumb{pointer-events:none;position:absolute;width:12px;height:12px;left:-6px;top:4px;z-index:4;transform:translate(100px)}.vjs-p .seek-slider .thumb .handler{border-radius:100%;width:100%;height:100%;background-color:#fff;opacity:0;transform:scale(.4);cursor:pointer;transition:transform .2s;pointer-events:none}.vjs-p .seek-slider .thumb.active .handler{opacity:1;transform:scale(1)}.vjs-p .seek-slider .hover-time{position:absolute;background-color:#0000004d;line-height:18px;font-size:16px;color:#ddd;top:-25px;left:0;padding:5px 10px;border-radius:5px;box-shadow:0 0 5px #0000004d;opacity:0;transform:translate(150px);pointer-events:none}.vjs-p .seek-slider .hover-time.active{opacity:1}.vjs-p .seek-slider:hover .track .main .seek-hover{opacity:1}\n";

  // style-stub:src/components/SeekSlider.css
  injectStyle(SeekSlider_default);

  // src/components/SeekSlider.tsx
  var SeekSlider = class extends import_react.Component {
    constructor(props) {
      super(props);
      __publicField(this, "seeking", false);
      __publicField(this, "mobileSeeking", false);
      __publicField(this, "track", null);
      __publicField(this, "hoverTime", null);
      __publicField(this, "offset", 0);
      __publicField(this, "secondsPrefix", "00:00:");
      __publicField(this, "minutesPrefix", "00:");
      __publicField(this, "seekPause", false);
      __publicField(this, "handleTouchSeeking", (event) => {
        let pageX = 0;
        for (let i = 0; i < event.changedTouches.length; i++) {
          pageX = event.changedTouches[i].pageX;
        }
        pageX = pageX < 0 ? 0 : pageX;
        if (this.mobileSeeking) {
          this.changeCurrentTimePosition(pageX);
        }
      });
      __publicField(this, "handleSeeking", (evt) => {
        if (this.seeking) {
          this.changeCurrentTimePosition(evt.pageX);
        }
      });
      __publicField(this, "setTrackWidthState", () => {
        if (this.track) {
          this.setState({ trackWidth: this.track.offsetWidth });
        }
      });
      __publicField(this, "handleTrackHover", (clear, evt) => {
        if (this.track) {
          const scale = this.props.scale || 1;
          let position;
          if (clear) {
            position = 0;
          } else {
            position = (evt.pageX - this.track.getBoundingClientRect().left) / scale;
          }
          this.setState({ seekHoverPosition: position, trackWidth: this.track.offsetWidth });
        }
      });
      __publicField(this, "mouseSeekingHandler", (event) => {
        this.setSeeking(false, event);
        this.onMouseUp();
      });
      __publicField(this, "setSeeking", (state, evt) => {
        evt.preventDefault();
        this.handleSeeking(evt);
        this.seeking = state;
        this.setState({ seekHoverPosition: !state ? 0 : this.state.seekHoverPosition });
      });
      __publicField(this, "mobileTouchSeekingHandler", () => {
        this.setMobileSeeking(false);
      });
      __publicField(this, "setMobileSeeking", (state) => {
        this.mobileSeeking = state;
        this.setState({ seekHoverPosition: !state ? 0 : this.state.seekHoverPosition });
      });
      __publicField(this, "renderBufferProgress", () => {
        if (this.props.buffered) {
          const style = {
            ...this.getPositionStyle(this.props.buffered),
            ...this.props.bufferColor && { backgroundColor: this.props.bufferColor }
          };
          return /* @__PURE__ */ import_react.default.createElement("div", {
            className: "buffered",
            style
          });
        } else {
          return null;
        }
      });
      __publicField(this, "renderProgress", () => {
        const style = {
          ...this.getPositionStyle(this.props.current),
          ...this.props.sliderColor && { backgroundColor: this.props.sliderColor }
        };
        return /* @__PURE__ */ import_react.default.createElement("div", {
          className: "connect",
          style
        });
      });
      __publicField(this, "renderHoverProgress", () => {
        const style = {
          ...this.getSeekHoverPosition(),
          ...this.props.sliderHoverColor && { backgroundColor: this.props.sliderHoverColor }
        };
        return /* @__PURE__ */ import_react.default.createElement("div", {
          className: "seek-hover",
          style
        });
      });
      __publicField(this, "renderThumb", () => {
        return /* @__PURE__ */ import_react.default.createElement("div", {
          className: this.isThumbActive() ? `thumb active` : "thumb",
          style: this.getThumbHandlerPosition()
        }, /* @__PURE__ */ import_react.default.createElement("div", {
          style: { backgroundColor: this.props.thumbColor },
          className: "handler"
        }));
      });
      __publicField(this, "onMouseDown", (event) => {
        var _a, _b;
        if (this.props.pause && !this.props.paused) {
          this.props.pause();
          this.seekPause = true;
        }
        this.setSeeking(true, event);
        (_b = (_a = this.props).onSeekStart) == null ? void 0 : _b.call(_a);
      });
      __publicField(this, "onMouseUp", () => {
        var _a, _b;
        if (this.props.play && this.seekPause) {
          this.props.play();
          this.seekPause = false;
        }
        (_b = (_a = this.props).onSeekEnd) == null ? void 0 : _b.call(_a);
      });
      if (this.props.secondsPrefix) {
        this.secondsPrefix = this.props.secondsPrefix;
      }
      if (this.props.minutesPrefix) {
        this.minutesPrefix = this.props.minutesPrefix;
      }
      this.state = {
        ready: false,
        trackWidth: 0,
        seekHoverPosition: 0
      };
    }
    componentDidMount() {
      this.setTrackWidthState();
      window.addEventListener("resize", this.setTrackWidthState);
      window.addEventListener("mousemove", this.handleSeeking);
      window.addEventListener("mouseup", this.mouseSeekingHandler);
      window.addEventListener("touchmove", this.handleTouchSeeking);
      window.addEventListener("touchend", this.mobileTouchSeekingHandler);
    }
    componentWillUnmount() {
      window.removeEventListener("resize", this.setTrackWidthState);
      window.removeEventListener("mousemove", this.handleSeeking);
      window.removeEventListener("mouseup", this.mouseSeekingHandler);
      window.removeEventListener("touchmove", this.handleTouchSeeking);
      window.removeEventListener("touchend", this.mobileTouchSeekingHandler);
    }
    changeCurrentTimePosition(pageX) {
      if (this.track) {
        const scale = this.props.scale || 1;
        let position = (pageX - this.track.getBoundingClientRect().left) / scale;
        position = Math.min(this.state.trackWidth, Math.max(0, position));
        this.setState({ seekHoverPosition: position });
        const percent = position / this.state.trackWidth;
        const time = +(percent * this.props.total).toFixed(0);
        this.props.onChange(time);
      }
    }
    getPositionStyle(time) {
      const position = time * 100 / this.props.total;
      return { transform: `scaleX(${position / 100})` };
    }
    getThumbHandlerPosition() {
      const position = this.state.trackWidth / (this.props.total / this.props.current);
      return { transform: `translateX(${position}px)` };
    }
    getSeekHoverPosition() {
      const position = this.state.seekHoverPosition * 100 / this.state.trackWidth;
      return { transform: `scaleX(${position / 100})` };
    }
    getHoverTimePosition() {
      let position = 0;
      if (this.hoverTime) {
        position = this.state.seekHoverPosition - this.hoverTime.offsetWidth / 2;
        if (this.props.limitTimeTooltipBySides) {
          if (position < 0) {
            position = 0;
          } else if (position + this.hoverTime.offsetWidth > this.state.trackWidth) {
            position = this.state.trackWidth - this.hoverTime.offsetWidth;
          }
        }
      }
      return {
        transform: `translateX(${position}px)`
      };
    }
    secondsToTime(seconds) {
      seconds = Math.round(seconds + this.offset);
      const hours = Math.floor(seconds / 3600);
      const divForMinutes = seconds % 3600;
      const minutes = Math.floor(divForMinutes / 60);
      const sec = Math.ceil(divForMinutes % 60);
      return {
        hh: hours.toString(),
        mm: minutes < 10 ? "0" + minutes : minutes.toString(),
        ss: sec < 10 ? "0" + sec : sec.toString()
      };
    }
    getHoverTime() {
      const percent = this.state.seekHoverPosition * 100 / this.state.trackWidth;
      const time = Math.floor(+(percent * (this.props.total / 100)));
      const times = this.secondsToTime(time);
      if (this.props.total + this.offset < 60) {
        return this.secondsPrefix + times.ss;
      } else if (this.props.total + this.offset < 3600) {
        return this.minutesPrefix + times.mm + ":" + times.ss;
      } else {
        return times.hh + ":" + times.mm + ":" + times.ss;
      }
    }
    isThumbActive() {
      return this.state.seekHoverPosition > 0 || this.seeking;
    }
    drawHoverTime() {
      if (!this.props.hideHoverTime) {
        return /* @__PURE__ */ import_react.default.createElement("div", {
          className: this.isThumbActive() ? `hover-time active` : "hover-time",
          style: this.getHoverTimePosition(),
          ref: (ref) => this.hoverTime = ref
        }, this.getHoverTime());
      } else {
        return null;
      }
    }
    render() {
      return /* @__PURE__ */ import_react.default.createElement("div", {
        className: "seek-slider"
      }, /* @__PURE__ */ import_react.default.createElement("div", {
        className: "track",
        ref: (ref) => this.track = ref,
        onMouseMove: (evt) => this.handleTrackHover(false, evt),
        onMouseLeave: (evt) => this.handleTrackHover(true, evt),
        onMouseDown: this.onMouseDown,
        onTouchStart: (evt) => {
          this.setMobileSeeking(true);
          this.onMouseDown(evt);
        },
        onMouseUp: this.onMouseUp,
        onTouchEnd: this.onMouseUp
      }, /* @__PURE__ */ import_react.default.createElement("div", {
        className: "main"
      }, this.renderBufferProgress(), this.renderHoverProgress(), this.renderProgress())), this.drawHoverTime(), this.renderThumb());
    }
  };

  // src/components/PlayerController.tsx
  var PlayerController = class extends import_react2.Component {
    constructor(props) {
      super(props);
      __publicField(this, "stageVolume", 0);
      __publicField(this, "updateVolumeTimer", 0);
      __publicField(this, "onVolumeSeeking", false);
      __publicField(this, "onClickOperationButton", () => {
        const { paused } = this.props;
        if (paused) {
          this.props.play();
        } else {
          this.props.pause();
        }
      });
      __publicField(this, "operationButton", () => {
        const { paused } = this.props;
        if (paused) {
          return /* @__PURE__ */ import_react2.default.createElement("img", {
            src: video_play_default
          });
        } else {
          return /* @__PURE__ */ import_react2.default.createElement("img", {
            src: video_pause_default
          });
        }
      });
      __publicField(this, "operationVolumeButton", () => {
        if (this.props.volume > 0.9) {
          return /* @__PURE__ */ import_react2.default.createElement("img", {
            src: volume2_default
          });
        } else if (this.props.volume === 0) {
          return /* @__PURE__ */ import_react2.default.createElement("img", {
            src: volume0_default
          });
        } else {
          return /* @__PURE__ */ import_react2.default.createElement("img", {
            src: volume1_default
          });
        }
      });
      __publicField(this, "handleClickVolume", () => {
        if (this.props.volume === 0) {
          if (this.stageVolume !== 0) {
            this.props.setVolume(this.stageVolume);
          } else {
            this.props.setVolume(1);
          }
        } else {
          this.stageVolume = this.props.volume;
          this.props.setVolume(0);
        }
      });
      __publicField(this, "onChange", (currentTime) => {
        this.setState({ currentTime });
        currentTime && this.changeTime(currentTime);
      });
      __publicField(this, "changeTime", debounce_default((time) => {
        this.props.setCurrentTime(time);
      }, 50));
      __publicField(this, "onVolumeChange", (time) => {
        this.changeVolume(time);
        this.setState({ seekVolume: time / 100 });
      });
      __publicField(this, "changeVolume", debounce_default((time) => {
        this.props.setVolume(time / 100);
      }, 50));
      __publicField(this, "onVolumeSeekStart", () => {
        this.onVolumeSeeking = true;
      });
      __publicField(this, "onVolumeSeekEnd", debounce_default(() => {
        this.onVolumeSeeking = false;
      }, 500));
      __publicField(this, "onProgressSeekStart", () => this.setState({ isPlayerSeeking: true }));
      __publicField(this, "onProgressSeekEnd", debounce_default(() => {
        this.setState({ isPlayerSeeking: false });
      }, 500));
      this.state = {
        isPlayerSeeking: false,
        isVolumeHover: false,
        seekVolume: 1,
        visible: true,
        currentTime: 0
      };
      this.stageVolume = props.volume;
    }
    componentDidMount() {
      this.updateVolumeTimer = setInterval(() => {
        if (!this.onVolumeSeeking) {
          this.setState({ seekVolume: this.props.volume });
        }
        if (!this.state.isPlayerSeeking) {
          this.setState({ currentTime: this.props.currentTime });
        }
      }, 100);
    }
    componentWillUnmount() {
      if (this.updateVolumeTimer) {
        clearInterval(this.updateVolumeTimer);
      }
    }
    render() {
      const { duration, currentTime: progressTime } = this.props;
      return /* @__PURE__ */ import_react2.default.createElement("div", {
        className: "player-controller",
        style: { opacity: this.props.visible ? "1" : "0" }
      }, /* @__PURE__ */ import_react2.default.createElement("div", {
        className: "player-controller-progress"
      }, /* @__PURE__ */ import_react2.default.createElement(SeekSlider, {
        total: duration,
        current: this.state.currentTime,
        onChange: this.onChange,
        buffered: this.props.buffered,
        bufferColor: "rgba(255,255,255,0.3)",
        hideHoverTime: true,
        limitTimeTooltipBySides: true,
        onSeekStart: this.onProgressSeekStart,
        onSeekEnd: this.onProgressSeekEnd,
        play: this.props.play,
        pause: this.props.pause,
        paused: this.props.paused,
        scale: this.props.scale
      })), /* @__PURE__ */ import_react2.default.createElement("div", {
        className: "player-controller-actions"
      }, /* @__PURE__ */ import_react2.default.createElement("div", {
        className: "player-controller-actions-left"
      }, /* @__PURE__ */ import_react2.default.createElement("div", {
        onClick: this.onClickOperationButton,
        className: "player-controller-play"
      }, this.operationButton()), /* @__PURE__ */ import_react2.default.createElement("div", {
        className: "player-volume-box",
        onMouseEnter: () => this.setState({ isVolumeHover: true }),
        onMouseLeave: () => this.setState({ isVolumeHover: false })
      }, /* @__PURE__ */ import_react2.default.createElement("div", {
        onClick: this.handleClickVolume,
        className: "player-volume"
      }, this.operationVolumeButton()), /* @__PURE__ */ import_react2.default.createElement("div", {
        className: "player-volume-slider"
      }, /* @__PURE__ */ import_react2.default.createElement(SeekSlider, {
        total: 100,
        current: 100 * this.state.seekVolume,
        onChange: this.onVolumeChange,
        onSeekStart: this.onVolumeSeekStart,
        onSeekEnd: this.onVolumeSeekEnd,
        scale: this.props.scale,
        limitTimeTooltipBySides: true,
        hideHoverTime: true
      })))), /* @__PURE__ */ import_react2.default.createElement("div", {
        className: "player-mid-box-time"
      }, displayWatch(Math.floor(progressTime / 1e3)), " /", " ", displayWatch(Math.floor(duration / 1e3)))));
    }
  };
  function displayWatch(seconds) {
    const displaySeconds = seconds % 60;
    const minutes = (seconds - displaySeconds) / 60;
    if (minutes >= 60) {
      const displayMinutes = minutes % 60;
      const hours = (minutes - displayMinutes) / 60;
      return `${updateNumber(hours)}:${updateNumber(displayMinutes)}:${updateNumber(displaySeconds)}`;
    } else {
      return `${updateNumber(minutes)}:${updateNumber(displaySeconds)}`;
    }
  }
  function updateNumber(time) {
    if (time <= 9) {
      return `0${time}`;
    } else {
      return `${time}`;
    }
  }

  // style-content:src/components/style.css
  var style_default = '.vjs-p{display:flex;flex-grow:1;position:relative}.vjs-p *{pointer-events:auto}.vjs-p.disabled *{pointer-events:none}.vjs-p .videojs-plugin-close-icon,.vjs-p .player-controller,.vjs-p .videojs-plugin-muted-alert{pointer-events:auto}.vjs-p.disabled .videojs-plugin-close-icon,.vjs-p.disabled .player-controller{pointer-events:none}.vjs-p .video-js-plugin-header{position:absolute;z-index:100;top:0;height:30px;width:100%;display:flex;background:linear-gradient(rgba(0,0,0,.85),rgba(0,0,0,.45) 40%,rgba(0,0,0,0));transition:opacity .2s;user-select:none}.vjs-p .video-js-plugin-title{padding:10px;font-size:14px;color:#fff}.vjs-p .video-js-plugin-player{position:absolute;top:0;left:0;right:0;bottom:0}.video-js,[data-vjs-player]{width:100%;height:100%}.vjs-p .videojs-plugin-close-icon.disabled{display:none}.vjs-p .videojs-plugin-close-icon{pointer-events:auto;z-index:42;color:#fff;position:absolute;top:0;right:0;width:32px;height:32px;font-size:20px;display:flex;align-items:center;justify-content:center}.vjs-p .videojs-plugin-muted-alert{pointer-events:auto;cursor:pointer;position:absolute;top:0;left:0;right:0;bottom:0;z-index:43}.vjs-p .videojs-plugin-muted-alert:before{pointer-events:auto;cursor:pointer;position:absolute;top:0;left:0;right:0;bottom:0;z-index:43;content:"\uF104";background:rgba(0,0,0,.3);font-family:VideoJS;font-size:2em;display:flex;align-items:center;justify-content:center;color:#fff}.vjs-p .videojs-plugin-recovery-mode{pointer-events:auto;cursor:pointer;position:absolute;top:0;left:0;right:0;bottom:0;z-index:44}.vjs-p .videojs-plugin-recovery-mode button{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%)}\n';

  // style-stub:src/components/style.css
  injectStyle(style_default);

  // src/components/Transform.tsx
  var import_react3 = __toModule(require_react());
  function FlexTransform({ scale = 1, size, children }) {
    return /* @__PURE__ */ import_react3.default.createElement("div", {
      style: {
        width: size.width / scale,
        height: size.height / scale,
        transform: `scale(${scale})`,
        transformOrigin: "top left",
        display: "flex",
        overflow: "hidden"
      }
    }, children);
  }

  // src/components/VideoJsPlugin.tsx
  var VideoJsPlugin = class extends import_react4.Component {
    render() {
      const { cnode, size, scale } = this.props;
      return /* @__PURE__ */ import_react4.default.createElement(import_white_web_sdk.CNode, {
        context: cnode
      }, /* @__PURE__ */ import_react4.default.createElement(FlexTransform, {
        size,
        scale
      }, /* @__PURE__ */ import_react4.default.createElement(import_white_web_sdk.RoomConsumer, null, (room) => room && /* @__PURE__ */ import_react4.default.createElement(Impl, {
        room,
        ...this.props
      })), /* @__PURE__ */ import_react4.default.createElement(import_white_web_sdk.PlayerConsumer, null, (player) => player && /* @__PURE__ */ import_react4.default.createElement(Impl, {
        player,
        ...this.props
      }))));
    }
  };
  var Impl = class extends import_react4.Component {
    constructor(props) {
      super(props);
      __publicField(this, "closeIcon", null);
      __publicField(this, "alertMask", null);
      __publicField(this, "container", import_react4.default.createRef());
      __publicField(this, "player");
      __publicField(this, "controllerHiddenTimer", 0);
      __publicField(this, "syncPlayerTimer", 0);
      __publicField(this, "retryCount", 0);
      __publicField(this, "decreaseRetryTimer", 0);
      __publicField(this, "disposer");
      __publicField(this, "showController", () => {
        this.setState({ controllerVisible: true });
        this.debounceHidingController();
      });
      __publicField(this, "play", () => {
        var _a;
        const hostTime = (_a = this.props.room) == null ? void 0 : _a.calibrationTimestamp;
        this.debug(">>> play", { paused: false, hostTime });
        this.isEnabled() && this.props.plugin.putAttributes({ paused: false, hostTime });
      });
      __publicField(this, "pause", () => {
        const currentTime = getCurrentTime(this.getAttributes(), this.props);
        this.debug(">>> pause", { paused: true, currentTime });
        this.isEnabled() && this.props.plugin.putAttributes({ paused: true, currentTime });
      });
      __publicField(this, "setVolume", (volume) => {
        this.debug(">>> volume", { volume });
        this.isEnabled() && this.props.plugin.putAttributes({ volume });
        this.isEnabled() && this.props.plugin.putAttributes({ volume, muted: volume === 0 });
      });
      __publicField(this, "setCurrentTime", (t) => {
        var _a;
        const hostTime = (_a = this.props.room) == null ? void 0 : _a.calibrationTimestamp;
        this.debug(">>> seek", { currentTime: t / 1e3, hostTime });
        this.isEnabled() && this.props.plugin.putAttributes({ currentTime: t / 1e3, hostTime });
      });
      __publicField(this, "resetPlayer", () => {
        var _a;
        (_a = this.player) == null ? void 0 : _a.autoplay(false);
        this.debug(">>> ended", { paused: true, currentTime: 0 });
        this.isEnabled() && this.props.plugin.putAttributes({ paused: true, currentTime: 0 });
      });
      __publicField(this, "syncPlayerWithAttributes", () => {
        var _a;
        void this.props.plugin.context;
        const s = this.getAttributes();
        const player = this.player;
        if (!player)
          return;
        if (player.paused() !== s.paused) {
          this.debug("<<< paused -> %o", s.paused);
          if (s.paused) {
            player.pause();
          } else {
            (_a = player.play()) == null ? void 0 : _a.catch(this.catchPlayFail);
          }
        }
        if (player.muted() !== s.muted) {
          this.debug("<<< muted -> %o", s.muted);
          player.muted(s.muted);
        }
        if (player.volume() !== s.volume) {
          this.debug("<<< volume -> %o", s.volume);
          player.volume(s.volume);
        }
        const currentTime = getCurrentTime(s, this.props);
        if (currentTime > player.duration()) {
          this.resetPlayer();
        } else if (Math.abs(player.currentTime() - currentTime) > options.currentTimeMaxError) {
          this.debug("<<< currentTime -> %o", currentTime);
          player.currentTime(currentTime);
        }
      });
      __publicField(this, "debounceHidingController", () => {
        if (this.controllerHiddenTimer) {
          clearTimeout(this.controllerHiddenTimer);
          this.controllerHiddenTimer = 0;
        }
        this.controllerHiddenTimer = setTimeout(() => {
          this.setState({ controllerVisible: false });
          this.controllerHiddenTimer = 0;
        }, 3e3);
      });
      __publicField(this, "decreaseRetryCount", () => {
        if (!this.player)
          return;
        if (this.retryCount > 0) {
          this.retryCount = this.retryCount - 1;
        }
      });
      __publicField(this, "catchPlayFail", (err) => {
        var _a, _b;
        if (String(err).includes("interact")) {
          (_a = this.player) == null ? void 0 : _a.autoplay("any");
          this.setState({ NoSound: true });
        } else {
          const mediaError = (_b = this.player) == null ? void 0 : _b.error();
          if (mediaError) {
            if (this.retryCount <= 3) {
              this.initPlayer();
              this.retryCount = this.retryCount + 1;
            } else {
              this.debug("catch videojs media error", mediaError);
              this.setState({ MediaError: true });
            }
          }
          this.debug("catch error", err);
        }
      });
      __publicField(this, "fixPlayFail", () => {
        this.debug("try to fix play state");
        this.setState({ NoSound: false });
        const { muted, volume } = this.getAttributes();
        if (this.player) {
          this.player.muted(muted);
          this.player.volume(volume);
        }
      });
      __publicField(this, "initPlayer", async () => {
        var _a;
        (_a = this.player) == null ? void 0 : _a.dispose();
        this.player = void 0;
        this.debug("creating elements ...");
        const { type, src, poster } = this.getAttributes();
        const wrapper = document.createElement("div");
        wrapper.setAttribute("data-vjs-player", "");
        const video = document.createElement("video");
        video.className = "video-js";
        poster && (video.poster = poster);
        video.setAttribute("playsInline", "");
        video.setAttribute("webkit-playsinline", "");
        const source = document.createElement("source");
        if (new URL(src).pathname.endsWith(".m3u8")) {
          source.type = "application/x-mpegURL";
        } else {
          video.src = src;
        }
        source.src = src;
        type && (source.type = type);
        video.appendChild(source);
        wrapper.appendChild(video);
        this.container.current.appendChild(wrapper);
        await nextFrame();
        this.debug("initializing videojs() ...");
        const player = (0, import_video.default)(video);
        this.player = player;
        player.one("loadedmetadata", this.gracefullyUpdate);
        player.on("ready", () => {
          var _a2, _b;
          (_b = (_a2 = options).onPlayer) == null ? void 0 : _b.call(_a2, player);
          player.on("timeupdate", this.gracefullyUpdate);
          player.on("volumechange", this.gracefullyUpdate);
          player.on("seeked", this.gracefullyUpdate);
          player.on("play", this.gracefullyUpdate);
          player.on("pause", this.gracefullyUpdate);
          player.on("ended", this.resetPlayer);
        });
        player.on("error", this.catchPlayFail);
        this.setState({ MediaError: false });
      });
      __publicField(this, "gracefullyUpdate", () => this.setState({ updater: !this.state.updater }));
      __publicField(this, "setupClose", (element) => {
        if (element) {
          element.addEventListener("touchstart", this.removeSelf);
          element.addEventListener("click", this.removeSelf);
        }
        this.closeIcon = element;
      });
      __publicField(this, "setupAlert", (element) => {
        if (element) {
          element.addEventListener("touchstart", this.fixPlayFail);
          element.addEventListener("click", this.fixPlayFail);
        }
        this.alertMask = element;
      });
      __publicField(this, "setupReload", (element) => {
        if (element) {
          element.addEventListener("touchstart", this.initPlayer);
          element.addEventListener("click", this.initPlayer);
        }
      });
      __publicField(this, "removeSelf", () => this.props.plugin.remove());
      this.state = {
        NoSound: false,
        MediaError: false,
        updater: false,
        controllerVisible: false
      };
      props.room && checkWhiteWebSdkVersion(props.room);
    }
    getAttributes() {
      let s;
      if (this.props.player) {
        s = this.props.plugin.attributes;
      } else {
        try {
          s = this.props.room.getPluginAttributes(this.props.plugin.identifier);
        } catch (e) {
          s = this.props.plugin.attributes;
        }
      }
      return s;
    }
    render() {
      var _a, _b, _c, _d;
      if (!(this.props.room || this.props.player)) {
        return null;
      }
      const s = this.getAttributes();
      const duration = (((_a = this.player) == null ? void 0 : _a.duration()) || 1e3) * 1e3;
      const bufferedPercent = ((_b = this.player) == null ? void 0 : _b.bufferedPercent()) || 0;
      return /* @__PURE__ */ import_react4.default.createElement("div", {
        className: this.isEnabled() ? "vjs-p" : "vjs-p disabled",
        onMouseEnter: this.showController,
        onMouseMove: this.showController
      }, /* @__PURE__ */ import_react4.default.createElement("div", {
        className: "video-js-plugin-player",
        ref: this.container
      }), /* @__PURE__ */ import_react4.default.createElement("div", {
        className: "video-js-plugin-header"
      }, s.title && /* @__PURE__ */ import_react4.default.createElement("div", {
        className: "video-js-plugin-title"
      }, s.title), ((_c = s.close) != null ? _c : true) && /* @__PURE__ */ import_react4.default.createElement("div", {
        className: "videojs-plugin-close-icon",
        ref: this.setupClose
      }, "\xD7")), /* @__PURE__ */ import_react4.default.createElement(PlayerController, {
        duration,
        volume: s.volume,
        setVolume: this.setVolume,
        paused: s.paused,
        play: this.play,
        pause: this.pause,
        currentTime: getCurrentTime(s, this.props) * 1e3,
        setCurrentTime: this.setCurrentTime,
        buffered: duration * bufferedPercent,
        scale: this.props.scale,
        visible: true
      }), !((_d = this.props.plugin.context) == null ? void 0 : _d.hideMuteAlert) && this.state.NoSound && /* @__PURE__ */ import_react4.default.createElement("div", {
        ref: this.setupAlert,
        className: "videojs-plugin-muted-alert"
      }), this.state.MediaError && /* @__PURE__ */ import_react4.default.createElement("div", {
        className: "videojs-plugin-recovery-mode"
      }, /* @__PURE__ */ import_react4.default.createElement("button", {
        ref: this.setupReload
      }, "Reload Player")));
    }
    debug(msg, ...args) {
      var _a;
      if ((_a = this.props.plugin.context) == null ? void 0 : _a.verbose) {
        console.log(`[VideoJS Plugin] ${msg}`, ...args);
      }
    }
    componentDidMount() {
      this.initPlayer();
      this.disposer = (0, import_white_web_sdk.autorun)(this.syncPlayerWithAttributes);
      this.syncPlayerTimer = setInterval(this.syncPlayerWithAttributes, options.syncInterval);
      this.decreaseRetryTimer = setInterval(this.decreaseRetryCount, options.retryInterval);
    }
    componentWillUnmount() {
      var _a, _b;
      (_a = this.disposer) == null ? void 0 : _a.call(this);
      (_b = this.player) == null ? void 0 : _b.dispose();
      clearInterval(this.syncPlayerTimer);
      clearInterval(this.decreaseRetryTimer);
    }
    isEnabled() {
      var _a;
      if (!((_a = this.props.room) == null ? void 0 : _a.isWritable))
        return false;
      const { identity, enable } = this.props.plugin.context || {};
      if (identity === void 0 && enable === void 0) {
        return false;
      }
      if (identity) {
        return ["host", "publisher"].includes(identity);
      }
      return Boolean(enable);
    }
  };

  // src/index.ts
  var videoJsPlugin = (options2) => {
    options2 && setOptions(options2);
    return {
      kind: PluginId,
      render: VideoJsPlugin,
      defaultAttributes: {
        src: "",
        poster: "",
        hostTime: 0,
        currentTime: 0,
        paused: true,
        muted: false,
        volume: 1,
        close: true
      }
    };
  };
  return src_exports;
})();
/**
 * @license
 * Lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="es" -o ./`
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
//# sourceMappingURL=index.iife.js.map
