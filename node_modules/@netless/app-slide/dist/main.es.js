var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
function clamp$1(value, min, max) {
  return Math.min(Math.max(value, min), max);
}
function isObj(obj) {
  return typeof obj === "object" && obj !== null;
}
function deepClone(obj) {
  return JSON.parse(JSON.stringify(obj));
}
class Logger {
  constructor(enable) {
    this.enable = enable;
    this.apps = {};
    this.level = "debug";
    this._onMessage = (ev) => {
      if (isObj(ev.data)) {
        if (typeof ev.data.slide === "boolean") {
          this.enable = ev.data.slide;
        } else if (ev.data.slide === "__instance") {
          console.log(this);
        }
      }
    };
    window.addEventListener("message", this._onMessage);
  }
  log(...args) {
    if (this.enable) {
      console.log(...args);
    }
  }
  verbose(...args) {
    if (this.enable && this.level === "verbose") {
      console.log(...args);
    }
  }
  dispose(appId) {
    this.enable = false;
    delete this.apps[appId];
    window.removeEventListener("message", this._onMessage);
  }
}
const logger = new Logger(false);
const log = logger.log.bind(logger);
const verbose = logger.verbose.bind(logger);
let useFreezer = false;
const FreezerLength = 2;
const apps = {
  map: new Map(),
  queue: [],
  validateQueue() {
    log("[Slide] freezer: validate", this.queue);
    while (this.queue.length > FreezerLength) {
      const appId = this.queue.pop();
      const slide = this.map.get(appId);
      if (slide) {
        log("[Slide] freezer: validate-freeze", appId, this.queue);
        slide.freeze();
      }
    }
  },
  set(appId, slide) {
    log("[Slide] freezer: add", appId, this.queue);
    this.map.set(appId, slide);
    if (!this.queue.includes(appId)) {
      this.queue.unshift(appId);
    }
    this.validateQueue();
  },
  delete(appId) {
    log("[Slide] freezer: delete", appId, this.queue);
    this.map.delete(appId);
    this.queue = this.queue.filter((id) => id !== appId);
  },
  focus(appId) {
    const slide = this.map.get(appId);
    const index = this.queue.indexOf(appId);
    if (index > -1) {
      this.queue.splice(index, 1);
    }
    this.queue.unshift(appId);
    this.validateQueue();
    log("[Slide] freezer: focus", appId, this.queue);
    if (slide) {
      slide.unfreeze();
    }
  }
};
const addHooks = (emitter) => {
  useFreezer = true;
  emitter.on("focus", ({ appId }) => {
    apps.focus(appId);
  });
};
const e = "!#%()*+,-./:;=?@[]^_`{|}~ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", s = e.length, t = Array(20), r = () => {
  for (let r2 = 0; r2 < 20; r2++)
    t[r2] = e.charAt(Math.random() * s);
  return t.join("");
};
class o {
  constructor() {
    this.disposers = new Map();
  }
  add(e2, s2 = r()) {
    return this.flush(s2), this.disposers.set(s2, e2()), s2;
  }
  addDisposer(e2, s2 = r()) {
    return this.flush(s2), this.disposers.set(s2, e2), s2;
  }
  addEventListener(e2, s2, t2, o2, i = r()) {
    return this.add(() => (e2.addEventListener(s2, t2, o2), () => e2.removeEventListener(s2, t2, o2)), i), i;
  }
  setTimeout(e2, s2, t2 = r()) {
    return this.add(() => {
      const r2 = window.setTimeout(() => {
        this.remove(t2), e2();
      }, s2);
      return () => window.clearTimeout(r2);
    }, t2);
  }
  setInterval(e2, s2, t2 = r()) {
    return this.add(() => {
      const t3 = window.setInterval(e2, s2);
      return () => window.clearInterval(t3);
    }, t2);
  }
  remove(e2) {
    const s2 = this.disposers.get(e2);
    return this.disposers.delete(e2), s2;
  }
  flush(e2) {
    const s2 = this.remove(e2);
    if (s2)
      try {
        s2();
      } catch (t2) {
        console.error(t2);
      }
  }
  flushAll() {
    this.disposers.forEach((e2) => {
      try {
        e2();
      } catch (s2) {
        console.error(s2);
      }
    }), this.disposers.clear();
  }
}
function isObject(val) {
  return val != null && typeof val === "object" && !Array.isArray(val);
}
function ensureAttributes(context, initAttrs) {
  let attrs = context.getAttributes();
  if (!attrs) {
    context.setAttributes(initAttrs);
    attrs = context.getAttributes();
  }
  if (!attrs) {
    throw new Error("[NetlessAppMonaco] No attributes");
  }
  if (isObject(initAttrs)) {
    Object.keys(initAttrs).forEach((key) => {
      if (!Object.prototype.hasOwnProperty.call(attrs, key)) {
        context.updateAttributes([key], initAttrs[key]);
      }
    });
  }
  return attrs;
}
var Slide = function(t2) {
  var e2 = {};
  function n(i) {
    if (e2[i])
      return e2[i].exports;
    var r2 = e2[i] = { i, l: false, exports: {} };
    return t2[i].call(r2.exports, r2, r2.exports, n), r2.l = true, r2.exports;
  }
  return n.m = t2, n.c = e2, n.d = function(t3, e3, i) {
    n.o(t3, e3) || Object.defineProperty(t3, e3, { enumerable: true, get: i });
  }, n.r = function(t3) {
    typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(t3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t3, "__esModule", { value: true });
  }, n.t = function(t3, e3) {
    if (1 & e3 && (t3 = n(t3)), 8 & e3)
      return t3;
    if (4 & e3 && typeof t3 == "object" && t3 && t3.__esModule)
      return t3;
    var i = Object.create(null);
    if (n.r(i), Object.defineProperty(i, "default", { enumerable: true, value: t3 }), 2 & e3 && typeof t3 != "string")
      for (var r2 in t3)
        n.d(i, r2, function(e4) {
          return t3[e4];
        }.bind(null, r2));
    return i;
  }, n.n = function(t3) {
    var e3 = t3 && t3.__esModule ? function() {
      return t3.default;
    } : function() {
      return t3;
    };
    return n.d(e3, "a", e3), e3;
  }, n.o = function(t3, e3) {
    return Object.prototype.hasOwnProperty.call(t3, e3);
  }, n.p = "", n(n.s = 65);
}([function(t2, e2, n) {
  var i = Object.prototype.hasOwnProperty, r2 = "~";
  function o2() {
  }
  function s2(t3, e3, n2) {
    this.fn = t3, this.context = e3, this.once = n2 || false;
  }
  function a(t3, e3, n2, i2, o3) {
    if (typeof n2 != "function")
      throw new TypeError("The listener must be a function");
    var a2 = new s2(n2, i2 || t3, o3), l2 = r2 ? r2 + e3 : e3;
    return t3._events[l2] ? t3._events[l2].fn ? t3._events[l2] = [t3._events[l2], a2] : t3._events[l2].push(a2) : (t3._events[l2] = a2, t3._eventsCount++), t3;
  }
  function l(t3, e3) {
    --t3._eventsCount == 0 ? t3._events = new o2() : delete t3._events[e3];
  }
  function u() {
    this._events = new o2(), this._eventsCount = 0;
  }
  Object.create && (o2.prototype = Object.create(null), new o2().__proto__ || (r2 = false)), u.prototype.eventNames = function() {
    var t3, e3, n2 = [];
    if (this._eventsCount === 0)
      return n2;
    for (e3 in t3 = this._events)
      i.call(t3, e3) && n2.push(r2 ? e3.slice(1) : e3);
    return Object.getOwnPropertySymbols ? n2.concat(Object.getOwnPropertySymbols(t3)) : n2;
  }, u.prototype.listeners = function(t3) {
    var e3 = r2 ? r2 + t3 : t3, n2 = this._events[e3];
    if (!n2)
      return [];
    if (n2.fn)
      return [n2.fn];
    for (var i2 = 0, o3 = n2.length, s3 = new Array(o3); i2 < o3; i2++)
      s3[i2] = n2[i2].fn;
    return s3;
  }, u.prototype.listenerCount = function(t3) {
    var e3 = r2 ? r2 + t3 : t3, n2 = this._events[e3];
    return n2 ? n2.fn ? 1 : n2.length : 0;
  }, u.prototype.emit = function(t3, e3, n2, i2, o3, s3) {
    var a2 = r2 ? r2 + t3 : t3;
    if (!this._events[a2])
      return false;
    var l2, u2, h = this._events[a2], c = arguments.length;
    if (h.fn) {
      switch (h.once && this.removeListener(t3, h.fn, void 0, true), c) {
        case 1:
          return h.fn.call(h.context), true;
        case 2:
          return h.fn.call(h.context, e3), true;
        case 3:
          return h.fn.call(h.context, e3, n2), true;
        case 4:
          return h.fn.call(h.context, e3, n2, i2), true;
        case 5:
          return h.fn.call(h.context, e3, n2, i2, o3), true;
        case 6:
          return h.fn.call(h.context, e3, n2, i2, o3, s3), true;
      }
      for (u2 = 1, l2 = new Array(c - 1); u2 < c; u2++)
        l2[u2 - 1] = arguments[u2];
      h.fn.apply(h.context, l2);
    } else {
      var d, p = h.length;
      for (u2 = 0; u2 < p; u2++)
        switch (h[u2].once && this.removeListener(t3, h[u2].fn, void 0, true), c) {
          case 1:
            h[u2].fn.call(h[u2].context);
            break;
          case 2:
            h[u2].fn.call(h[u2].context, e3);
            break;
          case 3:
            h[u2].fn.call(h[u2].context, e3, n2);
            break;
          case 4:
            h[u2].fn.call(h[u2].context, e3, n2, i2);
            break;
          default:
            if (!l2)
              for (d = 1, l2 = new Array(c - 1); d < c; d++)
                l2[d - 1] = arguments[d];
            h[u2].fn.apply(h[u2].context, l2);
        }
    }
    return true;
  }, u.prototype.on = function(t3, e3, n2) {
    return a(this, t3, e3, n2, false);
  }, u.prototype.once = function(t3, e3, n2) {
    return a(this, t3, e3, n2, true);
  }, u.prototype.removeListener = function(t3, e3, n2, i2) {
    var o3 = r2 ? r2 + t3 : t3;
    if (!this._events[o3])
      return this;
    if (!e3)
      return l(this, o3), this;
    var s3 = this._events[o3];
    if (s3.fn)
      s3.fn !== e3 || i2 && !s3.once || n2 && s3.context !== n2 || l(this, o3);
    else {
      for (var a2 = 0, u2 = [], h = s3.length; a2 < h; a2++)
        (s3[a2].fn !== e3 || i2 && !s3[a2].once || n2 && s3[a2].context !== n2) && u2.push(s3[a2]);
      u2.length ? this._events[o3] = u2.length === 1 ? u2[0] : u2 : l(this, o3);
    }
    return this;
  }, u.prototype.removeAllListeners = function(t3) {
    var e3;
    return t3 ? (e3 = r2 ? r2 + t3 : t3, this._events[e3] && l(this, e3)) : (this._events = new o2(), this._eventsCount = 0), this;
  }, u.prototype.off = u.prototype.removeListener, u.prototype.addListener = u.prototype.on, u.prefixed = r2, u.EventEmitter = u, t2.exports = u;
}, function(t2, e2, n) {
  (function(t3, i) {
    var r2;
    /**
     * @license
     * Lodash <https://lodash.com/>
     * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
     * Released under MIT license <https://lodash.com/license>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     */
    (function() {
      var o2 = "Expected a function", s2 = "__lodash_placeholder__", a = [["ary", 128], ["bind", 1], ["bindKey", 2], ["curry", 8], ["curryRight", 16], ["flip", 512], ["partial", 32], ["partialRight", 64], ["rearg", 256]], l = "[object Arguments]", u = "[object Array]", h = "[object Boolean]", c = "[object Date]", d = "[object Error]", p = "[object Function]", f = "[object GeneratorFunction]", m = "[object Map]", g = "[object Number]", v = "[object Object]", _ = "[object RegExp]", y = "[object Set]", x = "[object String]", b = "[object Symbol]", T = "[object WeakMap]", w = "[object ArrayBuffer]", S = "[object DataView]", E = "[object Float32Array]", M = "[object Float64Array]", A = "[object Int8Array]", R = "[object Int16Array]", P = "[object Int32Array]", C = "[object Uint8Array]", I = "[object Uint16Array]", O = "[object Uint32Array]", L = /\b__p \+= '';/g, N = /\b(__p \+=) '' \+/g, D = /(__e\(.*?\)|\b__t\)) \+\n'';/g, F = /&(?:amp|lt|gt|quot|#39);/g, B = /[&<>"']/g, U = RegExp(F.source), k = RegExp(B.source), G = /<%-([\s\S]+?)%>/g, H = /<%([\s\S]+?)%>/g, z = /<%=([\s\S]+?)%>/g, j = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, V = /^\w*$/, W = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, X = /[\\^$.*+?()[\]{}|]/g, q = RegExp(X.source), Y = /^\s+/, Z = /\s/, J = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, $ = /\{\n\/\* \[wrapped with (.+)\] \*/, K = /,? & /, Q = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, tt = /[()=,{}\[\]\/\s]/, et = /\\(\\)?/g, nt = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, it = /\w*$/, rt = /^[-+]0x[0-9a-f]+$/i, ot = /^0b[01]+$/i, st = /^\[object .+?Constructor\]$/, at = /^0o[0-7]+$/i, lt = /^(?:0|[1-9]\d*)$/, ut = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, ht = /($^)/, ct = /['\n\r\u2028\u2029\\]/g, dt = "\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff", pt = "\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", ft = "[\\ud800-\\udfff]", mt = "[" + pt + "]", gt = "[" + dt + "]", vt = "\\d+", _t = "[\\u2700-\\u27bf]", yt = "[a-z\\xdf-\\xf6\\xf8-\\xff]", xt = "[^\\ud800-\\udfff" + pt + vt + "\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde]", bt = "\\ud83c[\\udffb-\\udfff]", Tt = "[^\\ud800-\\udfff]", wt = "(?:\\ud83c[\\udde6-\\uddff]){2}", St = "[\\ud800-\\udbff][\\udc00-\\udfff]", Et = "[A-Z\\xc0-\\xd6\\xd8-\\xde]", Mt = "(?:" + yt + "|" + xt + ")", At = "(?:" + Et + "|" + xt + ")", Rt = "(?:" + gt + "|" + bt + ")?", Pt = "[\\ufe0e\\ufe0f]?" + Rt + ("(?:\\u200d(?:" + [Tt, wt, St].join("|") + ")[\\ufe0e\\ufe0f]?" + Rt + ")*"), Ct = "(?:" + [_t, wt, St].join("|") + ")" + Pt, It = "(?:" + [Tt + gt + "?", gt, wt, St, ft].join("|") + ")", Ot = RegExp("['\u2019]", "g"), Lt = RegExp(gt, "g"), Nt = RegExp(bt + "(?=" + bt + ")|" + It + Pt, "g"), Dt = RegExp([Et + "?" + yt + "+(?:['\u2019](?:d|ll|m|re|s|t|ve))?(?=" + [mt, Et, "$"].join("|") + ")", At + "+(?:['\u2019](?:D|LL|M|RE|S|T|VE))?(?=" + [mt, Et + Mt, "$"].join("|") + ")", Et + "?" + Mt + "+(?:['\u2019](?:d|ll|m|re|s|t|ve))?", Et + "+(?:['\u2019](?:D|LL|M|RE|S|T|VE))?", "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", vt, Ct].join("|"), "g"), Ft = RegExp("[\\u200d\\ud800-\\udfff" + dt + "\\ufe0e\\ufe0f]"), Bt = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, Ut = ["Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout"], kt = -1, Gt = {};
      Gt[E] = Gt[M] = Gt[A] = Gt[R] = Gt[P] = Gt[C] = Gt["[object Uint8ClampedArray]"] = Gt[I] = Gt[O] = true, Gt[l] = Gt[u] = Gt[w] = Gt[h] = Gt[S] = Gt[c] = Gt[d] = Gt[p] = Gt[m] = Gt[g] = Gt[v] = Gt[_] = Gt[y] = Gt[x] = Gt[T] = false;
      var Ht = {};
      Ht[l] = Ht[u] = Ht[w] = Ht[S] = Ht[h] = Ht[c] = Ht[E] = Ht[M] = Ht[A] = Ht[R] = Ht[P] = Ht[m] = Ht[g] = Ht[v] = Ht[_] = Ht[y] = Ht[x] = Ht[b] = Ht[C] = Ht["[object Uint8ClampedArray]"] = Ht[I] = Ht[O] = true, Ht[d] = Ht[p] = Ht[T] = false;
      var zt = { "\\": "\\", "'": "'", "\n": "n", "\r": "r", "\u2028": "u2028", "\u2029": "u2029" }, jt = parseFloat, Vt = parseInt, Wt = typeof t3 == "object" && t3 && t3.Object === Object && t3, Xt = typeof self == "object" && self && self.Object === Object && self, qt = Wt || Xt || Function("return this")(), Yt = e2 && !e2.nodeType && e2, Zt = Yt && typeof i == "object" && i && !i.nodeType && i, Jt = Zt && Zt.exports === Yt, $t = Jt && Wt.process, Kt = function() {
        try {
          var t4 = Zt && Zt.require && Zt.require("util").types;
          return t4 || $t && $t.binding && $t.binding("util");
        } catch (t5) {
        }
      }(), Qt = Kt && Kt.isArrayBuffer, te = Kt && Kt.isDate, ee = Kt && Kt.isMap, ne = Kt && Kt.isRegExp, ie = Kt && Kt.isSet, re = Kt && Kt.isTypedArray;
      function oe(t4, e3, n2) {
        switch (n2.length) {
          case 0:
            return t4.call(e3);
          case 1:
            return t4.call(e3, n2[0]);
          case 2:
            return t4.call(e3, n2[0], n2[1]);
          case 3:
            return t4.call(e3, n2[0], n2[1], n2[2]);
        }
        return t4.apply(e3, n2);
      }
      function se(t4, e3, n2, i2) {
        for (var r3 = -1, o3 = t4 == null ? 0 : t4.length; ++r3 < o3; ) {
          var s3 = t4[r3];
          e3(i2, s3, n2(s3), t4);
        }
        return i2;
      }
      function ae(t4, e3) {
        for (var n2 = -1, i2 = t4 == null ? 0 : t4.length; ++n2 < i2 && e3(t4[n2], n2, t4) !== false; )
          ;
        return t4;
      }
      function le(t4, e3) {
        for (var n2 = t4 == null ? 0 : t4.length; n2-- && e3(t4[n2], n2, t4) !== false; )
          ;
        return t4;
      }
      function ue(t4, e3) {
        for (var n2 = -1, i2 = t4 == null ? 0 : t4.length; ++n2 < i2; )
          if (!e3(t4[n2], n2, t4))
            return false;
        return true;
      }
      function he(t4, e3) {
        for (var n2 = -1, i2 = t4 == null ? 0 : t4.length, r3 = 0, o3 = []; ++n2 < i2; ) {
          var s3 = t4[n2];
          e3(s3, n2, t4) && (o3[r3++] = s3);
        }
        return o3;
      }
      function ce(t4, e3) {
        return !!(t4 == null ? 0 : t4.length) && be(t4, e3, 0) > -1;
      }
      function de(t4, e3, n2) {
        for (var i2 = -1, r3 = t4 == null ? 0 : t4.length; ++i2 < r3; )
          if (n2(e3, t4[i2]))
            return true;
        return false;
      }
      function pe(t4, e3) {
        for (var n2 = -1, i2 = t4 == null ? 0 : t4.length, r3 = Array(i2); ++n2 < i2; )
          r3[n2] = e3(t4[n2], n2, t4);
        return r3;
      }
      function fe(t4, e3) {
        for (var n2 = -1, i2 = e3.length, r3 = t4.length; ++n2 < i2; )
          t4[r3 + n2] = e3[n2];
        return t4;
      }
      function me(t4, e3, n2, i2) {
        var r3 = -1, o3 = t4 == null ? 0 : t4.length;
        for (i2 && o3 && (n2 = t4[++r3]); ++r3 < o3; )
          n2 = e3(n2, t4[r3], r3, t4);
        return n2;
      }
      function ge(t4, e3, n2, i2) {
        var r3 = t4 == null ? 0 : t4.length;
        for (i2 && r3 && (n2 = t4[--r3]); r3--; )
          n2 = e3(n2, t4[r3], r3, t4);
        return n2;
      }
      function ve(t4, e3) {
        for (var n2 = -1, i2 = t4 == null ? 0 : t4.length; ++n2 < i2; )
          if (e3(t4[n2], n2, t4))
            return true;
        return false;
      }
      var _e = Ee("length");
      function ye(t4, e3, n2) {
        var i2;
        return n2(t4, function(t5, n3, r3) {
          if (e3(t5, n3, r3))
            return i2 = n3, false;
        }), i2;
      }
      function xe(t4, e3, n2, i2) {
        for (var r3 = t4.length, o3 = n2 + (i2 ? 1 : -1); i2 ? o3-- : ++o3 < r3; )
          if (e3(t4[o3], o3, t4))
            return o3;
        return -1;
      }
      function be(t4, e3, n2) {
        return e3 == e3 ? function(t5, e4, n3) {
          var i2 = n3 - 1, r3 = t5.length;
          for (; ++i2 < r3; )
            if (t5[i2] === e4)
              return i2;
          return -1;
        }(t4, e3, n2) : xe(t4, we, n2);
      }
      function Te(t4, e3, n2, i2) {
        for (var r3 = n2 - 1, o3 = t4.length; ++r3 < o3; )
          if (i2(t4[r3], e3))
            return r3;
        return -1;
      }
      function we(t4) {
        return t4 != t4;
      }
      function Se(t4, e3) {
        var n2 = t4 == null ? 0 : t4.length;
        return n2 ? Re(t4, e3) / n2 : NaN;
      }
      function Ee(t4) {
        return function(e3) {
          return e3 == null ? void 0 : e3[t4];
        };
      }
      function Me(t4) {
        return function(e3) {
          return t4 == null ? void 0 : t4[e3];
        };
      }
      function Ae(t4, e3, n2, i2, r3) {
        return r3(t4, function(t5, r4, o3) {
          n2 = i2 ? (i2 = false, t5) : e3(n2, t5, r4, o3);
        }), n2;
      }
      function Re(t4, e3) {
        for (var n2, i2 = -1, r3 = t4.length; ++i2 < r3; ) {
          var o3 = e3(t4[i2]);
          o3 !== void 0 && (n2 = n2 === void 0 ? o3 : n2 + o3);
        }
        return n2;
      }
      function Pe(t4, e3) {
        for (var n2 = -1, i2 = Array(t4); ++n2 < t4; )
          i2[n2] = e3(n2);
        return i2;
      }
      function Ce(t4) {
        return t4 ? t4.slice(0, Ye(t4) + 1).replace(Y, "") : t4;
      }
      function Ie(t4) {
        return function(e3) {
          return t4(e3);
        };
      }
      function Oe(t4, e3) {
        return pe(e3, function(e4) {
          return t4[e4];
        });
      }
      function Le(t4, e3) {
        return t4.has(e3);
      }
      function Ne(t4, e3) {
        for (var n2 = -1, i2 = t4.length; ++n2 < i2 && be(e3, t4[n2], 0) > -1; )
          ;
        return n2;
      }
      function De(t4, e3) {
        for (var n2 = t4.length; n2-- && be(e3, t4[n2], 0) > -1; )
          ;
        return n2;
      }
      function Fe(t4, e3) {
        for (var n2 = t4.length, i2 = 0; n2--; )
          t4[n2] === e3 && ++i2;
        return i2;
      }
      var Be = Me({ "\xC0": "A", "\xC1": "A", "\xC2": "A", "\xC3": "A", "\xC4": "A", "\xC5": "A", "\xE0": "a", "\xE1": "a", "\xE2": "a", "\xE3": "a", "\xE4": "a", "\xE5": "a", "\xC7": "C", "\xE7": "c", "\xD0": "D", "\xF0": "d", "\xC8": "E", "\xC9": "E", "\xCA": "E", "\xCB": "E", "\xE8": "e", "\xE9": "e", "\xEA": "e", "\xEB": "e", "\xCC": "I", "\xCD": "I", "\xCE": "I", "\xCF": "I", "\xEC": "i", "\xED": "i", "\xEE": "i", "\xEF": "i", "\xD1": "N", "\xF1": "n", "\xD2": "O", "\xD3": "O", "\xD4": "O", "\xD5": "O", "\xD6": "O", "\xD8": "O", "\xF2": "o", "\xF3": "o", "\xF4": "o", "\xF5": "o", "\xF6": "o", "\xF8": "o", "\xD9": "U", "\xDA": "U", "\xDB": "U", "\xDC": "U", "\xF9": "u", "\xFA": "u", "\xFB": "u", "\xFC": "u", "\xDD": "Y", "\xFD": "y", "\xFF": "y", "\xC6": "Ae", "\xE6": "ae", "\xDE": "Th", "\xFE": "th", "\xDF": "ss", "\u0100": "A", "\u0102": "A", "\u0104": "A", "\u0101": "a", "\u0103": "a", "\u0105": "a", "\u0106": "C", "\u0108": "C", "\u010A": "C", "\u010C": "C", "\u0107": "c", "\u0109": "c", "\u010B": "c", "\u010D": "c", "\u010E": "D", "\u0110": "D", "\u010F": "d", "\u0111": "d", "\u0112": "E", "\u0114": "E", "\u0116": "E", "\u0118": "E", "\u011A": "E", "\u0113": "e", "\u0115": "e", "\u0117": "e", "\u0119": "e", "\u011B": "e", "\u011C": "G", "\u011E": "G", "\u0120": "G", "\u0122": "G", "\u011D": "g", "\u011F": "g", "\u0121": "g", "\u0123": "g", "\u0124": "H", "\u0126": "H", "\u0125": "h", "\u0127": "h", "\u0128": "I", "\u012A": "I", "\u012C": "I", "\u012E": "I", "\u0130": "I", "\u0129": "i", "\u012B": "i", "\u012D": "i", "\u012F": "i", "\u0131": "i", "\u0134": "J", "\u0135": "j", "\u0136": "K", "\u0137": "k", "\u0138": "k", "\u0139": "L", "\u013B": "L", "\u013D": "L", "\u013F": "L", "\u0141": "L", "\u013A": "l", "\u013C": "l", "\u013E": "l", "\u0140": "l", "\u0142": "l", "\u0143": "N", "\u0145": "N", "\u0147": "N", "\u014A": "N", "\u0144": "n", "\u0146": "n", "\u0148": "n", "\u014B": "n", "\u014C": "O", "\u014E": "O", "\u0150": "O", "\u014D": "o", "\u014F": "o", "\u0151": "o", "\u0154": "R", "\u0156": "R", "\u0158": "R", "\u0155": "r", "\u0157": "r", "\u0159": "r", "\u015A": "S", "\u015C": "S", "\u015E": "S", "\u0160": "S", "\u015B": "s", "\u015D": "s", "\u015F": "s", "\u0161": "s", "\u0162": "T", "\u0164": "T", "\u0166": "T", "\u0163": "t", "\u0165": "t", "\u0167": "t", "\u0168": "U", "\u016A": "U", "\u016C": "U", "\u016E": "U", "\u0170": "U", "\u0172": "U", "\u0169": "u", "\u016B": "u", "\u016D": "u", "\u016F": "u", "\u0171": "u", "\u0173": "u", "\u0174": "W", "\u0175": "w", "\u0176": "Y", "\u0177": "y", "\u0178": "Y", "\u0179": "Z", "\u017B": "Z", "\u017D": "Z", "\u017A": "z", "\u017C": "z", "\u017E": "z", "\u0132": "IJ", "\u0133": "ij", "\u0152": "Oe", "\u0153": "oe", "\u0149": "'n", "\u017F": "s" }), Ue = Me({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" });
      function ke(t4) {
        return "\\" + zt[t4];
      }
      function Ge(t4) {
        return Ft.test(t4);
      }
      function He(t4) {
        var e3 = -1, n2 = Array(t4.size);
        return t4.forEach(function(t5, i2) {
          n2[++e3] = [i2, t5];
        }), n2;
      }
      function ze(t4, e3) {
        return function(n2) {
          return t4(e3(n2));
        };
      }
      function je(t4, e3) {
        for (var n2 = -1, i2 = t4.length, r3 = 0, o3 = []; ++n2 < i2; ) {
          var a2 = t4[n2];
          a2 !== e3 && a2 !== s2 || (t4[n2] = s2, o3[r3++] = n2);
        }
        return o3;
      }
      function Ve(t4) {
        var e3 = -1, n2 = Array(t4.size);
        return t4.forEach(function(t5) {
          n2[++e3] = t5;
        }), n2;
      }
      function We(t4) {
        var e3 = -1, n2 = Array(t4.size);
        return t4.forEach(function(t5) {
          n2[++e3] = [t5, t5];
        }), n2;
      }
      function Xe(t4) {
        return Ge(t4) ? function(t5) {
          var e3 = Nt.lastIndex = 0;
          for (; Nt.test(t5); )
            ++e3;
          return e3;
        }(t4) : _e(t4);
      }
      function qe(t4) {
        return Ge(t4) ? function(t5) {
          return t5.match(Nt) || [];
        }(t4) : function(t5) {
          return t5.split("");
        }(t4);
      }
      function Ye(t4) {
        for (var e3 = t4.length; e3-- && Z.test(t4.charAt(e3)); )
          ;
        return e3;
      }
      var Ze = Me({ "&amp;": "&", "&lt;": "<", "&gt;": ">", "&quot;": '"', "&#39;": "'" });
      var Je = function t4(e3) {
        var n2, i2 = (e3 = e3 == null ? qt : Je.defaults(qt.Object(), e3, Je.pick(qt, Ut))).Array, r3 = e3.Date, Z2 = e3.Error, dt2 = e3.Function, pt2 = e3.Math, ft2 = e3.Object, mt2 = e3.RegExp, gt2 = e3.String, vt2 = e3.TypeError, _t2 = i2.prototype, yt2 = dt2.prototype, xt2 = ft2.prototype, bt2 = e3["__core-js_shared__"], Tt2 = yt2.toString, wt2 = xt2.hasOwnProperty, St2 = 0, Et2 = (n2 = /[^.]+$/.exec(bt2 && bt2.keys && bt2.keys.IE_PROTO || "")) ? "Symbol(src)_1." + n2 : "", Mt2 = xt2.toString, At2 = Tt2.call(ft2), Rt2 = qt._, Pt2 = mt2("^" + Tt2.call(wt2).replace(X, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), Ct2 = Jt ? e3.Buffer : void 0, It2 = e3.Symbol, Nt2 = e3.Uint8Array, Ft2 = Ct2 ? Ct2.allocUnsafe : void 0, zt2 = ze(ft2.getPrototypeOf, ft2), Wt2 = ft2.create, Xt2 = xt2.propertyIsEnumerable, Yt2 = _t2.splice, Zt2 = It2 ? It2.isConcatSpreadable : void 0, $t2 = It2 ? It2.iterator : void 0, Kt2 = It2 ? It2.toStringTag : void 0, _e2 = function() {
          try {
            var t5 = to(ft2, "defineProperty");
            return t5({}, "", {}), t5;
          } catch (t6) {
          }
        }(), Me2 = e3.clearTimeout !== qt.clearTimeout && e3.clearTimeout, $e = r3 && r3.now !== qt.Date.now && r3.now, Ke = e3.setTimeout !== qt.setTimeout && e3.setTimeout, Qe = pt2.ceil, tn = pt2.floor, en = ft2.getOwnPropertySymbols, nn = Ct2 ? Ct2.isBuffer : void 0, rn = e3.isFinite, on = _t2.join, sn = ze(ft2.keys, ft2), an = pt2.max, ln = pt2.min, un = r3.now, hn = e3.parseInt, cn = pt2.random, dn = _t2.reverse, pn = to(e3, "DataView"), fn = to(e3, "Map"), mn = to(e3, "Promise"), gn = to(e3, "Set"), vn = to(e3, "WeakMap"), _n = to(ft2, "create"), yn = vn && new vn(), xn = {}, bn = Ro(pn), Tn = Ro(fn), wn = Ro(mn), Sn = Ro(gn), En = Ro(vn), Mn = It2 ? It2.prototype : void 0, An = Mn ? Mn.valueOf : void 0, Rn = Mn ? Mn.toString : void 0;
        function Pn(t5) {
          if (Ws(t5) && !Ns(t5) && !(t5 instanceof Ln)) {
            if (t5 instanceof On)
              return t5;
            if (wt2.call(t5, "__wrapped__"))
              return Po(t5);
          }
          return new On(t5);
        }
        var Cn = function() {
          function t5() {
          }
          return function(e4) {
            if (!Vs(e4))
              return {};
            if (Wt2)
              return Wt2(e4);
            t5.prototype = e4;
            var n3 = new t5();
            return t5.prototype = void 0, n3;
          };
        }();
        function In() {
        }
        function On(t5, e4) {
          this.__wrapped__ = t5, this.__actions__ = [], this.__chain__ = !!e4, this.__index__ = 0, this.__values__ = void 0;
        }
        function Ln(t5) {
          this.__wrapped__ = t5, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = false, this.__iteratees__ = [], this.__takeCount__ = 4294967295, this.__views__ = [];
        }
        function Nn(t5) {
          var e4 = -1, n3 = t5 == null ? 0 : t5.length;
          for (this.clear(); ++e4 < n3; ) {
            var i3 = t5[e4];
            this.set(i3[0], i3[1]);
          }
        }
        function Dn(t5) {
          var e4 = -1, n3 = t5 == null ? 0 : t5.length;
          for (this.clear(); ++e4 < n3; ) {
            var i3 = t5[e4];
            this.set(i3[0], i3[1]);
          }
        }
        function Fn(t5) {
          var e4 = -1, n3 = t5 == null ? 0 : t5.length;
          for (this.clear(); ++e4 < n3; ) {
            var i3 = t5[e4];
            this.set(i3[0], i3[1]);
          }
        }
        function Bn(t5) {
          var e4 = -1, n3 = t5 == null ? 0 : t5.length;
          for (this.__data__ = new Fn(); ++e4 < n3; )
            this.add(t5[e4]);
        }
        function Un(t5) {
          var e4 = this.__data__ = new Dn(t5);
          this.size = e4.size;
        }
        function kn(t5, e4) {
          var n3 = Ns(t5), i3 = !n3 && Ls(t5), r4 = !n3 && !i3 && Us(t5), o3 = !n3 && !i3 && !r4 && Qs(t5), s3 = n3 || i3 || r4 || o3, a2 = s3 ? Pe(t5.length, gt2) : [], l2 = a2.length;
          for (var u2 in t5)
            !e4 && !wt2.call(t5, u2) || s3 && (u2 == "length" || r4 && (u2 == "offset" || u2 == "parent") || o3 && (u2 == "buffer" || u2 == "byteLength" || u2 == "byteOffset") || ao(u2, l2)) || a2.push(u2);
          return a2;
        }
        function Gn(t5) {
          var e4 = t5.length;
          return e4 ? t5[Bi(0, e4 - 1)] : void 0;
        }
        function Hn(t5, e4) {
          return Eo(_r(t5), Jn(e4, 0, t5.length));
        }
        function zn(t5) {
          return Eo(_r(t5));
        }
        function jn(t5, e4, n3) {
          (n3 !== void 0 && !Cs(t5[e4], n3) || n3 === void 0 && !(e4 in t5)) && Yn(t5, e4, n3);
        }
        function Vn(t5, e4, n3) {
          var i3 = t5[e4];
          wt2.call(t5, e4) && Cs(i3, n3) && (n3 !== void 0 || e4 in t5) || Yn(t5, e4, n3);
        }
        function Wn(t5, e4) {
          for (var n3 = t5.length; n3--; )
            if (Cs(t5[n3][0], e4))
              return n3;
          return -1;
        }
        function Xn(t5, e4, n3, i3) {
          return ei(t5, function(t6, r4, o3) {
            e4(i3, t6, n3(t6), o3);
          }), i3;
        }
        function qn(t5, e4) {
          return t5 && yr(e4, ba(e4), t5);
        }
        function Yn(t5, e4, n3) {
          e4 == "__proto__" && _e2 ? _e2(t5, e4, { configurable: true, enumerable: true, value: n3, writable: true }) : t5[e4] = n3;
        }
        function Zn(t5, e4) {
          for (var n3 = -1, r4 = e4.length, o3 = i2(r4), s3 = t5 == null; ++n3 < r4; )
            o3[n3] = s3 ? void 0 : ga(t5, e4[n3]);
          return o3;
        }
        function Jn(t5, e4, n3) {
          return t5 == t5 && (n3 !== void 0 && (t5 = t5 <= n3 ? t5 : n3), e4 !== void 0 && (t5 = t5 >= e4 ? t5 : e4)), t5;
        }
        function $n(t5, e4, n3, i3, r4, o3) {
          var s3, a2 = 1 & e4, u2 = 2 & e4, d2 = 4 & e4;
          if (n3 && (s3 = r4 ? n3(t5, i3, r4, o3) : n3(t5)), s3 !== void 0)
            return s3;
          if (!Vs(t5))
            return t5;
          var T2 = Ns(t5);
          if (T2) {
            if (s3 = function(t6) {
              var e5 = t6.length, n4 = new t6.constructor(e5);
              e5 && typeof t6[0] == "string" && wt2.call(t6, "index") && (n4.index = t6.index, n4.input = t6.input);
              return n4;
            }(t5), !a2)
              return _r(t5, s3);
          } else {
            var L2 = io(t5), N2 = L2 == p || L2 == f;
            if (Us(t5))
              return dr(t5, a2);
            if (L2 == v || L2 == l || N2 && !r4) {
              if (s3 = u2 || N2 ? {} : oo(t5), !a2)
                return u2 ? function(t6, e5) {
                  return yr(t6, no(t6), e5);
                }(t5, function(t6, e5) {
                  return t6 && yr(e5, Ta(e5), t6);
                }(s3, t5)) : function(t6, e5) {
                  return yr(t6, eo(t6), e5);
                }(t5, qn(s3, t5));
            } else {
              if (!Ht[L2])
                return r4 ? t5 : {};
              s3 = function(t6, e5, n4) {
                var i4 = t6.constructor;
                switch (e5) {
                  case w:
                    return pr(t6);
                  case h:
                  case c:
                    return new i4(+t6);
                  case S:
                    return function(t7, e6) {
                      var n5 = e6 ? pr(t7.buffer) : t7.buffer;
                      return new t7.constructor(n5, t7.byteOffset, t7.byteLength);
                    }(t6, n4);
                  case E:
                  case M:
                  case A:
                  case R:
                  case P:
                  case C:
                  case "[object Uint8ClampedArray]":
                  case I:
                  case O:
                    return fr(t6, n4);
                  case m:
                    return new i4();
                  case g:
                  case x:
                    return new i4(t6);
                  case _:
                    return function(t7) {
                      var e6 = new t7.constructor(t7.source, it.exec(t7));
                      return e6.lastIndex = t7.lastIndex, e6;
                    }(t6);
                  case y:
                    return new i4();
                  case b:
                    return r5 = t6, An ? ft2(An.call(r5)) : {};
                }
                var r5;
              }(t5, L2, a2);
            }
          }
          o3 || (o3 = new Un());
          var D2 = o3.get(t5);
          if (D2)
            return D2;
          o3.set(t5, s3), Js(t5) ? t5.forEach(function(i4) {
            s3.add($n(i4, e4, n3, i4, t5, o3));
          }) : Xs(t5) && t5.forEach(function(i4, r5) {
            s3.set(r5, $n(i4, e4, n3, r5, t5, o3));
          });
          var F2 = T2 ? void 0 : (d2 ? u2 ? qr : Xr : u2 ? Ta : ba)(t5);
          return ae(F2 || t5, function(i4, r5) {
            F2 && (i4 = t5[r5 = i4]), Vn(s3, r5, $n(i4, e4, n3, r5, t5, o3));
          }), s3;
        }
        function Kn(t5, e4, n3) {
          var i3 = n3.length;
          if (t5 == null)
            return !i3;
          for (t5 = ft2(t5); i3--; ) {
            var r4 = n3[i3], o3 = e4[r4], s3 = t5[r4];
            if (s3 === void 0 && !(r4 in t5) || !o3(s3))
              return false;
          }
          return true;
        }
        function Qn(t5, e4, n3) {
          if (typeof t5 != "function")
            throw new vt2(o2);
          return bo(function() {
            t5.apply(void 0, n3);
          }, e4);
        }
        function ti(t5, e4, n3, i3) {
          var r4 = -1, o3 = ce, s3 = true, a2 = t5.length, l2 = [], u2 = e4.length;
          if (!a2)
            return l2;
          n3 && (e4 = pe(e4, Ie(n3))), i3 ? (o3 = de, s3 = false) : e4.length >= 200 && (o3 = Le, s3 = false, e4 = new Bn(e4));
          t:
            for (; ++r4 < a2; ) {
              var h2 = t5[r4], c2 = n3 == null ? h2 : n3(h2);
              if (h2 = i3 || h2 !== 0 ? h2 : 0, s3 && c2 == c2) {
                for (var d2 = u2; d2--; )
                  if (e4[d2] === c2)
                    continue t;
                l2.push(h2);
              } else
                o3(e4, c2, i3) || l2.push(h2);
            }
          return l2;
        }
        Pn.templateSettings = { escape: G, evaluate: H, interpolate: z, variable: "", imports: { _: Pn } }, Pn.prototype = In.prototype, Pn.prototype.constructor = Pn, On.prototype = Cn(In.prototype), On.prototype.constructor = On, Ln.prototype = Cn(In.prototype), Ln.prototype.constructor = Ln, Nn.prototype.clear = function() {
          this.__data__ = _n ? _n(null) : {}, this.size = 0;
        }, Nn.prototype.delete = function(t5) {
          var e4 = this.has(t5) && delete this.__data__[t5];
          return this.size -= e4 ? 1 : 0, e4;
        }, Nn.prototype.get = function(t5) {
          var e4 = this.__data__;
          if (_n) {
            var n3 = e4[t5];
            return n3 === "__lodash_hash_undefined__" ? void 0 : n3;
          }
          return wt2.call(e4, t5) ? e4[t5] : void 0;
        }, Nn.prototype.has = function(t5) {
          var e4 = this.__data__;
          return _n ? e4[t5] !== void 0 : wt2.call(e4, t5);
        }, Nn.prototype.set = function(t5, e4) {
          var n3 = this.__data__;
          return this.size += this.has(t5) ? 0 : 1, n3[t5] = _n && e4 === void 0 ? "__lodash_hash_undefined__" : e4, this;
        }, Dn.prototype.clear = function() {
          this.__data__ = [], this.size = 0;
        }, Dn.prototype.delete = function(t5) {
          var e4 = this.__data__, n3 = Wn(e4, t5);
          return !(n3 < 0) && (n3 == e4.length - 1 ? e4.pop() : Yt2.call(e4, n3, 1), --this.size, true);
        }, Dn.prototype.get = function(t5) {
          var e4 = this.__data__, n3 = Wn(e4, t5);
          return n3 < 0 ? void 0 : e4[n3][1];
        }, Dn.prototype.has = function(t5) {
          return Wn(this.__data__, t5) > -1;
        }, Dn.prototype.set = function(t5, e4) {
          var n3 = this.__data__, i3 = Wn(n3, t5);
          return i3 < 0 ? (++this.size, n3.push([t5, e4])) : n3[i3][1] = e4, this;
        }, Fn.prototype.clear = function() {
          this.size = 0, this.__data__ = { hash: new Nn(), map: new (fn || Dn)(), string: new Nn() };
        }, Fn.prototype.delete = function(t5) {
          var e4 = Kr(this, t5).delete(t5);
          return this.size -= e4 ? 1 : 0, e4;
        }, Fn.prototype.get = function(t5) {
          return Kr(this, t5).get(t5);
        }, Fn.prototype.has = function(t5) {
          return Kr(this, t5).has(t5);
        }, Fn.prototype.set = function(t5, e4) {
          var n3 = Kr(this, t5), i3 = n3.size;
          return n3.set(t5, e4), this.size += n3.size == i3 ? 0 : 1, this;
        }, Bn.prototype.add = Bn.prototype.push = function(t5) {
          return this.__data__.set(t5, "__lodash_hash_undefined__"), this;
        }, Bn.prototype.has = function(t5) {
          return this.__data__.has(t5);
        }, Un.prototype.clear = function() {
          this.__data__ = new Dn(), this.size = 0;
        }, Un.prototype.delete = function(t5) {
          var e4 = this.__data__, n3 = e4.delete(t5);
          return this.size = e4.size, n3;
        }, Un.prototype.get = function(t5) {
          return this.__data__.get(t5);
        }, Un.prototype.has = function(t5) {
          return this.__data__.has(t5);
        }, Un.prototype.set = function(t5, e4) {
          var n3 = this.__data__;
          if (n3 instanceof Dn) {
            var i3 = n3.__data__;
            if (!fn || i3.length < 199)
              return i3.push([t5, e4]), this.size = ++n3.size, this;
            n3 = this.__data__ = new Fn(i3);
          }
          return n3.set(t5, e4), this.size = n3.size, this;
        };
        var ei = Tr(ui), ni = Tr(hi, true);
        function ii(t5, e4) {
          var n3 = true;
          return ei(t5, function(t6, i3, r4) {
            return n3 = !!e4(t6, i3, r4);
          }), n3;
        }
        function ri(t5, e4, n3) {
          for (var i3 = -1, r4 = t5.length; ++i3 < r4; ) {
            var o3 = t5[i3], s3 = e4(o3);
            if (s3 != null && (a2 === void 0 ? s3 == s3 && !Ks(s3) : n3(s3, a2)))
              var a2 = s3, l2 = o3;
          }
          return l2;
        }
        function oi(t5, e4) {
          var n3 = [];
          return ei(t5, function(t6, i3, r4) {
            e4(t6, i3, r4) && n3.push(t6);
          }), n3;
        }
        function si(t5, e4, n3, i3, r4) {
          var o3 = -1, s3 = t5.length;
          for (n3 || (n3 = so), r4 || (r4 = []); ++o3 < s3; ) {
            var a2 = t5[o3];
            e4 > 0 && n3(a2) ? e4 > 1 ? si(a2, e4 - 1, n3, i3, r4) : fe(r4, a2) : i3 || (r4[r4.length] = a2);
          }
          return r4;
        }
        var ai = wr(), li = wr(true);
        function ui(t5, e4) {
          return t5 && ai(t5, e4, ba);
        }
        function hi(t5, e4) {
          return t5 && li(t5, e4, ba);
        }
        function ci(t5, e4) {
          return he(e4, function(e5) {
            return Hs(t5[e5]);
          });
        }
        function di(t5, e4) {
          for (var n3 = 0, i3 = (e4 = lr(e4, t5)).length; t5 != null && n3 < i3; )
            t5 = t5[Ao(e4[n3++])];
          return n3 && n3 == i3 ? t5 : void 0;
        }
        function pi(t5, e4, n3) {
          var i3 = e4(t5);
          return Ns(t5) ? i3 : fe(i3, n3(t5));
        }
        function fi(t5) {
          return t5 == null ? t5 === void 0 ? "[object Undefined]" : "[object Null]" : Kt2 && Kt2 in ft2(t5) ? function(t6) {
            var e4 = wt2.call(t6, Kt2), n3 = t6[Kt2];
            try {
              t6[Kt2] = void 0;
              var i3 = true;
            } catch (t7) {
            }
            var r4 = Mt2.call(t6);
            i3 && (e4 ? t6[Kt2] = n3 : delete t6[Kt2]);
            return r4;
          }(t5) : function(t6) {
            return Mt2.call(t6);
          }(t5);
        }
        function mi(t5, e4) {
          return t5 > e4;
        }
        function gi(t5, e4) {
          return t5 != null && wt2.call(t5, e4);
        }
        function vi(t5, e4) {
          return t5 != null && e4 in ft2(t5);
        }
        function _i(t5, e4, n3) {
          for (var r4 = n3 ? de : ce, o3 = t5[0].length, s3 = t5.length, a2 = s3, l2 = i2(s3), u2 = 1 / 0, h2 = []; a2--; ) {
            var c2 = t5[a2];
            a2 && e4 && (c2 = pe(c2, Ie(e4))), u2 = ln(c2.length, u2), l2[a2] = !n3 && (e4 || o3 >= 120 && c2.length >= 120) ? new Bn(a2 && c2) : void 0;
          }
          c2 = t5[0];
          var d2 = -1, p2 = l2[0];
          t:
            for (; ++d2 < o3 && h2.length < u2; ) {
              var f2 = c2[d2], m2 = e4 ? e4(f2) : f2;
              if (f2 = n3 || f2 !== 0 ? f2 : 0, !(p2 ? Le(p2, m2) : r4(h2, m2, n3))) {
                for (a2 = s3; --a2; ) {
                  var g2 = l2[a2];
                  if (!(g2 ? Le(g2, m2) : r4(t5[a2], m2, n3)))
                    continue t;
                }
                p2 && p2.push(m2), h2.push(f2);
              }
            }
          return h2;
        }
        function yi(t5, e4, n3) {
          var i3 = (t5 = vo(t5, e4 = lr(e4, t5))) == null ? t5 : t5[Ao(Go(e4))];
          return i3 == null ? void 0 : oe(i3, t5, n3);
        }
        function xi(t5) {
          return Ws(t5) && fi(t5) == l;
        }
        function bi(t5, e4, n3, i3, r4) {
          return t5 === e4 || (t5 == null || e4 == null || !Ws(t5) && !Ws(e4) ? t5 != t5 && e4 != e4 : function(t6, e5, n4, i4, r5, o3) {
            var s3 = Ns(t6), a2 = Ns(e5), p2 = s3 ? u : io(t6), f2 = a2 ? u : io(e5), T2 = (p2 = p2 == l ? v : p2) == v, E2 = (f2 = f2 == l ? v : f2) == v, M2 = p2 == f2;
            if (M2 && Us(t6)) {
              if (!Us(e5))
                return false;
              s3 = true, T2 = false;
            }
            if (M2 && !T2)
              return o3 || (o3 = new Un()), s3 || Qs(t6) ? Vr(t6, e5, n4, i4, r5, o3) : function(t7, e6, n5, i5, r6, o4, s4) {
                switch (n5) {
                  case S:
                    if (t7.byteLength != e6.byteLength || t7.byteOffset != e6.byteOffset)
                      return false;
                    t7 = t7.buffer, e6 = e6.buffer;
                  case w:
                    return !(t7.byteLength != e6.byteLength || !o4(new Nt2(t7), new Nt2(e6)));
                  case h:
                  case c:
                  case g:
                    return Cs(+t7, +e6);
                  case d:
                    return t7.name == e6.name && t7.message == e6.message;
                  case _:
                  case x:
                    return t7 == e6 + "";
                  case m:
                    var a3 = He;
                  case y:
                    var l2 = 1 & i5;
                    if (a3 || (a3 = Ve), t7.size != e6.size && !l2)
                      return false;
                    var u2 = s4.get(t7);
                    if (u2)
                      return u2 == e6;
                    i5 |= 2, s4.set(t7, e6);
                    var p3 = Vr(a3(t7), a3(e6), i5, r6, o4, s4);
                    return s4.delete(t7), p3;
                  case b:
                    if (An)
                      return An.call(t7) == An.call(e6);
                }
                return false;
              }(t6, e5, p2, n4, i4, r5, o3);
            if (!(1 & n4)) {
              var A2 = T2 && wt2.call(t6, "__wrapped__"), R2 = E2 && wt2.call(e5, "__wrapped__");
              if (A2 || R2) {
                var P2 = A2 ? t6.value() : t6, C2 = R2 ? e5.value() : e5;
                return o3 || (o3 = new Un()), r5(P2, C2, n4, i4, o3);
              }
            }
            if (!M2)
              return false;
            return o3 || (o3 = new Un()), function(t7, e6, n5, i5, r6, o4) {
              var s4 = 1 & n5, a3 = Xr(t7), l2 = a3.length, u2 = Xr(e6).length;
              if (l2 != u2 && !s4)
                return false;
              var h2 = l2;
              for (; h2--; ) {
                var c2 = a3[h2];
                if (!(s4 ? c2 in e6 : wt2.call(e6, c2)))
                  return false;
              }
              var d2 = o4.get(t7), p3 = o4.get(e6);
              if (d2 && p3)
                return d2 == e6 && p3 == t7;
              var f3 = true;
              o4.set(t7, e6), o4.set(e6, t7);
              var m2 = s4;
              for (; ++h2 < l2; ) {
                c2 = a3[h2];
                var g2 = t7[c2], v2 = e6[c2];
                if (i5)
                  var _2 = s4 ? i5(v2, g2, c2, e6, t7, o4) : i5(g2, v2, c2, t7, e6, o4);
                if (!(_2 === void 0 ? g2 === v2 || r6(g2, v2, n5, i5, o4) : _2)) {
                  f3 = false;
                  break;
                }
                m2 || (m2 = c2 == "constructor");
              }
              if (f3 && !m2) {
                var y2 = t7.constructor, x2 = e6.constructor;
                y2 == x2 || !("constructor" in t7) || !("constructor" in e6) || typeof y2 == "function" && y2 instanceof y2 && typeof x2 == "function" && x2 instanceof x2 || (f3 = false);
              }
              return o4.delete(t7), o4.delete(e6), f3;
            }(t6, e5, n4, i4, r5, o3);
          }(t5, e4, n3, i3, bi, r4));
        }
        function Ti(t5, e4, n3, i3) {
          var r4 = n3.length, o3 = r4, s3 = !i3;
          if (t5 == null)
            return !o3;
          for (t5 = ft2(t5); r4--; ) {
            var a2 = n3[r4];
            if (s3 && a2[2] ? a2[1] !== t5[a2[0]] : !(a2[0] in t5))
              return false;
          }
          for (; ++r4 < o3; ) {
            var l2 = (a2 = n3[r4])[0], u2 = t5[l2], h2 = a2[1];
            if (s3 && a2[2]) {
              if (u2 === void 0 && !(l2 in t5))
                return false;
            } else {
              var c2 = new Un();
              if (i3)
                var d2 = i3(u2, h2, l2, t5, e4, c2);
              if (!(d2 === void 0 ? bi(h2, u2, 3, i3, c2) : d2))
                return false;
            }
          }
          return true;
        }
        function wi(t5) {
          return !(!Vs(t5) || (e4 = t5, Et2 && Et2 in e4)) && (Hs(t5) ? Pt2 : st).test(Ro(t5));
          var e4;
        }
        function Si(t5) {
          return typeof t5 == "function" ? t5 : t5 == null ? qa : typeof t5 == "object" ? Ns(t5) ? Ci(t5[0], t5[1]) : Pi(t5) : nl(t5);
        }
        function Ei(t5) {
          if (!po(t5))
            return sn(t5);
          var e4 = [];
          for (var n3 in ft2(t5))
            wt2.call(t5, n3) && n3 != "constructor" && e4.push(n3);
          return e4;
        }
        function Mi(t5) {
          if (!Vs(t5))
            return function(t6) {
              var e5 = [];
              if (t6 != null)
                for (var n4 in ft2(t6))
                  e5.push(n4);
              return e5;
            }(t5);
          var e4 = po(t5), n3 = [];
          for (var i3 in t5)
            (i3 != "constructor" || !e4 && wt2.call(t5, i3)) && n3.push(i3);
          return n3;
        }
        function Ai(t5, e4) {
          return t5 < e4;
        }
        function Ri(t5, e4) {
          var n3 = -1, r4 = Fs(t5) ? i2(t5.length) : [];
          return ei(t5, function(t6, i3, o3) {
            r4[++n3] = e4(t6, i3, o3);
          }), r4;
        }
        function Pi(t5) {
          var e4 = Qr(t5);
          return e4.length == 1 && e4[0][2] ? mo(e4[0][0], e4[0][1]) : function(n3) {
            return n3 === t5 || Ti(n3, t5, e4);
          };
        }
        function Ci(t5, e4) {
          return uo(t5) && fo(e4) ? mo(Ao(t5), e4) : function(n3) {
            var i3 = ga(n3, t5);
            return i3 === void 0 && i3 === e4 ? va(n3, t5) : bi(e4, i3, 3);
          };
        }
        function Ii(t5, e4, n3, i3, r4) {
          t5 !== e4 && ai(e4, function(o3, s3) {
            if (r4 || (r4 = new Un()), Vs(o3))
              !function(t6, e5, n4, i4, r5, o4, s4) {
                var a3 = yo(t6, n4), l2 = yo(e5, n4), u2 = s4.get(l2);
                if (u2)
                  return void jn(t6, n4, u2);
                var h2 = o4 ? o4(a3, l2, n4 + "", t6, e5, s4) : void 0, c2 = h2 === void 0;
                if (c2) {
                  var d2 = Ns(l2), p2 = !d2 && Us(l2), f2 = !d2 && !p2 && Qs(l2);
                  h2 = l2, d2 || p2 || f2 ? Ns(a3) ? h2 = a3 : Bs(a3) ? h2 = _r(a3) : p2 ? (c2 = false, h2 = dr(l2, true)) : f2 ? (c2 = false, h2 = fr(l2, true)) : h2 = [] : Ys(l2) || Ls(l2) ? (h2 = a3, Ls(a3) ? h2 = aa(a3) : Vs(a3) && !Hs(a3) || (h2 = oo(l2))) : c2 = false;
                }
                c2 && (s4.set(l2, h2), r5(h2, l2, i4, o4, s4), s4.delete(l2));
                jn(t6, n4, h2);
              }(t5, e4, s3, n3, Ii, i3, r4);
            else {
              var a2 = i3 ? i3(yo(t5, s3), o3, s3 + "", t5, e4, r4) : void 0;
              a2 === void 0 && (a2 = o3), jn(t5, s3, a2);
            }
          }, Ta);
        }
        function Oi(t5, e4) {
          var n3 = t5.length;
          if (n3)
            return ao(e4 += e4 < 0 ? n3 : 0, n3) ? t5[e4] : void 0;
        }
        function Li(t5, e4, n3) {
          e4 = e4.length ? pe(e4, function(t6) {
            return Ns(t6) ? function(e5) {
              return di(e5, t6.length === 1 ? t6[0] : t6);
            } : t6;
          }) : [qa];
          var i3 = -1;
          return e4 = pe(e4, Ie($r())), function(t6, e5) {
            var n4 = t6.length;
            for (t6.sort(e5); n4--; )
              t6[n4] = t6[n4].value;
            return t6;
          }(Ri(t5, function(t6, n4, r4) {
            return { criteria: pe(e4, function(e5) {
              return e5(t6);
            }), index: ++i3, value: t6 };
          }), function(t6, e5) {
            return function(t7, e6, n4) {
              var i4 = -1, r4 = t7.criteria, o3 = e6.criteria, s3 = r4.length, a2 = n4.length;
              for (; ++i4 < s3; ) {
                var l2 = mr(r4[i4], o3[i4]);
                if (l2) {
                  if (i4 >= a2)
                    return l2;
                  var u2 = n4[i4];
                  return l2 * (u2 == "desc" ? -1 : 1);
                }
              }
              return t7.index - e6.index;
            }(t6, e5, n3);
          });
        }
        function Ni(t5, e4, n3) {
          for (var i3 = -1, r4 = e4.length, o3 = {}; ++i3 < r4; ) {
            var s3 = e4[i3], a2 = di(t5, s3);
            n3(a2, s3) && zi(o3, lr(s3, t5), a2);
          }
          return o3;
        }
        function Di(t5, e4, n3, i3) {
          var r4 = i3 ? Te : be, o3 = -1, s3 = e4.length, a2 = t5;
          for (t5 === e4 && (e4 = _r(e4)), n3 && (a2 = pe(t5, Ie(n3))); ++o3 < s3; )
            for (var l2 = 0, u2 = e4[o3], h2 = n3 ? n3(u2) : u2; (l2 = r4(a2, h2, l2, i3)) > -1; )
              a2 !== t5 && Yt2.call(a2, l2, 1), Yt2.call(t5, l2, 1);
          return t5;
        }
        function Fi(t5, e4) {
          for (var n3 = t5 ? e4.length : 0, i3 = n3 - 1; n3--; ) {
            var r4 = e4[n3];
            if (n3 == i3 || r4 !== o3) {
              var o3 = r4;
              ao(r4) ? Yt2.call(t5, r4, 1) : tr(t5, r4);
            }
          }
          return t5;
        }
        function Bi(t5, e4) {
          return t5 + tn(cn() * (e4 - t5 + 1));
        }
        function Ui(t5, e4) {
          var n3 = "";
          if (!t5 || e4 < 1 || e4 > 9007199254740991)
            return n3;
          do {
            e4 % 2 && (n3 += t5), (e4 = tn(e4 / 2)) && (t5 += t5);
          } while (e4);
          return n3;
        }
        function ki(t5, e4) {
          return To(go(t5, e4, qa), t5 + "");
        }
        function Gi(t5) {
          return Gn(Ca(t5));
        }
        function Hi(t5, e4) {
          var n3 = Ca(t5);
          return Eo(n3, Jn(e4, 0, n3.length));
        }
        function zi(t5, e4, n3, i3) {
          if (!Vs(t5))
            return t5;
          for (var r4 = -1, o3 = (e4 = lr(e4, t5)).length, s3 = o3 - 1, a2 = t5; a2 != null && ++r4 < o3; ) {
            var l2 = Ao(e4[r4]), u2 = n3;
            if (l2 === "__proto__" || l2 === "constructor" || l2 === "prototype")
              return t5;
            if (r4 != s3) {
              var h2 = a2[l2];
              (u2 = i3 ? i3(h2, l2, a2) : void 0) === void 0 && (u2 = Vs(h2) ? h2 : ao(e4[r4 + 1]) ? [] : {});
            }
            Vn(a2, l2, u2), a2 = a2[l2];
          }
          return t5;
        }
        var ji = yn ? function(t5, e4) {
          return yn.set(t5, e4), t5;
        } : qa, Vi = _e2 ? function(t5, e4) {
          return _e2(t5, "toString", { configurable: true, enumerable: false, value: Va(e4), writable: true });
        } : qa;
        function Wi(t5) {
          return Eo(Ca(t5));
        }
        function Xi(t5, e4, n3) {
          var r4 = -1, o3 = t5.length;
          e4 < 0 && (e4 = -e4 > o3 ? 0 : o3 + e4), (n3 = n3 > o3 ? o3 : n3) < 0 && (n3 += o3), o3 = e4 > n3 ? 0 : n3 - e4 >>> 0, e4 >>>= 0;
          for (var s3 = i2(o3); ++r4 < o3; )
            s3[r4] = t5[r4 + e4];
          return s3;
        }
        function qi(t5, e4) {
          var n3;
          return ei(t5, function(t6, i3, r4) {
            return !(n3 = e4(t6, i3, r4));
          }), !!n3;
        }
        function Yi(t5, e4, n3) {
          var i3 = 0, r4 = t5 == null ? i3 : t5.length;
          if (typeof e4 == "number" && e4 == e4 && r4 <= 2147483647) {
            for (; i3 < r4; ) {
              var o3 = i3 + r4 >>> 1, s3 = t5[o3];
              s3 !== null && !Ks(s3) && (n3 ? s3 <= e4 : s3 < e4) ? i3 = o3 + 1 : r4 = o3;
            }
            return r4;
          }
          return Zi(t5, e4, qa, n3);
        }
        function Zi(t5, e4, n3, i3) {
          var r4 = 0, o3 = t5 == null ? 0 : t5.length;
          if (o3 === 0)
            return 0;
          for (var s3 = (e4 = n3(e4)) != e4, a2 = e4 === null, l2 = Ks(e4), u2 = e4 === void 0; r4 < o3; ) {
            var h2 = tn((r4 + o3) / 2), c2 = n3(t5[h2]), d2 = c2 !== void 0, p2 = c2 === null, f2 = c2 == c2, m2 = Ks(c2);
            if (s3)
              var g2 = i3 || f2;
            else
              g2 = u2 ? f2 && (i3 || d2) : a2 ? f2 && d2 && (i3 || !p2) : l2 ? f2 && d2 && !p2 && (i3 || !m2) : !p2 && !m2 && (i3 ? c2 <= e4 : c2 < e4);
            g2 ? r4 = h2 + 1 : o3 = h2;
          }
          return ln(o3, 4294967294);
        }
        function Ji(t5, e4) {
          for (var n3 = -1, i3 = t5.length, r4 = 0, o3 = []; ++n3 < i3; ) {
            var s3 = t5[n3], a2 = e4 ? e4(s3) : s3;
            if (!n3 || !Cs(a2, l2)) {
              var l2 = a2;
              o3[r4++] = s3 === 0 ? 0 : s3;
            }
          }
          return o3;
        }
        function $i(t5) {
          return typeof t5 == "number" ? t5 : Ks(t5) ? NaN : +t5;
        }
        function Ki(t5) {
          if (typeof t5 == "string")
            return t5;
          if (Ns(t5))
            return pe(t5, Ki) + "";
          if (Ks(t5))
            return Rn ? Rn.call(t5) : "";
          var e4 = t5 + "";
          return e4 == "0" && 1 / t5 == -1 / 0 ? "-0" : e4;
        }
        function Qi(t5, e4, n3) {
          var i3 = -1, r4 = ce, o3 = t5.length, s3 = true, a2 = [], l2 = a2;
          if (n3)
            s3 = false, r4 = de;
          else if (o3 >= 200) {
            var u2 = e4 ? null : Ur(t5);
            if (u2)
              return Ve(u2);
            s3 = false, r4 = Le, l2 = new Bn();
          } else
            l2 = e4 ? [] : a2;
          t:
            for (; ++i3 < o3; ) {
              var h2 = t5[i3], c2 = e4 ? e4(h2) : h2;
              if (h2 = n3 || h2 !== 0 ? h2 : 0, s3 && c2 == c2) {
                for (var d2 = l2.length; d2--; )
                  if (l2[d2] === c2)
                    continue t;
                e4 && l2.push(c2), a2.push(h2);
              } else
                r4(l2, c2, n3) || (l2 !== a2 && l2.push(c2), a2.push(h2));
            }
          return a2;
        }
        function tr(t5, e4) {
          return (t5 = vo(t5, e4 = lr(e4, t5))) == null || delete t5[Ao(Go(e4))];
        }
        function er(t5, e4, n3, i3) {
          return zi(t5, e4, n3(di(t5, e4)), i3);
        }
        function nr(t5, e4, n3, i3) {
          for (var r4 = t5.length, o3 = i3 ? r4 : -1; (i3 ? o3-- : ++o3 < r4) && e4(t5[o3], o3, t5); )
            ;
          return n3 ? Xi(t5, i3 ? 0 : o3, i3 ? o3 + 1 : r4) : Xi(t5, i3 ? o3 + 1 : 0, i3 ? r4 : o3);
        }
        function ir(t5, e4) {
          var n3 = t5;
          return n3 instanceof Ln && (n3 = n3.value()), me(e4, function(t6, e5) {
            return e5.func.apply(e5.thisArg, fe([t6], e5.args));
          }, n3);
        }
        function rr(t5, e4, n3) {
          var r4 = t5.length;
          if (r4 < 2)
            return r4 ? Qi(t5[0]) : [];
          for (var o3 = -1, s3 = i2(r4); ++o3 < r4; )
            for (var a2 = t5[o3], l2 = -1; ++l2 < r4; )
              l2 != o3 && (s3[o3] = ti(s3[o3] || a2, t5[l2], e4, n3));
          return Qi(si(s3, 1), e4, n3);
        }
        function or(t5, e4, n3) {
          for (var i3 = -1, r4 = t5.length, o3 = e4.length, s3 = {}; ++i3 < r4; ) {
            var a2 = i3 < o3 ? e4[i3] : void 0;
            n3(s3, t5[i3], a2);
          }
          return s3;
        }
        function sr(t5) {
          return Bs(t5) ? t5 : [];
        }
        function ar(t5) {
          return typeof t5 == "function" ? t5 : qa;
        }
        function lr(t5, e4) {
          return Ns(t5) ? t5 : uo(t5, e4) ? [t5] : Mo(la(t5));
        }
        var ur = ki;
        function hr(t5, e4, n3) {
          var i3 = t5.length;
          return n3 = n3 === void 0 ? i3 : n3, !e4 && n3 >= i3 ? t5 : Xi(t5, e4, n3);
        }
        var cr = Me2 || function(t5) {
          return qt.clearTimeout(t5);
        };
        function dr(t5, e4) {
          if (e4)
            return t5.slice();
          var n3 = t5.length, i3 = Ft2 ? Ft2(n3) : new t5.constructor(n3);
          return t5.copy(i3), i3;
        }
        function pr(t5) {
          var e4 = new t5.constructor(t5.byteLength);
          return new Nt2(e4).set(new Nt2(t5)), e4;
        }
        function fr(t5, e4) {
          var n3 = e4 ? pr(t5.buffer) : t5.buffer;
          return new t5.constructor(n3, t5.byteOffset, t5.length);
        }
        function mr(t5, e4) {
          if (t5 !== e4) {
            var n3 = t5 !== void 0, i3 = t5 === null, r4 = t5 == t5, o3 = Ks(t5), s3 = e4 !== void 0, a2 = e4 === null, l2 = e4 == e4, u2 = Ks(e4);
            if (!a2 && !u2 && !o3 && t5 > e4 || o3 && s3 && l2 && !a2 && !u2 || i3 && s3 && l2 || !n3 && l2 || !r4)
              return 1;
            if (!i3 && !o3 && !u2 && t5 < e4 || u2 && n3 && r4 && !i3 && !o3 || a2 && n3 && r4 || !s3 && r4 || !l2)
              return -1;
          }
          return 0;
        }
        function gr(t5, e4, n3, r4) {
          for (var o3 = -1, s3 = t5.length, a2 = n3.length, l2 = -1, u2 = e4.length, h2 = an(s3 - a2, 0), c2 = i2(u2 + h2), d2 = !r4; ++l2 < u2; )
            c2[l2] = e4[l2];
          for (; ++o3 < a2; )
            (d2 || o3 < s3) && (c2[n3[o3]] = t5[o3]);
          for (; h2--; )
            c2[l2++] = t5[o3++];
          return c2;
        }
        function vr(t5, e4, n3, r4) {
          for (var o3 = -1, s3 = t5.length, a2 = -1, l2 = n3.length, u2 = -1, h2 = e4.length, c2 = an(s3 - l2, 0), d2 = i2(c2 + h2), p2 = !r4; ++o3 < c2; )
            d2[o3] = t5[o3];
          for (var f2 = o3; ++u2 < h2; )
            d2[f2 + u2] = e4[u2];
          for (; ++a2 < l2; )
            (p2 || o3 < s3) && (d2[f2 + n3[a2]] = t5[o3++]);
          return d2;
        }
        function _r(t5, e4) {
          var n3 = -1, r4 = t5.length;
          for (e4 || (e4 = i2(r4)); ++n3 < r4; )
            e4[n3] = t5[n3];
          return e4;
        }
        function yr(t5, e4, n3, i3) {
          var r4 = !n3;
          n3 || (n3 = {});
          for (var o3 = -1, s3 = e4.length; ++o3 < s3; ) {
            var a2 = e4[o3], l2 = i3 ? i3(n3[a2], t5[a2], a2, n3, t5) : void 0;
            l2 === void 0 && (l2 = t5[a2]), r4 ? Yn(n3, a2, l2) : Vn(n3, a2, l2);
          }
          return n3;
        }
        function xr(t5, e4) {
          return function(n3, i3) {
            var r4 = Ns(n3) ? se : Xn, o3 = e4 ? e4() : {};
            return r4(n3, t5, $r(i3, 2), o3);
          };
        }
        function br(t5) {
          return ki(function(e4, n3) {
            var i3 = -1, r4 = n3.length, o3 = r4 > 1 ? n3[r4 - 1] : void 0, s3 = r4 > 2 ? n3[2] : void 0;
            for (o3 = t5.length > 3 && typeof o3 == "function" ? (r4--, o3) : void 0, s3 && lo(n3[0], n3[1], s3) && (o3 = r4 < 3 ? void 0 : o3, r4 = 1), e4 = ft2(e4); ++i3 < r4; ) {
              var a2 = n3[i3];
              a2 && t5(e4, a2, i3, o3);
            }
            return e4;
          });
        }
        function Tr(t5, e4) {
          return function(n3, i3) {
            if (n3 == null)
              return n3;
            if (!Fs(n3))
              return t5(n3, i3);
            for (var r4 = n3.length, o3 = e4 ? r4 : -1, s3 = ft2(n3); (e4 ? o3-- : ++o3 < r4) && i3(s3[o3], o3, s3) !== false; )
              ;
            return n3;
          };
        }
        function wr(t5) {
          return function(e4, n3, i3) {
            for (var r4 = -1, o3 = ft2(e4), s3 = i3(e4), a2 = s3.length; a2--; ) {
              var l2 = s3[t5 ? a2 : ++r4];
              if (n3(o3[l2], l2, o3) === false)
                break;
            }
            return e4;
          };
        }
        function Sr(t5) {
          return function(e4) {
            var n3 = Ge(e4 = la(e4)) ? qe(e4) : void 0, i3 = n3 ? n3[0] : e4.charAt(0), r4 = n3 ? hr(n3, 1).join("") : e4.slice(1);
            return i3[t5]() + r4;
          };
        }
        function Er(t5) {
          return function(e4) {
            return me(Ha(La(e4).replace(Ot, "")), t5, "");
          };
        }
        function Mr(t5) {
          return function() {
            var e4 = arguments;
            switch (e4.length) {
              case 0:
                return new t5();
              case 1:
                return new t5(e4[0]);
              case 2:
                return new t5(e4[0], e4[1]);
              case 3:
                return new t5(e4[0], e4[1], e4[2]);
              case 4:
                return new t5(e4[0], e4[1], e4[2], e4[3]);
              case 5:
                return new t5(e4[0], e4[1], e4[2], e4[3], e4[4]);
              case 6:
                return new t5(e4[0], e4[1], e4[2], e4[3], e4[4], e4[5]);
              case 7:
                return new t5(e4[0], e4[1], e4[2], e4[3], e4[4], e4[5], e4[6]);
            }
            var n3 = Cn(t5.prototype), i3 = t5.apply(n3, e4);
            return Vs(i3) ? i3 : n3;
          };
        }
        function Ar(t5) {
          return function(e4, n3, i3) {
            var r4 = ft2(e4);
            if (!Fs(e4)) {
              var o3 = $r(n3, 3);
              e4 = ba(e4), n3 = function(t6) {
                return o3(r4[t6], t6, r4);
              };
            }
            var s3 = t5(e4, n3, i3);
            return s3 > -1 ? r4[o3 ? e4[s3] : s3] : void 0;
          };
        }
        function Rr(t5) {
          return Wr(function(e4) {
            var n3 = e4.length, i3 = n3, r4 = On.prototype.thru;
            for (t5 && e4.reverse(); i3--; ) {
              var s3 = e4[i3];
              if (typeof s3 != "function")
                throw new vt2(o2);
              if (r4 && !a2 && Zr(s3) == "wrapper")
                var a2 = new On([], true);
            }
            for (i3 = a2 ? i3 : n3; ++i3 < n3; ) {
              var l2 = Zr(s3 = e4[i3]), u2 = l2 == "wrapper" ? Yr(s3) : void 0;
              a2 = u2 && ho(u2[0]) && u2[1] == 424 && !u2[4].length && u2[9] == 1 ? a2[Zr(u2[0])].apply(a2, u2[3]) : s3.length == 1 && ho(s3) ? a2[l2]() : a2.thru(s3);
            }
            return function() {
              var t6 = arguments, i4 = t6[0];
              if (a2 && t6.length == 1 && Ns(i4))
                return a2.plant(i4).value();
              for (var r5 = 0, o3 = n3 ? e4[r5].apply(this, t6) : i4; ++r5 < n3; )
                o3 = e4[r5].call(this, o3);
              return o3;
            };
          });
        }
        function Pr(t5, e4, n3, r4, o3, s3, a2, l2, u2, h2) {
          var c2 = 128 & e4, d2 = 1 & e4, p2 = 2 & e4, f2 = 24 & e4, m2 = 512 & e4, g2 = p2 ? void 0 : Mr(t5);
          return function v2() {
            for (var _2 = arguments.length, y2 = i2(_2), x2 = _2; x2--; )
              y2[x2] = arguments[x2];
            if (f2)
              var b2 = Jr(v2), T2 = Fe(y2, b2);
            if (r4 && (y2 = gr(y2, r4, o3, f2)), s3 && (y2 = vr(y2, s3, a2, f2)), _2 -= T2, f2 && _2 < h2) {
              var w2 = je(y2, b2);
              return Fr(t5, e4, Pr, v2.placeholder, n3, y2, w2, l2, u2, h2 - _2);
            }
            var S2 = d2 ? n3 : this, E2 = p2 ? S2[t5] : t5;
            return _2 = y2.length, l2 ? y2 = _o(y2, l2) : m2 && _2 > 1 && y2.reverse(), c2 && u2 < _2 && (y2.length = u2), this && this !== qt && this instanceof v2 && (E2 = g2 || Mr(E2)), E2.apply(S2, y2);
          };
        }
        function Cr(t5, e4) {
          return function(n3, i3) {
            return function(t6, e5, n4, i4) {
              return ui(t6, function(t7, r4, o3) {
                e5(i4, n4(t7), r4, o3);
              }), i4;
            }(n3, t5, e4(i3), {});
          };
        }
        function Ir(t5, e4) {
          return function(n3, i3) {
            var r4;
            if (n3 === void 0 && i3 === void 0)
              return e4;
            if (n3 !== void 0 && (r4 = n3), i3 !== void 0) {
              if (r4 === void 0)
                return i3;
              typeof n3 == "string" || typeof i3 == "string" ? (n3 = Ki(n3), i3 = Ki(i3)) : (n3 = $i(n3), i3 = $i(i3)), r4 = t5(n3, i3);
            }
            return r4;
          };
        }
        function Or(t5) {
          return Wr(function(e4) {
            return e4 = pe(e4, Ie($r())), ki(function(n3) {
              var i3 = this;
              return t5(e4, function(t6) {
                return oe(t6, i3, n3);
              });
            });
          });
        }
        function Lr(t5, e4) {
          var n3 = (e4 = e4 === void 0 ? " " : Ki(e4)).length;
          if (n3 < 2)
            return n3 ? Ui(e4, t5) : e4;
          var i3 = Ui(e4, Qe(t5 / Xe(e4)));
          return Ge(e4) ? hr(qe(i3), 0, t5).join("") : i3.slice(0, t5);
        }
        function Nr(t5) {
          return function(e4, n3, r4) {
            return r4 && typeof r4 != "number" && lo(e4, n3, r4) && (n3 = r4 = void 0), e4 = ia(e4), n3 === void 0 ? (n3 = e4, e4 = 0) : n3 = ia(n3), function(t6, e5, n4, r5) {
              for (var o3 = -1, s3 = an(Qe((e5 - t6) / (n4 || 1)), 0), a2 = i2(s3); s3--; )
                a2[r5 ? s3 : ++o3] = t6, t6 += n4;
              return a2;
            }(e4, n3, r4 = r4 === void 0 ? e4 < n3 ? 1 : -1 : ia(r4), t5);
          };
        }
        function Dr(t5) {
          return function(e4, n3) {
            return typeof e4 == "string" && typeof n3 == "string" || (e4 = sa(e4), n3 = sa(n3)), t5(e4, n3);
          };
        }
        function Fr(t5, e4, n3, i3, r4, o3, s3, a2, l2, u2) {
          var h2 = 8 & e4;
          e4 |= h2 ? 32 : 64, 4 & (e4 &= ~(h2 ? 64 : 32)) || (e4 &= -4);
          var c2 = [t5, e4, r4, h2 ? o3 : void 0, h2 ? s3 : void 0, h2 ? void 0 : o3, h2 ? void 0 : s3, a2, l2, u2], d2 = n3.apply(void 0, c2);
          return ho(t5) && xo(d2, c2), d2.placeholder = i3, wo(d2, t5, e4);
        }
        function Br(t5) {
          var e4 = pt2[t5];
          return function(t6, n3) {
            if (t6 = sa(t6), (n3 = n3 == null ? 0 : ln(ra(n3), 292)) && rn(t6)) {
              var i3 = (la(t6) + "e").split("e");
              return +((i3 = (la(e4(i3[0] + "e" + (+i3[1] + n3))) + "e").split("e"))[0] + "e" + (+i3[1] - n3));
            }
            return e4(t6);
          };
        }
        var Ur = gn && 1 / Ve(new gn([, -0]))[1] == 1 / 0 ? function(t5) {
          return new gn(t5);
        } : Ka;
        function kr(t5) {
          return function(e4) {
            var n3 = io(e4);
            return n3 == m ? He(e4) : n3 == y ? We(e4) : function(t6, e5) {
              return pe(e5, function(e6) {
                return [e6, t6[e6]];
              });
            }(e4, t5(e4));
          };
        }
        function Gr(t5, e4, n3, r4, a2, l2, u2, h2) {
          var c2 = 2 & e4;
          if (!c2 && typeof t5 != "function")
            throw new vt2(o2);
          var d2 = r4 ? r4.length : 0;
          if (d2 || (e4 &= -97, r4 = a2 = void 0), u2 = u2 === void 0 ? u2 : an(ra(u2), 0), h2 = h2 === void 0 ? h2 : ra(h2), d2 -= a2 ? a2.length : 0, 64 & e4) {
            var p2 = r4, f2 = a2;
            r4 = a2 = void 0;
          }
          var m2 = c2 ? void 0 : Yr(t5), g2 = [t5, e4, n3, r4, a2, p2, f2, l2, u2, h2];
          if (m2 && function(t6, e5) {
            var n4 = t6[1], i3 = e5[1], r5 = n4 | i3, o3 = r5 < 131, a3 = i3 == 128 && n4 == 8 || i3 == 128 && n4 == 256 && t6[7].length <= e5[8] || i3 == 384 && e5[7].length <= e5[8] && n4 == 8;
            if (!o3 && !a3)
              return t6;
            1 & i3 && (t6[2] = e5[2], r5 |= 1 & n4 ? 0 : 4);
            var l3 = e5[3];
            if (l3) {
              var u3 = t6[3];
              t6[3] = u3 ? gr(u3, l3, e5[4]) : l3, t6[4] = u3 ? je(t6[3], s2) : e5[4];
            }
            (l3 = e5[5]) && (u3 = t6[5], t6[5] = u3 ? vr(u3, l3, e5[6]) : l3, t6[6] = u3 ? je(t6[5], s2) : e5[6]);
            (l3 = e5[7]) && (t6[7] = l3);
            128 & i3 && (t6[8] = t6[8] == null ? e5[8] : ln(t6[8], e5[8]));
            t6[9] == null && (t6[9] = e5[9]);
            t6[0] = e5[0], t6[1] = r5;
          }(g2, m2), t5 = g2[0], e4 = g2[1], n3 = g2[2], r4 = g2[3], a2 = g2[4], !(h2 = g2[9] = g2[9] === void 0 ? c2 ? 0 : t5.length : an(g2[9] - d2, 0)) && 24 & e4 && (e4 &= -25), e4 && e4 != 1)
            v2 = e4 == 8 || e4 == 16 ? function(t6, e5, n4) {
              var r5 = Mr(t6);
              return function o3() {
                for (var s3 = arguments.length, a3 = i2(s3), l3 = s3, u3 = Jr(o3); l3--; )
                  a3[l3] = arguments[l3];
                var h3 = s3 < 3 && a3[0] !== u3 && a3[s3 - 1] !== u3 ? [] : je(a3, u3);
                if ((s3 -= h3.length) < n4)
                  return Fr(t6, e5, Pr, o3.placeholder, void 0, a3, h3, void 0, void 0, n4 - s3);
                var c3 = this && this !== qt && this instanceof o3 ? r5 : t6;
                return oe(c3, this, a3);
              };
            }(t5, e4, h2) : e4 != 32 && e4 != 33 || a2.length ? Pr.apply(void 0, g2) : function(t6, e5, n4, r5) {
              var o3 = 1 & e5, s3 = Mr(t6);
              return function e6() {
                for (var a3 = -1, l3 = arguments.length, u3 = -1, h3 = r5.length, c3 = i2(h3 + l3), d3 = this && this !== qt && this instanceof e6 ? s3 : t6; ++u3 < h3; )
                  c3[u3] = r5[u3];
                for (; l3--; )
                  c3[u3++] = arguments[++a3];
                return oe(d3, o3 ? n4 : this, c3);
              };
            }(t5, e4, n3, r4);
          else
            var v2 = function(t6, e5, n4) {
              var i3 = 1 & e5, r5 = Mr(t6);
              return function e6() {
                var o3 = this && this !== qt && this instanceof e6 ? r5 : t6;
                return o3.apply(i3 ? n4 : this, arguments);
              };
            }(t5, e4, n3);
          return wo((m2 ? ji : xo)(v2, g2), t5, e4);
        }
        function Hr(t5, e4, n3, i3) {
          return t5 === void 0 || Cs(t5, xt2[n3]) && !wt2.call(i3, n3) ? e4 : t5;
        }
        function zr(t5, e4, n3, i3, r4, o3) {
          return Vs(t5) && Vs(e4) && (o3.set(e4, t5), Ii(t5, e4, void 0, zr, o3), o3.delete(e4)), t5;
        }
        function jr(t5) {
          return Ys(t5) ? void 0 : t5;
        }
        function Vr(t5, e4, n3, i3, r4, o3) {
          var s3 = 1 & n3, a2 = t5.length, l2 = e4.length;
          if (a2 != l2 && !(s3 && l2 > a2))
            return false;
          var u2 = o3.get(t5), h2 = o3.get(e4);
          if (u2 && h2)
            return u2 == e4 && h2 == t5;
          var c2 = -1, d2 = true, p2 = 2 & n3 ? new Bn() : void 0;
          for (o3.set(t5, e4), o3.set(e4, t5); ++c2 < a2; ) {
            var f2 = t5[c2], m2 = e4[c2];
            if (i3)
              var g2 = s3 ? i3(m2, f2, c2, e4, t5, o3) : i3(f2, m2, c2, t5, e4, o3);
            if (g2 !== void 0) {
              if (g2)
                continue;
              d2 = false;
              break;
            }
            if (p2) {
              if (!ve(e4, function(t6, e5) {
                if (!Le(p2, e5) && (f2 === t6 || r4(f2, t6, n3, i3, o3)))
                  return p2.push(e5);
              })) {
                d2 = false;
                break;
              }
            } else if (f2 !== m2 && !r4(f2, m2, n3, i3, o3)) {
              d2 = false;
              break;
            }
          }
          return o3.delete(t5), o3.delete(e4), d2;
        }
        function Wr(t5) {
          return To(go(t5, void 0, Do), t5 + "");
        }
        function Xr(t5) {
          return pi(t5, ba, eo);
        }
        function qr(t5) {
          return pi(t5, Ta, no);
        }
        var Yr = yn ? function(t5) {
          return yn.get(t5);
        } : Ka;
        function Zr(t5) {
          for (var e4 = t5.name + "", n3 = xn[e4], i3 = wt2.call(xn, e4) ? n3.length : 0; i3--; ) {
            var r4 = n3[i3], o3 = r4.func;
            if (o3 == null || o3 == t5)
              return r4.name;
          }
          return e4;
        }
        function Jr(t5) {
          return (wt2.call(Pn, "placeholder") ? Pn : t5).placeholder;
        }
        function $r() {
          var t5 = Pn.iteratee || Ya;
          return t5 = t5 === Ya ? Si : t5, arguments.length ? t5(arguments[0], arguments[1]) : t5;
        }
        function Kr(t5, e4) {
          var n3, i3, r4 = t5.__data__;
          return ((i3 = typeof (n3 = e4)) == "string" || i3 == "number" || i3 == "symbol" || i3 == "boolean" ? n3 !== "__proto__" : n3 === null) ? r4[typeof e4 == "string" ? "string" : "hash"] : r4.map;
        }
        function Qr(t5) {
          for (var e4 = ba(t5), n3 = e4.length; n3--; ) {
            var i3 = e4[n3], r4 = t5[i3];
            e4[n3] = [i3, r4, fo(r4)];
          }
          return e4;
        }
        function to(t5, e4) {
          var n3 = function(t6, e5) {
            return t6 == null ? void 0 : t6[e5];
          }(t5, e4);
          return wi(n3) ? n3 : void 0;
        }
        var eo = en ? function(t5) {
          return t5 == null ? [] : (t5 = ft2(t5), he(en(t5), function(e4) {
            return Xt2.call(t5, e4);
          }));
        } : ol, no = en ? function(t5) {
          for (var e4 = []; t5; )
            fe(e4, eo(t5)), t5 = zt2(t5);
          return e4;
        } : ol, io = fi;
        function ro(t5, e4, n3) {
          for (var i3 = -1, r4 = (e4 = lr(e4, t5)).length, o3 = false; ++i3 < r4; ) {
            var s3 = Ao(e4[i3]);
            if (!(o3 = t5 != null && n3(t5, s3)))
              break;
            t5 = t5[s3];
          }
          return o3 || ++i3 != r4 ? o3 : !!(r4 = t5 == null ? 0 : t5.length) && js(r4) && ao(s3, r4) && (Ns(t5) || Ls(t5));
        }
        function oo(t5) {
          return typeof t5.constructor != "function" || po(t5) ? {} : Cn(zt2(t5));
        }
        function so(t5) {
          return Ns(t5) || Ls(t5) || !!(Zt2 && t5 && t5[Zt2]);
        }
        function ao(t5, e4) {
          var n3 = typeof t5;
          return !!(e4 = e4 == null ? 9007199254740991 : e4) && (n3 == "number" || n3 != "symbol" && lt.test(t5)) && t5 > -1 && t5 % 1 == 0 && t5 < e4;
        }
        function lo(t5, e4, n3) {
          if (!Vs(n3))
            return false;
          var i3 = typeof e4;
          return !!(i3 == "number" ? Fs(n3) && ao(e4, n3.length) : i3 == "string" && e4 in n3) && Cs(n3[e4], t5);
        }
        function uo(t5, e4) {
          if (Ns(t5))
            return false;
          var n3 = typeof t5;
          return !(n3 != "number" && n3 != "symbol" && n3 != "boolean" && t5 != null && !Ks(t5)) || (V.test(t5) || !j.test(t5) || e4 != null && t5 in ft2(e4));
        }
        function ho(t5) {
          var e4 = Zr(t5), n3 = Pn[e4];
          if (typeof n3 != "function" || !(e4 in Ln.prototype))
            return false;
          if (t5 === n3)
            return true;
          var i3 = Yr(n3);
          return !!i3 && t5 === i3[0];
        }
        (pn && io(new pn(new ArrayBuffer(1))) != S || fn && io(new fn()) != m || mn && io(mn.resolve()) != "[object Promise]" || gn && io(new gn()) != y || vn && io(new vn()) != T) && (io = function(t5) {
          var e4 = fi(t5), n3 = e4 == v ? t5.constructor : void 0, i3 = n3 ? Ro(n3) : "";
          if (i3)
            switch (i3) {
              case bn:
                return S;
              case Tn:
                return m;
              case wn:
                return "[object Promise]";
              case Sn:
                return y;
              case En:
                return T;
            }
          return e4;
        });
        var co = bt2 ? Hs : sl;
        function po(t5) {
          var e4 = t5 && t5.constructor;
          return t5 === (typeof e4 == "function" && e4.prototype || xt2);
        }
        function fo(t5) {
          return t5 == t5 && !Vs(t5);
        }
        function mo(t5, e4) {
          return function(n3) {
            return n3 != null && (n3[t5] === e4 && (e4 !== void 0 || t5 in ft2(n3)));
          };
        }
        function go(t5, e4, n3) {
          return e4 = an(e4 === void 0 ? t5.length - 1 : e4, 0), function() {
            for (var r4 = arguments, o3 = -1, s3 = an(r4.length - e4, 0), a2 = i2(s3); ++o3 < s3; )
              a2[o3] = r4[e4 + o3];
            o3 = -1;
            for (var l2 = i2(e4 + 1); ++o3 < e4; )
              l2[o3] = r4[o3];
            return l2[e4] = n3(a2), oe(t5, this, l2);
          };
        }
        function vo(t5, e4) {
          return e4.length < 2 ? t5 : di(t5, Xi(e4, 0, -1));
        }
        function _o(t5, e4) {
          for (var n3 = t5.length, i3 = ln(e4.length, n3), r4 = _r(t5); i3--; ) {
            var o3 = e4[i3];
            t5[i3] = ao(o3, n3) ? r4[o3] : void 0;
          }
          return t5;
        }
        function yo(t5, e4) {
          if ((e4 !== "constructor" || typeof t5[e4] != "function") && e4 != "__proto__")
            return t5[e4];
        }
        var xo = So(ji), bo = Ke || function(t5, e4) {
          return qt.setTimeout(t5, e4);
        }, To = So(Vi);
        function wo(t5, e4, n3) {
          var i3 = e4 + "";
          return To(t5, function(t6, e5) {
            var n4 = e5.length;
            if (!n4)
              return t6;
            var i4 = n4 - 1;
            return e5[i4] = (n4 > 1 ? "& " : "") + e5[i4], e5 = e5.join(n4 > 2 ? ", " : " "), t6.replace(J, "{\n/* [wrapped with " + e5 + "] */\n");
          }(i3, function(t6, e5) {
            return ae(a, function(n4) {
              var i4 = "_." + n4[0];
              e5 & n4[1] && !ce(t6, i4) && t6.push(i4);
            }), t6.sort();
          }(function(t6) {
            var e5 = t6.match($);
            return e5 ? e5[1].split(K) : [];
          }(i3), n3)));
        }
        function So(t5) {
          var e4 = 0, n3 = 0;
          return function() {
            var i3 = un(), r4 = 16 - (i3 - n3);
            if (n3 = i3, r4 > 0) {
              if (++e4 >= 800)
                return arguments[0];
            } else
              e4 = 0;
            return t5.apply(void 0, arguments);
          };
        }
        function Eo(t5, e4) {
          var n3 = -1, i3 = t5.length, r4 = i3 - 1;
          for (e4 = e4 === void 0 ? i3 : e4; ++n3 < e4; ) {
            var o3 = Bi(n3, r4), s3 = t5[o3];
            t5[o3] = t5[n3], t5[n3] = s3;
          }
          return t5.length = e4, t5;
        }
        var Mo = function(t5) {
          var e4 = Ss(t5, function(t6) {
            return n3.size === 500 && n3.clear(), t6;
          }), n3 = e4.cache;
          return e4;
        }(function(t5) {
          var e4 = [];
          return t5.charCodeAt(0) === 46 && e4.push(""), t5.replace(W, function(t6, n3, i3, r4) {
            e4.push(i3 ? r4.replace(et, "$1") : n3 || t6);
          }), e4;
        });
        function Ao(t5) {
          if (typeof t5 == "string" || Ks(t5))
            return t5;
          var e4 = t5 + "";
          return e4 == "0" && 1 / t5 == -1 / 0 ? "-0" : e4;
        }
        function Ro(t5) {
          if (t5 != null) {
            try {
              return Tt2.call(t5);
            } catch (t6) {
            }
            try {
              return t5 + "";
            } catch (t6) {
            }
          }
          return "";
        }
        function Po(t5) {
          if (t5 instanceof Ln)
            return t5.clone();
          var e4 = new On(t5.__wrapped__, t5.__chain__);
          return e4.__actions__ = _r(t5.__actions__), e4.__index__ = t5.__index__, e4.__values__ = t5.__values__, e4;
        }
        var Co = ki(function(t5, e4) {
          return Bs(t5) ? ti(t5, si(e4, 1, Bs, true)) : [];
        }), Io = ki(function(t5, e4) {
          var n3 = Go(e4);
          return Bs(n3) && (n3 = void 0), Bs(t5) ? ti(t5, si(e4, 1, Bs, true), $r(n3, 2)) : [];
        }), Oo = ki(function(t5, e4) {
          var n3 = Go(e4);
          return Bs(n3) && (n3 = void 0), Bs(t5) ? ti(t5, si(e4, 1, Bs, true), void 0, n3) : [];
        });
        function Lo(t5, e4, n3) {
          var i3 = t5 == null ? 0 : t5.length;
          if (!i3)
            return -1;
          var r4 = n3 == null ? 0 : ra(n3);
          return r4 < 0 && (r4 = an(i3 + r4, 0)), xe(t5, $r(e4, 3), r4);
        }
        function No(t5, e4, n3) {
          var i3 = t5 == null ? 0 : t5.length;
          if (!i3)
            return -1;
          var r4 = i3 - 1;
          return n3 !== void 0 && (r4 = ra(n3), r4 = n3 < 0 ? an(i3 + r4, 0) : ln(r4, i3 - 1)), xe(t5, $r(e4, 3), r4, true);
        }
        function Do(t5) {
          return (t5 == null ? 0 : t5.length) ? si(t5, 1) : [];
        }
        function Fo(t5) {
          return t5 && t5.length ? t5[0] : void 0;
        }
        var Bo = ki(function(t5) {
          var e4 = pe(t5, sr);
          return e4.length && e4[0] === t5[0] ? _i(e4) : [];
        }), Uo = ki(function(t5) {
          var e4 = Go(t5), n3 = pe(t5, sr);
          return e4 === Go(n3) ? e4 = void 0 : n3.pop(), n3.length && n3[0] === t5[0] ? _i(n3, $r(e4, 2)) : [];
        }), ko = ki(function(t5) {
          var e4 = Go(t5), n3 = pe(t5, sr);
          return (e4 = typeof e4 == "function" ? e4 : void 0) && n3.pop(), n3.length && n3[0] === t5[0] ? _i(n3, void 0, e4) : [];
        });
        function Go(t5) {
          var e4 = t5 == null ? 0 : t5.length;
          return e4 ? t5[e4 - 1] : void 0;
        }
        var Ho = ki(zo);
        function zo(t5, e4) {
          return t5 && t5.length && e4 && e4.length ? Di(t5, e4) : t5;
        }
        var jo = Wr(function(t5, e4) {
          var n3 = t5 == null ? 0 : t5.length, i3 = Zn(t5, e4);
          return Fi(t5, pe(e4, function(t6) {
            return ao(t6, n3) ? +t6 : t6;
          }).sort(mr)), i3;
        });
        function Vo(t5) {
          return t5 == null ? t5 : dn.call(t5);
        }
        var Wo = ki(function(t5) {
          return Qi(si(t5, 1, Bs, true));
        }), Xo = ki(function(t5) {
          var e4 = Go(t5);
          return Bs(e4) && (e4 = void 0), Qi(si(t5, 1, Bs, true), $r(e4, 2));
        }), qo = ki(function(t5) {
          var e4 = Go(t5);
          return e4 = typeof e4 == "function" ? e4 : void 0, Qi(si(t5, 1, Bs, true), void 0, e4);
        });
        function Yo(t5) {
          if (!t5 || !t5.length)
            return [];
          var e4 = 0;
          return t5 = he(t5, function(t6) {
            if (Bs(t6))
              return e4 = an(t6.length, e4), true;
          }), Pe(e4, function(e5) {
            return pe(t5, Ee(e5));
          });
        }
        function Zo(t5, e4) {
          if (!t5 || !t5.length)
            return [];
          var n3 = Yo(t5);
          return e4 == null ? n3 : pe(n3, function(t6) {
            return oe(e4, void 0, t6);
          });
        }
        var Jo = ki(function(t5, e4) {
          return Bs(t5) ? ti(t5, e4) : [];
        }), $o = ki(function(t5) {
          return rr(he(t5, Bs));
        }), Ko = ki(function(t5) {
          var e4 = Go(t5);
          return Bs(e4) && (e4 = void 0), rr(he(t5, Bs), $r(e4, 2));
        }), Qo = ki(function(t5) {
          var e4 = Go(t5);
          return e4 = typeof e4 == "function" ? e4 : void 0, rr(he(t5, Bs), void 0, e4);
        }), ts = ki(Yo);
        var es = ki(function(t5) {
          var e4 = t5.length, n3 = e4 > 1 ? t5[e4 - 1] : void 0;
          return n3 = typeof n3 == "function" ? (t5.pop(), n3) : void 0, Zo(t5, n3);
        });
        function ns(t5) {
          var e4 = Pn(t5);
          return e4.__chain__ = true, e4;
        }
        function is(t5, e4) {
          return e4(t5);
        }
        var rs = Wr(function(t5) {
          var e4 = t5.length, n3 = e4 ? t5[0] : 0, i3 = this.__wrapped__, r4 = function(e5) {
            return Zn(e5, t5);
          };
          return !(e4 > 1 || this.__actions__.length) && i3 instanceof Ln && ao(n3) ? ((i3 = i3.slice(n3, +n3 + (e4 ? 1 : 0))).__actions__.push({ func: is, args: [r4], thisArg: void 0 }), new On(i3, this.__chain__).thru(function(t6) {
            return e4 && !t6.length && t6.push(void 0), t6;
          })) : this.thru(r4);
        });
        var os = xr(function(t5, e4, n3) {
          wt2.call(t5, n3) ? ++t5[n3] : Yn(t5, n3, 1);
        });
        var ss = Ar(Lo), as = Ar(No);
        function ls(t5, e4) {
          return (Ns(t5) ? ae : ei)(t5, $r(e4, 3));
        }
        function us(t5, e4) {
          return (Ns(t5) ? le : ni)(t5, $r(e4, 3));
        }
        var hs = xr(function(t5, e4, n3) {
          wt2.call(t5, n3) ? t5[n3].push(e4) : Yn(t5, n3, [e4]);
        });
        var cs2 = ki(function(t5, e4, n3) {
          var r4 = -1, o3 = typeof e4 == "function", s3 = Fs(t5) ? i2(t5.length) : [];
          return ei(t5, function(t6) {
            s3[++r4] = o3 ? oe(e4, t6, n3) : yi(t6, e4, n3);
          }), s3;
        }), ds = xr(function(t5, e4, n3) {
          Yn(t5, n3, e4);
        });
        function ps(t5, e4) {
          return (Ns(t5) ? pe : Ri)(t5, $r(e4, 3));
        }
        var fs = xr(function(t5, e4, n3) {
          t5[n3 ? 0 : 1].push(e4);
        }, function() {
          return [[], []];
        });
        var ms = ki(function(t5, e4) {
          if (t5 == null)
            return [];
          var n3 = e4.length;
          return n3 > 1 && lo(t5, e4[0], e4[1]) ? e4 = [] : n3 > 2 && lo(e4[0], e4[1], e4[2]) && (e4 = [e4[0]]), Li(t5, si(e4, 1), []);
        }), gs = $e || function() {
          return qt.Date.now();
        };
        function vs(t5, e4, n3) {
          return e4 = n3 ? void 0 : e4, Gr(t5, 128, void 0, void 0, void 0, void 0, e4 = t5 && e4 == null ? t5.length : e4);
        }
        function _s(t5, e4) {
          var n3;
          if (typeof e4 != "function")
            throw new vt2(o2);
          return t5 = ra(t5), function() {
            return --t5 > 0 && (n3 = e4.apply(this, arguments)), t5 <= 1 && (e4 = void 0), n3;
          };
        }
        var ys = ki(function(t5, e4, n3) {
          var i3 = 1;
          if (n3.length) {
            var r4 = je(n3, Jr(ys));
            i3 |= 32;
          }
          return Gr(t5, i3, e4, n3, r4);
        }), xs = ki(function(t5, e4, n3) {
          var i3 = 3;
          if (n3.length) {
            var r4 = je(n3, Jr(xs));
            i3 |= 32;
          }
          return Gr(e4, i3, t5, n3, r4);
        });
        function bs(t5, e4, n3) {
          var i3, r4, s3, a2, l2, u2, h2 = 0, c2 = false, d2 = false, p2 = true;
          if (typeof t5 != "function")
            throw new vt2(o2);
          function f2(e5) {
            var n4 = i3, o3 = r4;
            return i3 = r4 = void 0, h2 = e5, a2 = t5.apply(o3, n4);
          }
          function m2(t6) {
            return h2 = t6, l2 = bo(v2, e4), c2 ? f2(t6) : a2;
          }
          function g2(t6) {
            var n4 = t6 - u2;
            return u2 === void 0 || n4 >= e4 || n4 < 0 || d2 && t6 - h2 >= s3;
          }
          function v2() {
            var t6 = gs();
            if (g2(t6))
              return _2(t6);
            l2 = bo(v2, function(t7) {
              var n4 = e4 - (t7 - u2);
              return d2 ? ln(n4, s3 - (t7 - h2)) : n4;
            }(t6));
          }
          function _2(t6) {
            return l2 = void 0, p2 && i3 ? f2(t6) : (i3 = r4 = void 0, a2);
          }
          function y2() {
            var t6 = gs(), n4 = g2(t6);
            if (i3 = arguments, r4 = this, u2 = t6, n4) {
              if (l2 === void 0)
                return m2(u2);
              if (d2)
                return cr(l2), l2 = bo(v2, e4), f2(u2);
            }
            return l2 === void 0 && (l2 = bo(v2, e4)), a2;
          }
          return e4 = sa(e4) || 0, Vs(n3) && (c2 = !!n3.leading, s3 = (d2 = "maxWait" in n3) ? an(sa(n3.maxWait) || 0, e4) : s3, p2 = "trailing" in n3 ? !!n3.trailing : p2), y2.cancel = function() {
            l2 !== void 0 && cr(l2), h2 = 0, i3 = u2 = r4 = l2 = void 0;
          }, y2.flush = function() {
            return l2 === void 0 ? a2 : _2(gs());
          }, y2;
        }
        var Ts = ki(function(t5, e4) {
          return Qn(t5, 1, e4);
        }), ws = ki(function(t5, e4, n3) {
          return Qn(t5, sa(e4) || 0, n3);
        });
        function Ss(t5, e4) {
          if (typeof t5 != "function" || e4 != null && typeof e4 != "function")
            throw new vt2(o2);
          var n3 = function() {
            var i3 = arguments, r4 = e4 ? e4.apply(this, i3) : i3[0], o3 = n3.cache;
            if (o3.has(r4))
              return o3.get(r4);
            var s3 = t5.apply(this, i3);
            return n3.cache = o3.set(r4, s3) || o3, s3;
          };
          return n3.cache = new (Ss.Cache || Fn)(), n3;
        }
        function Es(t5) {
          if (typeof t5 != "function")
            throw new vt2(o2);
          return function() {
            var e4 = arguments;
            switch (e4.length) {
              case 0:
                return !t5.call(this);
              case 1:
                return !t5.call(this, e4[0]);
              case 2:
                return !t5.call(this, e4[0], e4[1]);
              case 3:
                return !t5.call(this, e4[0], e4[1], e4[2]);
            }
            return !t5.apply(this, e4);
          };
        }
        Ss.Cache = Fn;
        var Ms = ur(function(t5, e4) {
          var n3 = (e4 = e4.length == 1 && Ns(e4[0]) ? pe(e4[0], Ie($r())) : pe(si(e4, 1), Ie($r()))).length;
          return ki(function(i3) {
            for (var r4 = -1, o3 = ln(i3.length, n3); ++r4 < o3; )
              i3[r4] = e4[r4].call(this, i3[r4]);
            return oe(t5, this, i3);
          });
        }), As = ki(function(t5, e4) {
          return Gr(t5, 32, void 0, e4, je(e4, Jr(As)));
        }), Rs = ki(function(t5, e4) {
          return Gr(t5, 64, void 0, e4, je(e4, Jr(Rs)));
        }), Ps = Wr(function(t5, e4) {
          return Gr(t5, 256, void 0, void 0, void 0, e4);
        });
        function Cs(t5, e4) {
          return t5 === e4 || t5 != t5 && e4 != e4;
        }
        var Is = Dr(mi), Os = Dr(function(t5, e4) {
          return t5 >= e4;
        }), Ls = xi(function() {
          return arguments;
        }()) ? xi : function(t5) {
          return Ws(t5) && wt2.call(t5, "callee") && !Xt2.call(t5, "callee");
        }, Ns = i2.isArray, Ds = Qt ? Ie(Qt) : function(t5) {
          return Ws(t5) && fi(t5) == w;
        };
        function Fs(t5) {
          return t5 != null && js(t5.length) && !Hs(t5);
        }
        function Bs(t5) {
          return Ws(t5) && Fs(t5);
        }
        var Us = nn || sl, ks = te ? Ie(te) : function(t5) {
          return Ws(t5) && fi(t5) == c;
        };
        function Gs(t5) {
          if (!Ws(t5))
            return false;
          var e4 = fi(t5);
          return e4 == d || e4 == "[object DOMException]" || typeof t5.message == "string" && typeof t5.name == "string" && !Ys(t5);
        }
        function Hs(t5) {
          if (!Vs(t5))
            return false;
          var e4 = fi(t5);
          return e4 == p || e4 == f || e4 == "[object AsyncFunction]" || e4 == "[object Proxy]";
        }
        function zs(t5) {
          return typeof t5 == "number" && t5 == ra(t5);
        }
        function js(t5) {
          return typeof t5 == "number" && t5 > -1 && t5 % 1 == 0 && t5 <= 9007199254740991;
        }
        function Vs(t5) {
          var e4 = typeof t5;
          return t5 != null && (e4 == "object" || e4 == "function");
        }
        function Ws(t5) {
          return t5 != null && typeof t5 == "object";
        }
        var Xs = ee ? Ie(ee) : function(t5) {
          return Ws(t5) && io(t5) == m;
        };
        function qs(t5) {
          return typeof t5 == "number" || Ws(t5) && fi(t5) == g;
        }
        function Ys(t5) {
          if (!Ws(t5) || fi(t5) != v)
            return false;
          var e4 = zt2(t5);
          if (e4 === null)
            return true;
          var n3 = wt2.call(e4, "constructor") && e4.constructor;
          return typeof n3 == "function" && n3 instanceof n3 && Tt2.call(n3) == At2;
        }
        var Zs = ne ? Ie(ne) : function(t5) {
          return Ws(t5) && fi(t5) == _;
        };
        var Js = ie ? Ie(ie) : function(t5) {
          return Ws(t5) && io(t5) == y;
        };
        function $s(t5) {
          return typeof t5 == "string" || !Ns(t5) && Ws(t5) && fi(t5) == x;
        }
        function Ks(t5) {
          return typeof t5 == "symbol" || Ws(t5) && fi(t5) == b;
        }
        var Qs = re ? Ie(re) : function(t5) {
          return Ws(t5) && js(t5.length) && !!Gt[fi(t5)];
        };
        var ta = Dr(Ai), ea = Dr(function(t5, e4) {
          return t5 <= e4;
        });
        function na(t5) {
          if (!t5)
            return [];
          if (Fs(t5))
            return $s(t5) ? qe(t5) : _r(t5);
          if ($t2 && t5[$t2])
            return function(t6) {
              for (var e5, n3 = []; !(e5 = t6.next()).done; )
                n3.push(e5.value);
              return n3;
            }(t5[$t2]());
          var e4 = io(t5);
          return (e4 == m ? He : e4 == y ? Ve : Ca)(t5);
        }
        function ia(t5) {
          return t5 ? (t5 = sa(t5)) === 1 / 0 || t5 === -1 / 0 ? 17976931348623157e292 * (t5 < 0 ? -1 : 1) : t5 == t5 ? t5 : 0 : t5 === 0 ? t5 : 0;
        }
        function ra(t5) {
          var e4 = ia(t5), n3 = e4 % 1;
          return e4 == e4 ? n3 ? e4 - n3 : e4 : 0;
        }
        function oa(t5) {
          return t5 ? Jn(ra(t5), 0, 4294967295) : 0;
        }
        function sa(t5) {
          if (typeof t5 == "number")
            return t5;
          if (Ks(t5))
            return NaN;
          if (Vs(t5)) {
            var e4 = typeof t5.valueOf == "function" ? t5.valueOf() : t5;
            t5 = Vs(e4) ? e4 + "" : e4;
          }
          if (typeof t5 != "string")
            return t5 === 0 ? t5 : +t5;
          t5 = Ce(t5);
          var n3 = ot.test(t5);
          return n3 || at.test(t5) ? Vt(t5.slice(2), n3 ? 2 : 8) : rt.test(t5) ? NaN : +t5;
        }
        function aa(t5) {
          return yr(t5, Ta(t5));
        }
        function la(t5) {
          return t5 == null ? "" : Ki(t5);
        }
        var ua = br(function(t5, e4) {
          if (po(e4) || Fs(e4))
            yr(e4, ba(e4), t5);
          else
            for (var n3 in e4)
              wt2.call(e4, n3) && Vn(t5, n3, e4[n3]);
        }), ha = br(function(t5, e4) {
          yr(e4, Ta(e4), t5);
        }), ca = br(function(t5, e4, n3, i3) {
          yr(e4, Ta(e4), t5, i3);
        }), da = br(function(t5, e4, n3, i3) {
          yr(e4, ba(e4), t5, i3);
        }), pa = Wr(Zn);
        var fa = ki(function(t5, e4) {
          t5 = ft2(t5);
          var n3 = -1, i3 = e4.length, r4 = i3 > 2 ? e4[2] : void 0;
          for (r4 && lo(e4[0], e4[1], r4) && (i3 = 1); ++n3 < i3; )
            for (var o3 = e4[n3], s3 = Ta(o3), a2 = -1, l2 = s3.length; ++a2 < l2; ) {
              var u2 = s3[a2], h2 = t5[u2];
              (h2 === void 0 || Cs(h2, xt2[u2]) && !wt2.call(t5, u2)) && (t5[u2] = o3[u2]);
            }
          return t5;
        }), ma = ki(function(t5) {
          return t5.push(void 0, zr), oe(Sa, void 0, t5);
        });
        function ga(t5, e4, n3) {
          var i3 = t5 == null ? void 0 : di(t5, e4);
          return i3 === void 0 ? n3 : i3;
        }
        function va(t5, e4) {
          return t5 != null && ro(t5, e4, vi);
        }
        var _a = Cr(function(t5, e4, n3) {
          e4 != null && typeof e4.toString != "function" && (e4 = Mt2.call(e4)), t5[e4] = n3;
        }, Va(qa)), ya = Cr(function(t5, e4, n3) {
          e4 != null && typeof e4.toString != "function" && (e4 = Mt2.call(e4)), wt2.call(t5, e4) ? t5[e4].push(n3) : t5[e4] = [n3];
        }, $r), xa = ki(yi);
        function ba(t5) {
          return Fs(t5) ? kn(t5) : Ei(t5);
        }
        function Ta(t5) {
          return Fs(t5) ? kn(t5, true) : Mi(t5);
        }
        var wa = br(function(t5, e4, n3) {
          Ii(t5, e4, n3);
        }), Sa = br(function(t5, e4, n3, i3) {
          Ii(t5, e4, n3, i3);
        }), Ea = Wr(function(t5, e4) {
          var n3 = {};
          if (t5 == null)
            return n3;
          var i3 = false;
          e4 = pe(e4, function(e5) {
            return e5 = lr(e5, t5), i3 || (i3 = e5.length > 1), e5;
          }), yr(t5, qr(t5), n3), i3 && (n3 = $n(n3, 7, jr));
          for (var r4 = e4.length; r4--; )
            tr(n3, e4[r4]);
          return n3;
        });
        var Ma = Wr(function(t5, e4) {
          return t5 == null ? {} : function(t6, e5) {
            return Ni(t6, e5, function(e6, n3) {
              return va(t6, n3);
            });
          }(t5, e4);
        });
        function Aa(t5, e4) {
          if (t5 == null)
            return {};
          var n3 = pe(qr(t5), function(t6) {
            return [t6];
          });
          return e4 = $r(e4), Ni(t5, n3, function(t6, n4) {
            return e4(t6, n4[0]);
          });
        }
        var Ra = kr(ba), Pa = kr(Ta);
        function Ca(t5) {
          return t5 == null ? [] : Oe(t5, ba(t5));
        }
        var Ia = Er(function(t5, e4, n3) {
          return e4 = e4.toLowerCase(), t5 + (n3 ? Oa(e4) : e4);
        });
        function Oa(t5) {
          return Ga(la(t5).toLowerCase());
        }
        function La(t5) {
          return (t5 = la(t5)) && t5.replace(ut, Be).replace(Lt, "");
        }
        var Na = Er(function(t5, e4, n3) {
          return t5 + (n3 ? "-" : "") + e4.toLowerCase();
        }), Da = Er(function(t5, e4, n3) {
          return t5 + (n3 ? " " : "") + e4.toLowerCase();
        }), Fa = Sr("toLowerCase");
        var Ba = Er(function(t5, e4, n3) {
          return t5 + (n3 ? "_" : "") + e4.toLowerCase();
        });
        var Ua = Er(function(t5, e4, n3) {
          return t5 + (n3 ? " " : "") + Ga(e4);
        });
        var ka = Er(function(t5, e4, n3) {
          return t5 + (n3 ? " " : "") + e4.toUpperCase();
        }), Ga = Sr("toUpperCase");
        function Ha(t5, e4, n3) {
          return t5 = la(t5), (e4 = n3 ? void 0 : e4) === void 0 ? function(t6) {
            return Bt.test(t6);
          }(t5) ? function(t6) {
            return t6.match(Dt) || [];
          }(t5) : function(t6) {
            return t6.match(Q) || [];
          }(t5) : t5.match(e4) || [];
        }
        var za = ki(function(t5, e4) {
          try {
            return oe(t5, void 0, e4);
          } catch (t6) {
            return Gs(t6) ? t6 : new Z2(t6);
          }
        }), ja = Wr(function(t5, e4) {
          return ae(e4, function(e5) {
            e5 = Ao(e5), Yn(t5, e5, ys(t5[e5], t5));
          }), t5;
        });
        function Va(t5) {
          return function() {
            return t5;
          };
        }
        var Wa = Rr(), Xa = Rr(true);
        function qa(t5) {
          return t5;
        }
        function Ya(t5) {
          return Si(typeof t5 == "function" ? t5 : $n(t5, 1));
        }
        var Za = ki(function(t5, e4) {
          return function(n3) {
            return yi(n3, t5, e4);
          };
        }), Ja = ki(function(t5, e4) {
          return function(n3) {
            return yi(t5, n3, e4);
          };
        });
        function $a(t5, e4, n3) {
          var i3 = ba(e4), r4 = ci(e4, i3);
          n3 != null || Vs(e4) && (r4.length || !i3.length) || (n3 = e4, e4 = t5, t5 = this, r4 = ci(e4, ba(e4)));
          var o3 = !(Vs(n3) && "chain" in n3 && !n3.chain), s3 = Hs(t5);
          return ae(r4, function(n4) {
            var i4 = e4[n4];
            t5[n4] = i4, s3 && (t5.prototype[n4] = function() {
              var e5 = this.__chain__;
              if (o3 || e5) {
                var n5 = t5(this.__wrapped__), r5 = n5.__actions__ = _r(this.__actions__);
                return r5.push({ func: i4, args: arguments, thisArg: t5 }), n5.__chain__ = e5, n5;
              }
              return i4.apply(t5, fe([this.value()], arguments));
            });
          }), t5;
        }
        function Ka() {
        }
        var Qa = Or(pe), tl = Or(ue), el = Or(ve);
        function nl(t5) {
          return uo(t5) ? Ee(Ao(t5)) : function(t6) {
            return function(e4) {
              return di(e4, t6);
            };
          }(t5);
        }
        var il = Nr(), rl = Nr(true);
        function ol() {
          return [];
        }
        function sl() {
          return false;
        }
        var al = Ir(function(t5, e4) {
          return t5 + e4;
        }, 0), ll = Br("ceil"), ul = Ir(function(t5, e4) {
          return t5 / e4;
        }, 1), hl = Br("floor");
        var cl, dl = Ir(function(t5, e4) {
          return t5 * e4;
        }, 1), pl = Br("round"), fl = Ir(function(t5, e4) {
          return t5 - e4;
        }, 0);
        return Pn.after = function(t5, e4) {
          if (typeof e4 != "function")
            throw new vt2(o2);
          return t5 = ra(t5), function() {
            if (--t5 < 1)
              return e4.apply(this, arguments);
          };
        }, Pn.ary = vs, Pn.assign = ua, Pn.assignIn = ha, Pn.assignInWith = ca, Pn.assignWith = da, Pn.at = pa, Pn.before = _s, Pn.bind = ys, Pn.bindAll = ja, Pn.bindKey = xs, Pn.castArray = function() {
          if (!arguments.length)
            return [];
          var t5 = arguments[0];
          return Ns(t5) ? t5 : [t5];
        }, Pn.chain = ns, Pn.chunk = function(t5, e4, n3) {
          e4 = (n3 ? lo(t5, e4, n3) : e4 === void 0) ? 1 : an(ra(e4), 0);
          var r4 = t5 == null ? 0 : t5.length;
          if (!r4 || e4 < 1)
            return [];
          for (var o3 = 0, s3 = 0, a2 = i2(Qe(r4 / e4)); o3 < r4; )
            a2[s3++] = Xi(t5, o3, o3 += e4);
          return a2;
        }, Pn.compact = function(t5) {
          for (var e4 = -1, n3 = t5 == null ? 0 : t5.length, i3 = 0, r4 = []; ++e4 < n3; ) {
            var o3 = t5[e4];
            o3 && (r4[i3++] = o3);
          }
          return r4;
        }, Pn.concat = function() {
          var t5 = arguments.length;
          if (!t5)
            return [];
          for (var e4 = i2(t5 - 1), n3 = arguments[0], r4 = t5; r4--; )
            e4[r4 - 1] = arguments[r4];
          return fe(Ns(n3) ? _r(n3) : [n3], si(e4, 1));
        }, Pn.cond = function(t5) {
          var e4 = t5 == null ? 0 : t5.length, n3 = $r();
          return t5 = e4 ? pe(t5, function(t6) {
            if (typeof t6[1] != "function")
              throw new vt2(o2);
            return [n3(t6[0]), t6[1]];
          }) : [], ki(function(n4) {
            for (var i3 = -1; ++i3 < e4; ) {
              var r4 = t5[i3];
              if (oe(r4[0], this, n4))
                return oe(r4[1], this, n4);
            }
          });
        }, Pn.conforms = function(t5) {
          return function(t6) {
            var e4 = ba(t6);
            return function(n3) {
              return Kn(n3, t6, e4);
            };
          }($n(t5, 1));
        }, Pn.constant = Va, Pn.countBy = os, Pn.create = function(t5, e4) {
          var n3 = Cn(t5);
          return e4 == null ? n3 : qn(n3, e4);
        }, Pn.curry = function t5(e4, n3, i3) {
          var r4 = Gr(e4, 8, void 0, void 0, void 0, void 0, void 0, n3 = i3 ? void 0 : n3);
          return r4.placeholder = t5.placeholder, r4;
        }, Pn.curryRight = function t5(e4, n3, i3) {
          var r4 = Gr(e4, 16, void 0, void 0, void 0, void 0, void 0, n3 = i3 ? void 0 : n3);
          return r4.placeholder = t5.placeholder, r4;
        }, Pn.debounce = bs, Pn.defaults = fa, Pn.defaultsDeep = ma, Pn.defer = Ts, Pn.delay = ws, Pn.difference = Co, Pn.differenceBy = Io, Pn.differenceWith = Oo, Pn.drop = function(t5, e4, n3) {
          var i3 = t5 == null ? 0 : t5.length;
          return i3 ? Xi(t5, (e4 = n3 || e4 === void 0 ? 1 : ra(e4)) < 0 ? 0 : e4, i3) : [];
        }, Pn.dropRight = function(t5, e4, n3) {
          var i3 = t5 == null ? 0 : t5.length;
          return i3 ? Xi(t5, 0, (e4 = i3 - (e4 = n3 || e4 === void 0 ? 1 : ra(e4))) < 0 ? 0 : e4) : [];
        }, Pn.dropRightWhile = function(t5, e4) {
          return t5 && t5.length ? nr(t5, $r(e4, 3), true, true) : [];
        }, Pn.dropWhile = function(t5, e4) {
          return t5 && t5.length ? nr(t5, $r(e4, 3), true) : [];
        }, Pn.fill = function(t5, e4, n3, i3) {
          var r4 = t5 == null ? 0 : t5.length;
          return r4 ? (n3 && typeof n3 != "number" && lo(t5, e4, n3) && (n3 = 0, i3 = r4), function(t6, e5, n4, i4) {
            var r5 = t6.length;
            for ((n4 = ra(n4)) < 0 && (n4 = -n4 > r5 ? 0 : r5 + n4), (i4 = i4 === void 0 || i4 > r5 ? r5 : ra(i4)) < 0 && (i4 += r5), i4 = n4 > i4 ? 0 : oa(i4); n4 < i4; )
              t6[n4++] = e5;
            return t6;
          }(t5, e4, n3, i3)) : [];
        }, Pn.filter = function(t5, e4) {
          return (Ns(t5) ? he : oi)(t5, $r(e4, 3));
        }, Pn.flatMap = function(t5, e4) {
          return si(ps(t5, e4), 1);
        }, Pn.flatMapDeep = function(t5, e4) {
          return si(ps(t5, e4), 1 / 0);
        }, Pn.flatMapDepth = function(t5, e4, n3) {
          return n3 = n3 === void 0 ? 1 : ra(n3), si(ps(t5, e4), n3);
        }, Pn.flatten = Do, Pn.flattenDeep = function(t5) {
          return (t5 == null ? 0 : t5.length) ? si(t5, 1 / 0) : [];
        }, Pn.flattenDepth = function(t5, e4) {
          return (t5 == null ? 0 : t5.length) ? si(t5, e4 = e4 === void 0 ? 1 : ra(e4)) : [];
        }, Pn.flip = function(t5) {
          return Gr(t5, 512);
        }, Pn.flow = Wa, Pn.flowRight = Xa, Pn.fromPairs = function(t5) {
          for (var e4 = -1, n3 = t5 == null ? 0 : t5.length, i3 = {}; ++e4 < n3; ) {
            var r4 = t5[e4];
            i3[r4[0]] = r4[1];
          }
          return i3;
        }, Pn.functions = function(t5) {
          return t5 == null ? [] : ci(t5, ba(t5));
        }, Pn.functionsIn = function(t5) {
          return t5 == null ? [] : ci(t5, Ta(t5));
        }, Pn.groupBy = hs, Pn.initial = function(t5) {
          return (t5 == null ? 0 : t5.length) ? Xi(t5, 0, -1) : [];
        }, Pn.intersection = Bo, Pn.intersectionBy = Uo, Pn.intersectionWith = ko, Pn.invert = _a, Pn.invertBy = ya, Pn.invokeMap = cs2, Pn.iteratee = Ya, Pn.keyBy = ds, Pn.keys = ba, Pn.keysIn = Ta, Pn.map = ps, Pn.mapKeys = function(t5, e4) {
          var n3 = {};
          return e4 = $r(e4, 3), ui(t5, function(t6, i3, r4) {
            Yn(n3, e4(t6, i3, r4), t6);
          }), n3;
        }, Pn.mapValues = function(t5, e4) {
          var n3 = {};
          return e4 = $r(e4, 3), ui(t5, function(t6, i3, r4) {
            Yn(n3, i3, e4(t6, i3, r4));
          }), n3;
        }, Pn.matches = function(t5) {
          return Pi($n(t5, 1));
        }, Pn.matchesProperty = function(t5, e4) {
          return Ci(t5, $n(e4, 1));
        }, Pn.memoize = Ss, Pn.merge = wa, Pn.mergeWith = Sa, Pn.method = Za, Pn.methodOf = Ja, Pn.mixin = $a, Pn.negate = Es, Pn.nthArg = function(t5) {
          return t5 = ra(t5), ki(function(e4) {
            return Oi(e4, t5);
          });
        }, Pn.omit = Ea, Pn.omitBy = function(t5, e4) {
          return Aa(t5, Es($r(e4)));
        }, Pn.once = function(t5) {
          return _s(2, t5);
        }, Pn.orderBy = function(t5, e4, n3, i3) {
          return t5 == null ? [] : (Ns(e4) || (e4 = e4 == null ? [] : [e4]), Ns(n3 = i3 ? void 0 : n3) || (n3 = n3 == null ? [] : [n3]), Li(t5, e4, n3));
        }, Pn.over = Qa, Pn.overArgs = Ms, Pn.overEvery = tl, Pn.overSome = el, Pn.partial = As, Pn.partialRight = Rs, Pn.partition = fs, Pn.pick = Ma, Pn.pickBy = Aa, Pn.property = nl, Pn.propertyOf = function(t5) {
          return function(e4) {
            return t5 == null ? void 0 : di(t5, e4);
          };
        }, Pn.pull = Ho, Pn.pullAll = zo, Pn.pullAllBy = function(t5, e4, n3) {
          return t5 && t5.length && e4 && e4.length ? Di(t5, e4, $r(n3, 2)) : t5;
        }, Pn.pullAllWith = function(t5, e4, n3) {
          return t5 && t5.length && e4 && e4.length ? Di(t5, e4, void 0, n3) : t5;
        }, Pn.pullAt = jo, Pn.range = il, Pn.rangeRight = rl, Pn.rearg = Ps, Pn.reject = function(t5, e4) {
          return (Ns(t5) ? he : oi)(t5, Es($r(e4, 3)));
        }, Pn.remove = function(t5, e4) {
          var n3 = [];
          if (!t5 || !t5.length)
            return n3;
          var i3 = -1, r4 = [], o3 = t5.length;
          for (e4 = $r(e4, 3); ++i3 < o3; ) {
            var s3 = t5[i3];
            e4(s3, i3, t5) && (n3.push(s3), r4.push(i3));
          }
          return Fi(t5, r4), n3;
        }, Pn.rest = function(t5, e4) {
          if (typeof t5 != "function")
            throw new vt2(o2);
          return ki(t5, e4 = e4 === void 0 ? e4 : ra(e4));
        }, Pn.reverse = Vo, Pn.sampleSize = function(t5, e4, n3) {
          return e4 = (n3 ? lo(t5, e4, n3) : e4 === void 0) ? 1 : ra(e4), (Ns(t5) ? Hn : Hi)(t5, e4);
        }, Pn.set = function(t5, e4, n3) {
          return t5 == null ? t5 : zi(t5, e4, n3);
        }, Pn.setWith = function(t5, e4, n3, i3) {
          return i3 = typeof i3 == "function" ? i3 : void 0, t5 == null ? t5 : zi(t5, e4, n3, i3);
        }, Pn.shuffle = function(t5) {
          return (Ns(t5) ? zn : Wi)(t5);
        }, Pn.slice = function(t5, e4, n3) {
          var i3 = t5 == null ? 0 : t5.length;
          return i3 ? (n3 && typeof n3 != "number" && lo(t5, e4, n3) ? (e4 = 0, n3 = i3) : (e4 = e4 == null ? 0 : ra(e4), n3 = n3 === void 0 ? i3 : ra(n3)), Xi(t5, e4, n3)) : [];
        }, Pn.sortBy = ms, Pn.sortedUniq = function(t5) {
          return t5 && t5.length ? Ji(t5) : [];
        }, Pn.sortedUniqBy = function(t5, e4) {
          return t5 && t5.length ? Ji(t5, $r(e4, 2)) : [];
        }, Pn.split = function(t5, e4, n3) {
          return n3 && typeof n3 != "number" && lo(t5, e4, n3) && (e4 = n3 = void 0), (n3 = n3 === void 0 ? 4294967295 : n3 >>> 0) ? (t5 = la(t5)) && (typeof e4 == "string" || e4 != null && !Zs(e4)) && !(e4 = Ki(e4)) && Ge(t5) ? hr(qe(t5), 0, n3) : t5.split(e4, n3) : [];
        }, Pn.spread = function(t5, e4) {
          if (typeof t5 != "function")
            throw new vt2(o2);
          return e4 = e4 == null ? 0 : an(ra(e4), 0), ki(function(n3) {
            var i3 = n3[e4], r4 = hr(n3, 0, e4);
            return i3 && fe(r4, i3), oe(t5, this, r4);
          });
        }, Pn.tail = function(t5) {
          var e4 = t5 == null ? 0 : t5.length;
          return e4 ? Xi(t5, 1, e4) : [];
        }, Pn.take = function(t5, e4, n3) {
          return t5 && t5.length ? Xi(t5, 0, (e4 = n3 || e4 === void 0 ? 1 : ra(e4)) < 0 ? 0 : e4) : [];
        }, Pn.takeRight = function(t5, e4, n3) {
          var i3 = t5 == null ? 0 : t5.length;
          return i3 ? Xi(t5, (e4 = i3 - (e4 = n3 || e4 === void 0 ? 1 : ra(e4))) < 0 ? 0 : e4, i3) : [];
        }, Pn.takeRightWhile = function(t5, e4) {
          return t5 && t5.length ? nr(t5, $r(e4, 3), false, true) : [];
        }, Pn.takeWhile = function(t5, e4) {
          return t5 && t5.length ? nr(t5, $r(e4, 3)) : [];
        }, Pn.tap = function(t5, e4) {
          return e4(t5), t5;
        }, Pn.throttle = function(t5, e4, n3) {
          var i3 = true, r4 = true;
          if (typeof t5 != "function")
            throw new vt2(o2);
          return Vs(n3) && (i3 = "leading" in n3 ? !!n3.leading : i3, r4 = "trailing" in n3 ? !!n3.trailing : r4), bs(t5, e4, { leading: i3, maxWait: e4, trailing: r4 });
        }, Pn.thru = is, Pn.toArray = na, Pn.toPairs = Ra, Pn.toPairsIn = Pa, Pn.toPath = function(t5) {
          return Ns(t5) ? pe(t5, Ao) : Ks(t5) ? [t5] : _r(Mo(la(t5)));
        }, Pn.toPlainObject = aa, Pn.transform = function(t5, e4, n3) {
          var i3 = Ns(t5), r4 = i3 || Us(t5) || Qs(t5);
          if (e4 = $r(e4, 4), n3 == null) {
            var o3 = t5 && t5.constructor;
            n3 = r4 ? i3 ? new o3() : [] : Vs(t5) && Hs(o3) ? Cn(zt2(t5)) : {};
          }
          return (r4 ? ae : ui)(t5, function(t6, i4, r5) {
            return e4(n3, t6, i4, r5);
          }), n3;
        }, Pn.unary = function(t5) {
          return vs(t5, 1);
        }, Pn.union = Wo, Pn.unionBy = Xo, Pn.unionWith = qo, Pn.uniq = function(t5) {
          return t5 && t5.length ? Qi(t5) : [];
        }, Pn.uniqBy = function(t5, e4) {
          return t5 && t5.length ? Qi(t5, $r(e4, 2)) : [];
        }, Pn.uniqWith = function(t5, e4) {
          return e4 = typeof e4 == "function" ? e4 : void 0, t5 && t5.length ? Qi(t5, void 0, e4) : [];
        }, Pn.unset = function(t5, e4) {
          return t5 == null || tr(t5, e4);
        }, Pn.unzip = Yo, Pn.unzipWith = Zo, Pn.update = function(t5, e4, n3) {
          return t5 == null ? t5 : er(t5, e4, ar(n3));
        }, Pn.updateWith = function(t5, e4, n3, i3) {
          return i3 = typeof i3 == "function" ? i3 : void 0, t5 == null ? t5 : er(t5, e4, ar(n3), i3);
        }, Pn.values = Ca, Pn.valuesIn = function(t5) {
          return t5 == null ? [] : Oe(t5, Ta(t5));
        }, Pn.without = Jo, Pn.words = Ha, Pn.wrap = function(t5, e4) {
          return As(ar(e4), t5);
        }, Pn.xor = $o, Pn.xorBy = Ko, Pn.xorWith = Qo, Pn.zip = ts, Pn.zipObject = function(t5, e4) {
          return or(t5 || [], e4 || [], Vn);
        }, Pn.zipObjectDeep = function(t5, e4) {
          return or(t5 || [], e4 || [], zi);
        }, Pn.zipWith = es, Pn.entries = Ra, Pn.entriesIn = Pa, Pn.extend = ha, Pn.extendWith = ca, $a(Pn, Pn), Pn.add = al, Pn.attempt = za, Pn.camelCase = Ia, Pn.capitalize = Oa, Pn.ceil = ll, Pn.clamp = function(t5, e4, n3) {
          return n3 === void 0 && (n3 = e4, e4 = void 0), n3 !== void 0 && (n3 = (n3 = sa(n3)) == n3 ? n3 : 0), e4 !== void 0 && (e4 = (e4 = sa(e4)) == e4 ? e4 : 0), Jn(sa(t5), e4, n3);
        }, Pn.clone = function(t5) {
          return $n(t5, 4);
        }, Pn.cloneDeep = function(t5) {
          return $n(t5, 5);
        }, Pn.cloneDeepWith = function(t5, e4) {
          return $n(t5, 5, e4 = typeof e4 == "function" ? e4 : void 0);
        }, Pn.cloneWith = function(t5, e4) {
          return $n(t5, 4, e4 = typeof e4 == "function" ? e4 : void 0);
        }, Pn.conformsTo = function(t5, e4) {
          return e4 == null || Kn(t5, e4, ba(e4));
        }, Pn.deburr = La, Pn.defaultTo = function(t5, e4) {
          return t5 == null || t5 != t5 ? e4 : t5;
        }, Pn.divide = ul, Pn.endsWith = function(t5, e4, n3) {
          t5 = la(t5), e4 = Ki(e4);
          var i3 = t5.length, r4 = n3 = n3 === void 0 ? i3 : Jn(ra(n3), 0, i3);
          return (n3 -= e4.length) >= 0 && t5.slice(n3, r4) == e4;
        }, Pn.eq = Cs, Pn.escape = function(t5) {
          return (t5 = la(t5)) && k.test(t5) ? t5.replace(B, Ue) : t5;
        }, Pn.escapeRegExp = function(t5) {
          return (t5 = la(t5)) && q.test(t5) ? t5.replace(X, "\\$&") : t5;
        }, Pn.every = function(t5, e4, n3) {
          var i3 = Ns(t5) ? ue : ii;
          return n3 && lo(t5, e4, n3) && (e4 = void 0), i3(t5, $r(e4, 3));
        }, Pn.find = ss, Pn.findIndex = Lo, Pn.findKey = function(t5, e4) {
          return ye(t5, $r(e4, 3), ui);
        }, Pn.findLast = as, Pn.findLastIndex = No, Pn.findLastKey = function(t5, e4) {
          return ye(t5, $r(e4, 3), hi);
        }, Pn.floor = hl, Pn.forEach = ls, Pn.forEachRight = us, Pn.forIn = function(t5, e4) {
          return t5 == null ? t5 : ai(t5, $r(e4, 3), Ta);
        }, Pn.forInRight = function(t5, e4) {
          return t5 == null ? t5 : li(t5, $r(e4, 3), Ta);
        }, Pn.forOwn = function(t5, e4) {
          return t5 && ui(t5, $r(e4, 3));
        }, Pn.forOwnRight = function(t5, e4) {
          return t5 && hi(t5, $r(e4, 3));
        }, Pn.get = ga, Pn.gt = Is, Pn.gte = Os, Pn.has = function(t5, e4) {
          return t5 != null && ro(t5, e4, gi);
        }, Pn.hasIn = va, Pn.head = Fo, Pn.identity = qa, Pn.includes = function(t5, e4, n3, i3) {
          t5 = Fs(t5) ? t5 : Ca(t5), n3 = n3 && !i3 ? ra(n3) : 0;
          var r4 = t5.length;
          return n3 < 0 && (n3 = an(r4 + n3, 0)), $s(t5) ? n3 <= r4 && t5.indexOf(e4, n3) > -1 : !!r4 && be(t5, e4, n3) > -1;
        }, Pn.indexOf = function(t5, e4, n3) {
          var i3 = t5 == null ? 0 : t5.length;
          if (!i3)
            return -1;
          var r4 = n3 == null ? 0 : ra(n3);
          return r4 < 0 && (r4 = an(i3 + r4, 0)), be(t5, e4, r4);
        }, Pn.inRange = function(t5, e4, n3) {
          return e4 = ia(e4), n3 === void 0 ? (n3 = e4, e4 = 0) : n3 = ia(n3), function(t6, e5, n4) {
            return t6 >= ln(e5, n4) && t6 < an(e5, n4);
          }(t5 = sa(t5), e4, n3);
        }, Pn.invoke = xa, Pn.isArguments = Ls, Pn.isArray = Ns, Pn.isArrayBuffer = Ds, Pn.isArrayLike = Fs, Pn.isArrayLikeObject = Bs, Pn.isBoolean = function(t5) {
          return t5 === true || t5 === false || Ws(t5) && fi(t5) == h;
        }, Pn.isBuffer = Us, Pn.isDate = ks, Pn.isElement = function(t5) {
          return Ws(t5) && t5.nodeType === 1 && !Ys(t5);
        }, Pn.isEmpty = function(t5) {
          if (t5 == null)
            return true;
          if (Fs(t5) && (Ns(t5) || typeof t5 == "string" || typeof t5.splice == "function" || Us(t5) || Qs(t5) || Ls(t5)))
            return !t5.length;
          var e4 = io(t5);
          if (e4 == m || e4 == y)
            return !t5.size;
          if (po(t5))
            return !Ei(t5).length;
          for (var n3 in t5)
            if (wt2.call(t5, n3))
              return false;
          return true;
        }, Pn.isEqual = function(t5, e4) {
          return bi(t5, e4);
        }, Pn.isEqualWith = function(t5, e4, n3) {
          var i3 = (n3 = typeof n3 == "function" ? n3 : void 0) ? n3(t5, e4) : void 0;
          return i3 === void 0 ? bi(t5, e4, void 0, n3) : !!i3;
        }, Pn.isError = Gs, Pn.isFinite = function(t5) {
          return typeof t5 == "number" && rn(t5);
        }, Pn.isFunction = Hs, Pn.isInteger = zs, Pn.isLength = js, Pn.isMap = Xs, Pn.isMatch = function(t5, e4) {
          return t5 === e4 || Ti(t5, e4, Qr(e4));
        }, Pn.isMatchWith = function(t5, e4, n3) {
          return n3 = typeof n3 == "function" ? n3 : void 0, Ti(t5, e4, Qr(e4), n3);
        }, Pn.isNaN = function(t5) {
          return qs(t5) && t5 != +t5;
        }, Pn.isNative = function(t5) {
          if (co(t5))
            throw new Z2("Unsupported core-js use. Try https://npms.io/search?q=ponyfill.");
          return wi(t5);
        }, Pn.isNil = function(t5) {
          return t5 == null;
        }, Pn.isNull = function(t5) {
          return t5 === null;
        }, Pn.isNumber = qs, Pn.isObject = Vs, Pn.isObjectLike = Ws, Pn.isPlainObject = Ys, Pn.isRegExp = Zs, Pn.isSafeInteger = function(t5) {
          return zs(t5) && t5 >= -9007199254740991 && t5 <= 9007199254740991;
        }, Pn.isSet = Js, Pn.isString = $s, Pn.isSymbol = Ks, Pn.isTypedArray = Qs, Pn.isUndefined = function(t5) {
          return t5 === void 0;
        }, Pn.isWeakMap = function(t5) {
          return Ws(t5) && io(t5) == T;
        }, Pn.isWeakSet = function(t5) {
          return Ws(t5) && fi(t5) == "[object WeakSet]";
        }, Pn.join = function(t5, e4) {
          return t5 == null ? "" : on.call(t5, e4);
        }, Pn.kebabCase = Na, Pn.last = Go, Pn.lastIndexOf = function(t5, e4, n3) {
          var i3 = t5 == null ? 0 : t5.length;
          if (!i3)
            return -1;
          var r4 = i3;
          return n3 !== void 0 && (r4 = (r4 = ra(n3)) < 0 ? an(i3 + r4, 0) : ln(r4, i3 - 1)), e4 == e4 ? function(t6, e5, n4) {
            for (var i4 = n4 + 1; i4--; )
              if (t6[i4] === e5)
                return i4;
            return i4;
          }(t5, e4, r4) : xe(t5, we, r4, true);
        }, Pn.lowerCase = Da, Pn.lowerFirst = Fa, Pn.lt = ta, Pn.lte = ea, Pn.max = function(t5) {
          return t5 && t5.length ? ri(t5, qa, mi) : void 0;
        }, Pn.maxBy = function(t5, e4) {
          return t5 && t5.length ? ri(t5, $r(e4, 2), mi) : void 0;
        }, Pn.mean = function(t5) {
          return Se(t5, qa);
        }, Pn.meanBy = function(t5, e4) {
          return Se(t5, $r(e4, 2));
        }, Pn.min = function(t5) {
          return t5 && t5.length ? ri(t5, qa, Ai) : void 0;
        }, Pn.minBy = function(t5, e4) {
          return t5 && t5.length ? ri(t5, $r(e4, 2), Ai) : void 0;
        }, Pn.stubArray = ol, Pn.stubFalse = sl, Pn.stubObject = function() {
          return {};
        }, Pn.stubString = function() {
          return "";
        }, Pn.stubTrue = function() {
          return true;
        }, Pn.multiply = dl, Pn.nth = function(t5, e4) {
          return t5 && t5.length ? Oi(t5, ra(e4)) : void 0;
        }, Pn.noConflict = function() {
          return qt._ === this && (qt._ = Rt2), this;
        }, Pn.noop = Ka, Pn.now = gs, Pn.pad = function(t5, e4, n3) {
          t5 = la(t5);
          var i3 = (e4 = ra(e4)) ? Xe(t5) : 0;
          if (!e4 || i3 >= e4)
            return t5;
          var r4 = (e4 - i3) / 2;
          return Lr(tn(r4), n3) + t5 + Lr(Qe(r4), n3);
        }, Pn.padEnd = function(t5, e4, n3) {
          t5 = la(t5);
          var i3 = (e4 = ra(e4)) ? Xe(t5) : 0;
          return e4 && i3 < e4 ? t5 + Lr(e4 - i3, n3) : t5;
        }, Pn.padStart = function(t5, e4, n3) {
          t5 = la(t5);
          var i3 = (e4 = ra(e4)) ? Xe(t5) : 0;
          return e4 && i3 < e4 ? Lr(e4 - i3, n3) + t5 : t5;
        }, Pn.parseInt = function(t5, e4, n3) {
          return n3 || e4 == null ? e4 = 0 : e4 && (e4 = +e4), hn(la(t5).replace(Y, ""), e4 || 0);
        }, Pn.random = function(t5, e4, n3) {
          if (n3 && typeof n3 != "boolean" && lo(t5, e4, n3) && (e4 = n3 = void 0), n3 === void 0 && (typeof e4 == "boolean" ? (n3 = e4, e4 = void 0) : typeof t5 == "boolean" && (n3 = t5, t5 = void 0)), t5 === void 0 && e4 === void 0 ? (t5 = 0, e4 = 1) : (t5 = ia(t5), e4 === void 0 ? (e4 = t5, t5 = 0) : e4 = ia(e4)), t5 > e4) {
            var i3 = t5;
            t5 = e4, e4 = i3;
          }
          if (n3 || t5 % 1 || e4 % 1) {
            var r4 = cn();
            return ln(t5 + r4 * (e4 - t5 + jt("1e-" + ((r4 + "").length - 1))), e4);
          }
          return Bi(t5, e4);
        }, Pn.reduce = function(t5, e4, n3) {
          var i3 = Ns(t5) ? me : Ae, r4 = arguments.length < 3;
          return i3(t5, $r(e4, 4), n3, r4, ei);
        }, Pn.reduceRight = function(t5, e4, n3) {
          var i3 = Ns(t5) ? ge : Ae, r4 = arguments.length < 3;
          return i3(t5, $r(e4, 4), n3, r4, ni);
        }, Pn.repeat = function(t5, e4, n3) {
          return e4 = (n3 ? lo(t5, e4, n3) : e4 === void 0) ? 1 : ra(e4), Ui(la(t5), e4);
        }, Pn.replace = function() {
          var t5 = arguments, e4 = la(t5[0]);
          return t5.length < 3 ? e4 : e4.replace(t5[1], t5[2]);
        }, Pn.result = function(t5, e4, n3) {
          var i3 = -1, r4 = (e4 = lr(e4, t5)).length;
          for (r4 || (r4 = 1, t5 = void 0); ++i3 < r4; ) {
            var o3 = t5 == null ? void 0 : t5[Ao(e4[i3])];
            o3 === void 0 && (i3 = r4, o3 = n3), t5 = Hs(o3) ? o3.call(t5) : o3;
          }
          return t5;
        }, Pn.round = pl, Pn.runInContext = t4, Pn.sample = function(t5) {
          return (Ns(t5) ? Gn : Gi)(t5);
        }, Pn.size = function(t5) {
          if (t5 == null)
            return 0;
          if (Fs(t5))
            return $s(t5) ? Xe(t5) : t5.length;
          var e4 = io(t5);
          return e4 == m || e4 == y ? t5.size : Ei(t5).length;
        }, Pn.snakeCase = Ba, Pn.some = function(t5, e4, n3) {
          var i3 = Ns(t5) ? ve : qi;
          return n3 && lo(t5, e4, n3) && (e4 = void 0), i3(t5, $r(e4, 3));
        }, Pn.sortedIndex = function(t5, e4) {
          return Yi(t5, e4);
        }, Pn.sortedIndexBy = function(t5, e4, n3) {
          return Zi(t5, e4, $r(n3, 2));
        }, Pn.sortedIndexOf = function(t5, e4) {
          var n3 = t5 == null ? 0 : t5.length;
          if (n3) {
            var i3 = Yi(t5, e4);
            if (i3 < n3 && Cs(t5[i3], e4))
              return i3;
          }
          return -1;
        }, Pn.sortedLastIndex = function(t5, e4) {
          return Yi(t5, e4, true);
        }, Pn.sortedLastIndexBy = function(t5, e4, n3) {
          return Zi(t5, e4, $r(n3, 2), true);
        }, Pn.sortedLastIndexOf = function(t5, e4) {
          if (t5 == null ? 0 : t5.length) {
            var n3 = Yi(t5, e4, true) - 1;
            if (Cs(t5[n3], e4))
              return n3;
          }
          return -1;
        }, Pn.startCase = Ua, Pn.startsWith = function(t5, e4, n3) {
          return t5 = la(t5), n3 = n3 == null ? 0 : Jn(ra(n3), 0, t5.length), e4 = Ki(e4), t5.slice(n3, n3 + e4.length) == e4;
        }, Pn.subtract = fl, Pn.sum = function(t5) {
          return t5 && t5.length ? Re(t5, qa) : 0;
        }, Pn.sumBy = function(t5, e4) {
          return t5 && t5.length ? Re(t5, $r(e4, 2)) : 0;
        }, Pn.template = function(t5, e4, n3) {
          var i3 = Pn.templateSettings;
          n3 && lo(t5, e4, n3) && (e4 = void 0), t5 = la(t5), e4 = ca({}, e4, i3, Hr);
          var r4, o3, s3 = ca({}, e4.imports, i3.imports, Hr), a2 = ba(s3), l2 = Oe(s3, a2), u2 = 0, h2 = e4.interpolate || ht, c2 = "__p += '", d2 = mt2((e4.escape || ht).source + "|" + h2.source + "|" + (h2 === z ? nt : ht).source + "|" + (e4.evaluate || ht).source + "|$", "g"), p2 = "//# sourceURL=" + (wt2.call(e4, "sourceURL") ? (e4.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++kt + "]") + "\n";
          t5.replace(d2, function(e5, n4, i4, s4, a3, l3) {
            return i4 || (i4 = s4), c2 += t5.slice(u2, l3).replace(ct, ke), n4 && (r4 = true, c2 += "' +\n__e(" + n4 + ") +\n'"), a3 && (o3 = true, c2 += "';\n" + a3 + ";\n__p += '"), i4 && (c2 += "' +\n((__t = (" + i4 + ")) == null ? '' : __t) +\n'"), u2 = l3 + e5.length, e5;
          }), c2 += "';\n";
          var f2 = wt2.call(e4, "variable") && e4.variable;
          if (f2) {
            if (tt.test(f2))
              throw new Z2("Invalid `variable` option passed into `_.template`");
          } else
            c2 = "with (obj) {\n" + c2 + "\n}\n";
          c2 = (o3 ? c2.replace(L, "") : c2).replace(N, "$1").replace(D, "$1;"), c2 = "function(" + (f2 || "obj") + ") {\n" + (f2 ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (r4 ? ", __e = _.escape" : "") + (o3 ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + c2 + "return __p\n}";
          var m2 = za(function() {
            return dt2(a2, p2 + "return " + c2).apply(void 0, l2);
          });
          if (m2.source = c2, Gs(m2))
            throw m2;
          return m2;
        }, Pn.times = function(t5, e4) {
          if ((t5 = ra(t5)) < 1 || t5 > 9007199254740991)
            return [];
          var n3 = 4294967295, i3 = ln(t5, 4294967295);
          t5 -= 4294967295;
          for (var r4 = Pe(i3, e4 = $r(e4)); ++n3 < t5; )
            e4(n3);
          return r4;
        }, Pn.toFinite = ia, Pn.toInteger = ra, Pn.toLength = oa, Pn.toLower = function(t5) {
          return la(t5).toLowerCase();
        }, Pn.toNumber = sa, Pn.toSafeInteger = function(t5) {
          return t5 ? Jn(ra(t5), -9007199254740991, 9007199254740991) : t5 === 0 ? t5 : 0;
        }, Pn.toString = la, Pn.toUpper = function(t5) {
          return la(t5).toUpperCase();
        }, Pn.trim = function(t5, e4, n3) {
          if ((t5 = la(t5)) && (n3 || e4 === void 0))
            return Ce(t5);
          if (!t5 || !(e4 = Ki(e4)))
            return t5;
          var i3 = qe(t5), r4 = qe(e4);
          return hr(i3, Ne(i3, r4), De(i3, r4) + 1).join("");
        }, Pn.trimEnd = function(t5, e4, n3) {
          if ((t5 = la(t5)) && (n3 || e4 === void 0))
            return t5.slice(0, Ye(t5) + 1);
          if (!t5 || !(e4 = Ki(e4)))
            return t5;
          var i3 = qe(t5);
          return hr(i3, 0, De(i3, qe(e4)) + 1).join("");
        }, Pn.trimStart = function(t5, e4, n3) {
          if ((t5 = la(t5)) && (n3 || e4 === void 0))
            return t5.replace(Y, "");
          if (!t5 || !(e4 = Ki(e4)))
            return t5;
          var i3 = qe(t5);
          return hr(i3, Ne(i3, qe(e4))).join("");
        }, Pn.truncate = function(t5, e4) {
          var n3 = 30, i3 = "...";
          if (Vs(e4)) {
            var r4 = "separator" in e4 ? e4.separator : r4;
            n3 = "length" in e4 ? ra(e4.length) : n3, i3 = "omission" in e4 ? Ki(e4.omission) : i3;
          }
          var o3 = (t5 = la(t5)).length;
          if (Ge(t5)) {
            var s3 = qe(t5);
            o3 = s3.length;
          }
          if (n3 >= o3)
            return t5;
          var a2 = n3 - Xe(i3);
          if (a2 < 1)
            return i3;
          var l2 = s3 ? hr(s3, 0, a2).join("") : t5.slice(0, a2);
          if (r4 === void 0)
            return l2 + i3;
          if (s3 && (a2 += l2.length - a2), Zs(r4)) {
            if (t5.slice(a2).search(r4)) {
              var u2, h2 = l2;
              for (r4.global || (r4 = mt2(r4.source, la(it.exec(r4)) + "g")), r4.lastIndex = 0; u2 = r4.exec(h2); )
                var c2 = u2.index;
              l2 = l2.slice(0, c2 === void 0 ? a2 : c2);
            }
          } else if (t5.indexOf(Ki(r4), a2) != a2) {
            var d2 = l2.lastIndexOf(r4);
            d2 > -1 && (l2 = l2.slice(0, d2));
          }
          return l2 + i3;
        }, Pn.unescape = function(t5) {
          return (t5 = la(t5)) && U.test(t5) ? t5.replace(F, Ze) : t5;
        }, Pn.uniqueId = function(t5) {
          var e4 = ++St2;
          return la(t5) + e4;
        }, Pn.upperCase = ka, Pn.upperFirst = Ga, Pn.each = ls, Pn.eachRight = us, Pn.first = Fo, $a(Pn, (cl = {}, ui(Pn, function(t5, e4) {
          wt2.call(Pn.prototype, e4) || (cl[e4] = t5);
        }), cl), { chain: false }), Pn.VERSION = "4.17.21", ae(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(t5) {
          Pn[t5].placeholder = Pn;
        }), ae(["drop", "take"], function(t5, e4) {
          Ln.prototype[t5] = function(n3) {
            n3 = n3 === void 0 ? 1 : an(ra(n3), 0);
            var i3 = this.__filtered__ && !e4 ? new Ln(this) : this.clone();
            return i3.__filtered__ ? i3.__takeCount__ = ln(n3, i3.__takeCount__) : i3.__views__.push({ size: ln(n3, 4294967295), type: t5 + (i3.__dir__ < 0 ? "Right" : "") }), i3;
          }, Ln.prototype[t5 + "Right"] = function(e5) {
            return this.reverse()[t5](e5).reverse();
          };
        }), ae(["filter", "map", "takeWhile"], function(t5, e4) {
          var n3 = e4 + 1, i3 = n3 == 1 || n3 == 3;
          Ln.prototype[t5] = function(t6) {
            var e5 = this.clone();
            return e5.__iteratees__.push({ iteratee: $r(t6, 3), type: n3 }), e5.__filtered__ = e5.__filtered__ || i3, e5;
          };
        }), ae(["head", "last"], function(t5, e4) {
          var n3 = "take" + (e4 ? "Right" : "");
          Ln.prototype[t5] = function() {
            return this[n3](1).value()[0];
          };
        }), ae(["initial", "tail"], function(t5, e4) {
          var n3 = "drop" + (e4 ? "" : "Right");
          Ln.prototype[t5] = function() {
            return this.__filtered__ ? new Ln(this) : this[n3](1);
          };
        }), Ln.prototype.compact = function() {
          return this.filter(qa);
        }, Ln.prototype.find = function(t5) {
          return this.filter(t5).head();
        }, Ln.prototype.findLast = function(t5) {
          return this.reverse().find(t5);
        }, Ln.prototype.invokeMap = ki(function(t5, e4) {
          return typeof t5 == "function" ? new Ln(this) : this.map(function(n3) {
            return yi(n3, t5, e4);
          });
        }), Ln.prototype.reject = function(t5) {
          return this.filter(Es($r(t5)));
        }, Ln.prototype.slice = function(t5, e4) {
          t5 = ra(t5);
          var n3 = this;
          return n3.__filtered__ && (t5 > 0 || e4 < 0) ? new Ln(n3) : (t5 < 0 ? n3 = n3.takeRight(-t5) : t5 && (n3 = n3.drop(t5)), e4 !== void 0 && (n3 = (e4 = ra(e4)) < 0 ? n3.dropRight(-e4) : n3.take(e4 - t5)), n3);
        }, Ln.prototype.takeRightWhile = function(t5) {
          return this.reverse().takeWhile(t5).reverse();
        }, Ln.prototype.toArray = function() {
          return this.take(4294967295);
        }, ui(Ln.prototype, function(t5, e4) {
          var n3 = /^(?:filter|find|map|reject)|While$/.test(e4), i3 = /^(?:head|last)$/.test(e4), r4 = Pn[i3 ? "take" + (e4 == "last" ? "Right" : "") : e4], o3 = i3 || /^find/.test(e4);
          r4 && (Pn.prototype[e4] = function() {
            var e5 = this.__wrapped__, s3 = i3 ? [1] : arguments, a2 = e5 instanceof Ln, l2 = s3[0], u2 = a2 || Ns(e5), h2 = function(t6) {
              var e6 = r4.apply(Pn, fe([t6], s3));
              return i3 && c2 ? e6[0] : e6;
            };
            u2 && n3 && typeof l2 == "function" && l2.length != 1 && (a2 = u2 = false);
            var c2 = this.__chain__, d2 = !!this.__actions__.length, p2 = o3 && !c2, f2 = a2 && !d2;
            if (!o3 && u2) {
              e5 = f2 ? e5 : new Ln(this);
              var m2 = t5.apply(e5, s3);
              return m2.__actions__.push({ func: is, args: [h2], thisArg: void 0 }), new On(m2, c2);
            }
            return p2 && f2 ? t5.apply(this, s3) : (m2 = this.thru(h2), p2 ? i3 ? m2.value()[0] : m2.value() : m2);
          });
        }), ae(["pop", "push", "shift", "sort", "splice", "unshift"], function(t5) {
          var e4 = _t2[t5], n3 = /^(?:push|sort|unshift)$/.test(t5) ? "tap" : "thru", i3 = /^(?:pop|shift)$/.test(t5);
          Pn.prototype[t5] = function() {
            var t6 = arguments;
            if (i3 && !this.__chain__) {
              var r4 = this.value();
              return e4.apply(Ns(r4) ? r4 : [], t6);
            }
            return this[n3](function(n4) {
              return e4.apply(Ns(n4) ? n4 : [], t6);
            });
          };
        }), ui(Ln.prototype, function(t5, e4) {
          var n3 = Pn[e4];
          if (n3) {
            var i3 = n3.name + "";
            wt2.call(xn, i3) || (xn[i3] = []), xn[i3].push({ name: e4, func: n3 });
          }
        }), xn[Pr(void 0, 2).name] = [{ name: "wrapper", func: void 0 }], Ln.prototype.clone = function() {
          var t5 = new Ln(this.__wrapped__);
          return t5.__actions__ = _r(this.__actions__), t5.__dir__ = this.__dir__, t5.__filtered__ = this.__filtered__, t5.__iteratees__ = _r(this.__iteratees__), t5.__takeCount__ = this.__takeCount__, t5.__views__ = _r(this.__views__), t5;
        }, Ln.prototype.reverse = function() {
          if (this.__filtered__) {
            var t5 = new Ln(this);
            t5.__dir__ = -1, t5.__filtered__ = true;
          } else
            (t5 = this.clone()).__dir__ *= -1;
          return t5;
        }, Ln.prototype.value = function() {
          var t5 = this.__wrapped__.value(), e4 = this.__dir__, n3 = Ns(t5), i3 = e4 < 0, r4 = n3 ? t5.length : 0, o3 = function(t6, e5, n4) {
            var i4 = -1, r5 = n4.length;
            for (; ++i4 < r5; ) {
              var o4 = n4[i4], s4 = o4.size;
              switch (o4.type) {
                case "drop":
                  t6 += s4;
                  break;
                case "dropRight":
                  e5 -= s4;
                  break;
                case "take":
                  e5 = ln(e5, t6 + s4);
                  break;
                case "takeRight":
                  t6 = an(t6, e5 - s4);
              }
            }
            return { start: t6, end: e5 };
          }(0, r4, this.__views__), s3 = o3.start, a2 = o3.end, l2 = a2 - s3, u2 = i3 ? a2 : s3 - 1, h2 = this.__iteratees__, c2 = h2.length, d2 = 0, p2 = ln(l2, this.__takeCount__);
          if (!n3 || !i3 && r4 == l2 && p2 == l2)
            return ir(t5, this.__actions__);
          var f2 = [];
          t:
            for (; l2-- && d2 < p2; ) {
              for (var m2 = -1, g2 = t5[u2 += e4]; ++m2 < c2; ) {
                var v2 = h2[m2], _2 = v2.iteratee, y2 = v2.type, x2 = _2(g2);
                if (y2 == 2)
                  g2 = x2;
                else if (!x2) {
                  if (y2 == 1)
                    continue t;
                  break t;
                }
              }
              f2[d2++] = g2;
            }
          return f2;
        }, Pn.prototype.at = rs, Pn.prototype.chain = function() {
          return ns(this);
        }, Pn.prototype.commit = function() {
          return new On(this.value(), this.__chain__);
        }, Pn.prototype.next = function() {
          this.__values__ === void 0 && (this.__values__ = na(this.value()));
          var t5 = this.__index__ >= this.__values__.length;
          return { done: t5, value: t5 ? void 0 : this.__values__[this.__index__++] };
        }, Pn.prototype.plant = function(t5) {
          for (var e4, n3 = this; n3 instanceof In; ) {
            var i3 = Po(n3);
            i3.__index__ = 0, i3.__values__ = void 0, e4 ? r4.__wrapped__ = i3 : e4 = i3;
            var r4 = i3;
            n3 = n3.__wrapped__;
          }
          return r4.__wrapped__ = t5, e4;
        }, Pn.prototype.reverse = function() {
          var t5 = this.__wrapped__;
          if (t5 instanceof Ln) {
            var e4 = t5;
            return this.__actions__.length && (e4 = new Ln(this)), (e4 = e4.reverse()).__actions__.push({ func: is, args: [Vo], thisArg: void 0 }), new On(e4, this.__chain__);
          }
          return this.thru(Vo);
        }, Pn.prototype.toJSON = Pn.prototype.valueOf = Pn.prototype.value = function() {
          return ir(this.__wrapped__, this.__actions__);
        }, Pn.prototype.first = Pn.prototype.head, $t2 && (Pn.prototype[$t2] = function() {
          return this;
        }), Pn;
      }();
      qt._ = Je, (r2 = function() {
        return Je;
      }.call(e2, n, e2, i)) === void 0 || (i.exports = r2);
    }).call(this);
  }).call(this, n(4), n(8)(t2));
}, function(t2, e2, n) {
  (function(e3) {
    t2.exports = function t3(e4, n2, i) {
      function r2(s3, a) {
        if (!n2[s3]) {
          if (!e4[s3]) {
            if (o2)
              return o2(s3, true);
            var l = new Error("Cannot find module '" + s3 + "'");
            throw l.code = "MODULE_NOT_FOUND", l;
          }
          var u = n2[s3] = { exports: {} };
          e4[s3][0].call(u.exports, function(t4) {
            var n3 = e4[s3][1][t4];
            return r2(n3 || t4);
          }, u, u.exports, t3, e4, n2, i);
        }
        return n2[s3].exports;
      }
      for (var o2 = false, s2 = 0; s2 < i.length; s2++)
        r2(i[s2]);
      return r2;
    }({ 1: [function(t3, n2, i) {
      (function(t4) {
        var e4, i2, r2 = t4.MutationObserver || t4.WebKitMutationObserver;
        if (r2) {
          var o2 = 0, s2 = new r2(h), a = t4.document.createTextNode("");
          s2.observe(a, { characterData: true }), e4 = function() {
            a.data = o2 = ++o2 % 2;
          };
        } else if (t4.setImmediate || t4.MessageChannel === void 0)
          e4 = "document" in t4 && "onreadystatechange" in t4.document.createElement("script") ? function() {
            var e5 = t4.document.createElement("script");
            e5.onreadystatechange = function() {
              h(), e5.onreadystatechange = null, e5.parentNode.removeChild(e5), e5 = null;
            }, t4.document.documentElement.appendChild(e5);
          } : function() {
            setTimeout(h, 0);
          };
        else {
          var l = new t4.MessageChannel();
          l.port1.onmessage = h, e4 = function() {
            l.port2.postMessage(0);
          };
        }
        var u = [];
        function h() {
          var t5, e5;
          i2 = true;
          for (var n3 = u.length; n3; ) {
            for (e5 = u, u = [], t5 = -1; ++t5 < n3; )
              e5[t5]();
            n3 = u.length;
          }
          i2 = false;
        }
        n2.exports = function(t5) {
          u.push(t5) !== 1 || i2 || e4();
        };
      }).call(this, e3 !== void 0 ? e3 : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, {}], 2: [function(t3, e4, n2) {
      var i = t3(1);
      function r2() {
      }
      var o2 = {}, s2 = ["REJECTED"], a = ["FULFILLED"], l = ["PENDING"];
      function u(t4) {
        if (typeof t4 != "function")
          throw new TypeError("resolver must be a function");
        this.state = l, this.queue = [], this.outcome = void 0, t4 !== r2 && p(this, t4);
      }
      function h(t4, e5, n3) {
        this.promise = t4, typeof e5 == "function" && (this.onFulfilled = e5, this.callFulfilled = this.otherCallFulfilled), typeof n3 == "function" && (this.onRejected = n3, this.callRejected = this.otherCallRejected);
      }
      function c(t4, e5, n3) {
        i(function() {
          var i2;
          try {
            i2 = e5(n3);
          } catch (e6) {
            return o2.reject(t4, e6);
          }
          i2 === t4 ? o2.reject(t4, new TypeError("Cannot resolve promise with itself")) : o2.resolve(t4, i2);
        });
      }
      function d(t4) {
        var e5 = t4 && t4.then;
        if (t4 && (typeof t4 == "object" || typeof t4 == "function") && typeof e5 == "function")
          return function() {
            e5.apply(t4, arguments);
          };
      }
      function p(t4, e5) {
        var n3 = false;
        function i2(e6) {
          n3 || (n3 = true, o2.reject(t4, e6));
        }
        function r3(e6) {
          n3 || (n3 = true, o2.resolve(t4, e6));
        }
        var s3 = f(function() {
          e5(r3, i2);
        });
        s3.status === "error" && i2(s3.value);
      }
      function f(t4, e5) {
        var n3 = {};
        try {
          n3.value = t4(e5), n3.status = "success";
        } catch (t5) {
          n3.status = "error", n3.value = t5;
        }
        return n3;
      }
      e4.exports = u, u.prototype.catch = function(t4) {
        return this.then(null, t4);
      }, u.prototype.then = function(t4, e5) {
        if (typeof t4 != "function" && this.state === a || typeof e5 != "function" && this.state === s2)
          return this;
        var n3 = new this.constructor(r2);
        return this.state !== l ? c(n3, this.state === a ? t4 : e5, this.outcome) : this.queue.push(new h(n3, t4, e5)), n3;
      }, h.prototype.callFulfilled = function(t4) {
        o2.resolve(this.promise, t4);
      }, h.prototype.otherCallFulfilled = function(t4) {
        c(this.promise, this.onFulfilled, t4);
      }, h.prototype.callRejected = function(t4) {
        o2.reject(this.promise, t4);
      }, h.prototype.otherCallRejected = function(t4) {
        c(this.promise, this.onRejected, t4);
      }, o2.resolve = function(t4, e5) {
        var n3 = f(d, e5);
        if (n3.status === "error")
          return o2.reject(t4, n3.value);
        var i2 = n3.value;
        if (i2)
          p(t4, i2);
        else {
          t4.state = a, t4.outcome = e5;
          for (var r3 = -1, s3 = t4.queue.length; ++r3 < s3; )
            t4.queue[r3].callFulfilled(e5);
        }
        return t4;
      }, o2.reject = function(t4, e5) {
        t4.state = s2, t4.outcome = e5;
        for (var n3 = -1, i2 = t4.queue.length; ++n3 < i2; )
          t4.queue[n3].callRejected(e5);
        return t4;
      }, u.resolve = function(t4) {
        return t4 instanceof this ? t4 : o2.resolve(new this(r2), t4);
      }, u.reject = function(t4) {
        var e5 = new this(r2);
        return o2.reject(e5, t4);
      }, u.all = function(t4) {
        var e5 = this;
        if (Object.prototype.toString.call(t4) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var n3 = t4.length, i2 = false;
        if (!n3)
          return this.resolve([]);
        for (var s3 = new Array(n3), a2 = 0, l2 = -1, u2 = new this(r2); ++l2 < n3; )
          h2(t4[l2], l2);
        return u2;
        function h2(t5, r3) {
          e5.resolve(t5).then(function(t6) {
            s3[r3] = t6, ++a2 !== n3 || i2 || (i2 = true, o2.resolve(u2, s3));
          }, function(t6) {
            i2 || (i2 = true, o2.reject(u2, t6));
          });
        }
      }, u.race = function(t4) {
        var e5 = this;
        if (Object.prototype.toString.call(t4) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var n3 = t4.length, i2 = false;
        if (!n3)
          return this.resolve([]);
        for (var s3, a2 = -1, l2 = new this(r2); ++a2 < n3; )
          s3 = t4[a2], e5.resolve(s3).then(function(t5) {
            i2 || (i2 = true, o2.resolve(l2, t5));
          }, function(t5) {
            i2 || (i2 = true, o2.reject(l2, t5));
          });
        return l2;
      };
    }, { 1: 1 }], 3: [function(t3, n2, i) {
      (function(e4) {
        typeof e4.Promise != "function" && (e4.Promise = t3(2));
      }).call(this, e3 !== void 0 ? e3 : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, { 2: 2 }], 4: [function(t3, e4, n2) {
      var i = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t4) {
        return typeof t4;
      } : function(t4) {
        return t4 && typeof Symbol == "function" && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
      }, r2 = function() {
        try {
          if (typeof indexedDB != "undefined")
            return indexedDB;
          if (typeof webkitIndexedDB != "undefined")
            return webkitIndexedDB;
          if (typeof mozIndexedDB != "undefined")
            return mozIndexedDB;
          if (typeof OIndexedDB != "undefined")
            return OIndexedDB;
          if (typeof msIndexedDB != "undefined")
            return msIndexedDB;
        } catch (t4) {
          return;
        }
      }();
      function o2(t4, e5) {
        t4 = t4 || [], e5 = e5 || {};
        try {
          return new Blob(t4, e5);
        } catch (r3) {
          if (r3.name !== "TypeError")
            throw r3;
          for (var n3 = new (typeof BlobBuilder != "undefined" ? BlobBuilder : typeof MSBlobBuilder != "undefined" ? MSBlobBuilder : typeof MozBlobBuilder != "undefined" ? MozBlobBuilder : WebKitBlobBuilder)(), i2 = 0; i2 < t4.length; i2 += 1)
            n3.append(t4[i2]);
          return n3.getBlob(e5.type);
        }
      }
      typeof Promise == "undefined" && t3(3);
      var s2 = Promise;
      function a(t4, e5) {
        e5 && t4.then(function(t5) {
          e5(null, t5);
        }, function(t5) {
          e5(t5);
        });
      }
      function l(t4, e5, n3) {
        typeof e5 == "function" && t4.then(e5), typeof n3 == "function" && t4.catch(n3);
      }
      function u(t4) {
        return typeof t4 != "string" && (console.warn(t4 + " used as a key, but it is not a string."), t4 = String(t4)), t4;
      }
      function h() {
        if (arguments.length && typeof arguments[arguments.length - 1] == "function")
          return arguments[arguments.length - 1];
      }
      var c = void 0, d = {}, p = Object.prototype.toString;
      function f(t4) {
        return typeof c == "boolean" ? s2.resolve(c) : function(t5) {
          return new s2(function(e5) {
            var n3 = t5.transaction("local-forage-detect-blob-support", "readwrite"), i2 = o2([""]);
            n3.objectStore("local-forage-detect-blob-support").put(i2, "key"), n3.onabort = function(t6) {
              t6.preventDefault(), t6.stopPropagation(), e5(false);
            }, n3.oncomplete = function() {
              var t6 = navigator.userAgent.match(/Chrome\/(\d+)/), n4 = navigator.userAgent.match(/Edge\//);
              e5(n4 || !t6 || parseInt(t6[1], 10) >= 43);
            };
          }).catch(function() {
            return false;
          });
        }(t4).then(function(t5) {
          return c = t5;
        });
      }
      function m(t4) {
        var e5 = d[t4.name], n3 = {};
        n3.promise = new s2(function(t5, e6) {
          n3.resolve = t5, n3.reject = e6;
        }), e5.deferredOperations.push(n3), e5.dbReady ? e5.dbReady = e5.dbReady.then(function() {
          return n3.promise;
        }) : e5.dbReady = n3.promise;
      }
      function g(t4) {
        var e5 = d[t4.name].deferredOperations.pop();
        if (e5)
          return e5.resolve(), e5.promise;
      }
      function v(t4, e5) {
        var n3 = d[t4.name].deferredOperations.pop();
        if (n3)
          return n3.reject(e5), n3.promise;
      }
      function _(t4, e5) {
        return new s2(function(n3, i2) {
          if (d[t4.name] = d[t4.name] || { forages: [], db: null, dbReady: null, deferredOperations: [] }, t4.db) {
            if (!e5)
              return n3(t4.db);
            m(t4), t4.db.close();
          }
          var o3 = [t4.name];
          e5 && o3.push(t4.version);
          var s3 = r2.open.apply(r2, o3);
          e5 && (s3.onupgradeneeded = function(e6) {
            var n4 = s3.result;
            try {
              n4.createObjectStore(t4.storeName), e6.oldVersion <= 1 && n4.createObjectStore("local-forage-detect-blob-support");
            } catch (n5) {
              if (n5.name !== "ConstraintError")
                throw n5;
              console.warn('The database "' + t4.name + '" has been upgraded from version ' + e6.oldVersion + " to version " + e6.newVersion + ', but the storage "' + t4.storeName + '" already exists.');
            }
          }), s3.onerror = function(t5) {
            t5.preventDefault(), i2(s3.error);
          }, s3.onsuccess = function() {
            n3(s3.result), g(t4);
          };
        });
      }
      function y(t4) {
        return _(t4, false);
      }
      function x(t4) {
        return _(t4, true);
      }
      function b(t4, e5) {
        if (!t4.db)
          return true;
        var n3 = !t4.db.objectStoreNames.contains(t4.storeName), i2 = t4.version < t4.db.version, r3 = t4.version > t4.db.version;
        if (i2 && (t4.version !== e5 && console.warn('The database "' + t4.name + `" can't be downgraded from version ` + t4.db.version + " to version " + t4.version + "."), t4.version = t4.db.version), r3 || n3) {
          if (n3) {
            var o3 = t4.db.version + 1;
            o3 > t4.version && (t4.version = o3);
          }
          return true;
        }
        return false;
      }
      function T(t4) {
        return o2([function(t5) {
          for (var e5 = t5.length, n3 = new ArrayBuffer(e5), i2 = new Uint8Array(n3), r3 = 0; r3 < e5; r3++)
            i2[r3] = t5.charCodeAt(r3);
          return n3;
        }(atob(t4.data))], { type: t4.type });
      }
      function w(t4) {
        return t4 && t4.__local_forage_encoded_blob;
      }
      function S(t4) {
        var e5 = this, n3 = e5._initReady().then(function() {
          var t5 = d[e5._dbInfo.name];
          if (t5 && t5.dbReady)
            return t5.dbReady;
        });
        return l(n3, t4, t4), n3;
      }
      function E(t4, e5, n3, i2) {
        i2 === void 0 && (i2 = 1);
        try {
          var r3 = t4.db.transaction(t4.storeName, e5);
          n3(null, r3);
        } catch (r4) {
          if (i2 > 0 && (!t4.db || r4.name === "InvalidStateError" || r4.name === "NotFoundError"))
            return s2.resolve().then(function() {
              if (!t4.db || r4.name === "NotFoundError" && !t4.db.objectStoreNames.contains(t4.storeName) && t4.version <= t4.db.version)
                return t4.db && (t4.version = t4.db.version + 1), x(t4);
            }).then(function() {
              return function(t5) {
                m(t5);
                for (var e6 = d[t5.name], n4 = e6.forages, i3 = 0; i3 < n4.length; i3++) {
                  var r5 = n4[i3];
                  r5._dbInfo.db && (r5._dbInfo.db.close(), r5._dbInfo.db = null);
                }
                return t5.db = null, y(t5).then(function(e7) {
                  return t5.db = e7, b(t5) ? x(t5) : e7;
                }).then(function(i4) {
                  t5.db = e6.db = i4;
                  for (var r6 = 0; r6 < n4.length; r6++)
                    n4[r6]._dbInfo.db = i4;
                }).catch(function(e7) {
                  throw v(t5, e7), e7;
                });
              }(t4).then(function() {
                E(t4, e5, n3, i2 - 1);
              });
            }).catch(n3);
          n3(r4);
        }
      }
      var M = { _driver: "asyncStorage", _initStorage: function(t4) {
        var e5 = this, n3 = { db: null };
        if (t4)
          for (var i2 in t4)
            n3[i2] = t4[i2];
        var r3 = d[n3.name];
        r3 || (r3 = { forages: [], db: null, dbReady: null, deferredOperations: [] }, d[n3.name] = r3), r3.forages.push(e5), e5._initReady || (e5._initReady = e5.ready, e5.ready = S);
        var o3 = [];
        function a2() {
          return s2.resolve();
        }
        for (var l2 = 0; l2 < r3.forages.length; l2++) {
          var u2 = r3.forages[l2];
          u2 !== e5 && o3.push(u2._initReady().catch(a2));
        }
        var h2 = r3.forages.slice(0);
        return s2.all(o3).then(function() {
          return n3.db = r3.db, y(n3);
        }).then(function(t5) {
          return n3.db = t5, b(n3, e5._defaultConfig.version) ? x(n3) : t5;
        }).then(function(t5) {
          n3.db = r3.db = t5, e5._dbInfo = n3;
          for (var i3 = 0; i3 < h2.length; i3++) {
            var o4 = h2[i3];
            o4 !== e5 && (o4._dbInfo.db = n3.db, o4._dbInfo.version = n3.version);
          }
        });
      }, _support: function() {
        try {
          if (!r2 || !r2.open)
            return false;
          var t4 = typeof openDatabase != "undefined" && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform), e5 = typeof fetch == "function" && fetch.toString().indexOf("[native code") !== -1;
          return (!t4 || e5) && typeof indexedDB != "undefined" && typeof IDBKeyRange != "undefined";
        } catch (t5) {
          return false;
        }
      }(), iterate: function(t4, e5) {
        var n3 = this, i2 = new s2(function(e6, i3) {
          n3.ready().then(function() {
            E(n3._dbInfo, "readonly", function(r3, o3) {
              if (r3)
                return i3(r3);
              try {
                var s3 = o3.objectStore(n3._dbInfo.storeName).openCursor(), a2 = 1;
                s3.onsuccess = function() {
                  var n4 = s3.result;
                  if (n4) {
                    var i4 = n4.value;
                    w(i4) && (i4 = T(i4));
                    var r4 = t4(i4, n4.key, a2++);
                    r4 !== void 0 ? e6(r4) : n4.continue();
                  } else
                    e6();
                }, s3.onerror = function() {
                  i3(s3.error);
                };
              } catch (t5) {
                i3(t5);
              }
            });
          }).catch(i3);
        });
        return a(i2, e5), i2;
      }, getItem: function(t4, e5) {
        var n3 = this;
        t4 = u(t4);
        var i2 = new s2(function(e6, i3) {
          n3.ready().then(function() {
            E(n3._dbInfo, "readonly", function(r3, o3) {
              if (r3)
                return i3(r3);
              try {
                var s3 = o3.objectStore(n3._dbInfo.storeName).get(t4);
                s3.onsuccess = function() {
                  var t5 = s3.result;
                  t5 === void 0 && (t5 = null), w(t5) && (t5 = T(t5)), e6(t5);
                }, s3.onerror = function() {
                  i3(s3.error);
                };
              } catch (t5) {
                i3(t5);
              }
            });
          }).catch(i3);
        });
        return a(i2, e5), i2;
      }, setItem: function(t4, e5, n3) {
        var i2 = this;
        t4 = u(t4);
        var r3 = new s2(function(n4, r4) {
          var o3;
          i2.ready().then(function() {
            return o3 = i2._dbInfo, p.call(e5) === "[object Blob]" ? f(o3.db).then(function(t5) {
              return t5 ? e5 : (n5 = e5, new s2(function(t6, e6) {
                var i3 = new FileReader();
                i3.onerror = e6, i3.onloadend = function(e7) {
                  var i4 = btoa(e7.target.result || "");
                  t6({ __local_forage_encoded_blob: true, data: i4, type: n5.type });
                }, i3.readAsBinaryString(n5);
              }));
              var n5;
            }) : e5;
          }).then(function(e6) {
            E(i2._dbInfo, "readwrite", function(o4, s3) {
              if (o4)
                return r4(o4);
              try {
                var a2 = s3.objectStore(i2._dbInfo.storeName);
                e6 === null && (e6 = void 0);
                var l2 = a2.put(e6, t4);
                s3.oncomplete = function() {
                  e6 === void 0 && (e6 = null), n4(e6);
                }, s3.onabort = s3.onerror = function() {
                  var t5 = l2.error ? l2.error : l2.transaction.error;
                  r4(t5);
                };
              } catch (t5) {
                r4(t5);
              }
            });
          }).catch(r4);
        });
        return a(r3, n3), r3;
      }, removeItem: function(t4, e5) {
        var n3 = this;
        t4 = u(t4);
        var i2 = new s2(function(e6, i3) {
          n3.ready().then(function() {
            E(n3._dbInfo, "readwrite", function(r3, o3) {
              if (r3)
                return i3(r3);
              try {
                var s3 = o3.objectStore(n3._dbInfo.storeName).delete(t4);
                o3.oncomplete = function() {
                  e6();
                }, o3.onerror = function() {
                  i3(s3.error);
                }, o3.onabort = function() {
                  var t5 = s3.error ? s3.error : s3.transaction.error;
                  i3(t5);
                };
              } catch (t5) {
                i3(t5);
              }
            });
          }).catch(i3);
        });
        return a(i2, e5), i2;
      }, clear: function(t4) {
        var e5 = this, n3 = new s2(function(t5, n4) {
          e5.ready().then(function() {
            E(e5._dbInfo, "readwrite", function(i2, r3) {
              if (i2)
                return n4(i2);
              try {
                var o3 = r3.objectStore(e5._dbInfo.storeName).clear();
                r3.oncomplete = function() {
                  t5();
                }, r3.onabort = r3.onerror = function() {
                  var t6 = o3.error ? o3.error : o3.transaction.error;
                  n4(t6);
                };
              } catch (t6) {
                n4(t6);
              }
            });
          }).catch(n4);
        });
        return a(n3, t4), n3;
      }, length: function(t4) {
        var e5 = this, n3 = new s2(function(t5, n4) {
          e5.ready().then(function() {
            E(e5._dbInfo, "readonly", function(i2, r3) {
              if (i2)
                return n4(i2);
              try {
                var o3 = r3.objectStore(e5._dbInfo.storeName).count();
                o3.onsuccess = function() {
                  t5(o3.result);
                }, o3.onerror = function() {
                  n4(o3.error);
                };
              } catch (t6) {
                n4(t6);
              }
            });
          }).catch(n4);
        });
        return a(n3, t4), n3;
      }, key: function(t4, e5) {
        var n3 = this, i2 = new s2(function(e6, i3) {
          t4 < 0 ? e6(null) : n3.ready().then(function() {
            E(n3._dbInfo, "readonly", function(r3, o3) {
              if (r3)
                return i3(r3);
              try {
                var s3 = o3.objectStore(n3._dbInfo.storeName), a2 = false, l2 = s3.openKeyCursor();
                l2.onsuccess = function() {
                  var n4 = l2.result;
                  n4 ? t4 === 0 || a2 ? e6(n4.key) : (a2 = true, n4.advance(t4)) : e6(null);
                }, l2.onerror = function() {
                  i3(l2.error);
                };
              } catch (t5) {
                i3(t5);
              }
            });
          }).catch(i3);
        });
        return a(i2, e5), i2;
      }, keys: function(t4) {
        var e5 = this, n3 = new s2(function(t5, n4) {
          e5.ready().then(function() {
            E(e5._dbInfo, "readonly", function(i2, r3) {
              if (i2)
                return n4(i2);
              try {
                var o3 = r3.objectStore(e5._dbInfo.storeName).openKeyCursor(), s3 = [];
                o3.onsuccess = function() {
                  var e6 = o3.result;
                  e6 ? (s3.push(e6.key), e6.continue()) : t5(s3);
                }, o3.onerror = function() {
                  n4(o3.error);
                };
              } catch (t6) {
                n4(t6);
              }
            });
          }).catch(n4);
        });
        return a(n3, t4), n3;
      }, dropInstance: function(t4, e5) {
        e5 = h.apply(this, arguments);
        var n3 = this.config();
        (t4 = typeof t4 != "function" && t4 || {}).name || (t4.name = t4.name || n3.name, t4.storeName = t4.storeName || n3.storeName);
        var i2, o3 = this;
        if (t4.name) {
          var l2 = t4.name === n3.name && o3._dbInfo.db, u2 = l2 ? s2.resolve(o3._dbInfo.db) : y(t4).then(function(e6) {
            var n4 = d[t4.name], i3 = n4.forages;
            n4.db = e6;
            for (var r3 = 0; r3 < i3.length; r3++)
              i3[r3]._dbInfo.db = e6;
            return e6;
          });
          i2 = t4.storeName ? u2.then(function(e6) {
            if (e6.objectStoreNames.contains(t4.storeName)) {
              var n4 = e6.version + 1;
              m(t4);
              var i3 = d[t4.name], o4 = i3.forages;
              e6.close();
              for (var a2 = 0; a2 < o4.length; a2++) {
                var l3 = o4[a2];
                l3._dbInfo.db = null, l3._dbInfo.version = n4;
              }
              return new s2(function(e7, i4) {
                var o5 = r2.open(t4.name, n4);
                o5.onerror = function(t5) {
                  o5.result.close(), i4(t5);
                }, o5.onupgradeneeded = function() {
                  o5.result.deleteObjectStore(t4.storeName);
                }, o5.onsuccess = function() {
                  var t5 = o5.result;
                  t5.close(), e7(t5);
                };
              }).then(function(t5) {
                i3.db = t5;
                for (var e7 = 0; e7 < o4.length; e7++) {
                  var n5 = o4[e7];
                  n5._dbInfo.db = t5, g(n5._dbInfo);
                }
              }).catch(function(e7) {
                throw (v(t4, e7) || s2.resolve()).catch(function() {
                }), e7;
              });
            }
          }) : u2.then(function(e6) {
            m(t4);
            var n4 = d[t4.name], i3 = n4.forages;
            e6.close();
            for (var o4 = 0; o4 < i3.length; o4++)
              i3[o4]._dbInfo.db = null;
            return new s2(function(e7, n5) {
              var i4 = r2.deleteDatabase(t4.name);
              i4.onerror = i4.onblocked = function(t5) {
                var e8 = i4.result;
                e8 && e8.close(), n5(t5);
              }, i4.onsuccess = function() {
                var t5 = i4.result;
                t5 && t5.close(), e7(t5);
              };
            }).then(function(t5) {
              n4.db = t5;
              for (var e7 = 0; e7 < i3.length; e7++)
                g(i3[e7]._dbInfo);
            }).catch(function(e7) {
              throw (v(t4, e7) || s2.resolve()).catch(function() {
              }), e7;
            });
          });
        } else
          i2 = s2.reject("Invalid arguments");
        return a(i2, e5), i2;
      } }, A = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", R = /^~~local_forage_type~([^~]+)~/, P = "__lfsc__:".length, C = P + "arbf".length, I = Object.prototype.toString;
      function O(t4) {
        var e5, n3, i2, r3, o3, s3 = 0.75 * t4.length, a2 = t4.length, l2 = 0;
        t4[t4.length - 1] === "=" && (s3--, t4[t4.length - 2] === "=" && s3--);
        var u2 = new ArrayBuffer(s3), h2 = new Uint8Array(u2);
        for (e5 = 0; e5 < a2; e5 += 4)
          n3 = A.indexOf(t4[e5]), i2 = A.indexOf(t4[e5 + 1]), r3 = A.indexOf(t4[e5 + 2]), o3 = A.indexOf(t4[e5 + 3]), h2[l2++] = n3 << 2 | i2 >> 4, h2[l2++] = (15 & i2) << 4 | r3 >> 2, h2[l2++] = (3 & r3) << 6 | 63 & o3;
        return u2;
      }
      function L(t4) {
        var e5, n3 = new Uint8Array(t4), i2 = "";
        for (e5 = 0; e5 < n3.length; e5 += 3)
          i2 += A[n3[e5] >> 2], i2 += A[(3 & n3[e5]) << 4 | n3[e5 + 1] >> 4], i2 += A[(15 & n3[e5 + 1]) << 2 | n3[e5 + 2] >> 6], i2 += A[63 & n3[e5 + 2]];
        return n3.length % 3 == 2 ? i2 = i2.substring(0, i2.length - 1) + "=" : n3.length % 3 == 1 && (i2 = i2.substring(0, i2.length - 2) + "=="), i2;
      }
      var N = { serialize: function(t4, e5) {
        var n3 = "";
        if (t4 && (n3 = I.call(t4)), t4 && (n3 === "[object ArrayBuffer]" || t4.buffer && I.call(t4.buffer) === "[object ArrayBuffer]")) {
          var i2, r3 = "__lfsc__:";
          t4 instanceof ArrayBuffer ? (i2 = t4, r3 += "arbf") : (i2 = t4.buffer, n3 === "[object Int8Array]" ? r3 += "si08" : n3 === "[object Uint8Array]" ? r3 += "ui08" : n3 === "[object Uint8ClampedArray]" ? r3 += "uic8" : n3 === "[object Int16Array]" ? r3 += "si16" : n3 === "[object Uint16Array]" ? r3 += "ur16" : n3 === "[object Int32Array]" ? r3 += "si32" : n3 === "[object Uint32Array]" ? r3 += "ui32" : n3 === "[object Float32Array]" ? r3 += "fl32" : n3 === "[object Float64Array]" ? r3 += "fl64" : e5(new Error("Failed to get type for BinaryArray"))), e5(r3 + L(i2));
        } else if (n3 === "[object Blob]") {
          var o3 = new FileReader();
          o3.onload = function() {
            var n4 = "~~local_forage_type~" + t4.type + "~" + L(this.result);
            e5("__lfsc__:blob" + n4);
          }, o3.readAsArrayBuffer(t4);
        } else
          try {
            e5(JSON.stringify(t4));
          } catch (n4) {
            console.error("Couldn't convert value into a JSON string: ", t4), e5(null, n4);
          }
      }, deserialize: function(t4) {
        if (t4.substring(0, P) !== "__lfsc__:")
          return JSON.parse(t4);
        var e5, n3 = t4.substring(C), i2 = t4.substring(P, C);
        if (i2 === "blob" && R.test(n3)) {
          var r3 = n3.match(R);
          e5 = r3[1], n3 = n3.substring(r3[0].length);
        }
        var s3 = O(n3);
        switch (i2) {
          case "arbf":
            return s3;
          case "blob":
            return o2([s3], { type: e5 });
          case "si08":
            return new Int8Array(s3);
          case "ui08":
            return new Uint8Array(s3);
          case "uic8":
            return new Uint8ClampedArray(s3);
          case "si16":
            return new Int16Array(s3);
          case "ur16":
            return new Uint16Array(s3);
          case "si32":
            return new Int32Array(s3);
          case "ui32":
            return new Uint32Array(s3);
          case "fl32":
            return new Float32Array(s3);
          case "fl64":
            return new Float64Array(s3);
          default:
            throw new Error("Unkown type: " + i2);
        }
      }, stringToBuffer: O, bufferToString: L };
      function D(t4, e5, n3, i2) {
        t4.executeSql("CREATE TABLE IF NOT EXISTS " + e5.storeName + " (id INTEGER PRIMARY KEY, key unique, value)", [], n3, i2);
      }
      function F(t4, e5, n3, i2, r3, o3) {
        t4.executeSql(n3, i2, r3, function(t5, s3) {
          s3.code === s3.SYNTAX_ERR ? t5.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name = ?", [e5.storeName], function(t6, a2) {
            a2.rows.length ? o3(t6, s3) : D(t6, e5, function() {
              t6.executeSql(n3, i2, r3, o3);
            }, o3);
          }, o3) : o3(t5, s3);
        }, o3);
      }
      function B(t4, e5, n3, i2) {
        var r3 = this;
        t4 = u(t4);
        var o3 = new s2(function(o4, s3) {
          r3.ready().then(function() {
            e5 === void 0 && (e5 = null);
            var a2 = e5, l2 = r3._dbInfo;
            l2.serializer.serialize(e5, function(e6, u2) {
              u2 ? s3(u2) : l2.db.transaction(function(n4) {
                F(n4, l2, "INSERT OR REPLACE INTO " + l2.storeName + " (key, value) VALUES (?, ?)", [t4, e6], function() {
                  o4(a2);
                }, function(t5, e7) {
                  s3(e7);
                });
              }, function(e7) {
                if (e7.code === e7.QUOTA_ERR) {
                  if (i2 > 0)
                    return void o4(B.apply(r3, [t4, a2, n3, i2 - 1]));
                  s3(e7);
                }
              });
            });
          }).catch(s3);
        });
        return a(o3, n3), o3;
      }
      function U(t4) {
        return new s2(function(e5, n3) {
          t4.transaction(function(i2) {
            i2.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function(n4, i3) {
              for (var r3 = [], o3 = 0; o3 < i3.rows.length; o3++)
                r3.push(i3.rows.item(o3).name);
              e5({ db: t4, storeNames: r3 });
            }, function(t5, e6) {
              n3(e6);
            });
          }, function(t5) {
            n3(t5);
          });
        });
      }
      var k = { _driver: "webSQLStorage", _initStorage: function(t4) {
        var e5 = this, n3 = { db: null };
        if (t4)
          for (var i2 in t4)
            n3[i2] = typeof t4[i2] != "string" ? t4[i2].toString() : t4[i2];
        var r3 = new s2(function(t5, i3) {
          try {
            n3.db = openDatabase(n3.name, String(n3.version), n3.description, n3.size);
          } catch (t6) {
            return i3(t6);
          }
          n3.db.transaction(function(r4) {
            D(r4, n3, function() {
              e5._dbInfo = n3, t5();
            }, function(t6, e6) {
              i3(e6);
            });
          }, i3);
        });
        return n3.serializer = N, r3;
      }, _support: typeof openDatabase == "function", iterate: function(t4, e5) {
        var n3 = this, i2 = new s2(function(e6, i3) {
          n3.ready().then(function() {
            var r3 = n3._dbInfo;
            r3.db.transaction(function(n4) {
              F(n4, r3, "SELECT * FROM " + r3.storeName, [], function(n5, i4) {
                for (var o3 = i4.rows, s3 = o3.length, a2 = 0; a2 < s3; a2++) {
                  var l2 = o3.item(a2), u2 = l2.value;
                  if (u2 && (u2 = r3.serializer.deserialize(u2)), (u2 = t4(u2, l2.key, a2 + 1)) !== void 0)
                    return void e6(u2);
                }
                e6();
              }, function(t5, e7) {
                i3(e7);
              });
            });
          }).catch(i3);
        });
        return a(i2, e5), i2;
      }, getItem: function(t4, e5) {
        var n3 = this;
        t4 = u(t4);
        var i2 = new s2(function(e6, i3) {
          n3.ready().then(function() {
            var r3 = n3._dbInfo;
            r3.db.transaction(function(n4) {
              F(n4, r3, "SELECT * FROM " + r3.storeName + " WHERE key = ? LIMIT 1", [t4], function(t5, n5) {
                var i4 = n5.rows.length ? n5.rows.item(0).value : null;
                i4 && (i4 = r3.serializer.deserialize(i4)), e6(i4);
              }, function(t5, e7) {
                i3(e7);
              });
            });
          }).catch(i3);
        });
        return a(i2, e5), i2;
      }, setItem: function(t4, e5, n3) {
        return B.apply(this, [t4, e5, n3, 1]);
      }, removeItem: function(t4, e5) {
        var n3 = this;
        t4 = u(t4);
        var i2 = new s2(function(e6, i3) {
          n3.ready().then(function() {
            var r3 = n3._dbInfo;
            r3.db.transaction(function(n4) {
              F(n4, r3, "DELETE FROM " + r3.storeName + " WHERE key = ?", [t4], function() {
                e6();
              }, function(t5, e7) {
                i3(e7);
              });
            });
          }).catch(i3);
        });
        return a(i2, e5), i2;
      }, clear: function(t4) {
        var e5 = this, n3 = new s2(function(t5, n4) {
          e5.ready().then(function() {
            var i2 = e5._dbInfo;
            i2.db.transaction(function(e6) {
              F(e6, i2, "DELETE FROM " + i2.storeName, [], function() {
                t5();
              }, function(t6, e7) {
                n4(e7);
              });
            });
          }).catch(n4);
        });
        return a(n3, t4), n3;
      }, length: function(t4) {
        var e5 = this, n3 = new s2(function(t5, n4) {
          e5.ready().then(function() {
            var i2 = e5._dbInfo;
            i2.db.transaction(function(e6) {
              F(e6, i2, "SELECT COUNT(key) as c FROM " + i2.storeName, [], function(e7, n5) {
                var i3 = n5.rows.item(0).c;
                t5(i3);
              }, function(t6, e7) {
                n4(e7);
              });
            });
          }).catch(n4);
        });
        return a(n3, t4), n3;
      }, key: function(t4, e5) {
        var n3 = this, i2 = new s2(function(e6, i3) {
          n3.ready().then(function() {
            var r3 = n3._dbInfo;
            r3.db.transaction(function(n4) {
              F(n4, r3, "SELECT key FROM " + r3.storeName + " WHERE id = ? LIMIT 1", [t4 + 1], function(t5, n5) {
                var i4 = n5.rows.length ? n5.rows.item(0).key : null;
                e6(i4);
              }, function(t5, e7) {
                i3(e7);
              });
            });
          }).catch(i3);
        });
        return a(i2, e5), i2;
      }, keys: function(t4) {
        var e5 = this, n3 = new s2(function(t5, n4) {
          e5.ready().then(function() {
            var i2 = e5._dbInfo;
            i2.db.transaction(function(e6) {
              F(e6, i2, "SELECT key FROM " + i2.storeName, [], function(e7, n5) {
                for (var i3 = [], r3 = 0; r3 < n5.rows.length; r3++)
                  i3.push(n5.rows.item(r3).key);
                t5(i3);
              }, function(t6, e7) {
                n4(e7);
              });
            });
          }).catch(n4);
        });
        return a(n3, t4), n3;
      }, dropInstance: function(t4, e5) {
        e5 = h.apply(this, arguments);
        var n3 = this.config();
        (t4 = typeof t4 != "function" && t4 || {}).name || (t4.name = t4.name || n3.name, t4.storeName = t4.storeName || n3.storeName);
        var i2, r3 = this;
        return a(i2 = t4.name ? new s2(function(e6) {
          var i3;
          i3 = t4.name === n3.name ? r3._dbInfo.db : openDatabase(t4.name, "", "", 0), t4.storeName ? e6({ db: i3, storeNames: [t4.storeName] }) : e6(U(i3));
        }).then(function(t5) {
          return new s2(function(e6, n4) {
            t5.db.transaction(function(i3) {
              function r4(t6) {
                return new s2(function(e7, n5) {
                  i3.executeSql("DROP TABLE IF EXISTS " + t6, [], function() {
                    e7();
                  }, function(t7, e8) {
                    n5(e8);
                  });
                });
              }
              for (var o3 = [], a2 = 0, l2 = t5.storeNames.length; a2 < l2; a2++)
                o3.push(r4(t5.storeNames[a2]));
              s2.all(o3).then(function() {
                e6();
              }).catch(function(t6) {
                n4(t6);
              });
            }, function(t6) {
              n4(t6);
            });
          });
        }) : s2.reject("Invalid arguments"), e5), i2;
      } };
      function G(t4, e5) {
        var n3 = t4.name + "/";
        return t4.storeName !== e5.storeName && (n3 += t4.storeName + "/"), n3;
      }
      function H() {
        return !function() {
          try {
            return localStorage.setItem("_localforage_support_test", true), localStorage.removeItem("_localforage_support_test"), false;
          } catch (t4) {
            return true;
          }
        }() || localStorage.length > 0;
      }
      var z = { _driver: "localStorageWrapper", _initStorage: function(t4) {
        var e5 = {};
        if (t4)
          for (var n3 in t4)
            e5[n3] = t4[n3];
        return e5.keyPrefix = G(t4, this._defaultConfig), H() ? (this._dbInfo = e5, e5.serializer = N, s2.resolve()) : s2.reject();
      }, _support: function() {
        try {
          return typeof localStorage != "undefined" && "setItem" in localStorage && !!localStorage.setItem;
        } catch (t4) {
          return false;
        }
      }(), iterate: function(t4, e5) {
        var n3 = this, i2 = n3.ready().then(function() {
          for (var e6 = n3._dbInfo, i3 = e6.keyPrefix, r3 = i3.length, o3 = localStorage.length, s3 = 1, a2 = 0; a2 < o3; a2++) {
            var l2 = localStorage.key(a2);
            if (l2.indexOf(i3) === 0) {
              var u2 = localStorage.getItem(l2);
              if (u2 && (u2 = e6.serializer.deserialize(u2)), (u2 = t4(u2, l2.substring(r3), s3++)) !== void 0)
                return u2;
            }
          }
        });
        return a(i2, e5), i2;
      }, getItem: function(t4, e5) {
        var n3 = this;
        t4 = u(t4);
        var i2 = n3.ready().then(function() {
          var e6 = n3._dbInfo, i3 = localStorage.getItem(e6.keyPrefix + t4);
          return i3 && (i3 = e6.serializer.deserialize(i3)), i3;
        });
        return a(i2, e5), i2;
      }, setItem: function(t4, e5, n3) {
        var i2 = this;
        t4 = u(t4);
        var r3 = i2.ready().then(function() {
          e5 === void 0 && (e5 = null);
          var n4 = e5;
          return new s2(function(r4, o3) {
            var s3 = i2._dbInfo;
            s3.serializer.serialize(e5, function(e6, i3) {
              if (i3)
                o3(i3);
              else
                try {
                  localStorage.setItem(s3.keyPrefix + t4, e6), r4(n4);
                } catch (t5) {
                  t5.name !== "QuotaExceededError" && t5.name !== "NS_ERROR_DOM_QUOTA_REACHED" || o3(t5), o3(t5);
                }
            });
          });
        });
        return a(r3, n3), r3;
      }, removeItem: function(t4, e5) {
        var n3 = this;
        t4 = u(t4);
        var i2 = n3.ready().then(function() {
          var e6 = n3._dbInfo;
          localStorage.removeItem(e6.keyPrefix + t4);
        });
        return a(i2, e5), i2;
      }, clear: function(t4) {
        var e5 = this, n3 = e5.ready().then(function() {
          for (var t5 = e5._dbInfo.keyPrefix, n4 = localStorage.length - 1; n4 >= 0; n4--) {
            var i2 = localStorage.key(n4);
            i2.indexOf(t5) === 0 && localStorage.removeItem(i2);
          }
        });
        return a(n3, t4), n3;
      }, length: function(t4) {
        var e5 = this.keys().then(function(t5) {
          return t5.length;
        });
        return a(e5, t4), e5;
      }, key: function(t4, e5) {
        var n3 = this, i2 = n3.ready().then(function() {
          var e6, i3 = n3._dbInfo;
          try {
            e6 = localStorage.key(t4);
          } catch (t5) {
            e6 = null;
          }
          return e6 && (e6 = e6.substring(i3.keyPrefix.length)), e6;
        });
        return a(i2, e5), i2;
      }, keys: function(t4) {
        var e5 = this, n3 = e5.ready().then(function() {
          for (var t5 = e5._dbInfo, n4 = localStorage.length, i2 = [], r3 = 0; r3 < n4; r3++) {
            var o3 = localStorage.key(r3);
            o3.indexOf(t5.keyPrefix) === 0 && i2.push(o3.substring(t5.keyPrefix.length));
          }
          return i2;
        });
        return a(n3, t4), n3;
      }, dropInstance: function(t4, e5) {
        if (e5 = h.apply(this, arguments), !(t4 = typeof t4 != "function" && t4 || {}).name) {
          var n3 = this.config();
          t4.name = t4.name || n3.name, t4.storeName = t4.storeName || n3.storeName;
        }
        var i2, r3 = this;
        return a(i2 = t4.name ? new s2(function(e6) {
          t4.storeName ? e6(G(t4, r3._defaultConfig)) : e6(t4.name + "/");
        }).then(function(t5) {
          for (var e6 = localStorage.length - 1; e6 >= 0; e6--) {
            var n4 = localStorage.key(e6);
            n4.indexOf(t5) === 0 && localStorage.removeItem(n4);
          }
        }) : s2.reject("Invalid arguments"), e5), i2;
      } }, j = function(t4, e5) {
        for (var n3, i2, r3 = t4.length, o3 = 0; o3 < r3; ) {
          if ((n3 = t4[o3]) === (i2 = e5) || typeof n3 == "number" && typeof i2 == "number" && isNaN(n3) && isNaN(i2))
            return true;
          o3++;
        }
        return false;
      }, V = Array.isArray || function(t4) {
        return Object.prototype.toString.call(t4) === "[object Array]";
      }, W = {}, X = {}, q = { INDEXEDDB: M, WEBSQL: k, LOCALSTORAGE: z }, Y = [q.INDEXEDDB._driver, q.WEBSQL._driver, q.LOCALSTORAGE._driver], Z = ["dropInstance"], J = ["clear", "getItem", "iterate", "key", "keys", "length", "removeItem", "setItem"].concat(Z), $ = { description: "", driver: Y.slice(), name: "localforage", size: 4980736, storeName: "keyvaluepairs", version: 1 };
      function K(t4, e5) {
        t4[e5] = function() {
          var n3 = arguments;
          return t4.ready().then(function() {
            return t4[e5].apply(t4, n3);
          });
        };
      }
      function Q() {
        for (var t4 = 1; t4 < arguments.length; t4++) {
          var e5 = arguments[t4];
          if (e5)
            for (var n3 in e5)
              e5.hasOwnProperty(n3) && (V(e5[n3]) ? arguments[0][n3] = e5[n3].slice() : arguments[0][n3] = e5[n3]);
        }
        return arguments[0];
      }
      var tt = new (function() {
        function t4(e5) {
          for (var n3 in function(t5, e6) {
            if (!(t5 instanceof e6))
              throw new TypeError("Cannot call a class as a function");
          }(this, t4), q)
            if (q.hasOwnProperty(n3)) {
              var i2 = q[n3], r3 = i2._driver;
              this[n3] = r3, W[r3] || this.defineDriver(i2);
            }
          this._defaultConfig = Q({}, $), this._config = Q({}, this._defaultConfig, e5), this._driverSet = null, this._initDriver = null, this._ready = false, this._dbInfo = null, this._wrapLibraryMethodsWithReady(), this.setDriver(this._config.driver).catch(function() {
          });
        }
        return t4.prototype.config = function(t5) {
          if ((t5 === void 0 ? "undefined" : i(t5)) === "object") {
            if (this._ready)
              return new Error("Can't call config() after localforage has been used.");
            for (var e5 in t5) {
              if (e5 === "storeName" && (t5[e5] = t5[e5].replace(/\W/g, "_")), e5 === "version" && typeof t5[e5] != "number")
                return new Error("Database version must be a number.");
              this._config[e5] = t5[e5];
            }
            return !("driver" in t5) || !t5.driver || this.setDriver(this._config.driver);
          }
          return typeof t5 == "string" ? this._config[t5] : this._config;
        }, t4.prototype.defineDriver = function(t5, e5, n3) {
          var i2 = new s2(function(e6, n4) {
            try {
              var i3 = t5._driver, r3 = new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver");
              if (!t5._driver)
                return void n4(r3);
              for (var o3 = J.concat("_initStorage"), l2 = 0, u2 = o3.length; l2 < u2; l2++) {
                var h2 = o3[l2];
                if ((!j(Z, h2) || t5[h2]) && typeof t5[h2] != "function")
                  return void n4(r3);
              }
              !function() {
                for (var e7 = function(t6) {
                  return function() {
                    var e8 = new Error("Method " + t6 + " is not implemented by the current driver"), n6 = s2.reject(e8);
                    return a(n6, arguments[arguments.length - 1]), n6;
                  };
                }, n5 = 0, i4 = Z.length; n5 < i4; n5++) {
                  var r4 = Z[n5];
                  t5[r4] || (t5[r4] = e7(r4));
                }
              }();
              var c2 = function(n5) {
                W[i3] && console.info("Redefining LocalForage driver: " + i3), W[i3] = t5, X[i3] = n5, e6();
              };
              "_support" in t5 ? t5._support && typeof t5._support == "function" ? t5._support().then(c2, n4) : c2(!!t5._support) : c2(true);
            } catch (t6) {
              n4(t6);
            }
          });
          return l(i2, e5, n3), i2;
        }, t4.prototype.driver = function() {
          return this._driver || null;
        }, t4.prototype.getDriver = function(t5, e5, n3) {
          var i2 = W[t5] ? s2.resolve(W[t5]) : s2.reject(new Error("Driver not found."));
          return l(i2, e5, n3), i2;
        }, t4.prototype.getSerializer = function(t5) {
          var e5 = s2.resolve(N);
          return l(e5, t5), e5;
        }, t4.prototype.ready = function(t5) {
          var e5 = this, n3 = e5._driverSet.then(function() {
            return e5._ready === null && (e5._ready = e5._initDriver()), e5._ready;
          });
          return l(n3, t5, t5), n3;
        }, t4.prototype.setDriver = function(t5, e5, n3) {
          var i2 = this;
          V(t5) || (t5 = [t5]);
          var r3 = this._getSupportedDrivers(t5);
          function o3() {
            i2._config.driver = i2.driver();
          }
          function a2(t6) {
            return i2._extend(t6), o3(), i2._ready = i2._initStorage(i2._config), i2._ready;
          }
          var u2 = this._driverSet !== null ? this._driverSet.catch(function() {
            return s2.resolve();
          }) : s2.resolve();
          return this._driverSet = u2.then(function() {
            var t6 = r3[0];
            return i2._dbInfo = null, i2._ready = null, i2.getDriver(t6).then(function(t7) {
              i2._driver = t7._driver, o3(), i2._wrapLibraryMethodsWithReady(), i2._initDriver = function(t8) {
                return function() {
                  var e6 = 0;
                  return function n4() {
                    for (; e6 < t8.length; ) {
                      var r4 = t8[e6];
                      return e6++, i2._dbInfo = null, i2._ready = null, i2.getDriver(r4).then(a2).catch(n4);
                    }
                    o3();
                    var l2 = new Error("No available storage method found.");
                    return i2._driverSet = s2.reject(l2), i2._driverSet;
                  }();
                };
              }(r3);
            });
          }).catch(function() {
            o3();
            var t6 = new Error("No available storage method found.");
            return i2._driverSet = s2.reject(t6), i2._driverSet;
          }), l(this._driverSet, e5, n3), this._driverSet;
        }, t4.prototype.supports = function(t5) {
          return !!X[t5];
        }, t4.prototype._extend = function(t5) {
          Q(this, t5);
        }, t4.prototype._getSupportedDrivers = function(t5) {
          for (var e5 = [], n3 = 0, i2 = t5.length; n3 < i2; n3++) {
            var r3 = t5[n3];
            this.supports(r3) && e5.push(r3);
          }
          return e5;
        }, t4.prototype._wrapLibraryMethodsWithReady = function() {
          for (var t5 = 0, e5 = J.length; t5 < e5; t5++)
            K(this, J[t5]);
        }, t4.prototype.createInstance = function(e5) {
          return new t4(e5);
        }, t4;
      }())();
      e4.exports = tt;
    }, { 3: 3 }] }, {}, [4])(4);
  }).call(this, n(4));
}, function(t2, e2, n) {
  var i;
  !function(r2) {
    function o2(t3, e3) {
      var n2 = (65535 & t3) + (65535 & e3);
      return (t3 >> 16) + (e3 >> 16) + (n2 >> 16) << 16 | 65535 & n2;
    }
    function s2(t3, e3, n2, i2, r3, s3) {
      return o2((a2 = o2(o2(e3, t3), o2(i2, s3))) << (l2 = r3) | a2 >>> 32 - l2, n2);
      var a2, l2;
    }
    function a(t3, e3, n2, i2, r3, o3, a2) {
      return s2(e3 & n2 | ~e3 & i2, t3, e3, r3, o3, a2);
    }
    function l(t3, e3, n2, i2, r3, o3, a2) {
      return s2(e3 & i2 | n2 & ~i2, t3, e3, r3, o3, a2);
    }
    function u(t3, e3, n2, i2, r3, o3, a2) {
      return s2(e3 ^ n2 ^ i2, t3, e3, r3, o3, a2);
    }
    function h(t3, e3, n2, i2, r3, o3, a2) {
      return s2(n2 ^ (e3 | ~i2), t3, e3, r3, o3, a2);
    }
    function c(t3, e3) {
      var n2, i2, r3, s3, c2;
      t3[e3 >> 5] |= 128 << e3 % 32, t3[14 + (e3 + 64 >>> 9 << 4)] = e3;
      var d2 = 1732584193, p2 = -271733879, f2 = -1732584194, m2 = 271733878;
      for (n2 = 0; n2 < t3.length; n2 += 16)
        i2 = d2, r3 = p2, s3 = f2, c2 = m2, d2 = a(d2, p2, f2, m2, t3[n2], 7, -680876936), m2 = a(m2, d2, p2, f2, t3[n2 + 1], 12, -389564586), f2 = a(f2, m2, d2, p2, t3[n2 + 2], 17, 606105819), p2 = a(p2, f2, m2, d2, t3[n2 + 3], 22, -1044525330), d2 = a(d2, p2, f2, m2, t3[n2 + 4], 7, -176418897), m2 = a(m2, d2, p2, f2, t3[n2 + 5], 12, 1200080426), f2 = a(f2, m2, d2, p2, t3[n2 + 6], 17, -1473231341), p2 = a(p2, f2, m2, d2, t3[n2 + 7], 22, -45705983), d2 = a(d2, p2, f2, m2, t3[n2 + 8], 7, 1770035416), m2 = a(m2, d2, p2, f2, t3[n2 + 9], 12, -1958414417), f2 = a(f2, m2, d2, p2, t3[n2 + 10], 17, -42063), p2 = a(p2, f2, m2, d2, t3[n2 + 11], 22, -1990404162), d2 = a(d2, p2, f2, m2, t3[n2 + 12], 7, 1804603682), m2 = a(m2, d2, p2, f2, t3[n2 + 13], 12, -40341101), f2 = a(f2, m2, d2, p2, t3[n2 + 14], 17, -1502002290), d2 = l(d2, p2 = a(p2, f2, m2, d2, t3[n2 + 15], 22, 1236535329), f2, m2, t3[n2 + 1], 5, -165796510), m2 = l(m2, d2, p2, f2, t3[n2 + 6], 9, -1069501632), f2 = l(f2, m2, d2, p2, t3[n2 + 11], 14, 643717713), p2 = l(p2, f2, m2, d2, t3[n2], 20, -373897302), d2 = l(d2, p2, f2, m2, t3[n2 + 5], 5, -701558691), m2 = l(m2, d2, p2, f2, t3[n2 + 10], 9, 38016083), f2 = l(f2, m2, d2, p2, t3[n2 + 15], 14, -660478335), p2 = l(p2, f2, m2, d2, t3[n2 + 4], 20, -405537848), d2 = l(d2, p2, f2, m2, t3[n2 + 9], 5, 568446438), m2 = l(m2, d2, p2, f2, t3[n2 + 14], 9, -1019803690), f2 = l(f2, m2, d2, p2, t3[n2 + 3], 14, -187363961), p2 = l(p2, f2, m2, d2, t3[n2 + 8], 20, 1163531501), d2 = l(d2, p2, f2, m2, t3[n2 + 13], 5, -1444681467), m2 = l(m2, d2, p2, f2, t3[n2 + 2], 9, -51403784), f2 = l(f2, m2, d2, p2, t3[n2 + 7], 14, 1735328473), d2 = u(d2, p2 = l(p2, f2, m2, d2, t3[n2 + 12], 20, -1926607734), f2, m2, t3[n2 + 5], 4, -378558), m2 = u(m2, d2, p2, f2, t3[n2 + 8], 11, -2022574463), f2 = u(f2, m2, d2, p2, t3[n2 + 11], 16, 1839030562), p2 = u(p2, f2, m2, d2, t3[n2 + 14], 23, -35309556), d2 = u(d2, p2, f2, m2, t3[n2 + 1], 4, -1530992060), m2 = u(m2, d2, p2, f2, t3[n2 + 4], 11, 1272893353), f2 = u(f2, m2, d2, p2, t3[n2 + 7], 16, -155497632), p2 = u(p2, f2, m2, d2, t3[n2 + 10], 23, -1094730640), d2 = u(d2, p2, f2, m2, t3[n2 + 13], 4, 681279174), m2 = u(m2, d2, p2, f2, t3[n2], 11, -358537222), f2 = u(f2, m2, d2, p2, t3[n2 + 3], 16, -722521979), p2 = u(p2, f2, m2, d2, t3[n2 + 6], 23, 76029189), d2 = u(d2, p2, f2, m2, t3[n2 + 9], 4, -640364487), m2 = u(m2, d2, p2, f2, t3[n2 + 12], 11, -421815835), f2 = u(f2, m2, d2, p2, t3[n2 + 15], 16, 530742520), d2 = h(d2, p2 = u(p2, f2, m2, d2, t3[n2 + 2], 23, -995338651), f2, m2, t3[n2], 6, -198630844), m2 = h(m2, d2, p2, f2, t3[n2 + 7], 10, 1126891415), f2 = h(f2, m2, d2, p2, t3[n2 + 14], 15, -1416354905), p2 = h(p2, f2, m2, d2, t3[n2 + 5], 21, -57434055), d2 = h(d2, p2, f2, m2, t3[n2 + 12], 6, 1700485571), m2 = h(m2, d2, p2, f2, t3[n2 + 3], 10, -1894986606), f2 = h(f2, m2, d2, p2, t3[n2 + 10], 15, -1051523), p2 = h(p2, f2, m2, d2, t3[n2 + 1], 21, -2054922799), d2 = h(d2, p2, f2, m2, t3[n2 + 8], 6, 1873313359), m2 = h(m2, d2, p2, f2, t3[n2 + 15], 10, -30611744), f2 = h(f2, m2, d2, p2, t3[n2 + 6], 15, -1560198380), p2 = h(p2, f2, m2, d2, t3[n2 + 13], 21, 1309151649), d2 = h(d2, p2, f2, m2, t3[n2 + 4], 6, -145523070), m2 = h(m2, d2, p2, f2, t3[n2 + 11], 10, -1120210379), f2 = h(f2, m2, d2, p2, t3[n2 + 2], 15, 718787259), p2 = h(p2, f2, m2, d2, t3[n2 + 9], 21, -343485551), d2 = o2(d2, i2), p2 = o2(p2, r3), f2 = o2(f2, s3), m2 = o2(m2, c2);
      return [d2, p2, f2, m2];
    }
    function d(t3) {
      var e3, n2 = "", i2 = 32 * t3.length;
      for (e3 = 0; e3 < i2; e3 += 8)
        n2 += String.fromCharCode(t3[e3 >> 5] >>> e3 % 32 & 255);
      return n2;
    }
    function p(t3) {
      var e3, n2 = [];
      for (n2[(t3.length >> 2) - 1] = void 0, e3 = 0; e3 < n2.length; e3 += 1)
        n2[e3] = 0;
      var i2 = 8 * t3.length;
      for (e3 = 0; e3 < i2; e3 += 8)
        n2[e3 >> 5] |= (255 & t3.charCodeAt(e3 / 8)) << e3 % 32;
      return n2;
    }
    function f(t3) {
      var e3, n2, i2 = "";
      for (n2 = 0; n2 < t3.length; n2 += 1)
        e3 = t3.charCodeAt(n2), i2 += "0123456789abcdef".charAt(e3 >>> 4 & 15) + "0123456789abcdef".charAt(15 & e3);
      return i2;
    }
    function m(t3) {
      return unescape(encodeURIComponent(t3));
    }
    function g(t3) {
      return function(t4) {
        return d(c(p(t4), 8 * t4.length));
      }(m(t3));
    }
    function v(t3, e3) {
      return function(t4, e4) {
        var n2, i2, r3 = p(t4), o3 = [], s3 = [];
        for (o3[15] = s3[15] = void 0, r3.length > 16 && (r3 = c(r3, 8 * t4.length)), n2 = 0; n2 < 16; n2 += 1)
          o3[n2] = 909522486 ^ r3[n2], s3[n2] = 1549556828 ^ r3[n2];
        return i2 = c(o3.concat(p(e4)), 512 + 8 * e4.length), d(c(s3.concat(i2), 640));
      }(m(t3), m(e3));
    }
    function _(t3, e3, n2) {
      return e3 ? n2 ? v(e3, t3) : f(v(e3, t3)) : n2 ? g(t3) : f(g(t3));
    }
    (i = function() {
      return _;
    }.call(e2, n, e2, t2)) === void 0 || (t2.exports = i);
  }();
}, function(t2, e2) {
  var n;
  n = function() {
    return this;
  }();
  try {
    n = n || new Function("return this")();
  } catch (t3) {
    typeof window == "object" && (n = window);
  }
  t2.exports = n;
}, function(t2, e2, n) {
  var i = n(58), r2 = n(59);
  function o2() {
    this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
  }
  e2.parse = y, e2.resolve = function(t3, e3) {
    return y(t3, false, true).resolve(e3);
  }, e2.resolveObject = function(t3, e3) {
    return t3 ? y(t3, false, true).resolveObject(e3) : e3;
  }, e2.format = function(t3) {
    r2.isString(t3) && (t3 = y(t3));
    return t3 instanceof o2 ? t3.format() : o2.prototype.format.call(t3);
  }, e2.Url = o2;
  var s2 = /^([a-z0-9.+-]+:)/i, a = /:[0-9]*$/, l = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, u = ["{", "}", "|", "\\", "^", "`"].concat(["<", ">", '"', "`", " ", "\r", "\n", "	"]), h = ["'"].concat(u), c = ["%", "/", "?", ";", "#"].concat(h), d = ["/", "?", "#"], p = /^[+a-z0-9A-Z_-]{0,63}$/, f = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, m = { javascript: true, "javascript:": true }, g = { javascript: true, "javascript:": true }, v = { http: true, https: true, ftp: true, gopher: true, file: true, "http:": true, "https:": true, "ftp:": true, "gopher:": true, "file:": true }, _ = n(60);
  function y(t3, e3, n2) {
    if (t3 && r2.isObject(t3) && t3 instanceof o2)
      return t3;
    var i2 = new o2();
    return i2.parse(t3, e3, n2), i2;
  }
  o2.prototype.parse = function(t3, e3, n2) {
    if (!r2.isString(t3))
      throw new TypeError("Parameter 'url' must be a string, not " + typeof t3);
    var o3 = t3.indexOf("?"), a2 = o3 !== -1 && o3 < t3.indexOf("#") ? "?" : "#", u2 = t3.split(a2);
    u2[0] = u2[0].replace(/\\/g, "/");
    var y2 = t3 = u2.join(a2);
    if (y2 = y2.trim(), !n2 && t3.split("#").length === 1) {
      var x = l.exec(y2);
      if (x)
        return this.path = y2, this.href = y2, this.pathname = x[1], x[2] ? (this.search = x[2], this.query = e3 ? _.parse(this.search.substr(1)) : this.search.substr(1)) : e3 && (this.search = "", this.query = {}), this;
    }
    var b = s2.exec(y2);
    if (b) {
      var T = (b = b[0]).toLowerCase();
      this.protocol = T, y2 = y2.substr(b.length);
    }
    if (n2 || b || y2.match(/^\/\/[^@\/]+@[^@\/]+/)) {
      var w = y2.substr(0, 2) === "//";
      !w || b && g[b] || (y2 = y2.substr(2), this.slashes = true);
    }
    if (!g[b] && (w || b && !v[b])) {
      for (var S, E, M = -1, A = 0; A < d.length; A++) {
        (R = y2.indexOf(d[A])) !== -1 && (M === -1 || R < M) && (M = R);
      }
      (E = M === -1 ? y2.lastIndexOf("@") : y2.lastIndexOf("@", M)) !== -1 && (S = y2.slice(0, E), y2 = y2.slice(E + 1), this.auth = decodeURIComponent(S)), M = -1;
      for (A = 0; A < c.length; A++) {
        var R;
        (R = y2.indexOf(c[A])) !== -1 && (M === -1 || R < M) && (M = R);
      }
      M === -1 && (M = y2.length), this.host = y2.slice(0, M), y2 = y2.slice(M), this.parseHost(), this.hostname = this.hostname || "";
      var P = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
      if (!P)
        for (var C = this.hostname.split(/\./), I = (A = 0, C.length); A < I; A++) {
          var O = C[A];
          if (O && !O.match(p)) {
            for (var L = "", N = 0, D = O.length; N < D; N++)
              O.charCodeAt(N) > 127 ? L += "x" : L += O[N];
            if (!L.match(p)) {
              var F = C.slice(0, A), B = C.slice(A + 1), U = O.match(f);
              U && (F.push(U[1]), B.unshift(U[2])), B.length && (y2 = "/" + B.join(".") + y2), this.hostname = F.join(".");
              break;
            }
          }
        }
      this.hostname.length > 255 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), P || (this.hostname = i.toASCII(this.hostname));
      var k = this.port ? ":" + this.port : "", G = this.hostname || "";
      this.host = G + k, this.href += this.host, P && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), y2[0] !== "/" && (y2 = "/" + y2));
    }
    if (!m[T])
      for (A = 0, I = h.length; A < I; A++) {
        var H = h[A];
        if (y2.indexOf(H) !== -1) {
          var z = encodeURIComponent(H);
          z === H && (z = escape(H)), y2 = y2.split(H).join(z);
        }
      }
    var j = y2.indexOf("#");
    j !== -1 && (this.hash = y2.substr(j), y2 = y2.slice(0, j));
    var V = y2.indexOf("?");
    if (V !== -1 ? (this.search = y2.substr(V), this.query = y2.substr(V + 1), e3 && (this.query = _.parse(this.query)), y2 = y2.slice(0, V)) : e3 && (this.search = "", this.query = {}), y2 && (this.pathname = y2), v[T] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
      k = this.pathname || "";
      var W = this.search || "";
      this.path = k + W;
    }
    return this.href = this.format(), this;
  }, o2.prototype.format = function() {
    var t3 = this.auth || "";
    t3 && (t3 = (t3 = encodeURIComponent(t3)).replace(/%3A/i, ":"), t3 += "@");
    var e3 = this.protocol || "", n2 = this.pathname || "", i2 = this.hash || "", o3 = false, s3 = "";
    this.host ? o3 = t3 + this.host : this.hostname && (o3 = t3 + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (o3 += ":" + this.port)), this.query && r2.isObject(this.query) && Object.keys(this.query).length && (s3 = _.stringify(this.query));
    var a2 = this.search || s3 && "?" + s3 || "";
    return e3 && e3.substr(-1) !== ":" && (e3 += ":"), this.slashes || (!e3 || v[e3]) && o3 !== false ? (o3 = "//" + (o3 || ""), n2 && n2.charAt(0) !== "/" && (n2 = "/" + n2)) : o3 || (o3 = ""), i2 && i2.charAt(0) !== "#" && (i2 = "#" + i2), a2 && a2.charAt(0) !== "?" && (a2 = "?" + a2), e3 + o3 + (n2 = n2.replace(/[?#]/g, function(t4) {
      return encodeURIComponent(t4);
    })) + (a2 = a2.replace("#", "%23")) + i2;
  }, o2.prototype.resolve = function(t3) {
    return this.resolveObject(y(t3, false, true)).format();
  }, o2.prototype.resolveObject = function(t3) {
    if (r2.isString(t3)) {
      var e3 = new o2();
      e3.parse(t3, false, true), t3 = e3;
    }
    for (var n2 = new o2(), i2 = Object.keys(this), s3 = 0; s3 < i2.length; s3++) {
      var a2 = i2[s3];
      n2[a2] = this[a2];
    }
    if (n2.hash = t3.hash, t3.href === "")
      return n2.href = n2.format(), n2;
    if (t3.slashes && !t3.protocol) {
      for (var l2 = Object.keys(t3), u2 = 0; u2 < l2.length; u2++) {
        var h2 = l2[u2];
        h2 !== "protocol" && (n2[h2] = t3[h2]);
      }
      return v[n2.protocol] && n2.hostname && !n2.pathname && (n2.path = n2.pathname = "/"), n2.href = n2.format(), n2;
    }
    if (t3.protocol && t3.protocol !== n2.protocol) {
      if (!v[t3.protocol]) {
        for (var c2 = Object.keys(t3), d2 = 0; d2 < c2.length; d2++) {
          var p2 = c2[d2];
          n2[p2] = t3[p2];
        }
        return n2.href = n2.format(), n2;
      }
      if (n2.protocol = t3.protocol, t3.host || g[t3.protocol])
        n2.pathname = t3.pathname;
      else {
        for (var f2 = (t3.pathname || "").split("/"); f2.length && !(t3.host = f2.shift()); )
          ;
        t3.host || (t3.host = ""), t3.hostname || (t3.hostname = ""), f2[0] !== "" && f2.unshift(""), f2.length < 2 && f2.unshift(""), n2.pathname = f2.join("/");
      }
      if (n2.search = t3.search, n2.query = t3.query, n2.host = t3.host || "", n2.auth = t3.auth, n2.hostname = t3.hostname || t3.host, n2.port = t3.port, n2.pathname || n2.search) {
        var m2 = n2.pathname || "", _2 = n2.search || "";
        n2.path = m2 + _2;
      }
      return n2.slashes = n2.slashes || t3.slashes, n2.href = n2.format(), n2;
    }
    var y2 = n2.pathname && n2.pathname.charAt(0) === "/", x = t3.host || t3.pathname && t3.pathname.charAt(0) === "/", b = x || y2 || n2.host && t3.pathname, T = b, w = n2.pathname && n2.pathname.split("/") || [], S = (f2 = t3.pathname && t3.pathname.split("/") || [], n2.protocol && !v[n2.protocol]);
    if (S && (n2.hostname = "", n2.port = null, n2.host && (w[0] === "" ? w[0] = n2.host : w.unshift(n2.host)), n2.host = "", t3.protocol && (t3.hostname = null, t3.port = null, t3.host && (f2[0] === "" ? f2[0] = t3.host : f2.unshift(t3.host)), t3.host = null), b = b && (f2[0] === "" || w[0] === "")), x)
      n2.host = t3.host || t3.host === "" ? t3.host : n2.host, n2.hostname = t3.hostname || t3.hostname === "" ? t3.hostname : n2.hostname, n2.search = t3.search, n2.query = t3.query, w = f2;
    else if (f2.length)
      w || (w = []), w.pop(), w = w.concat(f2), n2.search = t3.search, n2.query = t3.query;
    else if (!r2.isNullOrUndefined(t3.search)) {
      if (S)
        n2.hostname = n2.host = w.shift(), (P = !!(n2.host && n2.host.indexOf("@") > 0) && n2.host.split("@")) && (n2.auth = P.shift(), n2.host = n2.hostname = P.shift());
      return n2.search = t3.search, n2.query = t3.query, r2.isNull(n2.pathname) && r2.isNull(n2.search) || (n2.path = (n2.pathname ? n2.pathname : "") + (n2.search ? n2.search : "")), n2.href = n2.format(), n2;
    }
    if (!w.length)
      return n2.pathname = null, n2.search ? n2.path = "/" + n2.search : n2.path = null, n2.href = n2.format(), n2;
    for (var E = w.slice(-1)[0], M = (n2.host || t3.host || w.length > 1) && (E === "." || E === "..") || E === "", A = 0, R = w.length; R >= 0; R--)
      (E = w[R]) === "." ? w.splice(R, 1) : E === ".." ? (w.splice(R, 1), A++) : A && (w.splice(R, 1), A--);
    if (!b && !T)
      for (; A--; A)
        w.unshift("..");
    !b || w[0] === "" || w[0] && w[0].charAt(0) === "/" || w.unshift(""), M && w.join("/").substr(-1) !== "/" && w.push("");
    var P, C = w[0] === "" || w[0] && w[0].charAt(0) === "/";
    S && (n2.hostname = n2.host = C ? "" : w.length ? w.shift() : "", (P = !!(n2.host && n2.host.indexOf("@") > 0) && n2.host.split("@")) && (n2.auth = P.shift(), n2.host = n2.hostname = P.shift()));
    return (b = b || n2.host && w.length) && !C && w.unshift(""), w.length ? n2.pathname = w.join("/") : (n2.pathname = null, n2.path = null), r2.isNull(n2.pathname) && r2.isNull(n2.search) || (n2.path = (n2.pathname ? n2.pathname : "") + (n2.search ? n2.search : "")), n2.auth = t3.auth || n2.auth, n2.slashes = n2.slashes || t3.slashes, n2.href = n2.format(), n2;
  }, o2.prototype.parseHost = function() {
    var t3 = this.host, e3 = a.exec(t3);
    e3 && ((e3 = e3[0]) !== ":" && (this.port = e3.substr(1)), t3 = t3.substr(0, t3.length - e3.length)), t3 && (this.hostname = t3);
  };
}, function(t2, e2, n) {
  (function(e3) {
    t2.exports = function t3(e4, n2, i) {
      function r2(s3, a) {
        if (!n2[s3]) {
          if (!e4[s3]) {
            if (o2)
              return o2(s3, true);
            var l = new Error("Cannot find module '" + s3 + "'");
            throw l.code = "MODULE_NOT_FOUND", l;
          }
          var u = n2[s3] = { exports: {} };
          e4[s3][0].call(u.exports, function(t4) {
            var n3 = e4[s3][1][t4];
            return r2(n3 || t4);
          }, u, u.exports, t3, e4, n2, i);
        }
        return n2[s3].exports;
      }
      for (var o2 = false, s2 = 0; s2 < i.length; s2++)
        r2(i[s2]);
      return r2;
    }({ 1: [function(t3, n2, i) {
      (function(t4) {
        var e4, i2, r2 = t4.MutationObserver || t4.WebKitMutationObserver;
        if (r2) {
          var o2 = 0, s2 = new r2(h), a = t4.document.createTextNode("");
          s2.observe(a, { characterData: true }), e4 = function() {
            a.data = o2 = ++o2 % 2;
          };
        } else if (t4.setImmediate || t4.MessageChannel === void 0)
          e4 = "document" in t4 && "onreadystatechange" in t4.document.createElement("script") ? function() {
            var e5 = t4.document.createElement("script");
            e5.onreadystatechange = function() {
              h(), e5.onreadystatechange = null, e5.parentNode.removeChild(e5), e5 = null;
            }, t4.document.documentElement.appendChild(e5);
          } : function() {
            setTimeout(h, 0);
          };
        else {
          var l = new t4.MessageChannel();
          l.port1.onmessage = h, e4 = function() {
            l.port2.postMessage(0);
          };
        }
        var u = [];
        function h() {
          var t5, e5;
          i2 = true;
          for (var n3 = u.length; n3; ) {
            for (e5 = u, u = [], t5 = -1; ++t5 < n3; )
              e5[t5]();
            n3 = u.length;
          }
          i2 = false;
        }
        n2.exports = function(t5) {
          u.push(t5) !== 1 || i2 || e4();
        };
      }).call(this, e3 !== void 0 ? e3 : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, {}], 2: [function(t3, e4, n2) {
      var i = t3(1);
      function r2() {
      }
      var o2 = {}, s2 = ["REJECTED"], a = ["FULFILLED"], l = ["PENDING"];
      function u(t4) {
        if (typeof t4 != "function")
          throw new TypeError("resolver must be a function");
        this.state = l, this.queue = [], this.outcome = void 0, t4 !== r2 && p(this, t4);
      }
      function h(t4, e5, n3) {
        this.promise = t4, typeof e5 == "function" && (this.onFulfilled = e5, this.callFulfilled = this.otherCallFulfilled), typeof n3 == "function" && (this.onRejected = n3, this.callRejected = this.otherCallRejected);
      }
      function c(t4, e5, n3) {
        i(function() {
          var i2;
          try {
            i2 = e5(n3);
          } catch (e6) {
            return o2.reject(t4, e6);
          }
          i2 === t4 ? o2.reject(t4, new TypeError("Cannot resolve promise with itself")) : o2.resolve(t4, i2);
        });
      }
      function d(t4) {
        var e5 = t4 && t4.then;
        if (t4 && (typeof t4 == "object" || typeof t4 == "function") && typeof e5 == "function")
          return function() {
            e5.apply(t4, arguments);
          };
      }
      function p(t4, e5) {
        var n3 = false;
        function i2(e6) {
          n3 || (n3 = true, o2.reject(t4, e6));
        }
        function r3(e6) {
          n3 || (n3 = true, o2.resolve(t4, e6));
        }
        var s3 = f(function() {
          e5(r3, i2);
        });
        s3.status === "error" && i2(s3.value);
      }
      function f(t4, e5) {
        var n3 = {};
        try {
          n3.value = t4(e5), n3.status = "success";
        } catch (t5) {
          n3.status = "error", n3.value = t5;
        }
        return n3;
      }
      e4.exports = u, u.prototype.catch = function(t4) {
        return this.then(null, t4);
      }, u.prototype.then = function(t4, e5) {
        if (typeof t4 != "function" && this.state === a || typeof e5 != "function" && this.state === s2)
          return this;
        var n3 = new this.constructor(r2);
        return this.state !== l ? c(n3, this.state === a ? t4 : e5, this.outcome) : this.queue.push(new h(n3, t4, e5)), n3;
      }, h.prototype.callFulfilled = function(t4) {
        o2.resolve(this.promise, t4);
      }, h.prototype.otherCallFulfilled = function(t4) {
        c(this.promise, this.onFulfilled, t4);
      }, h.prototype.callRejected = function(t4) {
        o2.reject(this.promise, t4);
      }, h.prototype.otherCallRejected = function(t4) {
        c(this.promise, this.onRejected, t4);
      }, o2.resolve = function(t4, e5) {
        var n3 = f(d, e5);
        if (n3.status === "error")
          return o2.reject(t4, n3.value);
        var i2 = n3.value;
        if (i2)
          p(t4, i2);
        else {
          t4.state = a, t4.outcome = e5;
          for (var r3 = -1, s3 = t4.queue.length; ++r3 < s3; )
            t4.queue[r3].callFulfilled(e5);
        }
        return t4;
      }, o2.reject = function(t4, e5) {
        t4.state = s2, t4.outcome = e5;
        for (var n3 = -1, i2 = t4.queue.length; ++n3 < i2; )
          t4.queue[n3].callRejected(e5);
        return t4;
      }, u.resolve = function(t4) {
        return t4 instanceof this ? t4 : o2.resolve(new this(r2), t4);
      }, u.reject = function(t4) {
        var e5 = new this(r2);
        return o2.reject(e5, t4);
      }, u.all = function(t4) {
        var e5 = this;
        if (Object.prototype.toString.call(t4) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var n3 = t4.length, i2 = false;
        if (!n3)
          return this.resolve([]);
        for (var s3 = new Array(n3), a2 = 0, l2 = -1, u2 = new this(r2); ++l2 < n3; )
          h2(t4[l2], l2);
        return u2;
        function h2(t5, r3) {
          e5.resolve(t5).then(function(t6) {
            s3[r3] = t6, ++a2 !== n3 || i2 || (i2 = true, o2.resolve(u2, s3));
          }, function(t6) {
            i2 || (i2 = true, o2.reject(u2, t6));
          });
        }
      }, u.race = function(t4) {
        var e5 = this;
        if (Object.prototype.toString.call(t4) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var n3 = t4.length, i2 = false;
        if (!n3)
          return this.resolve([]);
        for (var s3, a2 = -1, l2 = new this(r2); ++a2 < n3; )
          s3 = t4[a2], e5.resolve(s3).then(function(t5) {
            i2 || (i2 = true, o2.resolve(l2, t5));
          }, function(t5) {
            i2 || (i2 = true, o2.reject(l2, t5));
          });
        return l2;
      };
    }, { 1: 1 }], 3: [function(t3, n2, i) {
      (function(e4) {
        typeof e4.Promise != "function" && (e4.Promise = t3(2));
      }).call(this, e3 !== void 0 ? e3 : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, { 2: 2 }], 4: [function(t3, e4, n2) {
      var i = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t4) {
        return typeof t4;
      } : function(t4) {
        return t4 && typeof Symbol == "function" && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
      }, r2 = function() {
        try {
          if (typeof indexedDB != "undefined")
            return indexedDB;
          if (typeof webkitIndexedDB != "undefined")
            return webkitIndexedDB;
          if (typeof mozIndexedDB != "undefined")
            return mozIndexedDB;
          if (typeof OIndexedDB != "undefined")
            return OIndexedDB;
          if (typeof msIndexedDB != "undefined")
            return msIndexedDB;
        } catch (t4) {
          return;
        }
      }();
      function o2(t4, e5) {
        t4 = t4 || [], e5 = e5 || {};
        try {
          return new Blob(t4, e5);
        } catch (r3) {
          if (r3.name !== "TypeError")
            throw r3;
          for (var n3 = new (typeof BlobBuilder != "undefined" ? BlobBuilder : typeof MSBlobBuilder != "undefined" ? MSBlobBuilder : typeof MozBlobBuilder != "undefined" ? MozBlobBuilder : WebKitBlobBuilder)(), i2 = 0; i2 < t4.length; i2 += 1)
            n3.append(t4[i2]);
          return n3.getBlob(e5.type);
        }
      }
      typeof Promise == "undefined" && t3(3);
      var s2 = Promise;
      function a(t4, e5) {
        e5 && t4.then(function(t5) {
          e5(null, t5);
        }, function(t5) {
          e5(t5);
        });
      }
      function l(t4, e5, n3) {
        typeof e5 == "function" && t4.then(e5), typeof n3 == "function" && t4.catch(n3);
      }
      function u(t4) {
        return typeof t4 != "string" && (console.warn(t4 + " used as a key, but it is not a string."), t4 = String(t4)), t4;
      }
      function h() {
        if (arguments.length && typeof arguments[arguments.length - 1] == "function")
          return arguments[arguments.length - 1];
      }
      var c = void 0, d = {}, p = Object.prototype.toString;
      function f(t4) {
        return typeof c == "boolean" ? s2.resolve(c) : function(t5) {
          return new s2(function(e5) {
            var n3 = t5.transaction("local-forage-detect-blob-support", "readwrite"), i2 = o2([""]);
            n3.objectStore("local-forage-detect-blob-support").put(i2, "key"), n3.onabort = function(t6) {
              t6.preventDefault(), t6.stopPropagation(), e5(false);
            }, n3.oncomplete = function() {
              var t6 = navigator.userAgent.match(/Chrome\/(\d+)/), n4 = navigator.userAgent.match(/Edge\//);
              e5(n4 || !t6 || parseInt(t6[1], 10) >= 43);
            };
          }).catch(function() {
            return false;
          });
        }(t4).then(function(t5) {
          return c = t5;
        });
      }
      function m(t4) {
        var e5 = d[t4.name], n3 = {};
        n3.promise = new s2(function(t5, e6) {
          n3.resolve = t5, n3.reject = e6;
        }), e5.deferredOperations.push(n3), e5.dbReady ? e5.dbReady = e5.dbReady.then(function() {
          return n3.promise;
        }) : e5.dbReady = n3.promise;
      }
      function g(t4) {
        var e5 = d[t4.name].deferredOperations.pop();
        if (e5)
          return e5.resolve(), e5.promise;
      }
      function v(t4, e5) {
        var n3 = d[t4.name].deferredOperations.pop();
        if (n3)
          return n3.reject(e5), n3.promise;
      }
      function _(t4, e5) {
        return new s2(function(n3, i2) {
          if (d[t4.name] = d[t4.name] || { forages: [], db: null, dbReady: null, deferredOperations: [] }, t4.db) {
            if (!e5)
              return n3(t4.db);
            m(t4), t4.db.close();
          }
          var o3 = [t4.name];
          e5 && o3.push(t4.version);
          var s3 = r2.open.apply(r2, o3);
          e5 && (s3.onupgradeneeded = function(e6) {
            var n4 = s3.result;
            try {
              n4.createObjectStore(t4.storeName), e6.oldVersion <= 1 && n4.createObjectStore("local-forage-detect-blob-support");
            } catch (n5) {
              if (n5.name !== "ConstraintError")
                throw n5;
              console.warn('The database "' + t4.name + '" has been upgraded from version ' + e6.oldVersion + " to version " + e6.newVersion + ', but the storage "' + t4.storeName + '" already exists.');
            }
          }), s3.onerror = function(t5) {
            t5.preventDefault(), i2(s3.error);
          }, s3.onsuccess = function() {
            var e6 = s3.result;
            e6.onversionchange = function(t5) {
              t5.target.close();
            }, n3(e6), g(t4);
          };
        });
      }
      function y(t4) {
        return _(t4, false);
      }
      function x(t4) {
        return _(t4, true);
      }
      function b(t4, e5) {
        if (!t4.db)
          return true;
        var n3 = !t4.db.objectStoreNames.contains(t4.storeName), i2 = t4.version < t4.db.version, r3 = t4.version > t4.db.version;
        if (i2 && (t4.version !== e5 && console.warn('The database "' + t4.name + `" can't be downgraded from version ` + t4.db.version + " to version " + t4.version + "."), t4.version = t4.db.version), r3 || n3) {
          if (n3) {
            var o3 = t4.db.version + 1;
            o3 > t4.version && (t4.version = o3);
          }
          return true;
        }
        return false;
      }
      function T(t4) {
        return o2([function(t5) {
          for (var e5 = t5.length, n3 = new ArrayBuffer(e5), i2 = new Uint8Array(n3), r3 = 0; r3 < e5; r3++)
            i2[r3] = t5.charCodeAt(r3);
          return n3;
        }(atob(t4.data))], { type: t4.type });
      }
      function w(t4) {
        return t4 && t4.__local_forage_encoded_blob;
      }
      function S(t4) {
        var e5 = this, n3 = e5._initReady().then(function() {
          var t5 = d[e5._dbInfo.name];
          if (t5 && t5.dbReady)
            return t5.dbReady;
        });
        return l(n3, t4, t4), n3;
      }
      function E(t4, e5, n3, i2) {
        i2 === void 0 && (i2 = 1);
        try {
          var r3 = t4.db.transaction(t4.storeName, e5);
          n3(null, r3);
        } catch (r4) {
          if (i2 > 0 && (!t4.db || r4.name === "InvalidStateError" || r4.name === "NotFoundError"))
            return s2.resolve().then(function() {
              if (!t4.db || r4.name === "NotFoundError" && !t4.db.objectStoreNames.contains(t4.storeName) && t4.version <= t4.db.version)
                return t4.db && (t4.version = t4.db.version + 1), x(t4);
            }).then(function() {
              return function(t5) {
                m(t5);
                for (var e6 = d[t5.name], n4 = e6.forages, i3 = 0; i3 < n4.length; i3++) {
                  var r5 = n4[i3];
                  r5._dbInfo.db && (r5._dbInfo.db.close(), r5._dbInfo.db = null);
                }
                return t5.db = null, y(t5).then(function(e7) {
                  return t5.db = e7, b(t5) ? x(t5) : e7;
                }).then(function(i4) {
                  t5.db = e6.db = i4;
                  for (var r6 = 0; r6 < n4.length; r6++)
                    n4[r6]._dbInfo.db = i4;
                }).catch(function(e7) {
                  throw v(t5, e7), e7;
                });
              }(t4).then(function() {
                E(t4, e5, n3, i2 - 1);
              });
            }).catch(n3);
          n3(r4);
        }
      }
      var M = { _driver: "asyncStorage", _initStorage: function(t4) {
        var e5 = this, n3 = { db: null };
        if (t4)
          for (var i2 in t4)
            n3[i2] = t4[i2];
        var r3 = d[n3.name];
        r3 || (r3 = { forages: [], db: null, dbReady: null, deferredOperations: [] }, d[n3.name] = r3), r3.forages.push(e5), e5._initReady || (e5._initReady = e5.ready, e5.ready = S);
        var o3 = [];
        function a2() {
          return s2.resolve();
        }
        for (var l2 = 0; l2 < r3.forages.length; l2++) {
          var u2 = r3.forages[l2];
          u2 !== e5 && o3.push(u2._initReady().catch(a2));
        }
        var h2 = r3.forages.slice(0);
        return s2.all(o3).then(function() {
          return n3.db = r3.db, y(n3);
        }).then(function(t5) {
          return n3.db = t5, b(n3, e5._defaultConfig.version) ? x(n3) : t5;
        }).then(function(t5) {
          n3.db = r3.db = t5, e5._dbInfo = n3;
          for (var i3 = 0; i3 < h2.length; i3++) {
            var o4 = h2[i3];
            o4 !== e5 && (o4._dbInfo.db = n3.db, o4._dbInfo.version = n3.version);
          }
        });
      }, _support: function() {
        try {
          if (!r2 || !r2.open)
            return false;
          var t4 = typeof openDatabase != "undefined" && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform), e5 = typeof fetch == "function" && fetch.toString().indexOf("[native code") !== -1;
          return (!t4 || e5) && typeof indexedDB != "undefined" && typeof IDBKeyRange != "undefined";
        } catch (t5) {
          return false;
        }
      }(), iterate: function(t4, e5) {
        var n3 = this, i2 = new s2(function(e6, i3) {
          n3.ready().then(function() {
            E(n3._dbInfo, "readonly", function(r3, o3) {
              if (r3)
                return i3(r3);
              try {
                var s3 = o3.objectStore(n3._dbInfo.storeName).openCursor(), a2 = 1;
                s3.onsuccess = function() {
                  var n4 = s3.result;
                  if (n4) {
                    var i4 = n4.value;
                    w(i4) && (i4 = T(i4));
                    var r4 = t4(i4, n4.key, a2++);
                    r4 !== void 0 ? e6(r4) : n4.continue();
                  } else
                    e6();
                }, s3.onerror = function() {
                  i3(s3.error);
                };
              } catch (t5) {
                i3(t5);
              }
            });
          }).catch(i3);
        });
        return a(i2, e5), i2;
      }, getItem: function(t4, e5) {
        var n3 = this;
        t4 = u(t4);
        var i2 = new s2(function(e6, i3) {
          n3.ready().then(function() {
            E(n3._dbInfo, "readonly", function(r3, o3) {
              if (r3)
                return i3(r3);
              try {
                var s3 = o3.objectStore(n3._dbInfo.storeName).get(t4);
                s3.onsuccess = function() {
                  var t5 = s3.result;
                  t5 === void 0 && (t5 = null), w(t5) && (t5 = T(t5)), e6(t5);
                }, s3.onerror = function() {
                  i3(s3.error);
                };
              } catch (t5) {
                i3(t5);
              }
            });
          }).catch(i3);
        });
        return a(i2, e5), i2;
      }, setItem: function(t4, e5, n3) {
        var i2 = this;
        t4 = u(t4);
        var r3 = new s2(function(n4, r4) {
          var o3;
          i2.ready().then(function() {
            return o3 = i2._dbInfo, p.call(e5) === "[object Blob]" ? f(o3.db).then(function(t5) {
              return t5 ? e5 : (n5 = e5, new s2(function(t6, e6) {
                var i3 = new FileReader();
                i3.onerror = e6, i3.onloadend = function(e7) {
                  var i4 = btoa(e7.target.result || "");
                  t6({ __local_forage_encoded_blob: true, data: i4, type: n5.type });
                }, i3.readAsBinaryString(n5);
              }));
              var n5;
            }) : e5;
          }).then(function(e6) {
            E(i2._dbInfo, "readwrite", function(o4, s3) {
              if (o4)
                return r4(o4);
              try {
                var a2 = s3.objectStore(i2._dbInfo.storeName);
                e6 === null && (e6 = void 0);
                var l2 = a2.put(e6, t4);
                s3.oncomplete = function() {
                  e6 === void 0 && (e6 = null), n4(e6);
                }, s3.onabort = s3.onerror = function() {
                  var t5 = l2.error ? l2.error : l2.transaction.error;
                  r4(t5);
                };
              } catch (t5) {
                r4(t5);
              }
            });
          }).catch(r4);
        });
        return a(r3, n3), r3;
      }, removeItem: function(t4, e5) {
        var n3 = this;
        t4 = u(t4);
        var i2 = new s2(function(e6, i3) {
          n3.ready().then(function() {
            E(n3._dbInfo, "readwrite", function(r3, o3) {
              if (r3)
                return i3(r3);
              try {
                var s3 = o3.objectStore(n3._dbInfo.storeName).delete(t4);
                o3.oncomplete = function() {
                  e6();
                }, o3.onerror = function() {
                  i3(s3.error);
                }, o3.onabort = function() {
                  var t5 = s3.error ? s3.error : s3.transaction.error;
                  i3(t5);
                };
              } catch (t5) {
                i3(t5);
              }
            });
          }).catch(i3);
        });
        return a(i2, e5), i2;
      }, clear: function(t4) {
        var e5 = this, n3 = new s2(function(t5, n4) {
          e5.ready().then(function() {
            E(e5._dbInfo, "readwrite", function(i2, r3) {
              if (i2)
                return n4(i2);
              try {
                var o3 = r3.objectStore(e5._dbInfo.storeName).clear();
                r3.oncomplete = function() {
                  t5();
                }, r3.onabort = r3.onerror = function() {
                  var t6 = o3.error ? o3.error : o3.transaction.error;
                  n4(t6);
                };
              } catch (t6) {
                n4(t6);
              }
            });
          }).catch(n4);
        });
        return a(n3, t4), n3;
      }, length: function(t4) {
        var e5 = this, n3 = new s2(function(t5, n4) {
          e5.ready().then(function() {
            E(e5._dbInfo, "readonly", function(i2, r3) {
              if (i2)
                return n4(i2);
              try {
                var o3 = r3.objectStore(e5._dbInfo.storeName).count();
                o3.onsuccess = function() {
                  t5(o3.result);
                }, o3.onerror = function() {
                  n4(o3.error);
                };
              } catch (t6) {
                n4(t6);
              }
            });
          }).catch(n4);
        });
        return a(n3, t4), n3;
      }, key: function(t4, e5) {
        var n3 = this, i2 = new s2(function(e6, i3) {
          t4 < 0 ? e6(null) : n3.ready().then(function() {
            E(n3._dbInfo, "readonly", function(r3, o3) {
              if (r3)
                return i3(r3);
              try {
                var s3 = o3.objectStore(n3._dbInfo.storeName), a2 = false, l2 = s3.openKeyCursor();
                l2.onsuccess = function() {
                  var n4 = l2.result;
                  n4 ? t4 === 0 || a2 ? e6(n4.key) : (a2 = true, n4.advance(t4)) : e6(null);
                }, l2.onerror = function() {
                  i3(l2.error);
                };
              } catch (t5) {
                i3(t5);
              }
            });
          }).catch(i3);
        });
        return a(i2, e5), i2;
      }, keys: function(t4) {
        var e5 = this, n3 = new s2(function(t5, n4) {
          e5.ready().then(function() {
            E(e5._dbInfo, "readonly", function(i2, r3) {
              if (i2)
                return n4(i2);
              try {
                var o3 = r3.objectStore(e5._dbInfo.storeName).openKeyCursor(), s3 = [];
                o3.onsuccess = function() {
                  var e6 = o3.result;
                  e6 ? (s3.push(e6.key), e6.continue()) : t5(s3);
                }, o3.onerror = function() {
                  n4(o3.error);
                };
              } catch (t6) {
                n4(t6);
              }
            });
          }).catch(n4);
        });
        return a(n3, t4), n3;
      }, dropInstance: function(t4, e5) {
        e5 = h.apply(this, arguments);
        var n3 = this.config();
        (t4 = typeof t4 != "function" && t4 || {}).name || (t4.name = t4.name || n3.name, t4.storeName = t4.storeName || n3.storeName);
        var i2, o3 = this;
        if (t4.name) {
          var l2 = t4.name === n3.name && o3._dbInfo.db, u2 = l2 ? s2.resolve(o3._dbInfo.db) : y(t4).then(function(e6) {
            var n4 = d[t4.name], i3 = n4.forages;
            n4.db = e6;
            for (var r3 = 0; r3 < i3.length; r3++)
              i3[r3]._dbInfo.db = e6;
            return e6;
          });
          i2 = t4.storeName ? u2.then(function(e6) {
            if (e6.objectStoreNames.contains(t4.storeName)) {
              var n4 = e6.version + 1;
              m(t4);
              var i3 = d[t4.name], o4 = i3.forages;
              e6.close();
              for (var a2 = 0; a2 < o4.length; a2++) {
                var l3 = o4[a2];
                l3._dbInfo.db = null, l3._dbInfo.version = n4;
              }
              return new s2(function(e7, i4) {
                var o5 = r2.open(t4.name, n4);
                o5.onerror = function(t5) {
                  o5.result.close(), i4(t5);
                }, o5.onupgradeneeded = function() {
                  o5.result.deleteObjectStore(t4.storeName);
                }, o5.onsuccess = function() {
                  var t5 = o5.result;
                  t5.close(), e7(t5);
                };
              }).then(function(t5) {
                i3.db = t5;
                for (var e7 = 0; e7 < o4.length; e7++) {
                  var n5 = o4[e7];
                  n5._dbInfo.db = t5, g(n5._dbInfo);
                }
              }).catch(function(e7) {
                throw (v(t4, e7) || s2.resolve()).catch(function() {
                }), e7;
              });
            }
          }) : u2.then(function(e6) {
            m(t4);
            var n4 = d[t4.name], i3 = n4.forages;
            e6.close();
            for (var o4 = 0; o4 < i3.length; o4++)
              i3[o4]._dbInfo.db = null;
            return new s2(function(e7, n5) {
              var i4 = r2.deleteDatabase(t4.name);
              i4.onerror = function() {
                var t5 = i4.result;
                t5 && t5.close(), n5(i4.error);
              }, i4.onblocked = function() {
                console.warn('dropInstance blocked for database "' + t4.name + '" until all open connections are closed');
              }, i4.onsuccess = function() {
                var t5 = i4.result;
                t5 && t5.close(), e7(t5);
              };
            }).then(function(t5) {
              n4.db = t5;
              for (var e7 = 0; e7 < i3.length; e7++)
                g(i3[e7]._dbInfo);
            }).catch(function(e7) {
              throw (v(t4, e7) || s2.resolve()).catch(function() {
              }), e7;
            });
          });
        } else
          i2 = s2.reject("Invalid arguments");
        return a(i2, e5), i2;
      } }, A = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", R = /^~~local_forage_type~([^~]+)~/, P = "__lfsc__:".length, C = P + "arbf".length, I = Object.prototype.toString;
      function O(t4) {
        var e5, n3, i2, r3, o3, s3 = 0.75 * t4.length, a2 = t4.length, l2 = 0;
        t4[t4.length - 1] === "=" && (s3--, t4[t4.length - 2] === "=" && s3--);
        var u2 = new ArrayBuffer(s3), h2 = new Uint8Array(u2);
        for (e5 = 0; e5 < a2; e5 += 4)
          n3 = A.indexOf(t4[e5]), i2 = A.indexOf(t4[e5 + 1]), r3 = A.indexOf(t4[e5 + 2]), o3 = A.indexOf(t4[e5 + 3]), h2[l2++] = n3 << 2 | i2 >> 4, h2[l2++] = (15 & i2) << 4 | r3 >> 2, h2[l2++] = (3 & r3) << 6 | 63 & o3;
        return u2;
      }
      function L(t4) {
        var e5, n3 = new Uint8Array(t4), i2 = "";
        for (e5 = 0; e5 < n3.length; e5 += 3)
          i2 += A[n3[e5] >> 2], i2 += A[(3 & n3[e5]) << 4 | n3[e5 + 1] >> 4], i2 += A[(15 & n3[e5 + 1]) << 2 | n3[e5 + 2] >> 6], i2 += A[63 & n3[e5 + 2]];
        return n3.length % 3 == 2 ? i2 = i2.substring(0, i2.length - 1) + "=" : n3.length % 3 == 1 && (i2 = i2.substring(0, i2.length - 2) + "=="), i2;
      }
      var N = { serialize: function(t4, e5) {
        var n3 = "";
        if (t4 && (n3 = I.call(t4)), t4 && (n3 === "[object ArrayBuffer]" || t4.buffer && I.call(t4.buffer) === "[object ArrayBuffer]")) {
          var i2, r3 = "__lfsc__:";
          t4 instanceof ArrayBuffer ? (i2 = t4, r3 += "arbf") : (i2 = t4.buffer, n3 === "[object Int8Array]" ? r3 += "si08" : n3 === "[object Uint8Array]" ? r3 += "ui08" : n3 === "[object Uint8ClampedArray]" ? r3 += "uic8" : n3 === "[object Int16Array]" ? r3 += "si16" : n3 === "[object Uint16Array]" ? r3 += "ur16" : n3 === "[object Int32Array]" ? r3 += "si32" : n3 === "[object Uint32Array]" ? r3 += "ui32" : n3 === "[object Float32Array]" ? r3 += "fl32" : n3 === "[object Float64Array]" ? r3 += "fl64" : e5(new Error("Failed to get type for BinaryArray"))), e5(r3 + L(i2));
        } else if (n3 === "[object Blob]") {
          var o3 = new FileReader();
          o3.onload = function() {
            var n4 = "~~local_forage_type~" + t4.type + "~" + L(this.result);
            e5("__lfsc__:blob" + n4);
          }, o3.readAsArrayBuffer(t4);
        } else
          try {
            e5(JSON.stringify(t4));
          } catch (n4) {
            console.error("Couldn't convert value into a JSON string: ", t4), e5(null, n4);
          }
      }, deserialize: function(t4) {
        if (t4.substring(0, P) !== "__lfsc__:")
          return JSON.parse(t4);
        var e5, n3 = t4.substring(C), i2 = t4.substring(P, C);
        if (i2 === "blob" && R.test(n3)) {
          var r3 = n3.match(R);
          e5 = r3[1], n3 = n3.substring(r3[0].length);
        }
        var s3 = O(n3);
        switch (i2) {
          case "arbf":
            return s3;
          case "blob":
            return o2([s3], { type: e5 });
          case "si08":
            return new Int8Array(s3);
          case "ui08":
            return new Uint8Array(s3);
          case "uic8":
            return new Uint8ClampedArray(s3);
          case "si16":
            return new Int16Array(s3);
          case "ur16":
            return new Uint16Array(s3);
          case "si32":
            return new Int32Array(s3);
          case "ui32":
            return new Uint32Array(s3);
          case "fl32":
            return new Float32Array(s3);
          case "fl64":
            return new Float64Array(s3);
          default:
            throw new Error("Unkown type: " + i2);
        }
      }, stringToBuffer: O, bufferToString: L };
      function D(t4, e5, n3, i2) {
        t4.executeSql("CREATE TABLE IF NOT EXISTS " + e5.storeName + " (id INTEGER PRIMARY KEY, key unique, value)", [], n3, i2);
      }
      function F(t4, e5, n3, i2, r3, o3) {
        t4.executeSql(n3, i2, r3, function(t5, s3) {
          s3.code === s3.SYNTAX_ERR ? t5.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name = ?", [e5.storeName], function(t6, a2) {
            a2.rows.length ? o3(t6, s3) : D(t6, e5, function() {
              t6.executeSql(n3, i2, r3, o3);
            }, o3);
          }, o3) : o3(t5, s3);
        }, o3);
      }
      function B(t4, e5, n3, i2) {
        var r3 = this;
        t4 = u(t4);
        var o3 = new s2(function(o4, s3) {
          r3.ready().then(function() {
            e5 === void 0 && (e5 = null);
            var a2 = e5, l2 = r3._dbInfo;
            l2.serializer.serialize(e5, function(e6, u2) {
              u2 ? s3(u2) : l2.db.transaction(function(n4) {
                F(n4, l2, "INSERT OR REPLACE INTO " + l2.storeName + " (key, value) VALUES (?, ?)", [t4, e6], function() {
                  o4(a2);
                }, function(t5, e7) {
                  s3(e7);
                });
              }, function(e7) {
                if (e7.code === e7.QUOTA_ERR) {
                  if (i2 > 0)
                    return void o4(B.apply(r3, [t4, a2, n3, i2 - 1]));
                  s3(e7);
                }
              });
            });
          }).catch(s3);
        });
        return a(o3, n3), o3;
      }
      function U(t4) {
        return new s2(function(e5, n3) {
          t4.transaction(function(i2) {
            i2.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function(n4, i3) {
              for (var r3 = [], o3 = 0; o3 < i3.rows.length; o3++)
                r3.push(i3.rows.item(o3).name);
              e5({ db: t4, storeNames: r3 });
            }, function(t5, e6) {
              n3(e6);
            });
          }, function(t5) {
            n3(t5);
          });
        });
      }
      var k = { _driver: "webSQLStorage", _initStorage: function(t4) {
        var e5 = this, n3 = { db: null };
        if (t4)
          for (var i2 in t4)
            n3[i2] = typeof t4[i2] != "string" ? t4[i2].toString() : t4[i2];
        var r3 = new s2(function(t5, i3) {
          try {
            n3.db = openDatabase(n3.name, String(n3.version), n3.description, n3.size);
          } catch (t6) {
            return i3(t6);
          }
          n3.db.transaction(function(r4) {
            D(r4, n3, function() {
              e5._dbInfo = n3, t5();
            }, function(t6, e6) {
              i3(e6);
            });
          }, i3);
        });
        return n3.serializer = N, r3;
      }, _support: typeof openDatabase == "function", iterate: function(t4, e5) {
        var n3 = this, i2 = new s2(function(e6, i3) {
          n3.ready().then(function() {
            var r3 = n3._dbInfo;
            r3.db.transaction(function(n4) {
              F(n4, r3, "SELECT * FROM " + r3.storeName, [], function(n5, i4) {
                for (var o3 = i4.rows, s3 = o3.length, a2 = 0; a2 < s3; a2++) {
                  var l2 = o3.item(a2), u2 = l2.value;
                  if (u2 && (u2 = r3.serializer.deserialize(u2)), (u2 = t4(u2, l2.key, a2 + 1)) !== void 0)
                    return void e6(u2);
                }
                e6();
              }, function(t5, e7) {
                i3(e7);
              });
            });
          }).catch(i3);
        });
        return a(i2, e5), i2;
      }, getItem: function(t4, e5) {
        var n3 = this;
        t4 = u(t4);
        var i2 = new s2(function(e6, i3) {
          n3.ready().then(function() {
            var r3 = n3._dbInfo;
            r3.db.transaction(function(n4) {
              F(n4, r3, "SELECT * FROM " + r3.storeName + " WHERE key = ? LIMIT 1", [t4], function(t5, n5) {
                var i4 = n5.rows.length ? n5.rows.item(0).value : null;
                i4 && (i4 = r3.serializer.deserialize(i4)), e6(i4);
              }, function(t5, e7) {
                i3(e7);
              });
            });
          }).catch(i3);
        });
        return a(i2, e5), i2;
      }, setItem: function(t4, e5, n3) {
        return B.apply(this, [t4, e5, n3, 1]);
      }, removeItem: function(t4, e5) {
        var n3 = this;
        t4 = u(t4);
        var i2 = new s2(function(e6, i3) {
          n3.ready().then(function() {
            var r3 = n3._dbInfo;
            r3.db.transaction(function(n4) {
              F(n4, r3, "DELETE FROM " + r3.storeName + " WHERE key = ?", [t4], function() {
                e6();
              }, function(t5, e7) {
                i3(e7);
              });
            });
          }).catch(i3);
        });
        return a(i2, e5), i2;
      }, clear: function(t4) {
        var e5 = this, n3 = new s2(function(t5, n4) {
          e5.ready().then(function() {
            var i2 = e5._dbInfo;
            i2.db.transaction(function(e6) {
              F(e6, i2, "DELETE FROM " + i2.storeName, [], function() {
                t5();
              }, function(t6, e7) {
                n4(e7);
              });
            });
          }).catch(n4);
        });
        return a(n3, t4), n3;
      }, length: function(t4) {
        var e5 = this, n3 = new s2(function(t5, n4) {
          e5.ready().then(function() {
            var i2 = e5._dbInfo;
            i2.db.transaction(function(e6) {
              F(e6, i2, "SELECT COUNT(key) as c FROM " + i2.storeName, [], function(e7, n5) {
                var i3 = n5.rows.item(0).c;
                t5(i3);
              }, function(t6, e7) {
                n4(e7);
              });
            });
          }).catch(n4);
        });
        return a(n3, t4), n3;
      }, key: function(t4, e5) {
        var n3 = this, i2 = new s2(function(e6, i3) {
          n3.ready().then(function() {
            var r3 = n3._dbInfo;
            r3.db.transaction(function(n4) {
              F(n4, r3, "SELECT key FROM " + r3.storeName + " WHERE id = ? LIMIT 1", [t4 + 1], function(t5, n5) {
                var i4 = n5.rows.length ? n5.rows.item(0).key : null;
                e6(i4);
              }, function(t5, e7) {
                i3(e7);
              });
            });
          }).catch(i3);
        });
        return a(i2, e5), i2;
      }, keys: function(t4) {
        var e5 = this, n3 = new s2(function(t5, n4) {
          e5.ready().then(function() {
            var i2 = e5._dbInfo;
            i2.db.transaction(function(e6) {
              F(e6, i2, "SELECT key FROM " + i2.storeName, [], function(e7, n5) {
                for (var i3 = [], r3 = 0; r3 < n5.rows.length; r3++)
                  i3.push(n5.rows.item(r3).key);
                t5(i3);
              }, function(t6, e7) {
                n4(e7);
              });
            });
          }).catch(n4);
        });
        return a(n3, t4), n3;
      }, dropInstance: function(t4, e5) {
        e5 = h.apply(this, arguments);
        var n3 = this.config();
        (t4 = typeof t4 != "function" && t4 || {}).name || (t4.name = t4.name || n3.name, t4.storeName = t4.storeName || n3.storeName);
        var i2, r3 = this;
        return a(i2 = t4.name ? new s2(function(e6) {
          var i3;
          i3 = t4.name === n3.name ? r3._dbInfo.db : openDatabase(t4.name, "", "", 0), t4.storeName ? e6({ db: i3, storeNames: [t4.storeName] }) : e6(U(i3));
        }).then(function(t5) {
          return new s2(function(e6, n4) {
            t5.db.transaction(function(i3) {
              function r4(t6) {
                return new s2(function(e7, n5) {
                  i3.executeSql("DROP TABLE IF EXISTS " + t6, [], function() {
                    e7();
                  }, function(t7, e8) {
                    n5(e8);
                  });
                });
              }
              for (var o3 = [], a2 = 0, l2 = t5.storeNames.length; a2 < l2; a2++)
                o3.push(r4(t5.storeNames[a2]));
              s2.all(o3).then(function() {
                e6();
              }).catch(function(t6) {
                n4(t6);
              });
            }, function(t6) {
              n4(t6);
            });
          });
        }) : s2.reject("Invalid arguments"), e5), i2;
      } };
      function G(t4, e5) {
        var n3 = t4.name + "/";
        return t4.storeName !== e5.storeName && (n3 += t4.storeName + "/"), n3;
      }
      function H() {
        return !function() {
          try {
            return localStorage.setItem("_localforage_support_test", true), localStorage.removeItem("_localforage_support_test"), false;
          } catch (t4) {
            return true;
          }
        }() || localStorage.length > 0;
      }
      var z = { _driver: "localStorageWrapper", _initStorage: function(t4) {
        var e5 = {};
        if (t4)
          for (var n3 in t4)
            e5[n3] = t4[n3];
        return e5.keyPrefix = G(t4, this._defaultConfig), H() ? (this._dbInfo = e5, e5.serializer = N, s2.resolve()) : s2.reject();
      }, _support: function() {
        try {
          return typeof localStorage != "undefined" && "setItem" in localStorage && !!localStorage.setItem;
        } catch (t4) {
          return false;
        }
      }(), iterate: function(t4, e5) {
        var n3 = this, i2 = n3.ready().then(function() {
          for (var e6 = n3._dbInfo, i3 = e6.keyPrefix, r3 = i3.length, o3 = localStorage.length, s3 = 1, a2 = 0; a2 < o3; a2++) {
            var l2 = localStorage.key(a2);
            if (l2.indexOf(i3) === 0) {
              var u2 = localStorage.getItem(l2);
              if (u2 && (u2 = e6.serializer.deserialize(u2)), (u2 = t4(u2, l2.substring(r3), s3++)) !== void 0)
                return u2;
            }
          }
        });
        return a(i2, e5), i2;
      }, getItem: function(t4, e5) {
        var n3 = this;
        t4 = u(t4);
        var i2 = n3.ready().then(function() {
          var e6 = n3._dbInfo, i3 = localStorage.getItem(e6.keyPrefix + t4);
          return i3 && (i3 = e6.serializer.deserialize(i3)), i3;
        });
        return a(i2, e5), i2;
      }, setItem: function(t4, e5, n3) {
        var i2 = this;
        t4 = u(t4);
        var r3 = i2.ready().then(function() {
          e5 === void 0 && (e5 = null);
          var n4 = e5;
          return new s2(function(r4, o3) {
            var s3 = i2._dbInfo;
            s3.serializer.serialize(e5, function(e6, i3) {
              if (i3)
                o3(i3);
              else
                try {
                  localStorage.setItem(s3.keyPrefix + t4, e6), r4(n4);
                } catch (t5) {
                  t5.name !== "QuotaExceededError" && t5.name !== "NS_ERROR_DOM_QUOTA_REACHED" || o3(t5), o3(t5);
                }
            });
          });
        });
        return a(r3, n3), r3;
      }, removeItem: function(t4, e5) {
        var n3 = this;
        t4 = u(t4);
        var i2 = n3.ready().then(function() {
          var e6 = n3._dbInfo;
          localStorage.removeItem(e6.keyPrefix + t4);
        });
        return a(i2, e5), i2;
      }, clear: function(t4) {
        var e5 = this, n3 = e5.ready().then(function() {
          for (var t5 = e5._dbInfo.keyPrefix, n4 = localStorage.length - 1; n4 >= 0; n4--) {
            var i2 = localStorage.key(n4);
            i2.indexOf(t5) === 0 && localStorage.removeItem(i2);
          }
        });
        return a(n3, t4), n3;
      }, length: function(t4) {
        var e5 = this.keys().then(function(t5) {
          return t5.length;
        });
        return a(e5, t4), e5;
      }, key: function(t4, e5) {
        var n3 = this, i2 = n3.ready().then(function() {
          var e6, i3 = n3._dbInfo;
          try {
            e6 = localStorage.key(t4);
          } catch (t5) {
            e6 = null;
          }
          return e6 && (e6 = e6.substring(i3.keyPrefix.length)), e6;
        });
        return a(i2, e5), i2;
      }, keys: function(t4) {
        var e5 = this, n3 = e5.ready().then(function() {
          for (var t5 = e5._dbInfo, n4 = localStorage.length, i2 = [], r3 = 0; r3 < n4; r3++) {
            var o3 = localStorage.key(r3);
            o3.indexOf(t5.keyPrefix) === 0 && i2.push(o3.substring(t5.keyPrefix.length));
          }
          return i2;
        });
        return a(n3, t4), n3;
      }, dropInstance: function(t4, e5) {
        if (e5 = h.apply(this, arguments), !(t4 = typeof t4 != "function" && t4 || {}).name) {
          var n3 = this.config();
          t4.name = t4.name || n3.name, t4.storeName = t4.storeName || n3.storeName;
        }
        var i2, r3 = this;
        return a(i2 = t4.name ? new s2(function(e6) {
          t4.storeName ? e6(G(t4, r3._defaultConfig)) : e6(t4.name + "/");
        }).then(function(t5) {
          for (var e6 = localStorage.length - 1; e6 >= 0; e6--) {
            var n4 = localStorage.key(e6);
            n4.indexOf(t5) === 0 && localStorage.removeItem(n4);
          }
        }) : s2.reject("Invalid arguments"), e5), i2;
      } }, j = function(t4, e5) {
        for (var n3, i2, r3 = t4.length, o3 = 0; o3 < r3; ) {
          if ((n3 = t4[o3]) === (i2 = e5) || typeof n3 == "number" && typeof i2 == "number" && isNaN(n3) && isNaN(i2))
            return true;
          o3++;
        }
        return false;
      }, V = Array.isArray || function(t4) {
        return Object.prototype.toString.call(t4) === "[object Array]";
      }, W = {}, X = {}, q = { INDEXEDDB: M, WEBSQL: k, LOCALSTORAGE: z }, Y = [q.INDEXEDDB._driver, q.WEBSQL._driver, q.LOCALSTORAGE._driver], Z = ["dropInstance"], J = ["clear", "getItem", "iterate", "key", "keys", "length", "removeItem", "setItem"].concat(Z), $ = { description: "", driver: Y.slice(), name: "localforage", size: 4980736, storeName: "keyvaluepairs", version: 1 };
      function K(t4, e5) {
        t4[e5] = function() {
          var n3 = arguments;
          return t4.ready().then(function() {
            return t4[e5].apply(t4, n3);
          });
        };
      }
      function Q() {
        for (var t4 = 1; t4 < arguments.length; t4++) {
          var e5 = arguments[t4];
          if (e5)
            for (var n3 in e5)
              e5.hasOwnProperty(n3) && (V(e5[n3]) ? arguments[0][n3] = e5[n3].slice() : arguments[0][n3] = e5[n3]);
        }
        return arguments[0];
      }
      var tt = new (function() {
        function t4(e5) {
          for (var n3 in function(t5, e6) {
            if (!(t5 instanceof e6))
              throw new TypeError("Cannot call a class as a function");
          }(this, t4), q)
            if (q.hasOwnProperty(n3)) {
              var i2 = q[n3], r3 = i2._driver;
              this[n3] = r3, W[r3] || this.defineDriver(i2);
            }
          this._defaultConfig = Q({}, $), this._config = Q({}, this._defaultConfig, e5), this._driverSet = null, this._initDriver = null, this._ready = false, this._dbInfo = null, this._wrapLibraryMethodsWithReady(), this.setDriver(this._config.driver).catch(function() {
          });
        }
        return t4.prototype.config = function(t5) {
          if ((t5 === void 0 ? "undefined" : i(t5)) === "object") {
            if (this._ready)
              return new Error("Can't call config() after localforage has been used.");
            for (var e5 in t5) {
              if (e5 === "storeName" && (t5[e5] = t5[e5].replace(/\W/g, "_")), e5 === "version" && typeof t5[e5] != "number")
                return new Error("Database version must be a number.");
              this._config[e5] = t5[e5];
            }
            return !("driver" in t5) || !t5.driver || this.setDriver(this._config.driver);
          }
          return typeof t5 == "string" ? this._config[t5] : this._config;
        }, t4.prototype.defineDriver = function(t5, e5, n3) {
          var i2 = new s2(function(e6, n4) {
            try {
              var i3 = t5._driver, r3 = new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver");
              if (!t5._driver)
                return void n4(r3);
              for (var o3 = J.concat("_initStorage"), l2 = 0, u2 = o3.length; l2 < u2; l2++) {
                var h2 = o3[l2];
                if ((!j(Z, h2) || t5[h2]) && typeof t5[h2] != "function")
                  return void n4(r3);
              }
              !function() {
                for (var e7 = function(t6) {
                  return function() {
                    var e8 = new Error("Method " + t6 + " is not implemented by the current driver"), n6 = s2.reject(e8);
                    return a(n6, arguments[arguments.length - 1]), n6;
                  };
                }, n5 = 0, i4 = Z.length; n5 < i4; n5++) {
                  var r4 = Z[n5];
                  t5[r4] || (t5[r4] = e7(r4));
                }
              }();
              var c2 = function(n5) {
                W[i3] && console.info("Redefining LocalForage driver: " + i3), W[i3] = t5, X[i3] = n5, e6();
              };
              "_support" in t5 ? t5._support && typeof t5._support == "function" ? t5._support().then(c2, n4) : c2(!!t5._support) : c2(true);
            } catch (t6) {
              n4(t6);
            }
          });
          return l(i2, e5, n3), i2;
        }, t4.prototype.driver = function() {
          return this._driver || null;
        }, t4.prototype.getDriver = function(t5, e5, n3) {
          var i2 = W[t5] ? s2.resolve(W[t5]) : s2.reject(new Error("Driver not found."));
          return l(i2, e5, n3), i2;
        }, t4.prototype.getSerializer = function(t5) {
          var e5 = s2.resolve(N);
          return l(e5, t5), e5;
        }, t4.prototype.ready = function(t5) {
          var e5 = this, n3 = e5._driverSet.then(function() {
            return e5._ready === null && (e5._ready = e5._initDriver()), e5._ready;
          });
          return l(n3, t5, t5), n3;
        }, t4.prototype.setDriver = function(t5, e5, n3) {
          var i2 = this;
          V(t5) || (t5 = [t5]);
          var r3 = this._getSupportedDrivers(t5);
          function o3() {
            i2._config.driver = i2.driver();
          }
          function a2(t6) {
            return i2._extend(t6), o3(), i2._ready = i2._initStorage(i2._config), i2._ready;
          }
          var u2 = this._driverSet !== null ? this._driverSet.catch(function() {
            return s2.resolve();
          }) : s2.resolve();
          return this._driverSet = u2.then(function() {
            var t6 = r3[0];
            return i2._dbInfo = null, i2._ready = null, i2.getDriver(t6).then(function(t7) {
              i2._driver = t7._driver, o3(), i2._wrapLibraryMethodsWithReady(), i2._initDriver = function(t8) {
                return function() {
                  var e6 = 0;
                  return function n4() {
                    for (; e6 < t8.length; ) {
                      var r4 = t8[e6];
                      return e6++, i2._dbInfo = null, i2._ready = null, i2.getDriver(r4).then(a2).catch(n4);
                    }
                    o3();
                    var l2 = new Error("No available storage method found.");
                    return i2._driverSet = s2.reject(l2), i2._driverSet;
                  }();
                };
              }(r3);
            });
          }).catch(function() {
            o3();
            var t6 = new Error("No available storage method found.");
            return i2._driverSet = s2.reject(t6), i2._driverSet;
          }), l(this._driverSet, e5, n3), this._driverSet;
        }, t4.prototype.supports = function(t5) {
          return !!X[t5];
        }, t4.prototype._extend = function(t5) {
          Q(this, t5);
        }, t4.prototype._getSupportedDrivers = function(t5) {
          for (var e5 = [], n3 = 0, i2 = t5.length; n3 < i2; n3++) {
            var r3 = t5[n3];
            this.supports(r3) && e5.push(r3);
          }
          return e5;
        }, t4.prototype._wrapLibraryMethodsWithReady = function() {
          for (var t5 = 0, e5 = J.length; t5 < e5; t5++)
            K(this, J[t5]);
        }, t4.prototype.createInstance = function(e5) {
          return new t4(e5);
        }, t4;
      }())();
      e4.exports = tt;
    }, { 3: 3 }] }, {}, [4])(4);
  }).call(this, n(4));
}, function(t2, e2, n) {
  var i = n(63);
  t2.exports = function(t3, e3) {
    e3 = e3 || {};
    var n2 = new i(), r2 = e3.inPlace || false, o2 = t3.map(function(t4) {
      return r2 ? t4 : { width: t4.width, height: t4.height, item: t4 };
    });
    o2 = o2.sort(function(t4, e4) {
      return e4.width * e4.height - t4.width * t4.height;
    }), n2.fit(o2);
    var s2 = { width: o2.reduce(function(t4, e4) {
      return Math.max(t4, e4.x + e4.width);
    }, 0), height: o2.reduce(function(t4, e4) {
      return Math.max(t4, e4.y + e4.height);
    }, 0) };
    return r2 || (s2.items = o2), s2;
  };
}, function(t2, e2) {
  t2.exports = function(t3) {
    return t3.webpackPolyfill || (t3.deprecate = function() {
    }, t3.paths = [], t3.children || (t3.children = []), Object.defineProperty(t3, "loaded", { enumerable: true, get: function() {
      return t3.l;
    } }), Object.defineProperty(t3, "id", { enumerable: true, get: function() {
      return t3.i;
    } }), t3.webpackPolyfill = 1), t3;
  };
}, function(t2, e2, n) {
  var i = Object.prototype.hasOwnProperty, r2 = "~";
  function o2() {
  }
  function s2(t3, e3, n2) {
    this.fn = t3, this.context = e3, this.once = n2 || false;
  }
  function a(t3, e3, n2, i2, o3) {
    if (typeof n2 != "function")
      throw new TypeError("The listener must be a function");
    var a2 = new s2(n2, i2 || t3, o3), l2 = r2 ? r2 + e3 : e3;
    return t3._events[l2] ? t3._events[l2].fn ? t3._events[l2] = [t3._events[l2], a2] : t3._events[l2].push(a2) : (t3._events[l2] = a2, t3._eventsCount++), t3;
  }
  function l(t3, e3) {
    --t3._eventsCount == 0 ? t3._events = new o2() : delete t3._events[e3];
  }
  function u() {
    this._events = new o2(), this._eventsCount = 0;
  }
  Object.create && (o2.prototype = Object.create(null), new o2().__proto__ || (r2 = false)), u.prototype.eventNames = function() {
    var t3, e3, n2 = [];
    if (this._eventsCount === 0)
      return n2;
    for (e3 in t3 = this._events)
      i.call(t3, e3) && n2.push(r2 ? e3.slice(1) : e3);
    return Object.getOwnPropertySymbols ? n2.concat(Object.getOwnPropertySymbols(t3)) : n2;
  }, u.prototype.listeners = function(t3) {
    var e3 = r2 ? r2 + t3 : t3, n2 = this._events[e3];
    if (!n2)
      return [];
    if (n2.fn)
      return [n2.fn];
    for (var i2 = 0, o3 = n2.length, s3 = new Array(o3); i2 < o3; i2++)
      s3[i2] = n2[i2].fn;
    return s3;
  }, u.prototype.listenerCount = function(t3) {
    var e3 = r2 ? r2 + t3 : t3, n2 = this._events[e3];
    return n2 ? n2.fn ? 1 : n2.length : 0;
  }, u.prototype.emit = function(t3, e3, n2, i2, o3, s3) {
    var a2 = r2 ? r2 + t3 : t3;
    if (!this._events[a2])
      return false;
    var l2, u2, h = this._events[a2], c = arguments.length;
    if (h.fn) {
      switch (h.once && this.removeListener(t3, h.fn, void 0, true), c) {
        case 1:
          return h.fn.call(h.context), true;
        case 2:
          return h.fn.call(h.context, e3), true;
        case 3:
          return h.fn.call(h.context, e3, n2), true;
        case 4:
          return h.fn.call(h.context, e3, n2, i2), true;
        case 5:
          return h.fn.call(h.context, e3, n2, i2, o3), true;
        case 6:
          return h.fn.call(h.context, e3, n2, i2, o3, s3), true;
      }
      for (u2 = 1, l2 = new Array(c - 1); u2 < c; u2++)
        l2[u2 - 1] = arguments[u2];
      h.fn.apply(h.context, l2);
    } else {
      var d, p = h.length;
      for (u2 = 0; u2 < p; u2++)
        switch (h[u2].once && this.removeListener(t3, h[u2].fn, void 0, true), c) {
          case 1:
            h[u2].fn.call(h[u2].context);
            break;
          case 2:
            h[u2].fn.call(h[u2].context, e3);
            break;
          case 3:
            h[u2].fn.call(h[u2].context, e3, n2);
            break;
          case 4:
            h[u2].fn.call(h[u2].context, e3, n2, i2);
            break;
          default:
            if (!l2)
              for (d = 1, l2 = new Array(c - 1); d < c; d++)
                l2[d - 1] = arguments[d];
            h[u2].fn.apply(h[u2].context, l2);
        }
    }
    return true;
  }, u.prototype.on = function(t3, e3, n2) {
    return a(this, t3, e3, n2, false);
  }, u.prototype.once = function(t3, e3, n2) {
    return a(this, t3, e3, n2, true);
  }, u.prototype.removeListener = function(t3, e3, n2, i2) {
    var o3 = r2 ? r2 + t3 : t3;
    if (!this._events[o3])
      return this;
    if (!e3)
      return l(this, o3), this;
    var s3 = this._events[o3];
    if (s3.fn)
      s3.fn !== e3 || i2 && !s3.once || n2 && s3.context !== n2 || l(this, o3);
    else {
      for (var a2 = 0, u2 = [], h = s3.length; a2 < h; a2++)
        (s3[a2].fn !== e3 || i2 && !s3[a2].once || n2 && s3[a2].context !== n2) && u2.push(s3[a2]);
      u2.length ? this._events[o3] = u2.length === 1 ? u2[0] : u2 : l(this, o3);
    }
    return this;
  }, u.prototype.removeAllListeners = function(t3) {
    var e3;
    return t3 ? (e3 = r2 ? r2 + t3 : t3, this._events[e3] && l(this, e3)) : (this._events = new o2(), this._eventsCount = 0), this;
  }, u.prototype.off = u.prototype.removeListener, u.prototype.addListener = u.prototype.on, u.prefixed = r2, u.EventEmitter = u, t2.exports = u;
}, function(t2, e2, n) {
  function i(t3, e3, n2) {
    n2 = n2 || 2;
    var i2, a2, l2, u2, h2, p2, f2, g2 = e3 && e3.length, v2 = g2 ? e3[0] * n2 : t3.length, _2 = r2(t3, 0, v2, n2, true), y2 = [];
    if (!_2 || _2.next === _2.prev)
      return y2;
    if (g2 && (_2 = function(t4, e4, n3, i3) {
      var s3, a3, l3, u3, h3, p3 = [];
      for (s3 = 0, a3 = e4.length; s3 < a3; s3++)
        l3 = e4[s3] * i3, u3 = s3 < a3 - 1 ? e4[s3 + 1] * i3 : t4.length, (h3 = r2(t4, l3, u3, i3, false)) === h3.next && (h3.steiner = true), p3.push(m(h3));
      for (p3.sort(c), s3 = 0; s3 < p3.length; s3++)
        n3 = o2(n3 = d(p3[s3], n3), n3.next);
      return n3;
    }(t3, e3, _2, n2)), t3.length > 80 * n2) {
      i2 = l2 = t3[0], a2 = u2 = t3[1];
      for (var x2 = n2; x2 < v2; x2 += n2)
        (h2 = t3[x2]) < i2 && (i2 = h2), (p2 = t3[x2 + 1]) < a2 && (a2 = p2), h2 > l2 && (l2 = h2), p2 > u2 && (u2 = p2);
      f2 = (f2 = Math.max(l2 - i2, u2 - a2)) !== 0 ? 1 / f2 : 0;
    }
    return s2(_2, y2, n2, i2, a2, f2), y2;
  }
  function r2(t3, e3, n2, i2, r3) {
    var o3, s3;
    if (r3 === R(t3, e3, n2, i2) > 0)
      for (o3 = e3; o3 < n2; o3 += i2)
        s3 = E(o3, t3[o3], t3[o3 + 1], s3);
    else
      for (o3 = n2 - i2; o3 >= e3; o3 -= i2)
        s3 = E(o3, t3[o3], t3[o3 + 1], s3);
    return s3 && y(s3, s3.next) && (M(s3), s3 = s3.next), s3;
  }
  function o2(t3, e3) {
    if (!t3)
      return t3;
    e3 || (e3 = t3);
    var n2, i2 = t3;
    do {
      if (n2 = false, i2.steiner || !y(i2, i2.next) && _(i2.prev, i2, i2.next) !== 0)
        i2 = i2.next;
      else {
        if (M(i2), (i2 = e3 = i2.prev) === i2.next)
          break;
        n2 = true;
      }
    } while (n2 || i2 !== e3);
    return e3;
  }
  function s2(t3, e3, n2, i2, r3, c2, d2) {
    if (t3) {
      !d2 && c2 && function(t4, e4, n3, i3) {
        var r4 = t4;
        do {
          r4.z === null && (r4.z = f(r4.x, r4.y, e4, n3, i3)), r4.prevZ = r4.prev, r4.nextZ = r4.next, r4 = r4.next;
        } while (r4 !== t4);
        r4.prevZ.nextZ = null, r4.prevZ = null, function(t5) {
          var e5, n4, i4, r5, o3, s3, a2, l2, u2 = 1;
          do {
            for (n4 = t5, t5 = null, o3 = null, s3 = 0; n4; ) {
              for (s3++, i4 = n4, a2 = 0, e5 = 0; e5 < u2 && (a2++, i4 = i4.nextZ); e5++)
                ;
              for (l2 = u2; a2 > 0 || l2 > 0 && i4; )
                a2 !== 0 && (l2 === 0 || !i4 || n4.z <= i4.z) ? (r5 = n4, n4 = n4.nextZ, a2--) : (r5 = i4, i4 = i4.nextZ, l2--), o3 ? o3.nextZ = r5 : t5 = r5, r5.prevZ = o3, o3 = r5;
              n4 = i4;
            }
            o3.nextZ = null, u2 *= 2;
          } while (s3 > 1);
        }(r4);
      }(t3, i2, r3, c2);
      for (var p2, m2, g2 = t3; t3.prev !== t3.next; )
        if (p2 = t3.prev, m2 = t3.next, c2 ? l(t3, i2, r3, c2) : a(t3))
          e3.push(p2.i / n2), e3.push(t3.i / n2), e3.push(m2.i / n2), M(t3), t3 = m2.next, g2 = m2.next;
        else if ((t3 = m2) === g2) {
          d2 ? d2 === 1 ? s2(t3 = u(o2(t3), e3, n2), e3, n2, i2, r3, c2, 2) : d2 === 2 && h(t3, e3, n2, i2, r3, c2) : s2(o2(t3), e3, n2, i2, r3, c2, 1);
          break;
        }
    }
  }
  function a(t3) {
    var e3 = t3.prev, n2 = t3, i2 = t3.next;
    if (_(e3, n2, i2) >= 0)
      return false;
    for (var r3 = t3.next.next; r3 !== t3.prev; ) {
      if (g(e3.x, e3.y, n2.x, n2.y, i2.x, i2.y, r3.x, r3.y) && _(r3.prev, r3, r3.next) >= 0)
        return false;
      r3 = r3.next;
    }
    return true;
  }
  function l(t3, e3, n2, i2) {
    var r3 = t3.prev, o3 = t3, s3 = t3.next;
    if (_(r3, o3, s3) >= 0)
      return false;
    for (var a2 = r3.x < o3.x ? r3.x < s3.x ? r3.x : s3.x : o3.x < s3.x ? o3.x : s3.x, l2 = r3.y < o3.y ? r3.y < s3.y ? r3.y : s3.y : o3.y < s3.y ? o3.y : s3.y, u2 = r3.x > o3.x ? r3.x > s3.x ? r3.x : s3.x : o3.x > s3.x ? o3.x : s3.x, h2 = r3.y > o3.y ? r3.y > s3.y ? r3.y : s3.y : o3.y > s3.y ? o3.y : s3.y, c2 = f(a2, l2, e3, n2, i2), d2 = f(u2, h2, e3, n2, i2), p2 = t3.prevZ, m2 = t3.nextZ; p2 && p2.z >= c2 && m2 && m2.z <= d2; ) {
      if (p2 !== t3.prev && p2 !== t3.next && g(r3.x, r3.y, o3.x, o3.y, s3.x, s3.y, p2.x, p2.y) && _(p2.prev, p2, p2.next) >= 0)
        return false;
      if (p2 = p2.prevZ, m2 !== t3.prev && m2 !== t3.next && g(r3.x, r3.y, o3.x, o3.y, s3.x, s3.y, m2.x, m2.y) && _(m2.prev, m2, m2.next) >= 0)
        return false;
      m2 = m2.nextZ;
    }
    for (; p2 && p2.z >= c2; ) {
      if (p2 !== t3.prev && p2 !== t3.next && g(r3.x, r3.y, o3.x, o3.y, s3.x, s3.y, p2.x, p2.y) && _(p2.prev, p2, p2.next) >= 0)
        return false;
      p2 = p2.prevZ;
    }
    for (; m2 && m2.z <= d2; ) {
      if (m2 !== t3.prev && m2 !== t3.next && g(r3.x, r3.y, o3.x, o3.y, s3.x, s3.y, m2.x, m2.y) && _(m2.prev, m2, m2.next) >= 0)
        return false;
      m2 = m2.nextZ;
    }
    return true;
  }
  function u(t3, e3, n2) {
    var i2 = t3;
    do {
      var r3 = i2.prev, s3 = i2.next.next;
      !y(r3, s3) && x(r3, i2, i2.next, s3) && w(r3, s3) && w(s3, r3) && (e3.push(r3.i / n2), e3.push(i2.i / n2), e3.push(s3.i / n2), M(i2), M(i2.next), i2 = t3 = s3), i2 = i2.next;
    } while (i2 !== t3);
    return o2(i2);
  }
  function h(t3, e3, n2, i2, r3, a2) {
    var l2 = t3;
    do {
      for (var u2 = l2.next.next; u2 !== l2.prev; ) {
        if (l2.i !== u2.i && v(l2, u2)) {
          var h2 = S(l2, u2);
          return l2 = o2(l2, l2.next), h2 = o2(h2, h2.next), s2(l2, e3, n2, i2, r3, a2), void s2(h2, e3, n2, i2, r3, a2);
        }
        u2 = u2.next;
      }
      l2 = l2.next;
    } while (l2 !== t3);
  }
  function c(t3, e3) {
    return t3.x - e3.x;
  }
  function d(t3, e3) {
    var n2 = function(t4, e4) {
      var n3, i3 = e4, r4 = t4.x, o3 = t4.y, s3 = -1 / 0;
      do {
        if (o3 <= i3.y && o3 >= i3.next.y && i3.next.y !== i3.y) {
          var a2 = i3.x + (o3 - i3.y) * (i3.next.x - i3.x) / (i3.next.y - i3.y);
          if (a2 <= r4 && a2 > s3) {
            if (s3 = a2, a2 === r4) {
              if (o3 === i3.y)
                return i3;
              if (o3 === i3.next.y)
                return i3.next;
            }
            n3 = i3.x < i3.next.x ? i3 : i3.next;
          }
        }
        i3 = i3.next;
      } while (i3 !== e4);
      if (!n3)
        return null;
      if (r4 === s3)
        return n3;
      var l2, u2 = n3, h2 = n3.x, c2 = n3.y, d2 = 1 / 0;
      i3 = n3;
      do {
        r4 >= i3.x && i3.x >= h2 && r4 !== i3.x && g(o3 < c2 ? r4 : s3, o3, h2, c2, o3 < c2 ? s3 : r4, o3, i3.x, i3.y) && (l2 = Math.abs(o3 - i3.y) / (r4 - i3.x), w(i3, t4) && (l2 < d2 || l2 === d2 && (i3.x > n3.x || i3.x === n3.x && p(n3, i3))) && (n3 = i3, d2 = l2)), i3 = i3.next;
      } while (i3 !== u2);
      return n3;
    }(t3, e3);
    if (!n2)
      return e3;
    var i2 = S(n2, t3), r3 = o2(n2, n2.next);
    return o2(i2, i2.next), e3 === n2 ? r3 : e3;
  }
  function p(t3, e3) {
    return _(t3.prev, t3, e3.prev) < 0 && _(e3.next, t3, t3.next) < 0;
  }
  function f(t3, e3, n2, i2, r3) {
    return (t3 = 1431655765 & ((t3 = 858993459 & ((t3 = 252645135 & ((t3 = 16711935 & ((t3 = 32767 * (t3 - n2) * r3) | t3 << 8)) | t3 << 4)) | t3 << 2)) | t3 << 1)) | (e3 = 1431655765 & ((e3 = 858993459 & ((e3 = 252645135 & ((e3 = 16711935 & ((e3 = 32767 * (e3 - i2) * r3) | e3 << 8)) | e3 << 4)) | e3 << 2)) | e3 << 1)) << 1;
  }
  function m(t3) {
    var e3 = t3, n2 = t3;
    do {
      (e3.x < n2.x || e3.x === n2.x && e3.y < n2.y) && (n2 = e3), e3 = e3.next;
    } while (e3 !== t3);
    return n2;
  }
  function g(t3, e3, n2, i2, r3, o3, s3, a2) {
    return (r3 - s3) * (e3 - a2) - (t3 - s3) * (o3 - a2) >= 0 && (t3 - s3) * (i2 - a2) - (n2 - s3) * (e3 - a2) >= 0 && (n2 - s3) * (o3 - a2) - (r3 - s3) * (i2 - a2) >= 0;
  }
  function v(t3, e3) {
    return t3.next.i !== e3.i && t3.prev.i !== e3.i && !function(t4, e4) {
      var n2 = t4;
      do {
        if (n2.i !== t4.i && n2.next.i !== t4.i && n2.i !== e4.i && n2.next.i !== e4.i && x(n2, n2.next, t4, e4))
          return true;
        n2 = n2.next;
      } while (n2 !== t4);
      return false;
    }(t3, e3) && (w(t3, e3) && w(e3, t3) && function(t4, e4) {
      var n2 = t4, i2 = false, r3 = (t4.x + e4.x) / 2, o3 = (t4.y + e4.y) / 2;
      do {
        n2.y > o3 != n2.next.y > o3 && n2.next.y !== n2.y && r3 < (n2.next.x - n2.x) * (o3 - n2.y) / (n2.next.y - n2.y) + n2.x && (i2 = !i2), n2 = n2.next;
      } while (n2 !== t4);
      return i2;
    }(t3, e3) && (_(t3.prev, t3, e3.prev) || _(t3, e3.prev, e3)) || y(t3, e3) && _(t3.prev, t3, t3.next) > 0 && _(e3.prev, e3, e3.next) > 0);
  }
  function _(t3, e3, n2) {
    return (e3.y - t3.y) * (n2.x - e3.x) - (e3.x - t3.x) * (n2.y - e3.y);
  }
  function y(t3, e3) {
    return t3.x === e3.x && t3.y === e3.y;
  }
  function x(t3, e3, n2, i2) {
    var r3 = T(_(t3, e3, n2)), o3 = T(_(t3, e3, i2)), s3 = T(_(n2, i2, t3)), a2 = T(_(n2, i2, e3));
    return r3 !== o3 && s3 !== a2 || (!(r3 !== 0 || !b(t3, n2, e3)) || (!(o3 !== 0 || !b(t3, i2, e3)) || (!(s3 !== 0 || !b(n2, t3, i2)) || !(a2 !== 0 || !b(n2, e3, i2)))));
  }
  function b(t3, e3, n2) {
    return e3.x <= Math.max(t3.x, n2.x) && e3.x >= Math.min(t3.x, n2.x) && e3.y <= Math.max(t3.y, n2.y) && e3.y >= Math.min(t3.y, n2.y);
  }
  function T(t3) {
    return t3 > 0 ? 1 : t3 < 0 ? -1 : 0;
  }
  function w(t3, e3) {
    return _(t3.prev, t3, t3.next) < 0 ? _(t3, e3, t3.next) >= 0 && _(t3, t3.prev, e3) >= 0 : _(t3, e3, t3.prev) < 0 || _(t3, t3.next, e3) < 0;
  }
  function S(t3, e3) {
    var n2 = new A(t3.i, t3.x, t3.y), i2 = new A(e3.i, e3.x, e3.y), r3 = t3.next, o3 = e3.prev;
    return t3.next = e3, e3.prev = t3, n2.next = r3, r3.prev = n2, i2.next = n2, n2.prev = i2, o3.next = i2, i2.prev = o3, i2;
  }
  function E(t3, e3, n2, i2) {
    var r3 = new A(t3, e3, n2);
    return i2 ? (r3.next = i2.next, r3.prev = i2, i2.next.prev = r3, i2.next = r3) : (r3.prev = r3, r3.next = r3), r3;
  }
  function M(t3) {
    t3.next.prev = t3.prev, t3.prev.next = t3.next, t3.prevZ && (t3.prevZ.nextZ = t3.nextZ), t3.nextZ && (t3.nextZ.prevZ = t3.prevZ);
  }
  function A(t3, e3, n2) {
    this.i = t3, this.x = e3, this.y = n2, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = false;
  }
  function R(t3, e3, n2, i2) {
    for (var r3 = 0, o3 = e3, s3 = n2 - i2; o3 < n2; o3 += i2)
      r3 += (t3[s3] - t3[o3]) * (t3[o3 + 1] + t3[s3 + 1]), s3 = o3;
    return r3;
  }
  t2.exports = i, t2.exports.default = i, i.deviation = function(t3, e3, n2, i2) {
    var r3 = e3 && e3.length, o3 = r3 ? e3[0] * n2 : t3.length, s3 = Math.abs(R(t3, 0, o3, n2));
    if (r3)
      for (var a2 = 0, l2 = e3.length; a2 < l2; a2++) {
        var u2 = e3[a2] * n2, h2 = a2 < l2 - 1 ? e3[a2 + 1] * n2 : t3.length;
        s3 -= Math.abs(R(t3, u2, h2, n2));
      }
    var c2 = 0;
    for (a2 = 0; a2 < i2.length; a2 += 3) {
      var d2 = i2[a2] * n2, p2 = i2[a2 + 1] * n2, f2 = i2[a2 + 2] * n2;
      c2 += Math.abs((t3[d2] - t3[f2]) * (t3[p2 + 1] - t3[d2 + 1]) - (t3[d2] - t3[p2]) * (t3[f2 + 1] - t3[d2 + 1]));
    }
    return s3 === 0 && c2 === 0 ? 0 : Math.abs((c2 - s3) / s3);
  }, i.flatten = function(t3) {
    for (var e3 = t3[0][0].length, n2 = { vertices: [], holes: [], dimensions: e3 }, i2 = 0, r3 = 0; r3 < t3.length; r3++) {
      for (var o3 = 0; o3 < t3[r3].length; o3++)
        for (var s3 = 0; s3 < e3; s3++)
          n2.vertices.push(t3[r3][o3][s3]);
      r3 > 0 && (i2 += t3[r3 - 1].length, n2.holes.push(i2));
    }
    return n2;
  };
}, function(t2, e2) {
  t2.exports = "varying vec2 vUv;\nvoid main() {\n	vUv = uv;\n	gl_Position = (projectionMatrix * modelViewMatrix) * vec4(position, 1.0);\n}\n";
}, function(t2, e2) {
  t2.exports = "vec4 blendSrcOver(vec4 src, vec4 dist) {\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	src.r *= src.a;\n	src.g *= src.a;\n	src.b *= src.a;\n	result.a = src.a + (dist.a * (1.0 - src.a));\n	result.r = (src.r + (dist.r * (1.0 - src.a))) / result.a;\n	result.g = (src.g + (dist.g * (1.0 - src.a))) / result.a;\n	result.b = (src.b + (dist.b * (1.0 - src.a))) / result.a;\n	return result;\n}\nuniform float lines[26];\nvarying vec2 vUv;\nuniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nvoid main() {\n	vec4 srcColor = texture2D(texturePrev, vUv);\n	vec4 distColor = texture2D(textureNext, vUv);\n	float middleAlpha = 0.0;\n	float endAlpha = 0.0;\n	float headLength = 0.0;\n	if (timePercent < 0.5) {\n		middleAlpha = 1.0;\n		endAlpha = 1.0 - (timePercent / 0.5);\n	}\n	else {\n		middleAlpha = 1.0 - ((timePercent - 0.5) / 0.5);\n		endAlpha = 0.0;\n	}\n	for (int i = 0; i < 26; i++) {\n		float halfDis = lines[i] / 2.0;\n		float middleX = headLength + halfDis;\n		headLength += lines[i];\n		if (abs(vUv.x - middleX) <= halfDis) {\n			srcColor.a = endAlpha + (((halfDis - abs(vUv.x - middleX)) / halfDis) * (middleAlpha - endAlpha));\n			gl_FragColor = blendSrcOver(srcColor, distColor);\n			return ;\n		}\n	}\n	gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}\n";
}, function(t2, e2) {
  t2.exports = "vec4 blendSrcOver(vec4 src, vec4 dist) {\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	src.r *= src.a;\n	src.g *= src.a;\n	src.b *= src.a;\n	result.a = src.a + (dist.a * (1.0 - src.a));\n	result.r = (src.r + (dist.r * (1.0 - src.a))) / result.a;\n	result.g = (src.g + (dist.g * (1.0 - src.a))) / result.a;\n	result.b = (src.b + (dist.b * (1.0 - src.a))) / result.a;\n	return result;\n}\nuniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nuniform float width;\nuniform float height;\nvarying vec2 vUv;\nvec2 transform(vec2 uv) {\n	uv.y = (uv.y * height) / width;\n	return uv - vec2(0.5, (0.5 * height) / width);\n}\nvoid main() {\n	float maxR;\n	float ringR;\n	float radiusMin;\n	float radiusMax;\n	float dist;\n	vec2 uv = vec2(vUv.x, vUv.y);\n	maxR = length(transform(vec2(1.0, 1.0)));\n	ringR = 1.0 / 6.0;\n	radiusMin = timePercent * maxR;\n	radiusMax = radiusMin + ringR;\n	dist = length(transform(uv));\n	vec4 srcColor = texture2D(texturePrev, vUv);\n	vec4 distColor = texture2D(textureNext, vUv);\n	if (dist < radiusMin) {\n		srcColor.a = 0.0;\n	}\n	else if ((dist >= radiusMin) && (dist <= radiusMax)) {\n		srcColor.a = (dist - radiusMin) / ringR;\n	}\n	else {\n		srcColor.a = 1.0;\n	}\n	if (timePercent >= 1.0) {\n		srcColor.a = 0.0;\n	}\n	else if (timePercent == 0.0) {\n		srcColor.a = 1.0;\n	}\n	gl_FragColor = blendSrcOver(srcColor, distColor);\n}\n";
}, function(t2, e2) {
  t2.exports = "vec4 blendSrcOver(vec4 src, vec4 dist) {\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	src.r *= src.a;\n	src.g *= src.a;\n	src.b *= src.a;\n	result.a = src.a + (dist.a * (1.0 - src.a));\n	result.r = (src.r + (dist.r * (1.0 - src.a))) / result.a;\n	result.g = (src.g + (dist.g * (1.0 - src.a))) / result.a;\n	result.b = (src.b + (dist.b * (1.0 - src.a))) / result.a;\n	return result;\n}\nuniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nuniform float width;\nuniform float height;\nvarying vec2 vUv;\nvec2 transform(vec2 uv) {\n	uv.y = (uv.y * height) / width;\n	return uv - vec2(0.5, (0.5 * height) / width);\n}\nvec2 offset(float progress[4], float band, float amp, float radius) {\n	vec2 tc = vUv.xy;\n	vec2 uv = vec2(0.0, 0.0);\n	vec2 p;\n	float len;\n	vec2 uv_offset;\n	float wave_width = band * radius;\n	for (int i = 0; i < 4; i += 1) {\n		if (progress[i] == -1.0) {\n			continue;\n		}\n		p = tc - vec2(0.5, 0.5);\n		p.x = (p.x * width) / height;\n		len = length(p);\n		float current_progress = progress[i];\n		float current_radius = radius * current_progress;\n		float damp_factor = 1.0;\n		if (current_progress > .5) {\n			damp_factor = (1.0 - current_progress) * 2.0;\n		}\n		float cut_factor = clamp((wave_width * damp_factor) - abs(current_radius - len), 0.0, 1.0);\n		float waves_factor = (4.0 * len) / radius;\n		uv_offset = (((p / len) * cos((waves_factor - (current_progress * 10.0)) * 3.14)) * amp) * cut_factor;\n		uv += uv_offset;\n	}\n	return uv;\n}\nvoid main() {\n	float maxR;\n	float ringR;\n	float radiusMin;\n	float radiusMax;\n	float dist;\n	float progress[4];\n	vec2 uv = vUv.xy;\n	vec2 uvOffset = vec2(0.0, 0.0);\n	maxR = length(transform(vec2(1.0, 1.0)));\n	ringR = 1.0 / 6.0;\n	radiusMin = timePercent * maxR;\n	radiusMax = radiusMin + ringR;\n	dist = length(transform(uv));\n	for (int i = 0; i < 4; i++) {\n		progress[i] = timePercent + (0.1 * float(i));\n		if (progress[i] < 0.0) {\n			progress[i] = 0.0;\n		}\n	}\n	uvOffset = offset(progress, 0.2, 0.3, 1.0);\n	vec4 srcColor = texture2D(texturePrev, fract(vUv + uvOffset));\n	vec4 distColor = texture2D(textureNext, fract(vUv + uvOffset));\n	if (dist < radiusMin) {\n		srcColor.a = 0.0;\n	}\n	else if ((dist >= radiusMin) && (dist <= radiusMax)) {\n		srcColor.a = (dist - radiusMin) / ringR;\n	}\n	else {\n		srcColor.a = 1.0;\n	}\n	if (timePercent >= 1.0) {\n		srcColor.a = 0.0;\n	}\n	else if (timePercent == 0.0) {\n		srcColor.a = 1.0;\n	}\n	gl_FragColor = blendSrcOver(srcColor, distColor);\n}\n";
}, function(t2, e2) {
  t2.exports = "vec4 blendSrcOver(vec4 src, vec4 dist) {\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	src.r *= src.a;\n	src.g *= src.a;\n	src.b *= src.a;\n	result.a = src.a + (dist.a * (1.0 - src.a));\n	result.r = (src.r + (dist.r * (1.0 - src.a))) / result.a;\n	result.g = (src.g + (dist.g * (1.0 - src.a))) / result.a;\n	result.b = (src.b + (dist.b * (1.0 - src.a))) / result.a;\n	return result;\n}\nuniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nvarying vec2 vUv;\nvoid main() {\n	vec4 srcColor = texture2D(texturePrev, vUv);\n	vec4 distColor = texture2D(textureNext, vUv);\n	float alphaStart = timePercent > 0.5 ? ((timePercent - 0.5) / 0.5) * 1.0 : 1.0;\n	float alphaEnd = timePercent < 0.5 ? ((0.5 - timePercent) / 0.5) * 1.0 : 0.0;\n	float rectStart = 0.5 * (1.0 - timePercent);\n	float rectEnd = rectStart + 0.5;\n	if (timePercent <= 0.33) {\n		alphaStart = 1.0;\n		alphaEnd = (1.0 - (timePercent / 0.33)) * 1.0;\n		rectStart = 0.5;\n		rectEnd = 1.0;\n	}\n	else if ((timePercent > 0.33) && (timePercent <= 0.66)) {\n		alphaStart = 1.0;\n		alphaEnd = 0.0;\n		rectEnd = 1.0 - (((timePercent - 0.33) / 0.33) * 0.5);\n		rectStart = rectEnd - 0.5;\n	}\n	else {\n		alphaStart = ((1.0 - timePercent) / (1.0 - 0.66)) * 1.0;\n		alphaEnd = 0.0;\n		rectStart = 0.0;\n		rectEnd = 0.5;\n	}\n	if (vUv.x >= rectEnd) {\n		srcColor.a = 0.0;\n	}\n	else if (vUv.x <= rectStart) {\n		srcColor.a = 1.0;\n	}\n	else {\n		srcColor.a = alphaStart - (((vUv.x - rectStart) / 0.5) * (alphaStart - alphaEnd));\n	}\n	gl_FragColor = blendSrcOver(srcColor, distColor);\n}\n";
}, function(t2, e2) {
  t2.exports = "uniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform sampler2D dissolveTexture;\nvarying vec2 vUv;\nvoid main() {\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	vec4 srcColor = texture2D(texturePrev, vUv);\n	vec4 distColor = texture2D(textureNext, vUv);\n	vec4 dissolveColor = texture2D(dissolveTexture, vUv);\n	if (dissolveColor.r == 0.0) {\n		result = srcColor;\n	}\n	else {\n		result = distColor;\n	}\n	gl_FragColor = result;\n}\n";
}, function(t2, e2) {
  t2.exports = "uniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nvarying vec2 vUv;\nvoid main() {\n	vec4 srcColor = texture2D(texturePrev, vUv);\n	vec4 distColor = texture2D(textureNext, vUv);\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	if (timePercent < 0.5) {\n		float stagePercent = timePercent / 0.5;\n		result = srcColor + (stagePercent * (1.0 - srcColor));\n	}\n	else {\n		float stagePercent = (timePercent - 0.5) / 0.5;\n		result = 1.0 - (stagePercent * (1.0 - distColor));\n	}\n	gl_FragColor = result;\n}\n";
}, function(t2, e2) {
  t2.exports = "vec4 blendSrcOver(vec4 src, vec4 dist) {\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	src.r *= src.a;\n	src.g *= src.a;\n	src.b *= src.a;\n	result.a = src.a + (dist.a * (1.0 - src.a));\n	result.r = (src.r + (dist.r * (1.0 - src.a))) / result.a;\n	result.g = (src.g + (dist.g * (1.0 - src.a))) / result.a;\n	result.b = (src.b + (dist.b * (1.0 - src.a))) / result.a;\n	return result;\n}\nuniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nvarying vec2 vUv;\nvoid main() {\n	vec4 srcColor = texture2D(texturePrev, vUv);\n	vec4 distColor = texture2D(textureNext, vUv);\n	srcColor.a = 1.0 - timePercent;\n	gl_FragColor = blendSrcOver(srcColor, distColor);\n}\n";
}, function(t2, e2) {
  t2.exports = "float interpolationFloat(float from, float to, float start, float end, float timePercent, int timing) {\n	float pi = 3.14159265358;\n	float current;\n	float duration = 1.0;\n	if (timePercent < start) {\n		current = 0.0;\n	}\n	else if (timePercent > end) {\n		current = 1.0;\n	}\n	else {\n		current = (timePercent - start) / (end - start);\n	}\n	if (timing == 0) {\n		return ((current / duration) * (to - from)) + from;\n	}\n	else if (timing == 1) {\n		current = current / duration;\n		return (((to - from) * current) * current) + from;\n	}\n	else if (timing == 2) {\n		current = current / duration;\n		return (((-1.0 * (to - from)) * current) * (current - 2.0)) + from;\n	}\n	else {\n		current /= (duration / 2.0);\n		if (current < 1.0) {\n			return ((((to - from) / 2.0) * current) * current) + from;\n		}\n		current--;\n		return ((-(to - from) / 2.0) * ((current * (current - 2.0)) - 1.0)) + from;\n	}\n}\nuniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nvarying vec2 vUv;\nvoid main() {\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	float line = interpolationFloat(0.0, 1.0, 0.0, 1.0, timePercent, 3);\n	if (vUv.y > line) {\n		vec2 uv = vUv.xy;\n		uv.y -= line;\n		result = texture2D(texturePrev, uv);\n	}\n	else {\n		vec2 uv = vUv.xy;\n		uv.y += (1.0 - line);\n		result = texture2D(textureNext, uv);\n	}\n	gl_FragColor = result;\n}\n";
}, function(t2, e2) {
  t2.exports = "vec4 blendSrcOver(vec4 src, vec4 dist) {\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	src.r *= src.a;\n	src.g *= src.a;\n	src.b *= src.a;\n	result.a = src.a + (dist.a * (1.0 - src.a));\n	result.r = (src.r + (dist.r * (1.0 - src.a))) / result.a;\n	result.g = (src.g + (dist.g * (1.0 - src.a))) / result.a;\n	result.b = (src.b + (dist.b * (1.0 - src.a))) / result.a;\n	return result;\n}\nuniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nvarying vec2 vUv;\nvoid main() {\n	vec4 srcColor = texture2D(texturePrev, vUv);\n	vec4 distColor = texture2D(textureNext, vUv);\n	vec2 rectLeft = vec2(0.25, 0.5);\n	vec2 rectRight = vec2(0.5, 0.75);\n	vec2 alphaLeft = vec2(1.0, 1.0);\n	vec2 alphaRight = vec2(1.0, 1.0);\n	if (timePercent <= 0.333) {\n		alphaLeft.y = 1.0 - (timePercent / 0.333);\n		alphaRight.x = 1.0 - (timePercent / 0.333);\n	}\n	else if ((timePercent <= 0.666) && (timePercent > 0.333)) {\n		rectLeft.x -= (((timePercent - 0.333) / 0.333) * 0.25);\n		rectLeft.y = rectLeft.x + 0.25;\n		rectRight.y += (((timePercent - 0.333) / 0.333) * 0.25);\n		rectRight.x = rectRight.y - 0.25;\n		alphaLeft.y = 0.0;\n		alphaRight.x = 0.0;\n	}\n	else {\n		rectLeft = vec2(0.0, 0.25);\n		rectRight = vec2(0.75, 1.0);\n		alphaLeft.y = 0.0;\n		alphaRight.x = 0.0;\n		alphaLeft.x = 1.0 - ((timePercent - 0.666) / (1.0 - 0.666));\n		alphaRight.y = 1.0 - ((timePercent - 0.666) / (1.0 - 0.666));\n	}\n	if ((vUv.x < rectLeft.x) || (vUv.x > rectRight.y)) {\n		srcColor.a = 1.0;\n	}\n	else if ((vUv.x > rectLeft.y) && (vUv.x < rectRight.x)) {\n		srcColor.a = 0.0;\n	}\n	else {\n		if ((vUv.x >= rectLeft.x) && (vUv.x <= rectLeft.y)) {\n			srcColor.a = alphaLeft.x - (((vUv.x - rectLeft.x) / (rectLeft.y - rectLeft.x)) * (alphaLeft.x - alphaLeft.y));\n		}\n		else {\n			srcColor.a = alphaRight.y - (((rectRight.y - vUv.x) / (rectLeft.y - rectLeft.x)) * (alphaRight.y - alphaRight.x));\n		}\n	}\n	gl_FragColor = blendSrcOver(srcColor, distColor);\n}\n";
}, function(t2, e2) {
  t2.exports = "uniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nvarying vec2 vUv;\nvoid main() {\n	vec4 uv4 = vec4(vUv.x, vUv.y, 1.0, 1.0);\n	float scale = 1.0;\n	float transform = 0.0;\n	if (timePercent < 0.5) {\n		scale = 1.0 - ((timePercent / 0.5) * 0.05);\n		transform = (1.0 - scale) * 0.5;\n	}\n	else {\n		scale = 0.95 + (((timePercent - 0.5) / 0.5) * 0.05);\n		transform = (1.0 - scale) * 0.5;\n	}\n	mat4 matrix = mat4(scale, 0.0, 0.0, 0.0, 0.0, scale, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, transform, transform, 0.0, 1.0);\n	vec4 uv = matrix * uv4;\n	vec4 srcColor = texture2D(texturePrev, uv.xy);\n	vec4 distColor = texture2D(textureNext, uv.xy);\n	vec4 result = timePercent < 0.5 ? srcColor : distColor;\n	vec3 start;\n	vec3 end;\n	vec3 white = vec3(1.0, 1.0, 1.0);\n	if ((timePercent < 0.25) || (timePercent > 0.75)) {\n		result *= 1.0;\n	}\n	else if ((timePercent >= 0.25) && (timePercent <= 0.5)) {\n		if (timePercent <= 0.375) {\n			start = result.rgb;\n			end = start + (((timePercent - 0.25) / 0.125) * (white - result.rgb));\n		}\n		else {\n			start = result.rgb + (((timePercent - 0.375) / 0.125) * (white - result.rgb));\n			end = white;\n		}\n		result = vec4(start - (vUv.x * (start - end)), result.a);\n	}\n	else if ((timePercent > 0.5) && (timePercent <= 0.75)) {\n		if (timePercent < 0.625) {\n			start = white - (((timePercent - 0.5) / 0.125) * (white - result.rgb));\n			end = white;\n		}\n		else {\n			start = result.rgb;\n			end = white - (((timePercent - 0.625) / 0.125) * (white - result.rgb));\n		}\n		result = vec4(start - (vUv.x * (start - end)), result.a);\n	}\n	gl_FragColor = result;\n}\n";
}, function(t2, e2) {
  t2.exports = "float interpolationFloat(float from, float to, float start, float end, float timePercent, int timing) {\n	float pi = 3.14159265358;\n	float current;\n	float duration = 1.0;\n	if (timePercent < start) {\n		current = 0.0;\n	}\n	else if (timePercent > end) {\n		current = 1.0;\n	}\n	else {\n		current = (timePercent - start) / (end - start);\n	}\n	if (timing == 0) {\n		return ((current / duration) * (to - from)) + from;\n	}\n	else if (timing == 1) {\n		current = current / duration;\n		return (((to - from) * current) * current) + from;\n	}\n	else if (timing == 2) {\n		current = current / duration;\n		return (((-1.0 * (to - from)) * current) * (current - 2.0)) + from;\n	}\n	else {\n		current /= (duration / 2.0);\n		if (current < 1.0) {\n			return ((((to - from) / 2.0) * current) * current) + from;\n		}\n		current--;\n		return ((-(to - from) / 2.0) * ((current * (current - 2.0)) - 1.0)) + from;\n	}\n}\nuniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nvarying vec2 vUv;\nvoid main() {\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	float line = interpolationFloat(1.0, 0.0, 0.0, 1.0, timePercent, 1);\n	if (vUv.x > line) {\n		result = texture2D(textureNext, vUv);\n	}\n	else {\n		vec2 uv = vUv.xy;\n		uv.x = 1.0 - (line - vUv.x);\n		result = texture2D(texturePrev, uv);\n	}\n	gl_FragColor = result;\n}\n";
}, function(t2, e2) {
  t2.exports = "float interpolationFloat(float from, float to, float start, float end, float timePercent, int timing) {\n	float pi = 3.14159265358;\n	float current;\n	float duration = 1.0;\n	if (timePercent < start) {\n		current = 0.0;\n	}\n	else if (timePercent > end) {\n		current = 1.0;\n	}\n	else {\n		current = (timePercent - start) / (end - start);\n	}\n	if (timing == 0) {\n		return ((current / duration) * (to - from)) + from;\n	}\n	else if (timing == 1) {\n		current = current / duration;\n		return (((to - from) * current) * current) + from;\n	}\n	else if (timing == 2) {\n		current = current / duration;\n		return (((-1.0 * (to - from)) * current) * (current - 2.0)) + from;\n	}\n	else {\n		current /= (duration / 2.0);\n		if (current < 1.0) {\n			return ((((to - from) / 2.0) * current) * current) + from;\n		}\n		current--;\n		return ((-(to - from) / 2.0) * ((current * (current - 2.0)) - 1.0)) + from;\n	}\n}\nuniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nvarying vec2 vUv;\nvoid main() {\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	float line = interpolationFloat(1.0, 0.0, 0.0, 1.0, timePercent, 3);\n	if (vUv.x > line) {\n		vec2 uv = vUv.xy;\n		uv.x = vUv.x - line;\n		result = texture2D(textureNext, uv);\n	}\n	else {\n		result = texture2D(texturePrev, vUv);\n	}\n	gl_FragColor = result;\n}\n";
}, function(t2, e2) {
  t2.exports = "float interpolationFloat(float from, float to, float start, float end, float timePercent, int timing) {\n	float pi = 3.14159265358;\n	float current;\n	float duration = 1.0;\n	if (timePercent < start) {\n		current = 0.0;\n	}\n	else if (timePercent > end) {\n		current = 1.0;\n	}\n	else {\n		current = (timePercent - start) / (end - start);\n	}\n	if (timing == 0) {\n		return ((current / duration) * (to - from)) + from;\n	}\n	else if (timing == 1) {\n		current = current / duration;\n		return (((to - from) * current) * current) + from;\n	}\n	else if (timing == 2) {\n		current = current / duration;\n		return (((-1.0 * (to - from)) * current) * (current - 2.0)) + from;\n	}\n	else {\n		current /= (duration / 2.0);\n		if (current < 1.0) {\n			return ((((to - from) / 2.0) * current) * current) + from;\n		}\n		current--;\n		return ((-(to - from) / 2.0) * ((current * (current - 2.0)) - 1.0)) + from;\n	}\n}\nuniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nvarying vec2 vUv;\nmat3 yuv2rgb = mat3(1.0, 0.0, 1.13983, 1.0, -0.39465, -0.58060, 1.0, 2.03211, 0.0);\nmat3 rgb2yuv = mat3(0.2126, 0.7152, 0.0722, -0.09991, -0.33609, 0.43600, 0.615, -0.5586, -0.05639);\nvoid main() {\n	vec4 srcColor = texture2D(texturePrev, vUv);\n	vec4 distColor = texture2D(textureNext, vUv);\n	vec3 result;\n	float resultAlpha;\n	if (timePercent < 0.5) {\n		result = srcColor.rgb * rgb2yuv;\n		result.r += interpolationFloat(0.0, 1.0, 0.0, 0.5, timePercent, 0);\n		resultAlpha = srcColor.a;\n	}\n	else {\n		result = distColor.rgb * rgb2yuv;\n		result.r += interpolationFloat(1.0, 0.0, 0.5, 1.0, timePercent, 0);\n		resultAlpha = distColor.a;\n	}\n	result *= yuv2rgb;\n	gl_FragColor = vec4(result.rgb, resultAlpha);\n}\n";
}, function(t2, e2) {
  t2.exports = "uniform float horizontalSegments;\nuniform float verticalSegments;\nuniform float timePercent;\nuniform float segmentWidth;\nuniform float segmentHeight;\nattribute vec2 segment;\nattribute float times;\nvarying vec2 vUv;\nvarying float fakePercent;\nvoid main() {\n	vUv = uv;\n	float width = segmentWidth * horizontalSegments;\n	float height = segmentHeight * verticalSegments;\n	vec4 newPosition = vec4(position, 1.0);\n	vec2 segmentOrigin = vec2(((segment.x + 0.5) * segmentWidth) - (width * 0.5), (height * 0.5) - ((1.0 * (segment.y + 0.5)) * segmentHeight));\n	if (timePercent > times) {\n		float percent = (timePercent - times) / 0.7;\n		if (percent > 1.0) {\n			percent = 1.0;\n		}\n		if (percent > 0.5) {\n			percent += 1.0;\n		}\n		mat4 matrix = mat4(cos((-1.0 * percent) * 3.14), 0.0, sin((-1.0 * percent) * 3.14), 0.0, 0.0, 1.0, 0.0, 0.0, -sin((-1.0 * percent) * 3.14), 0.0, cos((-1.0 * percent) * 3.14), 0.0, 0.0, 0.0, 0.0, 1.0);\n		newPosition.x -= segmentOrigin.x;\n		newPosition.y -= segmentOrigin.y;\n		newPosition = matrix * newPosition;\n		newPosition.x += segmentOrigin.x;\n		newPosition.y += segmentOrigin.y;\n		if (segment.x < (horizontalSegments / 2.0)) {\n			fakePercent = percent - (abs((horizontalSegments / 2.0) - segment.x) * (0.25 / horizontalSegments));\n		}\n		else {\n			fakePercent = percent + (abs((horizontalSegments / 2.0) - segment.x) * (0.25 / horizontalSegments));\n		}\n	}\n	if ((timePercent < 0.0001) || (timePercent > 0.9999)) {\n		gl_Position = (projectionMatrix * modelViewMatrix) * vec4(position, 1.0);\n		return ;\n	}\n	gl_Position = (projectionMatrix * modelViewMatrix) * newPosition;\n}\n";
}, function(t2, e2) {
  t2.exports = "uniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nvarying vec2 vUv;\nvarying float fakePercent;\nvoid main() {\n	vec4 srcColor = texture2D(texturePrev, vUv);\n	vec4 distColor = texture2D(textureNext, vUv);\n	vec4 color = srcColor;\n	if (fakePercent > 0.5) {\n		color = distColor;\n	}\n	if ((fakePercent < 0.5) && (fakePercent > 0.35)) {\n		color.a = 0.5;\n	}\n	gl_FragColor = color;\n}\n";
}, function(t2, e2) {
  t2.exports = "#define PI 3.14159265\nuniform float horizontalSegments;\nuniform float verticalSegments;\nuniform float timePercent;\nuniform float segmentWidth;\nuniform float segmentHeight;\nuniform float duration;\nattribute vec2 segment;\nattribute float times;\nvarying vec2 vUv;\nmat4 rotateY(float angle) {\n	return mat4(cos(angle), 0.0, sin(angle), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angle), 0.0, cos(angle), 0.0, 0.0, 0.0, 0.0, 1.0);\n}\nvoid main() {\n	vUv = uv;\n	float width = segmentWidth * horizontalSegments;\n	float height = segmentHeight * verticalSegments;\n	mat4 matrix;\n	float stagePercent;\n	vec4 newPosition = vec4(position, 1.0);\n	float selfTimePercent = (timePercent - times) / (4.0 / 5.0);\n	if (selfTimePercent < 0.0) {\n		selfTimePercent = 0.0;\n	}\n	else if (selfTimePercent > 1.0) {\n		selfTimePercent = 1.0;\n	}\n	if (selfTimePercent < (2.0 / 5.0)) {\n		stagePercent = selfTimePercent / (2.0 / 5.0);\n		newPosition.x -= (0.5 * width);\n		matrix = rotateY(((-1.0 * stagePercent) * PI) * 0.5);\n		newPosition = matrix * newPosition;\n		newPosition.x += (0.5 * width);\n	}\n	else if ((selfTimePercent >= (2.0 / 5.0)) && (selfTimePercent < (3.0 / 5.0))) {\n		stagePercent = (selfTimePercent - (2.0 / 5.0)) / (1.0 / 5.0);\n		newPosition.x -= (0.5 * width);\n		newPosition = rotateY((-1.0 * PI) * 0.5) * newPosition;\n		matrix = rotateY(((-1.0 * stagePercent) * PI) * 2.0);\n		newPosition = matrix * newPosition;\n		newPosition.x += (0.5 * width);\n		newPosition.x -= (width * stagePercent);\n	}\n	else {\n		float offset = (((newPosition.x + (0.5 * width)) / width) * 2.0) / 5.0;\n		stagePercent = (selfTimePercent - (1.0 / 5.0)) / ((2.0 / 5.0) + offset);\n		if (stagePercent > 1.0) {\n			stagePercent = 1.0;\n		}\n		vec4 vvUvv = vec4(vUv.x - 0.5, vUv.y - 0.5, 0.0, 1.0);\n		vvUvv = rotateY(-1.0 * PI) * vvUvv;\n		vUv = vvUvv.xy + 0.5;\n		newPosition.x -= (0.5 * width);\n		matrix = rotateY((((-1.0 * stagePercent) * PI) * 0.5) - (PI * 2.5));\n		newPosition = matrix * newPosition;\n		newPosition.x += (0.5 * width);\n		newPosition.x -= width;\n	}\n	if ((timePercent < 0.0001) || (timePercent > 0.9999)) {\n		vUv = uv;\n		gl_Position = (projectionMatrix * modelViewMatrix) * vec4(position, 1.0);\n		return ;\n	}\n	gl_Position = (projectionMatrix * modelViewMatrix) * newPosition;\n}\n";
}, function(t2, e2) {
  t2.exports = "uniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nvarying vec2 vUv;\nvoid main() {\n	vec4 srcColor = texture2D(texturePrev, vUv);\n	vec4 distColor = texture2D(textureNext, vUv);\n	vec4 color = srcColor;\n	if (timePercent > 0.5) {\n		color = distColor;\n	}\n	if (timePercent < 0.0001) {\n		color = srcColor;\n	}\n	else if (timePercent > 0.9999) {\n		color = distColor;\n	}\n	gl_FragColor = color;\n}\n";
}, function(t2, e2) {
  t2.exports = "#define PI 3.14159265\nattribute float index;\nattribute float type;\nattribute float delay;\nuniform float timePercent;\nuniform float segmentWidth;\nuniform float segments;\nvarying vec2 vUv;\nvarying float vType;\nvarying float rotatePercent;\nmat4 rotateY(float angle) {\n	return mat4(cos(angle), 0.0, sin(angle), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angle), 0.0, cos(angle), 0.0, 0.0, 0.0, 0.0, 1.0);\n}\nvoid main() {\n	vUv = uv;\n	vType = type;\n	vec4 newPosition = vec4(position, 1.0);\n	float selfPercent = (timePercent - delay) / 0.7;\n	rotatePercent = selfPercent;\n	if (selfPercent < 0.0) {\n		selfPercent = 0.0;\n	}\n	else if (selfPercent > 1.0) {\n		selfPercent = 1.0;\n	}\n	float offsetX = ((segments * segmentWidth) * 0.5) - ((index + 0.5) * segmentWidth);\n	float offsetZ = segmentWidth * 0.5;\n	newPosition.x += offsetX;\n	newPosition.z += offsetZ;\n	newPosition.x *= (0.9 + ((abs(timePercent - 0.5) / 0.5) * 0.1));\n	newPosition.z *= (0.9 + ((abs(timePercent - 0.5) / 0.5) * 0.1));\n	newPosition = rotateY((PI * 0.5) * selfPercent) * newPosition;\n	newPosition.x -= offsetX;\n	newPosition.z -= offsetZ;\n	gl_Position = (projectionMatrix * modelViewMatrix) * newPosition;\n}\n";
}, function(t2, e2) {
  t2.exports = "uniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nvarying vec2 vUv;\nvarying float vType;\nvarying float rotatePercent;\nmat3 yuv2rgb = mat3(1.0, 0.0, 1.13983, 1.0, -0.39465, -0.58060, 1.0, 2.03211, 0.0);\nmat3 rgb2yuv = mat3(0.2126, 0.7152, 0.0722, -0.09991, -0.33609, 0.43600, 0.615, -0.5586, -0.05639);\nvoid main() {\n	vec4 srcColor = texture2D(texturePrev, vUv);\n	vec4 distColor = texture2D(textureNext, vUv);\n	vec3 srcYuv;\n	vec3 distYuv;\n	if (rotatePercent < 0.5) {\n		distYuv = distColor.rgb * rgb2yuv;\n		distYuv.r *= (1.0 - (abs(rotatePercent - 0.5) / 0.5));\n		distColor = vec4(distYuv * yuv2rgb, distColor.a);\n	}\n	else {\n		srcYuv = distColor.rgb * rgb2yuv;\n		srcYuv.r *= (abs(rotatePercent - 0.5) / 0.5);\n		srcColor = vec4(srcYuv * yuv2rgb, srcColor.a);\n	}\n	vec4 color = vType < 0.5 ? srcColor : distColor;\n	gl_FragColor = color;\n}\n";
}, function(t2, e2) {
  t2.exports = "float easeInFloat(float t, float b, float c, float d) {\n	t = t / d;\n	return ((c * t) * t) + b;\n}\nfloat interpolationFloat(float from, float to, float start, float end, float timePercent, int timing) {\n	float pi = 3.14159265358;\n	float current;\n	float duration = 1.0;\n	if (timePercent < start) {\n		current = 0.0;\n	}\n	else if (timePercent > end) {\n		current = 1.0;\n	}\n	else {\n		current = (timePercent - start) / (end - start);\n	}\n	if (timing == 0) {\n		return ((current / duration) * (to - from)) + from;\n	}\n	else if (timing == 1) {\n		current = current / duration;\n		return (((to - from) * current) * current) + from;\n	}\n	else if (timing == 2) {\n		current = current / duration;\n		return (((-1.0 * (to - from)) * current) * (current - 2.0)) + from;\n	}\n	else {\n		current /= (duration / 2.0);\n		if (current < 1.0) {\n			return ((((to - from) / 2.0) * current) * current) + from;\n		}\n		current--;\n		return ((-(to - from) / 2.0) * ((current * (current - 2.0)) - 1.0)) + from;\n	}\n}\n#define PI 3.141592653\nuniform float horizontalSegments;\nuniform float verticalSegments;\nuniform float timePercent;\nuniform float segmentWidth;\nuniform float segmentHeight;\nattribute float isLeft;\nvarying vec2 vUv;\nvarying vec4 shadow;\nvoid main() {\n	vUv = uv;\n	float scaleX;\n	float transform;\n	float displacement;\n	vec4 newPosition = vec4(position, 1.0);\n	vec4 glPosition = (projectionMatrix * modelViewMatrix) * newPosition;\n	float crestCount = 24.0;\n	float width = horizontalSegments * segmentWidth;\n	float height = verticalSegments * segmentHeight;\n	float heightFactor = (newPosition.y + (height * 0.5)) / height;\n	float scaleY = interpolationFloat(1.0, 1.05, 0.0, 0.11, timePercent, 0);\n	newPosition.y += (height * 0.5);\n	newPosition.y *= scaleY;\n	newPosition.y -= (height * 0.5);\n	newPosition.y += 10.0;\n	if ((timePercent > 0.0) && (timePercent < 0.333)) {\n		float delay = (1.0 - heightFactor) * 0.1;\n		scaleX = interpolationFloat(1.0, 0.5, 0.0 + delay, 0.333, timePercent, 1);\n	}\n	else if ((timePercent >= 0.333) && (timePercent < 0.5)) {\n		float scaleTop = 0.5;\n		float scaleBottom = interpolationFloat(0.5, 0.25, 0.333, 0.5, timePercent, 2);\n		float incr = easeInFloat(1.0 - heightFactor, 0.0, abs(scaleBottom - scaleTop), 1.0);\n		scaleX = scaleTop - incr;\n	}\n	else if ((timePercent >= 0.5) && (timePercent < 0.583)) {\n		float scaleTop = 0.5;\n		float scaleBottom = interpolationFloat(0.25, 0.5, 0.5, 0.583, timePercent, 1);\n		float incr = easeInFloat(1.0 - heightFactor, 0.0, abs(scaleBottom - scaleTop), 1.0);\n		scaleX = scaleTop - incr;\n	}\n	else if (timePercent >= 0.583) {\n		float scaleTop = 0.5;\n		float scaleBottom = interpolationFloat(0.5, 0.75, 0.583, 0.666, timePercent, 2);\n		float incr = easeInFloat(1.0 - heightFactor, 0.0, abs(scaleBottom - scaleTop), 1.0);\n		scaleX = scaleTop + incr;\n	}\n	if (timePercent > 0.583) {\n		displacement = (isLeft < 0.5 ? 1.0 : -1.0) * interpolationFloat(0.0, width / 2.0, 0.583, 1.0, timePercent, 0);\n	}\n	float ampTop = interpolationFloat(0.0, 1.0, 0.0, 0.11, timePercent, 0);\n	float ampBottom = interpolationFloat(0.0, 1.0, 0.11, 0.22, timePercent, 0);\n	float amp = ampBottom + (heightFactor * abs(ampBottom - ampTop));\n	float foo = newPosition.x * ((crestCount * PI) / width);\n	newPosition.z = (amp * cos(foo + (PI / 2.0))) * 20.0;\n	transform = (isLeft < 0.5 ? -1.0 : 1.0) * (width * 0.5);\n	newPosition.x += transform;\n	newPosition.x *= scaleX;\n	newPosition.x -= transform;\n	newPosition.x += displacement;\n	shadow = vec4(0.0, 0.0, 0.0, 0.0);\n	if (newPosition.z < 15.0) {\n		float alpha = 0.3 * (1.0 - ((newPosition.z + 20.0) / 35.0));\n		shadow.a = alpha * amp;\n	}\n	gl_Position = (projectionMatrix * modelViewMatrix) * newPosition;\n}\n";
}, function(t2, e2) {
  t2.exports = "vec4 blendSrcOver(vec4 src, vec4 dist) {\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	src.r *= src.a;\n	src.g *= src.a;\n	src.b *= src.a;\n	result.a = src.a + (dist.a * (1.0 - src.a));\n	result.r = (src.r + (dist.r * (1.0 - src.a))) / result.a;\n	result.g = (src.g + (dist.g * (1.0 - src.a))) / result.a;\n	result.b = (src.b + (dist.b * (1.0 - src.a))) / result.a;\n	return result;\n}\nuniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nvarying vec2 vUv;\nvarying vec4 shadow;\nvoid main() {\n	vec4 srcColor = texture2D(texturePrev, vUv);\n	vec4 distColor = texture2D(textureNext, vUv);\n	vec4 color = blendSrcOver(shadow, srcColor);\n	gl_FragColor = color;\n}\n";
}, function(t2, e2) {
  t2.exports = "float interpolationFloat(float from, float to, float start, float end, float timePercent, int timing) {\n	float pi = 3.14159265358;\n	float current;\n	float duration = 1.0;\n	if (timePercent < start) {\n		current = 0.0;\n	}\n	else if (timePercent > end) {\n		current = 1.0;\n	}\n	else {\n		current = (timePercent - start) / (end - start);\n	}\n	if (timing == 0) {\n		return ((current / duration) * (to - from)) + from;\n	}\n	else if (timing == 1) {\n		current = current / duration;\n		return (((to - from) * current) * current) + from;\n	}\n	else if (timing == 2) {\n		current = current / duration;\n		return (((-1.0 * (to - from)) * current) * (current - 2.0)) + from;\n	}\n	else {\n		current /= (duration / 2.0);\n		if (current < 1.0) {\n			return ((((to - from) / 2.0) * current) * current) + from;\n		}\n		current--;\n		return ((-(to - from) / 2.0) * ((current * (current - 2.0)) - 1.0)) + from;\n	}\n}\n#define PI 3.14159265\nuniform float timePercent;\nuniform float aCoefficient;\nuniform float zCurveLimit;\nuniform float horizontalSegments;\nuniform float verticalSegments;\nuniform float segmentWidth;\nuniform float segmentHeight;\nvarying vec2 vUv;\nvoid main() {\n	float halfWidth = (segmentWidth * horizontalSegments) * 0.5;\n	float halfHeight = (segmentHeight * verticalSegments) * 0.5;\n	vUv = uv;\n	vec4 newPosition = vec4(position, 1.0);\n	float curve;\n	float aStart = interpolationFloat(0.00000009, aCoefficient, 0.0, 0.5, timePercent, 0);\n	float aEnd = 0.0000009;\n	float zStart = interpolationFloat(0.0, zCurveLimit, 0.0, 0.5, timePercent, 0);\n	float zEnd = 0.0;\n	float a = interpolationFloat(aStart, aEnd, 0.0, halfWidth * 2.0, newPosition.x + halfWidth, 0);\n	float z = interpolationFloat(zStart, zEnd, 0.0, halfWidth * 2.0, newPosition.x + halfWidth, 0);\n	newPosition.z -= (((-a * newPosition.y) * newPosition.y) + z);\n	float scaleYStart = interpolationFloat(1.0, 0.8, 0.0, 0.5, timePercent, 0);\n	float scaleYEnd = 1.0;\n	float scaleY = interpolationFloat(scaleYStart, scaleYEnd, 0.0, halfWidth * 2.0, newPosition.x + halfWidth, 0);\n	newPosition.y += halfHeight;\n	newPosition.y *= scaleY;\n	float angle = interpolationFloat(0.0, -((2.0 * PI) / 3.0), 0.111, 1.0, timePercent, 1);\n	mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angle), sin(angle), 0.0, 0.0, -sin(angle), cos(angle), 0.0, 0.0, 0.0, 0.0, 1.0);\n	newPosition = rotateX * newPosition;\n	newPosition.y -= halfHeight;\n	gl_Position = (projectionMatrix * modelViewMatrix) * newPosition;\n}\n";
}, function(t2, e2) {
  t2.exports = "float interpolationFloat(float from, float to, float start, float end, float timePercent, int timing) {\n	float pi = 3.14159265358;\n	float current;\n	float duration = 1.0;\n	if (timePercent < start) {\n		current = 0.0;\n	}\n	else if (timePercent > end) {\n		current = 1.0;\n	}\n	else {\n		current = (timePercent - start) / (end - start);\n	}\n	if (timing == 0) {\n		return ((current / duration) * (to - from)) + from;\n	}\n	else if (timing == 1) {\n		current = current / duration;\n		return (((to - from) * current) * current) + from;\n	}\n	else if (timing == 2) {\n		current = current / duration;\n		return (((-1.0 * (to - from)) * current) * (current - 2.0)) + from;\n	}\n	else {\n		current /= (duration / 2.0);\n		if (current < 1.0) {\n			return ((((to - from) / 2.0) * current) * current) + from;\n		}\n		current--;\n		return ((-(to - from) / 2.0) * ((current * (current - 2.0)) - 1.0)) + from;\n	}\n}\nvec4 blendSrcOver(vec4 src, vec4 dist) {\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	src.r *= src.a;\n	src.g *= src.a;\n	src.b *= src.a;\n	result.a = src.a + (dist.a * (1.0 - src.a));\n	result.r = (src.r + (dist.r * (1.0 - src.a))) / result.a;\n	result.g = (src.g + (dist.g * (1.0 - src.a))) / result.a;\n	result.b = (src.b + (dist.b * (1.0 - src.a))) / result.a;\n	return result;\n}\nuniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nvarying vec2 vUv;\nvoid main() {\n	vec4 srcColor = texture2D(texturePrev, vUv);\n	vec4 distColor = texture2D(textureNext, vUv);\n	float alpha = interpolationFloat(0.0, 0.6, 0.5, 1.0, timePercent, 0);\n	vec4 shadow = vec4(0.0, 0.0, 0.0, alpha);\n	gl_FragColor = blendSrcOver(shadow, srcColor);\n}\n";
}, function(t2, e2) {
  t2.exports = "float interpolationFloat(float from, float to, float start, float end, float timePercent, int timing) {\n	float pi = 3.14159265358;\n	float current;\n	float duration = 1.0;\n	if (timePercent < start) {\n		current = 0.0;\n	}\n	else if (timePercent > end) {\n		current = 1.0;\n	}\n	else {\n		current = (timePercent - start) / (end - start);\n	}\n	if (timing == 0) {\n		return ((current / duration) * (to - from)) + from;\n	}\n	else if (timing == 1) {\n		current = current / duration;\n		return (((to - from) * current) * current) + from;\n	}\n	else if (timing == 2) {\n		current = current / duration;\n		return (((-1.0 * (to - from)) * current) * (current - 2.0)) + from;\n	}\n	else {\n		current /= (duration / 2.0);\n		if (current < 1.0) {\n			return ((((to - from) / 2.0) * current) * current) + from;\n		}\n		current--;\n		return ((-(to - from) / 2.0) * ((current * (current - 2.0)) - 1.0)) + from;\n	}\n}\n#define PI 3.14159265358\nuniform float timePercent;\nuniform float horizontalSegments;\nuniform float verticalSegments;\nuniform float segmentWidth;\nuniform float segmentHeight;\nvarying vec2 vUv;\nvarying float shadowAlpha;\nmat2 rotateOrigin(float angle) {\n	return mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n}\nvoid main() {\n	float halfWidth = (segmentWidth * horizontalSegments) * 0.5;\n	float halfHeight = (segmentHeight * verticalSegments) * 0.5;\n	vUv = uv;\n	vec2 shadowPosition = vec2(position.xy);\n	float rotateAngle = PI * 0.27;\n	float min_r = halfWidth * 0.05;\n	shadowPosition = rotateOrigin(rotateAngle) * shadowPosition;\n	vec4 newPosition = vec4(shadowPosition.xy, position.z, 1.0);\n	float line = interpolationFloat(0.0, halfWidth * 2.8, 0.0, 1.0, timePercent, 1);\n	float dis2BaseLine = halfWidth - newPosition.x;\n	float dis2Line = line - dis2BaseLine;\n	float L = line <= (halfWidth * 2.0) ? line : halfWidth * 2.0;\n	float r = L / PI;\n	r = r < min_r ? min_r : r;\n	float angle = dis2Line / r;\n	if (((dis2Line > 0.0) && (dis2Line < (line * 0.5))) && (r > min_r)) {\n		shadowAlpha = interpolationFloat(0.0, 0.3, 0.0, line * 0.5, dis2Line, 0);\n	}\n	else {\n		shadowAlpha = 0.0;\n	}\n	if (dis2BaseLine < line) {\n		newPosition.x = ((sin(angle) * r) + halfWidth) - line;\n		newPosition.z = (r - (cos(angle) * r)) * 0.5;\n	}\n	vec2 finalPosition = vec2(newPosition.xy);\n	finalPosition = rotateOrigin(-rotateAngle) * finalPosition;\n	gl_Position = (projectionMatrix * modelViewMatrix) * vec4(finalPosition.xy, newPosition.z, 1.0);\n}\n";
}, function(t2, e2) {
  t2.exports = "vec4 blendSrcOver(vec4 src, vec4 dist) {\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	src.r *= src.a;\n	src.g *= src.a;\n	src.b *= src.a;\n	result.a = src.a + (dist.a * (1.0 - src.a));\n	result.r = (src.r + (dist.r * (1.0 - src.a))) / result.a;\n	result.g = (src.g + (dist.g * (1.0 - src.a))) / result.a;\n	result.b = (src.b + (dist.b * (1.0 - src.a))) / result.a;\n	return result;\n}\nuniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nvarying vec2 vUv;\nvarying float shadowAlpha;\nvoid main() {\n	vec4 srcColor = texture2D(texturePrev, vUv);\n	vec4 distColor = texture2D(textureNext, vUv);\n	vec4 shadow = vec4(0.0, 0.0, 0.0, shadowAlpha);\n	gl_FragColor = blendSrcOver(shadow, srcColor);\n}\n";
}, function(t2, e2) {
  t2.exports = "float interpolationFloat(float from, float to, float start, float end, float timePercent, int timing) {\n	float pi = 3.14159265358;\n	float current;\n	float duration = 1.0;\n	if (timePercent < start) {\n		current = 0.0;\n	}\n	else if (timePercent > end) {\n		current = 1.0;\n	}\n	else {\n		current = (timePercent - start) / (end - start);\n	}\n	if (timing == 0) {\n		return ((current / duration) * (to - from)) + from;\n	}\n	else if (timing == 1) {\n		current = current / duration;\n		return (((to - from) * current) * current) + from;\n	}\n	else if (timing == 2) {\n		current = current / duration;\n		return (((-1.0 * (to - from)) * current) * (current - 2.0)) + from;\n	}\n	else {\n		current /= (duration / 2.0);\n		if (current < 1.0) {\n			return ((((to - from) / 2.0) * current) * current) + from;\n		}\n		current--;\n		return ((-(to - from) / 2.0) * ((current * (current - 2.0)) - 1.0)) + from;\n	}\n}\n#define PI 3.14159265358\nuniform float timePercent;\nuniform float horizontalSegments;\nuniform float verticalSegments;\nuniform float segmentWidth;\nuniform float segmentHeight;\nvarying vec2 vUv;\nmat4 rotateX(float angle) {\n	return mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angle), sin(angle), 0.0, 0.0, -sin(angle), cos(angle), 0.0, 0.0, 0.0, 0.0, 1.0);\n}\nvoid main() {\n	float halfWidth = (segmentWidth * horizontalSegments) * 0.5;\n	float halfHeight = (segmentHeight * verticalSegments) * 0.5;\n	vUv = uv;\n	vec4 newPosition = vec4(position, 1.0);\n	float delay = interpolationFloat(0.0, 0.08, 0.0, halfWidth * 2.0, halfWidth + newPosition.x, 0);\n	float arc = halfHeight - newPosition.y;\n	float L;\n	if (timePercent < 0.8) {\n		L = interpolationFloat(halfHeight * 4.0, halfHeight * 22.0, 0.3 + delay, 0.8, timePercent, 0);\n	}\n	else {\n		L = interpolationFloat(halfHeight * 22.0, halfHeight * 300.0, 0.8, 1.0, timePercent, 0);\n	}\n	float r = L / (2.0 * PI);\n	float angle = PI - (arc / r);\n	float y = sin(angle) * r;\n	float z = cos(angle) * r;\n	newPosition.y = halfHeight - y;\n	newPosition.z = (z + r) * 0.45;\n	float rotateAngle = interpolationFloat(-PI * 0.5, 0.0, 0.0 + delay, 0.4, timePercent, 0);\n	newPosition.y -= halfHeight;\n	newPosition = rotateX(rotateAngle) * newPosition;\n	newPosition.y += halfHeight;\n	float backRotate1 = interpolationFloat(0.0, PI * 0.03, 0.75, 0.9, timePercent, 0);\n	newPosition.y -= halfHeight;\n	newPosition = rotateX(backRotate1) * newPosition;\n	newPosition.y += halfHeight;\n	float backRotate2 = interpolationFloat(0.0, -PI * 0.03, 0.8, 1.0, timePercent, 0);\n	newPosition.y -= halfHeight;\n	newPosition = rotateX(backRotate2) * newPosition;\n	newPosition.y += halfHeight;\n	gl_Position = (projectionMatrix * modelViewMatrix) * newPosition;\n}\n";
}, function(t2, e2) {
  t2.exports = "float interpolationFloat(float from, float to, float start, float end, float timePercent, int timing) {\n	float pi = 3.14159265358;\n	float current;\n	float duration = 1.0;\n	if (timePercent < start) {\n		current = 0.0;\n	}\n	else if (timePercent > end) {\n		current = 1.0;\n	}\n	else {\n		current = (timePercent - start) / (end - start);\n	}\n	if (timing == 0) {\n		return ((current / duration) * (to - from)) + from;\n	}\n	else if (timing == 1) {\n		current = current / duration;\n		return (((to - from) * current) * current) + from;\n	}\n	else if (timing == 2) {\n		current = current / duration;\n		return (((-1.0 * (to - from)) * current) * (current - 2.0)) + from;\n	}\n	else {\n		current /= (duration / 2.0);\n		if (current < 1.0) {\n			return ((((to - from) / 2.0) * current) * current) + from;\n		}\n		current--;\n		return ((-(to - from) / 2.0) * ((current * (current - 2.0)) - 1.0)) + from;\n	}\n}\nvec4 blendSrcOver(vec4 src, vec4 dist) {\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	src.r *= src.a;\n	src.g *= src.a;\n	src.b *= src.a;\n	result.a = src.a + (dist.a * (1.0 - src.a));\n	result.r = (src.r + (dist.r * (1.0 - src.a))) / result.a;\n	result.g = (src.g + (dist.g * (1.0 - src.a))) / result.a;\n	result.b = (src.b + (dist.b * (1.0 - src.a))) / result.a;\n	return result;\n}\nuniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nvarying vec2 vUv;\nvoid main() {\n	vec4 srcColor = texture2D(texturePrev, vUv);\n	vec4 distColor = texture2D(textureNext, vUv);\n	float alpha = interpolationFloat(0.0, 0.6, 0.5, 1.0, timePercent, 0);\n	vec4 shadow = vec4(0.0, 0.0, 0.0, 0.0);\n	gl_FragColor = blendSrcOver(shadow, distColor);\n}\n";
}, function(t2, e2) {
  t2.exports = "vec4 blendSrcOver(vec4 src, vec4 dist) {\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	src.r *= src.a;\n	src.g *= src.a;\n	src.b *= src.a;\n	result.a = src.a + (dist.a * (1.0 - src.a));\n	result.r = (src.r + (dist.r * (1.0 - src.a))) / result.a;\n	result.g = (src.g + (dist.g * (1.0 - src.a))) / result.a;\n	result.b = (src.b + (dist.b * (1.0 - src.a))) / result.a;\n	return result;\n}\nfloat interpolationFloat(float from, float to, float start, float end, float timePercent, int timing) {\n	float pi = 3.14159265358;\n	float current;\n	float duration = 1.0;\n	if (timePercent < start) {\n		current = 0.0;\n	}\n	else if (timePercent > end) {\n		current = 1.0;\n	}\n	else {\n		current = (timePercent - start) / (end - start);\n	}\n	if (timing == 0) {\n		return ((current / duration) * (to - from)) + from;\n	}\n	else if (timing == 1) {\n		current = current / duration;\n		return (((to - from) * current) * current) + from;\n	}\n	else if (timing == 2) {\n		current = current / duration;\n		return (((-1.0 * (to - from)) * current) * (current - 2.0)) + from;\n	}\n	else {\n		current /= (duration / 2.0);\n		if (current < 1.0) {\n			return ((((to - from) / 2.0) * current) * current) + from;\n		}\n		current--;\n		return ((-(to - from) / 2.0) * ((current * (current - 2.0)) - 1.0)) + from;\n	}\n}\n#define PI 3.14159265358\nuniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nuniform float width;\nuniform float height;\nvarying vec2 vUv;\nvec2 transform(vec2 uv) {\n	uv.y = (uv.y * height) / width;\n	return uv - vec2(0.5, (0.5 * height) / width);\n}\nvoid main() {\n	vec4 srcColor = texture2D(texturePrev, vUv);\n	vec4 distColor = texture2D(textureNext, vUv);\n	float shadowAngle = PI / 6.0;\n	float clockAngle;\n	vec2 a;\n	vec2 b = transform(vUv);\n	float angle;\n	if (timePercent < 0.5) {\n		a = vec2(0.0, 0.5);\n		clockAngle = interpolationFloat(0.0, PI, 0.0, 0.5, timePercent, 0);\n		if (b.x > 0.0) {\n			angle = acos(((a.x * b.x) + (a.y * b.y)) / (sqrt((a.x * a.x) + (a.y * a.y)) * sqrt((b.x * b.x) + (b.y * b.y))));\n			if (angle < clockAngle) {\n				if (angle > (clockAngle - shadowAngle)) {\n					float shadowAlpha = interpolationFloat(1.0, 0.0, 0.0, 1.0, abs(clockAngle - angle) / shadowAngle, 0);\n					srcColor.a = shadowAlpha;\n				}\n				else {\n					srcColor.a = 0.0;\n				}\n			}\n		}\n		else {\n			srcColor.a = 1.0;\n		}\n	}\n	else {\n		a = vec2(0.0, -0.5);\n		clockAngle = interpolationFloat(0.0, PI + shadowAngle, 0.5, 1.0, timePercent, 0);\n		if (b.x <= 0.0) {\n			angle = acos(((a.x * b.x) + (a.y * b.y)) / (sqrt((a.x * a.x) + (a.y * a.y)) * sqrt((b.x * b.x) + (b.y * b.y))));\n			if (angle < clockAngle) {\n				if (angle > (clockAngle - shadowAngle)) {\n					float shadowAlpha = interpolationFloat(1.0, 0.0, 0.0, 1.0, abs(clockAngle - angle) / shadowAngle, 0);\n					srcColor.a = shadowAlpha;\n				}\n				else {\n					srcColor.a = 0.0;\n				}\n			}\n		}\n		else {\n			srcColor.a = 0.0;\n		}\n	}\n	gl_FragColor = blendSrcOver(srcColor, distColor);\n}\n";
}, function(t2, e2) {
  t2.exports = "float interpolationFloat(float from, float to, float start, float end, float timePercent, int timing) {\n	float pi = 3.14159265358;\n	float current;\n	float duration = 1.0;\n	if (timePercent < start) {\n		current = 0.0;\n	}\n	else if (timePercent > end) {\n		current = 1.0;\n	}\n	else {\n		current = (timePercent - start) / (end - start);\n	}\n	if (timing == 0) {\n		return ((current / duration) * (to - from)) + from;\n	}\n	else if (timing == 1) {\n		current = current / duration;\n		return (((to - from) * current) * current) + from;\n	}\n	else if (timing == 2) {\n		current = current / duration;\n		return (((-1.0 * (to - from)) * current) * (current - 2.0)) + from;\n	}\n	else {\n		current /= (duration / 2.0);\n		if (current < 1.0) {\n			return ((((to - from) / 2.0) * current) * current) + from;\n		}\n		current--;\n		return ((-(to - from) / 2.0) * ((current * (current - 2.0)) - 1.0)) + from;\n	}\n}\n#define PI 3.14159265358\nuniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nuniform float width;\nuniform float height;\nvarying vec2 vUv;\nvoid main() {\n	vec2 uv = vUv;\n	bool useSrc = false;\n	vec2 row;\n	float delay = 0.02;\n	for (int i = 0; i < 7; i++) {\n		float fi = float(i);\n		row.r = (fi * 1.0) / 7.0;\n		row.g = (float(i + 1) * 1.0) / 7.0;\n		if ((vUv.y <= row.g) && (vUv.y > row.r)) {\n			if ((i % 2) == 0) {\n				float x = interpolationFloat(0.0, 1.0, delay * fi, (delay * fi) + 0.86, timePercent, 1);\n				if (vUv.x < x) {\n					useSrc = false;\n				}\n				else {\n					uv.x -= x;\n					useSrc = true;\n				}\n			}\n			else {\n				float x = interpolationFloat(1.0, 0.0, delay * fi, (delay * fi) + 0.86, timePercent, 1);\n				if (vUv.x < x) {\n					uv.x = (1.0 - x) + uv.x;\n					useSrc = true;\n				}\n				else {\n					useSrc = false;\n				}\n			}\n			break;\n		}\n	}\n	vec4 srcColor = texture2D(texturePrev, uv);\n	vec4 distColor = texture2D(textureNext, uv);\n	gl_FragColor = useSrc ? srcColor : distColor;\n}\n";
}, function(t2, e2) {
  t2.exports = "vec4 blendSrcOver(vec4 src, vec4 dist) {\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	src.r *= src.a;\n	src.g *= src.a;\n	src.b *= src.a;\n	result.a = src.a + (dist.a * (1.0 - src.a));\n	result.r = (src.r + (dist.r * (1.0 - src.a))) / result.a;\n	result.g = (src.g + (dist.g * (1.0 - src.a))) / result.a;\n	result.b = (src.b + (dist.b * (1.0 - src.a))) / result.a;\n	return result;\n}\nfloat interpolationFloat(float from, float to, float start, float end, float timePercent, int timing) {\n	float pi = 3.14159265358;\n	float current;\n	float duration = 1.0;\n	if (timePercent < start) {\n		current = 0.0;\n	}\n	else if (timePercent > end) {\n		current = 1.0;\n	}\n	else {\n		current = (timePercent - start) / (end - start);\n	}\n	if (timing == 0) {\n		return ((current / duration) * (to - from)) + from;\n	}\n	else if (timing == 1) {\n		current = current / duration;\n		return (((to - from) * current) * current) + from;\n	}\n	else if (timing == 2) {\n		current = current / duration;\n		return (((-1.0 * (to - from)) * current) * (current - 2.0)) + from;\n	}\n	else {\n		current /= (duration / 2.0);\n		if (current < 1.0) {\n			return ((((to - from) / 2.0) * current) * current) + from;\n		}\n		current--;\n		return ((-(to - from) / 2.0) * ((current * (current - 2.0)) - 1.0)) + from;\n	}\n}\n#define PI 3.14159265358\nuniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nuniform float width;\nuniform float height;\nvarying vec2 vUv;\nvoid main() {\n	vec2 uvSrc = vUv;\n	vec2 uvDist = vUv;\n	float scaleSrc = interpolationFloat(1.0, 0.1, 0.0, 1.0, timePercent, 0);\n	float scaleDist = interpolationFloat(2.0, 1.0, 0.0, 1.0, timePercent, 0);\n	uvSrc -= 0.5;\n	uvSrc *= scaleSrc;\n	uvSrc += 0.5;\n	uvDist -= 0.5;\n	uvDist *= scaleDist;\n	uvDist += 0.5;\n	vec4 srcColor = texture2D(texturePrev, uvSrc);\n	srcColor.a = interpolationFloat(1.0, 0.0, 0.0, 1.0, timePercent, 0);\n	vec4 distColor;\n	if ((((uvDist.x > 1.0) || (uvDist.x < 0.0)) || (uvDist.y > 1.0)) || (uvDist.y < 0.0)) {\n		distColor = vec4(0.0, 0.0, 0.0, 1.0);\n	}\n	else {\n		distColor = texture2D(textureNext, uvDist);\n	}\n	gl_FragColor = blendSrcOver(srcColor, distColor);\n}\n";
}, function(t2, e2) {
  t2.exports = "float interpolationFloat(float from, float to, float start, float end, float timePercent, int timing) {\n	float pi = 3.14159265358;\n	float current;\n	float duration = 1.0;\n	if (timePercent < start) {\n		current = 0.0;\n	}\n	else if (timePercent > end) {\n		current = 1.0;\n	}\n	else {\n		current = (timePercent - start) / (end - start);\n	}\n	if (timing == 0) {\n		return ((current / duration) * (to - from)) + from;\n	}\n	else if (timing == 1) {\n		current = current / duration;\n		return (((to - from) * current) * current) + from;\n	}\n	else if (timing == 2) {\n		current = current / duration;\n		return (((-1.0 * (to - from)) * current) * (current - 2.0)) + from;\n	}\n	else {\n		current /= (duration / 2.0);\n		if (current < 1.0) {\n			return ((((to - from) / 2.0) * current) * current) + from;\n		}\n		current--;\n		return ((-(to - from) / 2.0) * ((current * (current - 2.0)) - 1.0)) + from;\n	}\n}\n#define PI 3.14159265358\nuniform float timePercent;\nuniform float horizontalSegments;\nuniform float verticalSegments;\nuniform float segmentWidth;\nuniform float segmentHeight;\nvarying vec2 vUv;\nmat4 rotateY(float angle) {\n	return mat4(cos(angle), 0.0, sin(angle), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angle), 0.0, cos(angle), 0.0, 0.0, 0.0, 0.0, 1.0);\n}\nvoid main() {\n	float halfWidth = (segmentWidth * horizontalSegments) * 0.5;\n	float halfHeight = (segmentHeight * verticalSegments) * 0.5;\n	vUv = uv;\n	vec4 newPosition = vec4(position, 1.0);\n	float stageOneAngle = PI / 14.0;\n	float stageTwoAngle = (PI * 12.0) / 14.0;\n	float stage_1 = 0.1;\n	float stage_2 = 0.8;\n	if (timePercent < 0.5) {\n		newPosition.z = interpolationFloat(0.0, -100.0, 0.0, 0.5, timePercent, 0);\n	}\n	else {\n		newPosition.z = interpolationFloat(-100.0, 0.0, 0.5, 1.0, timePercent, 0);\n	}\n	if (timePercent < stage_1) {\n		float angle = interpolationFloat(0.0, stageOneAngle, 0.0, stage_1, timePercent, 0);\n		newPosition.x += halfWidth;\n		newPosition *= rotateY(angle);\n		newPosition.x -= halfWidth;\n	}\n	else if ((timePercent >= stage_1) && (timePercent < stage_2)) {\n		if (timePercent > 0.5) {\n			newPosition *= rotateY(PI);\n		}\n		float offset = halfWidth - (sin((PI * 0.5) - stageOneAngle) * halfWidth);\n		float angle = interpolationFloat(0.0, stageTwoAngle, stage_1, stage_2, timePercent, 0);\n		newPosition *= rotateY(angle);\n		newPosition.x += halfWidth;\n		newPosition *= rotateY(stageOneAngle);\n		newPosition.x -= halfWidth;\n		newPosition.x += interpolationFloat(0.0, 2.0 * offset, stage_1, stage_2, timePercent, 0);\n	}\n	else {\n		float angle = interpolationFloat(-stageOneAngle, 0.0, stage_2, 1.0, timePercent, 0);\n		newPosition.x -= halfWidth;\n		newPosition *= rotateY(angle);\n		newPosition.x += halfWidth;\n	}\n	gl_Position = (projectionMatrix * modelViewMatrix) * newPosition;\n}\n";
}, function(t2, e2) {
  t2.exports = "uniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nvarying vec2 vUv;\nvoid main() {\n	vec4 srcColor = texture2D(texturePrev, vUv);\n	vec4 distColor = texture2D(textureNext, vUv);\n	gl_FragColor = timePercent < 0.5 ? srcColor : distColor;\n}\n";
}, function(t2, e2, n) {
  (function(t3) {
    var i = n(45), r2 = n(46), o2 = setTimeout, s2 = t3 !== void 0 ? t3 : null;
    function a(t4) {
      return Boolean(t4 && t4.length !== void 0);
    }
    function l() {
    }
    function u(t4) {
      if (!(this instanceof u))
        throw new TypeError("Promises must be constructed via new");
      if (typeof t4 != "function")
        throw new TypeError("not a function");
      this._state = 0, this._handled = false, this._value = void 0, this._deferreds = [], m(t4, this);
    }
    function h(t4, e3) {
      for (; t4._state === 3; )
        t4 = t4._value;
      t4._state !== 0 ? (t4._handled = true, u._immediateFn(function() {
        var n2 = t4._state === 1 ? e3.onFulfilled : e3.onRejected;
        if (n2 !== null) {
          var i2;
          try {
            i2 = n2(t4._value);
          } catch (t5) {
            return void d(e3.promise, t5);
          }
          c(e3.promise, i2);
        } else
          (t4._state === 1 ? c : d)(e3.promise, t4._value);
      })) : t4._deferreds.push(e3);
    }
    function c(t4, e3) {
      try {
        if (e3 === t4)
          throw new TypeError("A promise cannot be resolved with itself.");
        if (e3 && (typeof e3 == "object" || typeof e3 == "function")) {
          var n2 = e3.then;
          if (e3 instanceof u)
            return t4._state = 3, t4._value = e3, void p(t4);
          if (typeof n2 == "function")
            return void m((i2 = n2, r3 = e3, function() {
              i2.apply(r3, arguments);
            }), t4);
        }
        t4._state = 1, t4._value = e3, p(t4);
      } catch (e4) {
        d(t4, e4);
      }
      var i2, r3;
    }
    function d(t4, e3) {
      t4._state = 2, t4._value = e3, p(t4);
    }
    function p(t4) {
      t4._state === 2 && t4._deferreds.length === 0 && u._immediateFn(function() {
        t4._handled || u._unhandledRejectionFn(t4._value);
      });
      for (var e3 = 0, n2 = t4._deferreds.length; e3 < n2; e3++)
        h(t4, t4._deferreds[e3]);
      t4._deferreds = null;
    }
    function f(t4, e3, n2) {
      this.onFulfilled = typeof t4 == "function" ? t4 : null, this.onRejected = typeof e3 == "function" ? e3 : null, this.promise = n2;
    }
    function m(t4, e3) {
      var n2 = false;
      try {
        t4(function(t5) {
          n2 || (n2 = true, c(e3, t5));
        }, function(t5) {
          n2 || (n2 = true, d(e3, t5));
        });
      } catch (t5) {
        if (n2)
          return;
        n2 = true, d(e3, t5);
      }
    }
    u.prototype.catch = function(t4) {
      return this.then(null, t4);
    }, u.prototype.then = function(t4, e3) {
      var n2 = new this.constructor(l);
      return h(this, new f(t4, e3, n2)), n2;
    }, u.prototype.finally = i.a, u.all = function(t4) {
      return new u(function(e3, n2) {
        if (!a(t4))
          return n2(new TypeError("Promise.all accepts an array"));
        var i2 = Array.prototype.slice.call(t4);
        if (i2.length === 0)
          return e3([]);
        var r3 = i2.length;
        function o3(t5, s4) {
          try {
            if (s4 && (typeof s4 == "object" || typeof s4 == "function")) {
              var a2 = s4.then;
              if (typeof a2 == "function")
                return void a2.call(s4, function(e4) {
                  o3(t5, e4);
                }, n2);
            }
            i2[t5] = s4, --r3 == 0 && e3(i2);
          } catch (t6) {
            n2(t6);
          }
        }
        for (var s3 = 0; s3 < i2.length; s3++)
          o3(s3, i2[s3]);
      });
    }, u.allSettled = r2.a, u.resolve = function(t4) {
      return t4 && typeof t4 == "object" && t4.constructor === u ? t4 : new u(function(e3) {
        e3(t4);
      });
    }, u.reject = function(t4) {
      return new u(function(e3, n2) {
        n2(t4);
      });
    }, u.race = function(t4) {
      return new u(function(e3, n2) {
        if (!a(t4))
          return n2(new TypeError("Promise.race accepts an array"));
        for (var i2 = 0, r3 = t4.length; i2 < r3; i2++)
          u.resolve(t4[i2]).then(e3, n2);
      });
    }, u._immediateFn = typeof s2 == "function" && function(t4) {
      s2(t4);
    } || function(t4) {
      o2(t4, 0);
    }, u._unhandledRejectionFn = function(t4) {
      typeof console != "undefined" && console && console.warn("Possible Unhandled Promise Rejection:", t4);
    }, e2.a = u;
  }).call(this, n(55).setImmediate);
}, function(t2, e2, n) {
  e2.a = function(t3) {
    var e3 = this.constructor;
    return this.then(function(n2) {
      return e3.resolve(t3()).then(function() {
        return n2;
      });
    }, function(n2) {
      return e3.resolve(t3()).then(function() {
        return e3.reject(n2);
      });
    });
  };
}, function(t2, e2, n) {
  e2.a = function(t3) {
    return new this(function(e3, n2) {
      if (!t3 || t3.length === void 0)
        return n2(new TypeError(typeof t3 + " " + t3 + " is not iterable(cannot read property Symbol(Symbol.iterator))"));
      var i = Array.prototype.slice.call(t3);
      if (i.length === 0)
        return e3([]);
      var r2 = i.length;
      function o2(t4, n3) {
        if (n3 && (typeof n3 == "object" || typeof n3 == "function")) {
          var s3 = n3.then;
          if (typeof s3 == "function")
            return void s3.call(n3, function(e4) {
              o2(t4, e4);
            }, function(n4) {
              i[t4] = { status: "rejected", reason: n4 }, --r2 == 0 && e3(i);
            });
        }
        i[t4] = { status: "fulfilled", value: n3 }, --r2 == 0 && e3(i);
      }
      for (var s2 = 0; s2 < i.length; s2++)
        o2(s2, i[s2]);
    });
  };
}, function(t2, e2, n) {
  /*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  */
  var i = Object.getOwnPropertySymbols, r2 = Object.prototype.hasOwnProperty, o2 = Object.prototype.propertyIsEnumerable;
  function s2(t3) {
    if (t3 == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(t3);
  }
  t2.exports = function() {
    try {
      if (!Object.assign)
        return false;
      var t3 = new String("abc");
      if (t3[5] = "de", Object.getOwnPropertyNames(t3)[0] === "5")
        return false;
      for (var e3 = {}, n2 = 0; n2 < 10; n2++)
        e3["_" + String.fromCharCode(n2)] = n2;
      if (Object.getOwnPropertyNames(e3).map(function(t4) {
        return e3[t4];
      }).join("") !== "0123456789")
        return false;
      var i2 = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(t4) {
        i2[t4] = t4;
      }), Object.keys(Object.assign({}, i2)).join("") === "abcdefghijklmnopqrst";
    } catch (t4) {
      return false;
    }
  }() ? Object.assign : function(t3, e3) {
    for (var n2, a, l = s2(t3), u = 1; u < arguments.length; u++) {
      for (var h in n2 = Object(arguments[u]))
        r2.call(n2, h) && (l[h] = n2[h]);
      if (i) {
        a = i(n2);
        for (var c = 0; c < a.length; c++)
          o2.call(n2, a[c]) && (l[a[c]] = n2[a[c]]);
      }
    }
    return l;
  };
}, function(t2, e2) {
  t2.exports = "precision mediump float;\nattribute vec2 aVertexPosition;\nuniform mat3 projectionMatrix;\nvarying vec2 vTextureCoord;\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\nvec4 filterVertexPosition() {\n	vec2 position = (aVertexPosition * max(outputFrame.zw, vec2(0.))) + outputFrame.xy;\n	return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\nvec2 filterTextureCoord() {\n	return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\nvoid main() {\n	gl_Position = filterVertexPosition();\n	vTextureCoord = filterTextureCoord();\n}\n";
}, function(t2, e2) {
  t2.exports = "precision mediump float;\n#define KERNEL 7\nvarying vec2 vTextureCoord;\nuniform vec4 uShapeFilterArea;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\nuniform vec4 inputSize;\nuniform float uStartAlpha;\nuniform float uEndAlpha;\nuniform int uBlur;\nvoid main() {\n	float halfHeight = uShapeFilterArea.w / 2.0;\n	vec2 cod = vTextureCoord * inputSize.xy;\n	if (cod.y < halfHeight) {\n		gl_FragColor = texture2D(uSampler, vTextureCoord);\n	}\n	else {\n		float alpha = uStartAlpha - (((cod.y - halfHeight) / halfHeight) * (uStartAlpha - uEndAlpha));\n		vec2 cord = vec2(vTextureCoord.x, (uShapeFilterArea.w - cod.y) / inputSize.y);\n		vec4 outputColor = texture2D(uSampler, cord);\n		outputColor *= alpha;\n		gl_FragColor = outputColor;\n	}\n}\n";
}, function(t2, e2) {
  t2.exports = "varying vec2 vTextureCoord;\nvarying vec2 vVertexPosition;\nvarying float vPercent;\nvarying float vDirection;\nvarying float vTransition;\nuniform sampler2D uSampler;\nvoid main() {\n	vec4 outputColor;\n	float percent = vPercent;\n	float direction = vDirection;\n	if (vTransition < 0.0) {\n		percent = 1.0 - percent;\n		if ((vDirection > 1.5) && (vDirection < 2.5)) {\n			direction = 1.0;\n		}\n		else if ((vDirection > 0.5) && (vDirection < 1.5)) {\n			direction = 2.0;\n		}\n		else if ((vDirection > 2.5) && (vDirection < 3.5)) {\n			direction = 4.0;\n		}\n		else {\n			direction = 3.0;\n		}\n	}\n	if ((direction > 1.5) && (direction < 2.5)) {\n		if (vVertexPosition.y >= (1.0 - percent)) {\n			outputColor = texture2D(uSampler, vTextureCoord);\n		}\n		else {\n			outputColor = vec4(0.0, 0.0, 0.0, 0.0);\n		}\n		if ((vVertexPosition.y >= (1.0 - percent)) && (vVertexPosition.y <= ((1.0 - percent) + 0.2))) {\n			outputColor = outputColor * ((vVertexPosition.y - (1.0 - percent)) / 0.2);\n		}\n	}\n	else if ((direction > 0.5) && (direction < 1.5)) {\n		if (vVertexPosition.y <= percent) {\n			outputColor = texture2D(uSampler, vTextureCoord);\n		}\n		else {\n			outputColor = vec4(0.0, 0.0, 0.0, 0.0);\n		}\n		if ((vVertexPosition.y <= percent) && (vVertexPosition.y >= (percent - 0.2))) {\n			outputColor = outputColor * (1.0 - ((vVertexPosition.y - (percent - 0.2)) / 0.2));\n		}\n	}\n	else if ((direction > 2.5) && (direction < 3.5)) {\n		if (vVertexPosition.x <= percent) {\n			outputColor = texture2D(uSampler, vTextureCoord);\n		}\n		else {\n			outputColor = vec4(0.0, 0.0, 0.0, 0.0);\n		}\n		if ((vVertexPosition.x <= percent) && (vVertexPosition.x >= (percent - 0.2))) {\n			outputColor = outputColor * (1.0 - ((vVertexPosition.x - (percent - 0.2)) / 0.2));\n		}\n	}\n	else {\n		if (vVertexPosition.x >= (1.0 - percent)) {\n			outputColor = texture2D(uSampler, vTextureCoord);\n		}\n		else {\n			outputColor = vec4(0.0, 0.0, 0.0, 0.0);\n		}\n		if ((vVertexPosition.x >= (1.0 - percent)) && (vVertexPosition.x <= ((1.0 - percent) + 0.2))) {\n			outputColor = outputColor * ((vVertexPosition.x - (1.0 - percent)) / 0.2);\n		}\n	}\n	gl_FragColor = outputColor;\n}\n";
}, function(t2, e2) {
  t2.exports = "attribute vec2 aVertexPosition;\nuniform mat3 projectionMatrix;\nvarying vec2 vTextureCoord;\nvarying vec2 vVertexPosition;\nvarying float vPercent;\nvarying float vDirection;\nvarying float vTransition;\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\nuniform float percent;\nuniform float direction;\nuniform float transition;\nvec4 filterVertexPosition() {\n	vec2 position = (aVertexPosition * max(outputFrame.zw, vec2(0.))) + outputFrame.xy;\n	return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\nvec2 filterTextureCoord(vec2 aVertexPosition) {\n	return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\nvoid main() {\n	vTransition = transition;\n	vDirection = direction;\n	vPercent = percent;\n	vVertexPosition = aVertexPosition;\n	vec2 localVertexPosition = aVertexPosition;\n	gl_Position = filterVertexPosition();\n	vTextureCoord = filterTextureCoord(localVertexPosition);\n}\n";
}, function(t2, e2) {
  t2.exports = "varying vec2 vTextureCoord;\nuniform float percent;\nuniform sampler2D uSampler;\nuniform float transition;\nvoid main() {\n	float alpha = (transition * (percent - 0.5)) + 0.5;\n	vec4 color1 = texture2D(uSampler, vTextureCoord);\n	gl_FragColor = color1 * alpha;\n}\n";
}, function(t2, e2, n) {
  (function(n2) {
    var i;
    /*!
     *  howler.js v2.2.3
     *  howlerjs.com
     *
     *  (c) 2013-2020, James Simpson of GoldFire Studios
     *  goldfirestudios.com
     *
     *  MIT License
     */
    !function() {
      var r2 = function() {
        this.init();
      };
      r2.prototype = { init: function() {
        var t3 = this || o2;
        return t3._counter = 1e3, t3._html5AudioPool = [], t3.html5PoolSize = 10, t3._codecs = {}, t3._howls = [], t3._muted = false, t3._volume = 1, t3._canPlayEvent = "canplaythrough", t3._navigator = typeof window != "undefined" && window.navigator ? window.navigator : null, t3.masterGain = null, t3.noAudio = false, t3.usingWebAudio = true, t3.autoSuspend = true, t3.ctx = null, t3.autoUnlock = true, t3._setup(), t3;
      }, volume: function(t3) {
        var e3 = this || o2;
        if (t3 = parseFloat(t3), e3.ctx || p(), t3 !== void 0 && t3 >= 0 && t3 <= 1) {
          if (e3._volume = t3, e3._muted)
            return e3;
          e3.usingWebAudio && e3.masterGain.gain.setValueAtTime(t3, o2.ctx.currentTime);
          for (var n3 = 0; n3 < e3._howls.length; n3++)
            if (!e3._howls[n3]._webAudio)
              for (var i2 = e3._howls[n3]._getSoundIds(), r3 = 0; r3 < i2.length; r3++) {
                var s3 = e3._howls[n3]._soundById(i2[r3]);
                s3 && s3._node && (s3._node.volume = s3._volume * t3);
              }
          return e3;
        }
        return e3._volume;
      }, mute: function(t3) {
        var e3 = this || o2;
        e3.ctx || p(), e3._muted = t3, e3.usingWebAudio && e3.masterGain.gain.setValueAtTime(t3 ? 0 : e3._volume, o2.ctx.currentTime);
        for (var n3 = 0; n3 < e3._howls.length; n3++)
          if (!e3._howls[n3]._webAudio)
            for (var i2 = e3._howls[n3]._getSoundIds(), r3 = 0; r3 < i2.length; r3++) {
              var s3 = e3._howls[n3]._soundById(i2[r3]);
              s3 && s3._node && (s3._node.muted = !!t3 || s3._muted);
            }
        return e3;
      }, stop: function() {
        for (var t3 = this || o2, e3 = 0; e3 < t3._howls.length; e3++)
          t3._howls[e3].stop();
        return t3;
      }, unload: function() {
        for (var t3 = this || o2, e3 = t3._howls.length - 1; e3 >= 0; e3--)
          t3._howls[e3].unload();
        return t3.usingWebAudio && t3.ctx && t3.ctx.close !== void 0 && (t3.ctx.close(), t3.ctx = null, p()), t3;
      }, codecs: function(t3) {
        return (this || o2)._codecs[t3.replace(/^x-/, "")];
      }, _setup: function() {
        var t3 = this || o2;
        if (t3.state = t3.ctx && t3.ctx.state || "suspended", t3._autoSuspend(), !t3.usingWebAudio)
          if (typeof Audio != "undefined")
            try {
              new Audio().oncanplaythrough === void 0 && (t3._canPlayEvent = "canplay");
            } catch (e3) {
              t3.noAudio = true;
            }
          else
            t3.noAudio = true;
        try {
          new Audio().muted && (t3.noAudio = true);
        } catch (t4) {
        }
        return t3.noAudio || t3._setupCodecs(), t3;
      }, _setupCodecs: function() {
        var t3 = this || o2, e3 = null;
        try {
          e3 = typeof Audio != "undefined" ? new Audio() : null;
        } catch (e4) {
          return t3;
        }
        if (!e3 || typeof e3.canPlayType != "function")
          return t3;
        var n3 = e3.canPlayType("audio/mpeg;").replace(/^no$/, ""), i2 = t3._navigator ? t3._navigator.userAgent : "", r3 = i2.match(/OPR\/([0-6].)/g), s3 = r3 && parseInt(r3[0].split("/")[1], 10) < 33, a2 = i2.indexOf("Safari") !== -1 && i2.indexOf("Chrome") === -1, l2 = i2.match(/Version\/(.*?) /), u2 = a2 && l2 && parseInt(l2[1], 10) < 15;
        return t3._codecs = { mp3: !(s3 || !n3 && !e3.canPlayType("audio/mp3;").replace(/^no$/, "")), mpeg: !!n3, opus: !!e3.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""), ogg: !!e3.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""), oga: !!e3.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""), wav: !!(e3.canPlayType('audio/wav; codecs="1"') || e3.canPlayType("audio/wav")).replace(/^no$/, ""), aac: !!e3.canPlayType("audio/aac;").replace(/^no$/, ""), caf: !!e3.canPlayType("audio/x-caf;").replace(/^no$/, ""), m4a: !!(e3.canPlayType("audio/x-m4a;") || e3.canPlayType("audio/m4a;") || e3.canPlayType("audio/aac;")).replace(/^no$/, ""), m4b: !!(e3.canPlayType("audio/x-m4b;") || e3.canPlayType("audio/m4b;") || e3.canPlayType("audio/aac;")).replace(/^no$/, ""), mp4: !!(e3.canPlayType("audio/x-mp4;") || e3.canPlayType("audio/mp4;") || e3.canPlayType("audio/aac;")).replace(/^no$/, ""), weba: !(u2 || !e3.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")), webm: !(u2 || !e3.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")), dolby: !!e3.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ""), flac: !!(e3.canPlayType("audio/x-flac;") || e3.canPlayType("audio/flac;")).replace(/^no$/, "") }, t3;
      }, _unlockAudio: function() {
        var t3 = this || o2;
        if (!t3._audioUnlocked && t3.ctx) {
          t3._audioUnlocked = false, t3.autoUnlock = false, t3._mobileUnloaded || t3.ctx.sampleRate === 44100 || (t3._mobileUnloaded = true, t3.unload()), t3._scratchBuffer = t3.ctx.createBuffer(1, 1, 22050);
          var e3 = function(n3) {
            for (; t3._html5AudioPool.length < t3.html5PoolSize; )
              try {
                var i2 = new Audio();
                i2._unlocked = true, t3._releaseHtml5Audio(i2);
              } catch (n4) {
                t3.noAudio = true;
                break;
              }
            for (var r3 = 0; r3 < t3._howls.length; r3++)
              if (!t3._howls[r3]._webAudio)
                for (var o3 = t3._howls[r3]._getSoundIds(), s3 = 0; s3 < o3.length; s3++) {
                  var a2 = t3._howls[r3]._soundById(o3[s3]);
                  a2 && a2._node && !a2._node._unlocked && (a2._node._unlocked = true, a2._node.load());
                }
            t3._autoResume();
            var l2 = t3.ctx.createBufferSource();
            l2.buffer = t3._scratchBuffer, l2.connect(t3.ctx.destination), l2.start === void 0 ? l2.noteOn(0) : l2.start(0), typeof t3.ctx.resume == "function" && t3.ctx.resume(), l2.onended = function() {
              l2.disconnect(0), t3._audioUnlocked = true, document.removeEventListener("touchstart", e3, true), document.removeEventListener("touchend", e3, true), document.removeEventListener("click", e3, true), document.removeEventListener("keydown", e3, true);
              for (var n4 = 0; n4 < t3._howls.length; n4++)
                t3._howls[n4]._emit("unlock");
            };
          };
          return document.addEventListener("touchstart", e3, true), document.addEventListener("touchend", e3, true), document.addEventListener("click", e3, true), document.addEventListener("keydown", e3, true), t3;
        }
      }, _obtainHtml5Audio: function() {
        var t3 = this || o2;
        if (t3._html5AudioPool.length)
          return t3._html5AudioPool.pop();
        var e3 = new Audio().play();
        return e3 && typeof Promise != "undefined" && (e3 instanceof Promise || typeof e3.then == "function") && e3.catch(function() {
          console.warn("HTML5 Audio pool exhausted, returning potentially locked audio object.");
        }), new Audio();
      }, _releaseHtml5Audio: function(t3) {
        var e3 = this || o2;
        return t3._unlocked && e3._html5AudioPool.push(t3), e3;
      }, _autoSuspend: function() {
        var t3 = this;
        if (t3.autoSuspend && t3.ctx && t3.ctx.suspend !== void 0 && o2.usingWebAudio) {
          for (var e3 = 0; e3 < t3._howls.length; e3++)
            if (t3._howls[e3]._webAudio) {
              for (var n3 = 0; n3 < t3._howls[e3]._sounds.length; n3++)
                if (!t3._howls[e3]._sounds[n3]._paused)
                  return t3;
            }
          return t3._suspendTimer && clearTimeout(t3._suspendTimer), t3._suspendTimer = setTimeout(function() {
            if (t3.autoSuspend) {
              t3._suspendTimer = null, t3.state = "suspending";
              var e4 = function() {
                t3.state = "suspended", t3._resumeAfterSuspend && (delete t3._resumeAfterSuspend, t3._autoResume());
              };
              t3.ctx.suspend().then(e4, e4);
            }
          }, 3e4), t3;
        }
      }, _autoResume: function() {
        var t3 = this;
        if (t3.ctx && t3.ctx.resume !== void 0 && o2.usingWebAudio)
          return t3.state === "running" && t3.ctx.state !== "interrupted" && t3._suspendTimer ? (clearTimeout(t3._suspendTimer), t3._suspendTimer = null) : t3.state === "suspended" || t3.state === "running" && t3.ctx.state === "interrupted" ? (t3.ctx.resume().then(function() {
            t3.state = "running";
            for (var e3 = 0; e3 < t3._howls.length; e3++)
              t3._howls[e3]._emit("resume");
          }), t3._suspendTimer && (clearTimeout(t3._suspendTimer), t3._suspendTimer = null)) : t3.state === "suspending" && (t3._resumeAfterSuspend = true), t3;
      } };
      var o2 = new r2(), s2 = function(t3) {
        t3.src && t3.src.length !== 0 ? this.init(t3) : console.error("An array of source files must be passed with any new Howl.");
      };
      s2.prototype = { init: function(t3) {
        var e3 = this;
        return o2.ctx || p(), e3._autoplay = t3.autoplay || false, e3._format = typeof t3.format != "string" ? t3.format : [t3.format], e3._html5 = t3.html5 || false, e3._muted = t3.mute || false, e3._loop = t3.loop || false, e3._pool = t3.pool || 5, e3._preload = typeof t3.preload != "boolean" && t3.preload !== "metadata" || t3.preload, e3._rate = t3.rate || 1, e3._sprite = t3.sprite || {}, e3._src = typeof t3.src != "string" ? t3.src : [t3.src], e3._volume = t3.volume !== void 0 ? t3.volume : 1, e3._xhr = { method: t3.xhr && t3.xhr.method ? t3.xhr.method : "GET", headers: t3.xhr && t3.xhr.headers ? t3.xhr.headers : null, withCredentials: !(!t3.xhr || !t3.xhr.withCredentials) && t3.xhr.withCredentials }, e3._duration = 0, e3._state = "unloaded", e3._sounds = [], e3._endTimers = {}, e3._queue = [], e3._playLock = false, e3._onend = t3.onend ? [{ fn: t3.onend }] : [], e3._onfade = t3.onfade ? [{ fn: t3.onfade }] : [], e3._onload = t3.onload ? [{ fn: t3.onload }] : [], e3._onloaderror = t3.onloaderror ? [{ fn: t3.onloaderror }] : [], e3._onplayerror = t3.onplayerror ? [{ fn: t3.onplayerror }] : [], e3._onpause = t3.onpause ? [{ fn: t3.onpause }] : [], e3._onplay = t3.onplay ? [{ fn: t3.onplay }] : [], e3._onstop = t3.onstop ? [{ fn: t3.onstop }] : [], e3._onmute = t3.onmute ? [{ fn: t3.onmute }] : [], e3._onvolume = t3.onvolume ? [{ fn: t3.onvolume }] : [], e3._onrate = t3.onrate ? [{ fn: t3.onrate }] : [], e3._onseek = t3.onseek ? [{ fn: t3.onseek }] : [], e3._onunlock = t3.onunlock ? [{ fn: t3.onunlock }] : [], e3._onresume = [], e3._webAudio = o2.usingWebAudio && !e3._html5, o2.ctx !== void 0 && o2.ctx && o2.autoUnlock && o2._unlockAudio(), o2._howls.push(e3), e3._autoplay && e3._queue.push({ event: "play", action: function() {
          e3.play();
        } }), e3._preload && e3._preload !== "none" && e3.load(), e3;
      }, load: function() {
        var t3 = null;
        if (o2.noAudio)
          this._emit("loaderror", null, "No audio support.");
        else {
          typeof this._src == "string" && (this._src = [this._src]);
          for (var e3 = 0; e3 < this._src.length; e3++) {
            var n3, i2;
            if (this._format && this._format[e3])
              n3 = this._format[e3];
            else {
              if (typeof (i2 = this._src[e3]) != "string") {
                this._emit("loaderror", null, "Non-string found in selected audio sources - ignoring.");
                continue;
              }
              (n3 = /^data:audio\/([^;,]+);/i.exec(i2)) || (n3 = /\.([^.]+)$/.exec(i2.split("?", 1)[0])), n3 && (n3 = n3[1].toLowerCase());
            }
            if (n3 || console.warn('No file extension was found. Consider using the "format" property or specify an extension.'), n3 && o2.codecs(n3)) {
              t3 = this._src[e3];
              break;
            }
          }
          if (t3)
            return this._src = t3, this._state = "loading", window.location.protocol === "https:" && t3.slice(0, 5) === "http:" && (this._html5 = true, this._webAudio = false), new a(this), this._webAudio && u(this), this;
          this._emit("loaderror", null, "No codec support for selected audio sources.");
        }
      }, play: function(t3, e3) {
        var n3 = this, i2 = null;
        if (typeof t3 == "number")
          i2 = t3, t3 = null;
        else {
          if (typeof t3 == "string" && n3._state === "loaded" && !n3._sprite[t3])
            return null;
          if (t3 === void 0 && (t3 = "__default", !n3._playLock)) {
            for (var r3 = 0, s3 = 0; s3 < n3._sounds.length; s3++)
              n3._sounds[s3]._paused && !n3._sounds[s3]._ended && (r3++, i2 = n3._sounds[s3]._id);
            r3 === 1 ? t3 = null : i2 = null;
          }
        }
        var a2 = i2 ? n3._soundById(i2) : n3._inactiveSound();
        if (!a2)
          return null;
        if (i2 && !t3 && (t3 = a2._sprite || "__default"), n3._state !== "loaded") {
          a2._sprite = t3, a2._ended = false;
          var l2 = a2._id;
          return n3._queue.push({ event: "play", action: function() {
            n3.play(l2);
          } }), l2;
        }
        if (i2 && !a2._paused)
          return e3 || n3._loadQueue("play"), a2._id;
        n3._webAudio && o2._autoResume();
        var u2 = Math.max(0, a2._seek > 0 ? a2._seek : n3._sprite[t3][0] / 1e3), h2 = Math.max(0, (n3._sprite[t3][0] + n3._sprite[t3][1]) / 1e3 - u2), c2 = 1e3 * h2 / Math.abs(a2._rate), d2 = n3._sprite[t3][0] / 1e3, p2 = (n3._sprite[t3][0] + n3._sprite[t3][1]) / 1e3;
        a2._sprite = t3, a2._ended = false;
        var f = function() {
          a2._paused = false, a2._seek = u2, a2._start = d2, a2._stop = p2, a2._loop = !(!a2._loop && !n3._sprite[t3][2]);
        };
        if (!(u2 >= p2)) {
          var m = a2._node;
          if (n3._webAudio) {
            var g = function() {
              n3._playLock = false, f(), n3._refreshBuffer(a2);
              var t4 = a2._muted || n3._muted ? 0 : a2._volume;
              m.gain.setValueAtTime(t4, o2.ctx.currentTime), a2._playStart = o2.ctx.currentTime, m.bufferSource.start === void 0 ? a2._loop ? m.bufferSource.noteGrainOn(0, u2, 86400) : m.bufferSource.noteGrainOn(0, u2, h2) : a2._loop ? m.bufferSource.start(0, u2, 86400) : m.bufferSource.start(0, u2, h2), c2 !== 1 / 0 && (n3._endTimers[a2._id] = setTimeout(n3._ended.bind(n3, a2), c2)), e3 || setTimeout(function() {
                n3._emit("play", a2._id), n3._loadQueue();
              }, 0);
            };
            o2.state === "running" && o2.ctx.state !== "interrupted" ? g() : (n3._playLock = true, n3.once("resume", g), n3._clearTimer(a2._id));
          } else {
            var v = function() {
              m.currentTime = u2, m.muted = a2._muted || n3._muted || o2._muted || m.muted, m.volume = a2._volume * o2.volume(), m.playbackRate = a2._rate;
              try {
                var i3 = m.play();
                if (i3 && typeof Promise != "undefined" && (i3 instanceof Promise || typeof i3.then == "function") ? (n3._playLock = true, f(), i3.then(function() {
                  n3._playLock = false, m._unlocked = true, e3 ? n3._loadQueue() : n3._emit("play", a2._id);
                }).catch(function() {
                  n3._playLock = false, n3._emit("playerror", a2._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."), a2._ended = true, a2._paused = true;
                })) : e3 || (n3._playLock = false, f(), n3._emit("play", a2._id)), m.playbackRate = a2._rate, m.paused)
                  return void n3._emit("playerror", a2._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");
                t3 !== "__default" || a2._loop ? n3._endTimers[a2._id] = setTimeout(n3._ended.bind(n3, a2), c2) : (n3._endTimers[a2._id] = function() {
                  n3._ended(a2), m.removeEventListener("ended", n3._endTimers[a2._id], false);
                }, m.addEventListener("ended", n3._endTimers[a2._id], false));
              } catch (t4) {
                n3._emit("playerror", a2._id, t4);
              }
            };
            m.src === "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA" && (m.src = n3._src, m.load());
            var _ = window && window.ejecta || !m.readyState && o2._navigator.isCocoonJS;
            if (m.readyState >= 3 || _)
              v();
            else {
              n3._playLock = true, n3._state = "loading";
              var y = function() {
                n3._state = "loaded", v(), m.removeEventListener(o2._canPlayEvent, y, false);
              };
              m.addEventListener(o2._canPlayEvent, y, false), n3._clearTimer(a2._id);
            }
          }
          return a2._id;
        }
        n3._ended(a2);
      }, pause: function(t3) {
        var e3 = this;
        if (e3._state !== "loaded" || e3._playLock)
          return e3._queue.push({ event: "pause", action: function() {
            e3.pause(t3);
          } }), e3;
        for (var n3 = e3._getSoundIds(t3), i2 = 0; i2 < n3.length; i2++) {
          e3._clearTimer(n3[i2]);
          var r3 = e3._soundById(n3[i2]);
          if (r3 && !r3._paused && (r3._seek = e3.seek(n3[i2]), r3._rateSeek = 0, r3._paused = true, e3._stopFade(n3[i2]), r3._node))
            if (e3._webAudio) {
              if (!r3._node.bufferSource)
                continue;
              r3._node.bufferSource.stop === void 0 ? r3._node.bufferSource.noteOff(0) : r3._node.bufferSource.stop(0), e3._cleanBuffer(r3._node);
            } else
              isNaN(r3._node.duration) && r3._node.duration !== 1 / 0 || r3._node.pause();
          arguments[1] || e3._emit("pause", r3 ? r3._id : null);
        }
        return e3;
      }, stop: function(t3, e3) {
        var n3 = this;
        if (n3._state !== "loaded" || n3._playLock)
          return n3._queue.push({ event: "stop", action: function() {
            n3.stop(t3);
          } }), n3;
        for (var i2 = n3._getSoundIds(t3), r3 = 0; r3 < i2.length; r3++) {
          n3._clearTimer(i2[r3]);
          var o3 = n3._soundById(i2[r3]);
          o3 && (o3._seek = o3._start || 0, o3._rateSeek = 0, o3._paused = true, o3._ended = true, n3._stopFade(i2[r3]), o3._node && (n3._webAudio ? o3._node.bufferSource && (o3._node.bufferSource.stop === void 0 ? o3._node.bufferSource.noteOff(0) : o3._node.bufferSource.stop(0), n3._cleanBuffer(o3._node)) : isNaN(o3._node.duration) && o3._node.duration !== 1 / 0 || (o3._node.currentTime = o3._start || 0, o3._node.pause(), o3._node.duration === 1 / 0 && n3._clearSound(o3._node))), e3 || n3._emit("stop", o3._id));
        }
        return n3;
      }, mute: function(t3, e3) {
        var n3 = this;
        if (n3._state !== "loaded" || n3._playLock)
          return n3._queue.push({ event: "mute", action: function() {
            n3.mute(t3, e3);
          } }), n3;
        if (e3 === void 0) {
          if (typeof t3 != "boolean")
            return n3._muted;
          n3._muted = t3;
        }
        for (var i2 = n3._getSoundIds(e3), r3 = 0; r3 < i2.length; r3++) {
          var s3 = n3._soundById(i2[r3]);
          s3 && (s3._muted = t3, s3._interval && n3._stopFade(s3._id), n3._webAudio && s3._node ? s3._node.gain.setValueAtTime(t3 ? 0 : s3._volume, o2.ctx.currentTime) : s3._node && (s3._node.muted = !!o2._muted || t3), n3._emit("mute", s3._id));
        }
        return n3;
      }, volume: function() {
        var t3, e3, n3, i2 = this, r3 = arguments;
        if (r3.length === 0)
          return i2._volume;
        if (r3.length === 1 || r3.length === 2 && r3[1] === void 0) {
          var s3 = i2._getSoundIds(), a2 = s3.indexOf(r3[0]);
          a2 >= 0 ? e3 = parseInt(r3[0], 10) : t3 = parseFloat(r3[0]);
        } else
          r3.length >= 2 && (t3 = parseFloat(r3[0]), e3 = parseInt(r3[1], 10));
        if (!(t3 !== void 0 && t3 >= 0 && t3 <= 1))
          return (n3 = e3 ? i2._soundById(e3) : i2._sounds[0]) ? n3._volume : 0;
        if (i2._state !== "loaded" || i2._playLock)
          return i2._queue.push({ event: "volume", action: function() {
            i2.volume.apply(i2, r3);
          } }), i2;
        e3 === void 0 && (i2._volume = t3), e3 = i2._getSoundIds(e3);
        for (var l2 = 0; l2 < e3.length; l2++)
          (n3 = i2._soundById(e3[l2])) && (n3._volume = t3, r3[2] || i2._stopFade(e3[l2]), i2._webAudio && n3._node && !n3._muted ? n3._node.gain.setValueAtTime(t3, o2.ctx.currentTime) : n3._node && !n3._muted && (n3._node.volume = t3 * o2.volume()), i2._emit("volume", n3._id));
        return i2;
      }, fade: function(t3, e3, n3, i2) {
        var r3 = this;
        if (r3._state !== "loaded" || r3._playLock)
          return r3._queue.push({ event: "fade", action: function() {
            r3.fade(t3, e3, n3, i2);
          } }), r3;
        t3 = Math.min(Math.max(0, parseFloat(t3)), 1), e3 = Math.min(Math.max(0, parseFloat(e3)), 1), n3 = parseFloat(n3), r3.volume(t3, i2);
        for (var s3 = r3._getSoundIds(i2), a2 = 0; a2 < s3.length; a2++) {
          var l2 = r3._soundById(s3[a2]);
          if (l2) {
            if (i2 || r3._stopFade(s3[a2]), r3._webAudio && !l2._muted) {
              var u2 = o2.ctx.currentTime, h2 = u2 + n3 / 1e3;
              l2._volume = t3, l2._node.gain.setValueAtTime(t3, u2), l2._node.gain.linearRampToValueAtTime(e3, h2);
            }
            r3._startFadeInterval(l2, t3, e3, n3, s3[a2], i2 === void 0);
          }
        }
        return r3;
      }, _startFadeInterval: function(t3, e3, n3, i2, r3, o3) {
        var s3 = this, a2 = e3, l2 = n3 - e3, u2 = Math.abs(l2 / 0.01), h2 = Math.max(4, u2 > 0 ? i2 / u2 : i2), c2 = Date.now();
        t3._fadeTo = n3, t3._interval = setInterval(function() {
          var r4 = (Date.now() - c2) / i2;
          c2 = Date.now(), a2 += l2 * r4, a2 = Math.round(100 * a2) / 100, a2 = l2 < 0 ? Math.max(n3, a2) : Math.min(n3, a2), s3._webAudio ? t3._volume = a2 : s3.volume(a2, t3._id, true), o3 && (s3._volume = a2), (n3 < e3 && a2 <= n3 || n3 > e3 && a2 >= n3) && (clearInterval(t3._interval), t3._interval = null, t3._fadeTo = null, s3.volume(n3, t3._id), s3._emit("fade", t3._id));
        }, h2);
      }, _stopFade: function(t3) {
        var e3 = this._soundById(t3);
        return e3 && e3._interval && (this._webAudio && e3._node.gain.cancelScheduledValues(o2.ctx.currentTime), clearInterval(e3._interval), e3._interval = null, this.volume(e3._fadeTo, t3), e3._fadeTo = null, this._emit("fade", t3)), this;
      }, loop: function() {
        var t3, e3, n3, i2 = this, r3 = arguments;
        if (r3.length === 0)
          return i2._loop;
        if (r3.length === 1) {
          if (typeof r3[0] != "boolean")
            return !!(n3 = i2._soundById(parseInt(r3[0], 10))) && n3._loop;
          t3 = r3[0], i2._loop = t3;
        } else
          r3.length === 2 && (t3 = r3[0], e3 = parseInt(r3[1], 10));
        for (var o3 = i2._getSoundIds(e3), s3 = 0; s3 < o3.length; s3++)
          (n3 = i2._soundById(o3[s3])) && (n3._loop = t3, i2._webAudio && n3._node && n3._node.bufferSource && (n3._node.bufferSource.loop = t3, t3 && (n3._node.bufferSource.loopStart = n3._start || 0, n3._node.bufferSource.loopEnd = n3._stop, i2.playing(o3[s3]) && (i2.pause(o3[s3], true), i2.play(o3[s3], true)))));
        return i2;
      }, rate: function() {
        var t3, e3, n3, i2 = this, r3 = arguments;
        if (r3.length === 0)
          e3 = i2._sounds[0]._id;
        else if (r3.length === 1) {
          var s3 = i2._getSoundIds(), a2 = s3.indexOf(r3[0]);
          a2 >= 0 ? e3 = parseInt(r3[0], 10) : t3 = parseFloat(r3[0]);
        } else
          r3.length === 2 && (t3 = parseFloat(r3[0]), e3 = parseInt(r3[1], 10));
        if (typeof t3 != "number")
          return (n3 = i2._soundById(e3)) ? n3._rate : i2._rate;
        if (i2._state !== "loaded" || i2._playLock)
          return i2._queue.push({ event: "rate", action: function() {
            i2.rate.apply(i2, r3);
          } }), i2;
        e3 === void 0 && (i2._rate = t3), e3 = i2._getSoundIds(e3);
        for (var l2 = 0; l2 < e3.length; l2++)
          if (n3 = i2._soundById(e3[l2])) {
            i2.playing(e3[l2]) && (n3._rateSeek = i2.seek(e3[l2]), n3._playStart = i2._webAudio ? o2.ctx.currentTime : n3._playStart), n3._rate = t3, i2._webAudio && n3._node && n3._node.bufferSource ? n3._node.bufferSource.playbackRate.setValueAtTime(t3, o2.ctx.currentTime) : n3._node && (n3._node.playbackRate = t3);
            var u2 = i2.seek(e3[l2]), h2 = (i2._sprite[n3._sprite][0] + i2._sprite[n3._sprite][1]) / 1e3 - u2, c2 = 1e3 * h2 / Math.abs(n3._rate);
            !i2._endTimers[e3[l2]] && n3._paused || (i2._clearTimer(e3[l2]), i2._endTimers[e3[l2]] = setTimeout(i2._ended.bind(i2, n3), c2)), i2._emit("rate", n3._id);
          }
        return i2;
      }, seek: function() {
        var t3, e3, n3 = this, i2 = arguments;
        if (i2.length === 0)
          n3._sounds.length && (e3 = n3._sounds[0]._id);
        else if (i2.length === 1) {
          var r3 = n3._getSoundIds(), s3 = r3.indexOf(i2[0]);
          s3 >= 0 ? e3 = parseInt(i2[0], 10) : n3._sounds.length && (e3 = n3._sounds[0]._id, t3 = parseFloat(i2[0]));
        } else
          i2.length === 2 && (t3 = parseFloat(i2[0]), e3 = parseInt(i2[1], 10));
        if (e3 === void 0)
          return 0;
        if (typeof t3 == "number" && (n3._state !== "loaded" || n3._playLock))
          return n3._queue.push({ event: "seek", action: function() {
            n3.seek.apply(n3, i2);
          } }), n3;
        var a2 = n3._soundById(e3);
        if (a2) {
          if (!(typeof t3 == "number" && t3 >= 0)) {
            if (n3._webAudio) {
              var l2 = n3.playing(e3) ? o2.ctx.currentTime - a2._playStart : 0, u2 = a2._rateSeek ? a2._rateSeek - a2._seek : 0;
              return a2._seek + (u2 + l2 * Math.abs(a2._rate));
            }
            return a2._node.currentTime;
          }
          var h2 = n3.playing(e3);
          h2 && n3.pause(e3, true), a2._seek = t3, a2._ended = false, n3._clearTimer(e3), n3._webAudio || !a2._node || isNaN(a2._node.duration) || (a2._node.currentTime = t3);
          var c2 = function() {
            h2 && n3.play(e3, true), n3._emit("seek", e3);
          };
          if (h2 && !n3._webAudio) {
            var d2 = function() {
              n3._playLock ? setTimeout(d2, 0) : c2();
            };
            setTimeout(d2, 0);
          } else
            c2();
        }
        return n3;
      }, playing: function(t3) {
        if (typeof t3 == "number") {
          var e3 = this._soundById(t3);
          return !!e3 && !e3._paused;
        }
        for (var n3 = 0; n3 < this._sounds.length; n3++)
          if (!this._sounds[n3]._paused)
            return true;
        return false;
      }, duration: function(t3) {
        var e3 = this._duration, n3 = this._soundById(t3);
        return n3 && (e3 = this._sprite[n3._sprite][1] / 1e3), e3;
      }, state: function() {
        return this._state;
      }, unload: function() {
        for (var t3 = this, e3 = t3._sounds, n3 = 0; n3 < e3.length; n3++)
          e3[n3]._paused || t3.stop(e3[n3]._id), t3._webAudio || (t3._clearSound(e3[n3]._node), e3[n3]._node.removeEventListener("error", e3[n3]._errorFn, false), e3[n3]._node.removeEventListener(o2._canPlayEvent, e3[n3]._loadFn, false), e3[n3]._node.removeEventListener("ended", e3[n3]._endFn, false), o2._releaseHtml5Audio(e3[n3]._node)), delete e3[n3]._node, t3._clearTimer(e3[n3]._id);
        var i2 = o2._howls.indexOf(t3);
        i2 >= 0 && o2._howls.splice(i2, 1);
        var r3 = true;
        for (n3 = 0; n3 < o2._howls.length; n3++)
          if (o2._howls[n3]._src === t3._src || t3._src.indexOf(o2._howls[n3]._src) >= 0) {
            r3 = false;
            break;
          }
        return l && r3 && delete l[t3._src], o2.noAudio = false, t3._state = "unloaded", t3._sounds = [], t3 = null, null;
      }, on: function(t3, e3, n3, i2) {
        var r3 = this["_on" + t3];
        return typeof e3 == "function" && r3.push(i2 ? { id: n3, fn: e3, once: i2 } : { id: n3, fn: e3 }), this;
      }, off: function(t3, e3, n3) {
        var i2 = this["_on" + t3], r3 = 0;
        if (typeof e3 == "number" && (n3 = e3, e3 = null), e3 || n3)
          for (r3 = 0; r3 < i2.length; r3++) {
            var o3 = n3 === i2[r3].id;
            if (e3 === i2[r3].fn && o3 || !e3 && o3) {
              i2.splice(r3, 1);
              break;
            }
          }
        else if (t3)
          this["_on" + t3] = [];
        else {
          var s3 = Object.keys(this);
          for (r3 = 0; r3 < s3.length; r3++)
            s3[r3].indexOf("_on") === 0 && Array.isArray(this[s3[r3]]) && (this[s3[r3]] = []);
        }
        return this;
      }, once: function(t3, e3, n3) {
        return this.on(t3, e3, n3, 1), this;
      }, _emit: function(t3, e3, n3) {
        for (var i2 = this["_on" + t3], r3 = i2.length - 1; r3 >= 0; r3--)
          i2[r3].id && i2[r3].id !== e3 && t3 !== "load" || (setTimeout(function(t4) {
            t4.call(this, e3, n3);
          }.bind(this, i2[r3].fn), 0), i2[r3].once && this.off(t3, i2[r3].fn, i2[r3].id));
        return this._loadQueue(t3), this;
      }, _loadQueue: function(t3) {
        if (this._queue.length > 0) {
          var e3 = this._queue[0];
          e3.event === t3 && (this._queue.shift(), this._loadQueue()), t3 || e3.action();
        }
        return this;
      }, _ended: function(t3) {
        var e3 = t3._sprite;
        if (!this._webAudio && t3._node && !t3._node.paused && !t3._node.ended && t3._node.currentTime < t3._stop)
          return setTimeout(this._ended.bind(this, t3), 100), this;
        var n3 = !(!t3._loop && !this._sprite[e3][2]);
        if (this._emit("end", t3._id), !this._webAudio && n3 && this.stop(t3._id, true).play(t3._id), this._webAudio && n3) {
          this._emit("play", t3._id), t3._seek = t3._start || 0, t3._rateSeek = 0, t3._playStart = o2.ctx.currentTime;
          var i2 = 1e3 * (t3._stop - t3._start) / Math.abs(t3._rate);
          this._endTimers[t3._id] = setTimeout(this._ended.bind(this, t3), i2);
        }
        return this._webAudio && !n3 && (t3._paused = true, t3._ended = true, t3._seek = t3._start || 0, t3._rateSeek = 0, this._clearTimer(t3._id), this._cleanBuffer(t3._node), o2._autoSuspend()), this._webAudio || n3 || this.stop(t3._id, true), this;
      }, _clearTimer: function(t3) {
        if (this._endTimers[t3]) {
          if (typeof this._endTimers[t3] != "function")
            clearTimeout(this._endTimers[t3]);
          else {
            var e3 = this._soundById(t3);
            e3 && e3._node && e3._node.removeEventListener("ended", this._endTimers[t3], false);
          }
          delete this._endTimers[t3];
        }
        return this;
      }, _soundById: function(t3) {
        for (var e3 = 0; e3 < this._sounds.length; e3++)
          if (t3 === this._sounds[e3]._id)
            return this._sounds[e3];
        return null;
      }, _inactiveSound: function() {
        this._drain();
        for (var t3 = 0; t3 < this._sounds.length; t3++)
          if (this._sounds[t3]._ended)
            return this._sounds[t3].reset();
        return new a(this);
      }, _drain: function() {
        var t3 = this._pool, e3 = 0, n3 = 0;
        if (!(this._sounds.length < t3)) {
          for (n3 = 0; n3 < this._sounds.length; n3++)
            this._sounds[n3]._ended && e3++;
          for (n3 = this._sounds.length - 1; n3 >= 0; n3--) {
            if (e3 <= t3)
              return;
            this._sounds[n3]._ended && (this._webAudio && this._sounds[n3]._node && this._sounds[n3]._node.disconnect(0), this._sounds.splice(n3, 1), e3--);
          }
        }
      }, _getSoundIds: function(t3) {
        if (t3 === void 0) {
          for (var e3 = [], n3 = 0; n3 < this._sounds.length; n3++)
            e3.push(this._sounds[n3]._id);
          return e3;
        }
        return [t3];
      }, _refreshBuffer: function(t3) {
        return t3._node.bufferSource = o2.ctx.createBufferSource(), t3._node.bufferSource.buffer = l[this._src], t3._panner ? t3._node.bufferSource.connect(t3._panner) : t3._node.bufferSource.connect(t3._node), t3._node.bufferSource.loop = t3._loop, t3._loop && (t3._node.bufferSource.loopStart = t3._start || 0, t3._node.bufferSource.loopEnd = t3._stop || 0), t3._node.bufferSource.playbackRate.setValueAtTime(t3._rate, o2.ctx.currentTime), this;
      }, _cleanBuffer: function(t3) {
        var e3 = o2._navigator && o2._navigator.vendor.indexOf("Apple") >= 0;
        if (o2._scratchBuffer && t3.bufferSource && (t3.bufferSource.onended = null, t3.bufferSource.disconnect(0), e3))
          try {
            t3.bufferSource.buffer = o2._scratchBuffer;
          } catch (t4) {
          }
        return t3.bufferSource = null, this;
      }, _clearSound: function(t3) {
        /MSIE |Trident\//.test(o2._navigator && o2._navigator.userAgent) || (t3.src = "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA");
      } };
      var a = function(t3) {
        this._parent = t3, this.init();
      };
      a.prototype = { init: function() {
        var t3 = this._parent;
        return this._muted = t3._muted, this._loop = t3._loop, this._volume = t3._volume, this._rate = t3._rate, this._seek = 0, this._paused = true, this._ended = true, this._sprite = "__default", this._id = ++o2._counter, t3._sounds.push(this), this.create(), this;
      }, create: function() {
        var t3 = this._parent, e3 = o2._muted || this._muted || this._parent._muted ? 0 : this._volume;
        return t3._webAudio ? (this._node = o2.ctx.createGain === void 0 ? o2.ctx.createGainNode() : o2.ctx.createGain(), this._node.gain.setValueAtTime(e3, o2.ctx.currentTime), this._node.paused = true, this._node.connect(o2.masterGain)) : o2.noAudio || (this._node = o2._obtainHtml5Audio(), this._errorFn = this._errorListener.bind(this), this._node.addEventListener("error", this._errorFn, false), this._loadFn = this._loadListener.bind(this), this._node.addEventListener(o2._canPlayEvent, this._loadFn, false), this._endFn = this._endListener.bind(this), this._node.addEventListener("ended", this._endFn, false), this._node.src = t3._src, this._node.preload = t3._preload === true ? "auto" : t3._preload, this._node.volume = e3 * o2.volume(), this._node.load()), this;
      }, reset: function() {
        var t3 = this._parent;
        return this._muted = t3._muted, this._loop = t3._loop, this._volume = t3._volume, this._rate = t3._rate, this._seek = 0, this._rateSeek = 0, this._paused = true, this._ended = true, this._sprite = "__default", this._id = ++o2._counter, this;
      }, _errorListener: function() {
        this._parent._emit("loaderror", this._id, this._node.error ? this._node.error.code : 0), this._node.removeEventListener("error", this._errorFn, false);
      }, _loadListener: function() {
        var t3 = this._parent;
        t3._duration = Math.ceil(10 * this._node.duration) / 10, Object.keys(t3._sprite).length === 0 && (t3._sprite = { __default: [0, 1e3 * t3._duration] }), t3._state !== "loaded" && (t3._state = "loaded", t3._emit("load"), t3._loadQueue()), this._node.removeEventListener(o2._canPlayEvent, this._loadFn, false);
      }, _endListener: function() {
        var t3 = this._parent;
        t3._duration === 1 / 0 && (t3._duration = Math.ceil(10 * this._node.duration) / 10, t3._sprite.__default[1] === 1 / 0 && (t3._sprite.__default[1] = 1e3 * t3._duration), t3._ended(this)), this._node.removeEventListener("ended", this._endFn, false);
      } };
      var l = {}, u = function(t3) {
        var e3 = t3._src;
        if (l[e3])
          return t3._duration = l[e3].duration, void d(t3);
        if (/^data:[^;]+;base64,/.test(e3)) {
          for (var n3 = atob(e3.split(",")[1]), i2 = new Uint8Array(n3.length), r3 = 0; r3 < n3.length; ++r3)
            i2[r3] = n3.charCodeAt(r3);
          c(i2.buffer, t3);
        } else {
          var o3 = new XMLHttpRequest();
          o3.open(t3._xhr.method, e3, true), o3.withCredentials = t3._xhr.withCredentials, o3.responseType = "arraybuffer", t3._xhr.headers && Object.keys(t3._xhr.headers).forEach(function(e4) {
            o3.setRequestHeader(e4, t3._xhr.headers[e4]);
          }), o3.onload = function() {
            var e4 = (o3.status + "")[0];
            e4 === "0" || e4 === "2" || e4 === "3" ? c(o3.response, t3) : t3._emit("loaderror", null, "Failed loading audio file with status: " + o3.status + ".");
          }, o3.onerror = function() {
            t3._webAudio && (t3._html5 = true, t3._webAudio = false, t3._sounds = [], delete l[e3], t3.load());
          }, h(o3);
        }
      }, h = function(t3) {
        try {
          t3.send();
        } catch (e3) {
          t3.onerror();
        }
      }, c = function(t3, e3) {
        var n3 = function() {
          e3._emit("loaderror", null, "Decoding audio data failed.");
        }, i2 = function(t4) {
          t4 && e3._sounds.length > 0 ? (l[e3._src] = t4, d(e3, t4)) : n3();
        };
        typeof Promise != "undefined" && o2.ctx.decodeAudioData.length === 1 ? o2.ctx.decodeAudioData(t3).then(i2).catch(n3) : o2.ctx.decodeAudioData(t3, i2, n3);
      }, d = function(t3, e3) {
        e3 && !t3._duration && (t3._duration = e3.duration), Object.keys(t3._sprite).length === 0 && (t3._sprite = { __default: [0, 1e3 * t3._duration] }), t3._state !== "loaded" && (t3._state = "loaded", t3._emit("load"), t3._loadQueue());
      }, p = function() {
        if (o2.usingWebAudio) {
          try {
            typeof AudioContext != "undefined" ? o2.ctx = new AudioContext() : typeof webkitAudioContext != "undefined" ? o2.ctx = new webkitAudioContext() : o2.usingWebAudio = false;
          } catch (t4) {
            o2.usingWebAudio = false;
          }
          o2.ctx || (o2.usingWebAudio = false);
          var t3 = /iP(hone|od|ad)/.test(o2._navigator && o2._navigator.platform), e3 = o2._navigator && o2._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/), n3 = e3 ? parseInt(e3[1], 10) : null;
          if (t3 && n3 && n3 < 9) {
            var i2 = /safari/.test(o2._navigator && o2._navigator.userAgent.toLowerCase());
            o2._navigator && !i2 && (o2.usingWebAudio = false);
          }
          o2.usingWebAudio && (o2.masterGain = o2.ctx.createGain === void 0 ? o2.ctx.createGainNode() : o2.ctx.createGain(), o2.masterGain.gain.setValueAtTime(o2._muted ? 0 : o2._volume, o2.ctx.currentTime), o2.masterGain.connect(o2.ctx.destination)), o2._setup();
        }
      };
      (i = function() {
        return { Howler: o2, Howl: s2 };
      }.apply(e2, [])) === void 0 || (t2.exports = i), e2.Howler = o2, e2.Howl = s2, n2 !== void 0 ? (n2.HowlerGlobal = r2, n2.Howler = o2, n2.Howl = s2, n2.Sound = a) : typeof window != "undefined" && (window.HowlerGlobal = r2, window.Howler = o2, window.Howl = s2, window.Sound = a);
    }(), function() {
      var t3;
      HowlerGlobal.prototype._pos = [0, 0, 0], HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0], HowlerGlobal.prototype.stereo = function(t4) {
        if (!this.ctx || !this.ctx.listener)
          return this;
        for (var e4 = this._howls.length - 1; e4 >= 0; e4--)
          this._howls[e4].stereo(t4);
        return this;
      }, HowlerGlobal.prototype.pos = function(t4, e4, n3) {
        return this.ctx && this.ctx.listener ? (e4 = typeof e4 != "number" ? this._pos[1] : e4, n3 = typeof n3 != "number" ? this._pos[2] : n3, typeof t4 != "number" ? this._pos : (this._pos = [t4, e4, n3], this.ctx.listener.positionX !== void 0 ? (this.ctx.listener.positionX.setTargetAtTime(this._pos[0], Howler.ctx.currentTime, 0.1), this.ctx.listener.positionY.setTargetAtTime(this._pos[1], Howler.ctx.currentTime, 0.1), this.ctx.listener.positionZ.setTargetAtTime(this._pos[2], Howler.ctx.currentTime, 0.1)) : this.ctx.listener.setPosition(this._pos[0], this._pos[1], this._pos[2]), this)) : this;
      }, HowlerGlobal.prototype.orientation = function(t4, e4, n3, i2, r2, o2) {
        if (!this.ctx || !this.ctx.listener)
          return this;
        var s2 = this._orientation;
        return e4 = typeof e4 != "number" ? s2[1] : e4, n3 = typeof n3 != "number" ? s2[2] : n3, i2 = typeof i2 != "number" ? s2[3] : i2, r2 = typeof r2 != "number" ? s2[4] : r2, o2 = typeof o2 != "number" ? s2[5] : o2, typeof t4 != "number" ? s2 : (this._orientation = [t4, e4, n3, i2, r2, o2], this.ctx.listener.forwardX !== void 0 ? (this.ctx.listener.forwardX.setTargetAtTime(t4, Howler.ctx.currentTime, 0.1), this.ctx.listener.forwardY.setTargetAtTime(e4, Howler.ctx.currentTime, 0.1), this.ctx.listener.forwardZ.setTargetAtTime(n3, Howler.ctx.currentTime, 0.1), this.ctx.listener.upX.setTargetAtTime(i2, Howler.ctx.currentTime, 0.1), this.ctx.listener.upY.setTargetAtTime(r2, Howler.ctx.currentTime, 0.1), this.ctx.listener.upZ.setTargetAtTime(o2, Howler.ctx.currentTime, 0.1)) : this.ctx.listener.setOrientation(t4, e4, n3, i2, r2, o2), this);
      }, Howl.prototype.init = (t3 = Howl.prototype.init, function(e4) {
        return this._orientation = e4.orientation || [1, 0, 0], this._stereo = e4.stereo || null, this._pos = e4.pos || null, this._pannerAttr = { coneInnerAngle: e4.coneInnerAngle !== void 0 ? e4.coneInnerAngle : 360, coneOuterAngle: e4.coneOuterAngle !== void 0 ? e4.coneOuterAngle : 360, coneOuterGain: e4.coneOuterGain !== void 0 ? e4.coneOuterGain : 0, distanceModel: e4.distanceModel !== void 0 ? e4.distanceModel : "inverse", maxDistance: e4.maxDistance !== void 0 ? e4.maxDistance : 1e4, panningModel: e4.panningModel !== void 0 ? e4.panningModel : "HRTF", refDistance: e4.refDistance !== void 0 ? e4.refDistance : 1, rolloffFactor: e4.rolloffFactor !== void 0 ? e4.rolloffFactor : 1 }, this._onstereo = e4.onstereo ? [{ fn: e4.onstereo }] : [], this._onpos = e4.onpos ? [{ fn: e4.onpos }] : [], this._onorientation = e4.onorientation ? [{ fn: e4.onorientation }] : [], t3.call(this, e4);
      }), Howl.prototype.stereo = function(t4, n3) {
        var i2 = this;
        if (!i2._webAudio)
          return i2;
        if (i2._state !== "loaded")
          return i2._queue.push({ event: "stereo", action: function() {
            i2.stereo(t4, n3);
          } }), i2;
        var r2 = Howler.ctx.createStereoPanner === void 0 ? "spatial" : "stereo";
        if (n3 === void 0) {
          if (typeof t4 != "number")
            return i2._stereo;
          i2._stereo = t4, i2._pos = [t4, 0, 0];
        }
        for (var o2 = i2._getSoundIds(n3), s2 = 0; s2 < o2.length; s2++) {
          var a = i2._soundById(o2[s2]);
          if (a) {
            if (typeof t4 != "number")
              return a._stereo;
            a._stereo = t4, a._pos = [t4, 0, 0], a._node && (a._pannerAttr.panningModel = "equalpower", a._panner && a._panner.pan || e3(a, r2), r2 === "spatial" ? a._panner.positionX !== void 0 ? (a._panner.positionX.setValueAtTime(t4, Howler.ctx.currentTime), a._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime), a._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime)) : a._panner.setPosition(t4, 0, 0) : a._panner.pan.setValueAtTime(t4, Howler.ctx.currentTime)), i2._emit("stereo", a._id);
          }
        }
        return i2;
      }, Howl.prototype.pos = function(t4, n3, i2, r2) {
        var o2 = this;
        if (!o2._webAudio)
          return o2;
        if (o2._state !== "loaded")
          return o2._queue.push({ event: "pos", action: function() {
            o2.pos(t4, n3, i2, r2);
          } }), o2;
        if (n3 = typeof n3 != "number" ? 0 : n3, i2 = typeof i2 != "number" ? -0.5 : i2, r2 === void 0) {
          if (typeof t4 != "number")
            return o2._pos;
          o2._pos = [t4, n3, i2];
        }
        for (var s2 = o2._getSoundIds(r2), a = 0; a < s2.length; a++) {
          var l = o2._soundById(s2[a]);
          if (l) {
            if (typeof t4 != "number")
              return l._pos;
            l._pos = [t4, n3, i2], l._node && (l._panner && !l._panner.pan || e3(l, "spatial"), l._panner.positionX !== void 0 ? (l._panner.positionX.setValueAtTime(t4, Howler.ctx.currentTime), l._panner.positionY.setValueAtTime(n3, Howler.ctx.currentTime), l._panner.positionZ.setValueAtTime(i2, Howler.ctx.currentTime)) : l._panner.setPosition(t4, n3, i2)), o2._emit("pos", l._id);
          }
        }
        return o2;
      }, Howl.prototype.orientation = function(t4, n3, i2, r2) {
        var o2 = this;
        if (!o2._webAudio)
          return o2;
        if (o2._state !== "loaded")
          return o2._queue.push({ event: "orientation", action: function() {
            o2.orientation(t4, n3, i2, r2);
          } }), o2;
        if (n3 = typeof n3 != "number" ? o2._orientation[1] : n3, i2 = typeof i2 != "number" ? o2._orientation[2] : i2, r2 === void 0) {
          if (typeof t4 != "number")
            return o2._orientation;
          o2._orientation = [t4, n3, i2];
        }
        for (var s2 = o2._getSoundIds(r2), a = 0; a < s2.length; a++) {
          var l = o2._soundById(s2[a]);
          if (l) {
            if (typeof t4 != "number")
              return l._orientation;
            l._orientation = [t4, n3, i2], l._node && (l._panner || (l._pos || (l._pos = o2._pos || [0, 0, -0.5]), e3(l, "spatial")), l._panner.orientationX !== void 0 ? (l._panner.orientationX.setValueAtTime(t4, Howler.ctx.currentTime), l._panner.orientationY.setValueAtTime(n3, Howler.ctx.currentTime), l._panner.orientationZ.setValueAtTime(i2, Howler.ctx.currentTime)) : l._panner.setOrientation(t4, n3, i2)), o2._emit("orientation", l._id);
          }
        }
        return o2;
      }, Howl.prototype.pannerAttr = function() {
        var t4, n3, i2, r2 = this, o2 = arguments;
        if (!r2._webAudio)
          return r2;
        if (o2.length === 0)
          return r2._pannerAttr;
        if (o2.length === 1) {
          if (typeof o2[0] != "object")
            return (i2 = r2._soundById(parseInt(o2[0], 10))) ? i2._pannerAttr : r2._pannerAttr;
          t4 = o2[0], n3 === void 0 && (t4.pannerAttr || (t4.pannerAttr = { coneInnerAngle: t4.coneInnerAngle, coneOuterAngle: t4.coneOuterAngle, coneOuterGain: t4.coneOuterGain, distanceModel: t4.distanceModel, maxDistance: t4.maxDistance, refDistance: t4.refDistance, rolloffFactor: t4.rolloffFactor, panningModel: t4.panningModel }), r2._pannerAttr = { coneInnerAngle: t4.pannerAttr.coneInnerAngle !== void 0 ? t4.pannerAttr.coneInnerAngle : r2._coneInnerAngle, coneOuterAngle: t4.pannerAttr.coneOuterAngle !== void 0 ? t4.pannerAttr.coneOuterAngle : r2._coneOuterAngle, coneOuterGain: t4.pannerAttr.coneOuterGain !== void 0 ? t4.pannerAttr.coneOuterGain : r2._coneOuterGain, distanceModel: t4.pannerAttr.distanceModel !== void 0 ? t4.pannerAttr.distanceModel : r2._distanceModel, maxDistance: t4.pannerAttr.maxDistance !== void 0 ? t4.pannerAttr.maxDistance : r2._maxDistance, refDistance: t4.pannerAttr.refDistance !== void 0 ? t4.pannerAttr.refDistance : r2._refDistance, rolloffFactor: t4.pannerAttr.rolloffFactor !== void 0 ? t4.pannerAttr.rolloffFactor : r2._rolloffFactor, panningModel: t4.pannerAttr.panningModel !== void 0 ? t4.pannerAttr.panningModel : r2._panningModel });
        } else
          o2.length === 2 && (t4 = o2[0], n3 = parseInt(o2[1], 10));
        for (var s2 = r2._getSoundIds(n3), a = 0; a < s2.length; a++)
          if (i2 = r2._soundById(s2[a])) {
            var l = i2._pannerAttr;
            l = { coneInnerAngle: t4.coneInnerAngle !== void 0 ? t4.coneInnerAngle : l.coneInnerAngle, coneOuterAngle: t4.coneOuterAngle !== void 0 ? t4.coneOuterAngle : l.coneOuterAngle, coneOuterGain: t4.coneOuterGain !== void 0 ? t4.coneOuterGain : l.coneOuterGain, distanceModel: t4.distanceModel !== void 0 ? t4.distanceModel : l.distanceModel, maxDistance: t4.maxDistance !== void 0 ? t4.maxDistance : l.maxDistance, refDistance: t4.refDistance !== void 0 ? t4.refDistance : l.refDistance, rolloffFactor: t4.rolloffFactor !== void 0 ? t4.rolloffFactor : l.rolloffFactor, panningModel: t4.panningModel !== void 0 ? t4.panningModel : l.panningModel };
            var u = i2._panner;
            u ? (u.coneInnerAngle = l.coneInnerAngle, u.coneOuterAngle = l.coneOuterAngle, u.coneOuterGain = l.coneOuterGain, u.distanceModel = l.distanceModel, u.maxDistance = l.maxDistance, u.refDistance = l.refDistance, u.rolloffFactor = l.rolloffFactor, u.panningModel = l.panningModel) : (i2._pos || (i2._pos = r2._pos || [0, 0, -0.5]), e3(i2, "spatial"));
          }
        return r2;
      }, Sound.prototype.init = function(t4) {
        return function() {
          var e4 = this._parent;
          this._orientation = e4._orientation, this._stereo = e4._stereo, this._pos = e4._pos, this._pannerAttr = e4._pannerAttr, t4.call(this), this._stereo ? e4.stereo(this._stereo) : this._pos && e4.pos(this._pos[0], this._pos[1], this._pos[2], this._id);
        };
      }(Sound.prototype.init), Sound.prototype.reset = function(t4) {
        return function() {
          var e4 = this._parent;
          return this._orientation = e4._orientation, this._stereo = e4._stereo, this._pos = e4._pos, this._pannerAttr = e4._pannerAttr, this._stereo ? e4.stereo(this._stereo) : this._pos ? e4.pos(this._pos[0], this._pos[1], this._pos[2], this._id) : this._panner && (this._panner.disconnect(0), this._panner = void 0, e4._refreshBuffer(this)), t4.call(this);
        };
      }(Sound.prototype.reset);
      var e3 = function(t4, e4) {
        (e4 = e4 || "spatial") === "spatial" ? (t4._panner = Howler.ctx.createPanner(), t4._panner.coneInnerAngle = t4._pannerAttr.coneInnerAngle, t4._panner.coneOuterAngle = t4._pannerAttr.coneOuterAngle, t4._panner.coneOuterGain = t4._pannerAttr.coneOuterGain, t4._panner.distanceModel = t4._pannerAttr.distanceModel, t4._panner.maxDistance = t4._pannerAttr.maxDistance, t4._panner.refDistance = t4._pannerAttr.refDistance, t4._panner.rolloffFactor = t4._pannerAttr.rolloffFactor, t4._panner.panningModel = t4._pannerAttr.panningModel, t4._panner.positionX !== void 0 ? (t4._panner.positionX.setValueAtTime(t4._pos[0], Howler.ctx.currentTime), t4._panner.positionY.setValueAtTime(t4._pos[1], Howler.ctx.currentTime), t4._panner.positionZ.setValueAtTime(t4._pos[2], Howler.ctx.currentTime)) : t4._panner.setPosition(t4._pos[0], t4._pos[1], t4._pos[2]), t4._panner.orientationX !== void 0 ? (t4._panner.orientationX.setValueAtTime(t4._orientation[0], Howler.ctx.currentTime), t4._panner.orientationY.setValueAtTime(t4._orientation[1], Howler.ctx.currentTime), t4._panner.orientationZ.setValueAtTime(t4._orientation[2], Howler.ctx.currentTime)) : t4._panner.setOrientation(t4._orientation[0], t4._orientation[1], t4._orientation[2])) : (t4._panner = Howler.ctx.createStereoPanner(), t4._panner.pan.setValueAtTime(t4._stereo, Howler.ctx.currentTime)), t4._panner.connect(t4._node), t4._paused || t4._parent.pause(t4._id, true).play(t4._id, true);
      };
    }();
  }).call(this, n(4));
}, function(t2, e2, n) {
  var i;
  !function(r2, o2) {
    var s2 = "model", a = "name", l = "type", u = "vendor", h = "version", c = "mobile", d = "tablet", p = "smarttv", f = function(t3) {
      for (var e3 = {}, n2 = 0; n2 < t3.length; n2++)
        e3[t3[n2].toUpperCase()] = t3[n2];
      return e3;
    }, m = function(t3, e3) {
      return typeof t3 == "string" && g(e3).indexOf(g(t3)) !== -1;
    }, g = function(t3) {
      return t3.toLowerCase();
    }, v = function(t3, e3) {
      if (typeof t3 == "string")
        return t3 = t3.replace(/^\s\s*/, "").replace(/\s\s*$/, ""), e3 === void 0 ? t3 : t3.substring(0, 255);
    }, _ = function(t3, e3) {
      for (var n2, i2, r3, o3, s3, a2, l2 = 0; l2 < e3.length && !s3; ) {
        var u2 = e3[l2], h2 = e3[l2 + 1];
        for (n2 = i2 = 0; n2 < u2.length && !s3; )
          if (s3 = u2[n2++].exec(t3))
            for (r3 = 0; r3 < h2.length; r3++)
              a2 = s3[++i2], typeof (o3 = h2[r3]) == "object" && o3.length > 0 ? o3.length === 2 ? typeof o3[1] == "function" ? this[o3[0]] = o3[1].call(this, a2) : this[o3[0]] = o3[1] : o3.length === 3 ? typeof o3[1] != "function" || o3[1].exec && o3[1].test ? this[o3[0]] = a2 ? a2.replace(o3[1], o3[2]) : void 0 : this[o3[0]] = a2 ? o3[1].call(this, a2, o3[2]) : void 0 : o3.length === 4 && (this[o3[0]] = a2 ? o3[3].call(this, a2.replace(o3[1], o3[2])) : void 0) : this[o3] = a2 || void 0;
        l2 += 2;
      }
    }, y = function(t3, e3) {
      for (var n2 in e3)
        if (typeof e3[n2] == "object" && e3[n2].length > 0) {
          for (var i2 = 0; i2 < e3[n2].length; i2++)
            if (m(e3[n2][i2], t3))
              return n2 === "?" ? void 0 : n2;
        } else if (m(e3[n2], t3))
          return n2 === "?" ? void 0 : n2;
      return t3;
    }, x = { ME: "4.90", "NT 3.11": "NT3.51", "NT 4.0": "NT4.0", 2e3: "NT 5.0", XP: ["NT 5.1", "NT 5.2"], Vista: "NT 6.0", 7: "NT 6.1", 8: "NT 6.2", 8.1: "NT 6.3", 10: ["NT 6.4", "NT 10.0"], RT: "ARM" }, b = { browser: [[/\b(?:crmo|crios)\/([\w\.]+)/i], [h, [a, "Chrome"]], [/edg(?:e|ios|a)?\/([\w\.]+)/i], [h, [a, "Edge"]], [/(opera mini)\/([-\w\.]+)/i, /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i, /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i], [a, h], [/opios[\/ ]+([\w\.]+)/i], [h, [a, "Opera Mini"]], [/\bopr\/([\w\.]+)/i], [h, [a, "Opera"]], [/(kindle)\/([\w\.]+)/i, /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i, /(avant |iemobile|slim)(?:browser)?[\/ ]?([\w\.]*)/i, /(ba?idubrowser)[\/ ]?([\w\.]+)/i, /(?:ms|\()(ie) ([\w\.]+)/i, /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale|qqbrowserlite|qq)\/([-\w\.]+)/i, /(weibo)__([\d\.]+)/i], [a, h], [/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i], [h, [a, "UCBrowser"]], [/\bqbcore\/([\w\.]+)/i], [h, [a, "WeChat(Win) Desktop"]], [/micromessenger\/([\w\.]+)/i], [h, [a, "WeChat"]], [/konqueror\/([\w\.]+)/i], [h, [a, "Konqueror"]], [/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i], [h, [a, "IE"]], [/yabrowser\/([\w\.]+)/i], [h, [a, "Yandex"]], [/(avast|avg)\/([\w\.]+)/i], [[a, /(.+)/, "$1 Secure Browser"], h], [/\bfocus\/([\w\.]+)/i], [h, [a, "Firefox Focus"]], [/\bopt\/([\w\.]+)/i], [h, [a, "Opera Touch"]], [/coc_coc\w+\/([\w\.]+)/i], [h, [a, "Coc Coc"]], [/dolfin\/([\w\.]+)/i], [h, [a, "Dolphin"]], [/coast\/([\w\.]+)/i], [h, [a, "Opera Coast"]], [/miuibrowser\/([\w\.]+)/i], [h, [a, "MIUI Browser"]], [/fxios\/([-\w\.]+)/i], [h, [a, "Firefox"]], [/\bqihu|(qi?ho?o?|360)browser/i], [[a, "360 Browser"]], [/(oculus|samsung|sailfish)browser\/([\w\.]+)/i], [[a, /(.+)/, "$1 Browser"], h], [/(comodo_dragon)\/([\w\.]+)/i], [[a, /_/g, " "], h], [/(electron)\/([\w\.]+) safari/i, /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i, /m?(qqbrowser|baiduboxapp|2345Explorer)[\/ ]?([\w\.]+)/i], [a, h], [/(metasr)[\/ ]?([\w\.]+)/i, /(lbbrowser)/i], [a], [/((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i], [[a, "Facebook"], h], [/safari (line)\/([\w\.]+)/i, /\b(line)\/([\w\.]+)\/iab/i, /(chromium|instagram)[\/ ]([-\w\.]+)/i], [a, h], [/\bgsa\/([\w\.]+) .*safari\//i], [h, [a, "GSA"]], [/headlesschrome(?:\/([\w\.]+)| )/i], [h, [a, "Chrome Headless"]], [/ wv\).+(chrome)\/([\w\.]+)/i], [[a, "Chrome WebView"], h], [/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i], [h, [a, "Android Browser"]], [/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i], [a, h], [/version\/([\w\.]+) .*mobile\/\w+ (safari)/i], [h, [a, "Mobile Safari"]], [/version\/([\w\.]+) .*(mobile ?safari|safari)/i], [h, a], [/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i], [a, [h, y, { "1.0": "/8", 1.2: "/1", 1.3: "/3", "2.0": "/412", "2.0.2": "/416", "2.0.3": "/417", "2.0.4": "/419", "?": "/" }]], [/(webkit|khtml)\/([\w\.]+)/i], [a, h], [/(navigator|netscape\d?)\/([-\w\.]+)/i], [[a, "Netscape"], h], [/mobile vr; rv:([\w\.]+)\).+firefox/i], [h, [a, "Firefox Reality"]], [/ekiohf.+(flow)\/([\w\.]+)/i, /(swiftfox)/i, /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i, /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i, /(firefox)\/([\w\.]+)/i, /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i, /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i, /(links) \(([\w\.]+)/i], [a, h]], cpu: [[/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i], [["architecture", "amd64"]], [/(ia32(?=;))/i], [["architecture", g]], [/((?:i[346]|x)86)[;\)]/i], [["architecture", "ia32"]], [/\b(aarch64|arm(v?8e?l?|_?64))\b/i], [["architecture", "arm64"]], [/\b(arm(?:v[67])?ht?n?[fl]p?)\b/i], [["architecture", "armhf"]], [/windows (ce|mobile); ppc;/i], [["architecture", "arm"]], [/((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i], [["architecture", /ower/, "", g]], [/(sun4\w)[;\)]/i], [["architecture", "sparc"]], [/((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i], [["architecture", g]]], device: [[/\b(sch-i[89]0\d|shw-m380s|sm-[pt]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i], [s2, [u, "Samsung"], [l, d]], [/\b((?:s[cgp]h|gt|sm)-\w+|galaxy nexus)/i, /samsung[- ]([-\w]+)/i, /sec-(sgh\w+)/i], [s2, [u, "Samsung"], [l, c]], [/\((ip(?:hone|od)[\w ]*);/i], [s2, [u, "Apple"], [l, c]], [/\((ipad);[-\w\),; ]+apple/i, /applecoremedia\/[\w\.]+ \((ipad)/i, /\b(ipad)\d\d?,\d\d?[;\]].+ios/i], [s2, [u, "Apple"], [l, d]], [/\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i], [s2, [u, "Huawei"], [l, d]], [/(?:huawei|honor)([-\w ]+)[;\)]/i, /\b(nexus 6p|\w{2,4}-[atu]?[ln][01259x][012359][an]?)\b(?!.+d\/s)/i], [s2, [u, "Huawei"], [l, c]], [/\b(poco[\w ]+)(?: bui|\))/i, /\b; (\w+) build\/hm\1/i, /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i, /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i, /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i], [[s2, /_/g, " "], [u, "Xiaomi"], [l, c]], [/\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i], [[s2, /_/g, " "], [u, "Xiaomi"], [l, d]], [/; (\w+) bui.+ oppo/i, /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i], [s2, [u, "OPPO"], [l, c]], [/vivo (\w+)(?: bui|\))/i, /\b(v[12]\d{3}\w?[at])(?: bui|;)/i], [s2, [u, "Vivo"], [l, c]], [/\b(rmx[12]\d{3})(?: bui|;|\))/i], [s2, [u, "Realme"], [l, c]], [/\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i, /\bmot(?:orola)?[- ](\w*)/i, /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i], [s2, [u, "Motorola"], [l, c]], [/\b(mz60\d|xoom[2 ]{0,2}) build\//i], [s2, [u, "Motorola"], [l, d]], [/((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i], [s2, [u, "LG"], [l, d]], [/(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i, /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i, /\blg-?([\d\w]+) bui/i], [s2, [u, "LG"], [l, c]], [/(ideatab[-\w ]+)/i, /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i], [s2, [u, "Lenovo"], [l, d]], [/(?:maemo|nokia).*(n900|lumia \d+)/i, /nokia[-_ ]?([-\w\.]*)/i], [[s2, /_/g, " "], [u, "Nokia"], [l, c]], [/(pixel c)\b/i], [s2, [u, "Google"], [l, d]], [/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i], [s2, [u, "Google"], [l, c]], [/droid.+ ([c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i], [s2, [u, "Sony"], [l, c]], [/sony tablet [ps]/i, /\b(?:sony)?sgp\w+(?: bui|\))/i], [[s2, "Xperia Tablet"], [u, "Sony"], [l, d]], [/ (kb2005|in20[12]5|be20[12][59])\b/i, /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i], [s2, [u, "OnePlus"], [l, c]], [/(alexa)webm/i, /(kf[a-z]{2}wi)( bui|\))/i, /(kf[a-z]+)( bui|\)).+silk\//i], [s2, [u, "Amazon"], [l, d]], [/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i], [[s2, /(.+)/g, "Fire Phone $1"], [u, "Amazon"], [l, c]], [/(playbook);[-\w\),; ]+(rim)/i], [s2, u, [l, d]], [/\b((?:bb[a-f]|st[hv])100-\d)/i, /\(bb10; (\w+)/i], [s2, [u, "BlackBerry"], [l, c]], [/(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i], [s2, [u, "ASUS"], [l, d]], [/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i], [s2, [u, "ASUS"], [l, c]], [/(nexus 9)/i], [s2, [u, "HTC"], [l, d]], [/(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i, /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i, /(alcatel|geeksphone|nexian|panasonic|sony)[-_ ]?([-\w]*)/i], [u, [s2, /_/g, " "], [l, c]], [/droid.+; ([ab][1-7]-?[0178a]\d\d?)/i], [s2, [u, "Acer"], [l, d]], [/droid.+; (m[1-5] note) bui/i, /\bmz-([-\w]{2,})/i], [s2, [u, "Meizu"], [l, c]], [/\b(sh-?[altvz]?\d\d[a-ekm]?)/i], [s2, [u, "Sharp"], [l, c]], [/(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[-_ ]?([-\w]*)/i, /(hp) ([\w ]+\w)/i, /(asus)-?(\w+)/i, /(microsoft); (lumia[\w ]+)/i, /(lenovo)[-_ ]?([-\w]+)/i, /(jolla)/i, /(oppo) ?([\w ]+) bui/i], [u, s2, [l, c]], [/(archos) (gamepad2?)/i, /(hp).+(touchpad(?!.+tablet)|tablet)/i, /(kindle)\/([\w\.]+)/i, /(nook)[\w ]+build\/(\w+)/i, /(dell) (strea[kpr\d ]*[\dko])/i, /(le[- ]+pan)[- ]+(\w{1,9}) bui/i, /(trinity)[- ]*(t\d{3}) bui/i, /(gigaset)[- ]+(q\w{1,9}) bui/i, /(vodafone) ([\w ]+)(?:\)| bui)/i], [u, s2, [l, d]], [/(surface duo)/i], [s2, [u, "Microsoft"], [l, d]], [/droid [\d\.]+; (fp\du?)(?: b|\))/i], [s2, [u, "Fairphone"], [l, c]], [/(u304aa)/i], [s2, [u, "AT&T"], [l, c]], [/\bsie-(\w*)/i], [s2, [u, "Siemens"], [l, c]], [/\b(rct\w+) b/i], [s2, [u, "RCA"], [l, d]], [/\b(venue[\d ]{2,7}) b/i], [s2, [u, "Dell"], [l, d]], [/\b(q(?:mv|ta)\w+) b/i], [s2, [u, "Verizon"], [l, d]], [/\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i], [s2, [u, "Barnes & Noble"], [l, d]], [/\b(tm\d{3}\w+) b/i], [s2, [u, "NuVision"], [l, d]], [/\b(k88) b/i], [s2, [u, "ZTE"], [l, d]], [/\b(nx\d{3}j) b/i], [s2, [u, "ZTE"], [l, c]], [/\b(gen\d{3}) b.+49h/i], [s2, [u, "Swiss"], [l, c]], [/\b(zur\d{3}) b/i], [s2, [u, "Swiss"], [l, d]], [/\b((zeki)?tb.*\b) b/i], [s2, [u, "Zeki"], [l, d]], [/\b([yr]\d{2}) b/i, /\b(dragon[- ]+touch |dt)(\w{5}) b/i], [[u, "Dragon Touch"], s2, [l, d]], [/\b(ns-?\w{0,9}) b/i], [s2, [u, "Insignia"], [l, d]], [/\b((nxa|next)-?\w{0,9}) b/i], [s2, [u, "NextBook"], [l, d]], [/\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i], [[u, "Voice"], s2, [l, c]], [/\b(lvtel\-)?(v1[12]) b/i], [[u, "LvTel"], s2, [l, c]], [/\b(ph-1) /i], [s2, [u, "Essential"], [l, c]], [/\b(v(100md|700na|7011|917g).*\b) b/i], [s2, [u, "Envizen"], [l, d]], [/\b(trio[-\w\. ]+) b/i], [s2, [u, "MachSpeed"], [l, d]], [/\btu_(1491) b/i], [s2, [u, "Rotor"], [l, d]], [/(shield[\w ]+) b/i], [s2, [u, "Nvidia"], [l, d]], [/(sprint) (\w+)/i], [u, s2, [l, c]], [/(kin\.[onetw]{3})/i], [[s2, /\./g, " "], [u, "Microsoft"], [l, c]], [/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i], [s2, [u, "Zebra"], [l, d]], [/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i], [s2, [u, "Zebra"], [l, c]], [/(ouya)/i, /(nintendo) ([wids3utch]+)/i], [u, s2, [l, "console"]], [/droid.+; (shield) bui/i], [s2, [u, "Nvidia"], [l, "console"]], [/(playstation [345portablevi]+)/i], [s2, [u, "Sony"], [l, "console"]], [/\b(xbox(?: one)?(?!; xbox))[\); ]/i], [s2, [u, "Microsoft"], [l, "console"]], [/smart-tv.+(samsung)/i], [u, [l, p]], [/hbbtv.+maple;(\d+)/i], [[s2, /^/, "SmartTV"], [u, "Samsung"], [l, p]], [/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i], [[u, "LG"], [l, p]], [/(apple) ?tv/i], [u, [s2, "Apple TV"], [l, p]], [/crkey/i], [[s2, "Chromecast"], [u, "Google"], [l, p]], [/droid.+aft(\w)( bui|\))/i], [s2, [u, "Amazon"], [l, p]], [/\(dtv[\);].+(aquos)/i], [s2, [u, "Sharp"], [l, p]], [/\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i, /hbbtv\/\d+\.\d+\.\d+ +\([\w ]*; *(\w[^;]*);([^;]*)/i], [[u, v], [s2, v], [l, p]], [/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i], [[l, p]], [/((pebble))app/i], [u, s2, [l, "wearable"]], [/droid.+; (glass) \d/i], [s2, [u, "Google"], [l, "wearable"]], [/droid.+; (wt63?0{2,3})\)/i], [s2, [u, "Zebra"], [l, "wearable"]], [/(quest( 2)?)/i], [s2, [u, "Facebook"], [l, "wearable"]], [/(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i], [u, [l, "embedded"]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+? mobile safari/i], [s2, [l, c]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i], [s2, [l, d]], [/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i], [[l, d]], [/(phone|mobile(?:[;\/]| safari)|pda(?=.+windows ce))/i], [[l, c]], [/(android[-\w\. ]{0,9});.+buil/i], [s2, [u, "Generic"]]], engine: [[/windows.+ edge\/([\w\.]+)/i], [h, [a, "EdgeHTML"]], [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i], [h, [a, "Blink"]], [/(presto)\/([\w\.]+)/i, /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i, /ekioh(flow)\/([\w\.]+)/i, /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i, /(icab)[\/ ]([23]\.[\d\.]+)/i], [a, h], [/rv\:([\w\.]{1,9})\b.+(gecko)/i], [h, a]], os: [[/microsoft (windows) (vista|xp)/i], [a, h], [/(windows) nt 6\.2; (arm)/i, /(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i, /(windows)[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i], [a, [h, y, x]], [/(win(?=3|9|n)|win 9x )([nt\d\.]+)/i], [[a, "Windows"], [h, y, x]], [/ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i, /cfnetwork\/.+darwin/i], [[h, /_/g, "."], [a, "iOS"]], [/(mac os x) ?([\w\. ]*)/i, /(macintosh|mac_powerpc\b)(?!.+haiku)/i], [[a, "Mac OS"], [h, /_/g, "."]], [/droid ([\w\.]+)\b.+(android[- ]x86)/i], [h, a], [/(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i, /(blackberry)\w*\/([\w\.]*)/i, /(tizen|kaios)[\/ ]([\w\.]+)/i, /\((series40);/i], [a, h], [/\(bb(10);/i], [h, [a, "BlackBerry"]], [/(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i], [h, [a, "Symbian"]], [/mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i], [h, [a, "Firefox OS"]], [/web0s;.+rt(tv)/i, /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i], [h, [a, "webOS"]], [/crkey\/([\d\.]+)/i], [h, [a, "Chromecast"]], [/(cros) [\w]+ ([\w\.]+\w)/i], [[a, "Chromium OS"], h], [/(nintendo|playstation) ([wids345portablevuch]+)/i, /(xbox); +xbox ([^\);]+)/i, /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i, /(mint)[\/\(\) ]?(\w*)/i, /(mageia|vectorlinux)[; ]/i, /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i, /(hurd|linux) ?([\w\.]*)/i, /(gnu) ?([\w\.]*)/i, /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i, /(haiku) (\w+)/i], [a, h], [/(sunos) ?([\w\.\d]*)/i], [[a, "Solaris"], h], [/((?:open)?solaris)[-\/ ]?([\w\.]*)/i, /(aix) ((\d)(?=\.|\)| )[\w\.])*/i, /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux)/i, /(unix) ?([\w\.]*)/i], [a, h]] }, T = function(t3, e3) {
      if (typeof t3 == "object" && (e3 = t3, t3 = void 0), !(this instanceof T))
        return new T(t3, e3).getResult();
      var n2 = t3 || (r2 !== void 0 && r2.navigator && r2.navigator.userAgent ? r2.navigator.userAgent : ""), i2 = e3 ? function(t4, e4) {
        var n3 = {};
        for (var i3 in t4)
          e4[i3] && e4[i3].length % 2 == 0 ? n3[i3] = e4[i3].concat(t4[i3]) : n3[i3] = t4[i3];
        return n3;
      }(b, e3) : b;
      return this.getBrowser = function() {
        var t4, e4 = {};
        return e4[a] = void 0, e4[h] = void 0, _.call(e4, n2, i2.browser), e4.major = typeof (t4 = e4.version) == "string" ? t4.replace(/[^\d\.]/g, "").split(".")[0] : void 0, e4;
      }, this.getCPU = function() {
        var t4 = { architecture: void 0 };
        return _.call(t4, n2, i2.cpu), t4;
      }, this.getDevice = function() {
        var t4 = { vendor: void 0, model: void 0, type: void 0 };
        return _.call(t4, n2, i2.device), t4;
      }, this.getEngine = function() {
        var t4 = { name: void 0, version: void 0 };
        return _.call(t4, n2, i2.engine), t4;
      }, this.getOS = function() {
        var t4 = { name: void 0, version: void 0 };
        return _.call(t4, n2, i2.os), t4;
      }, this.getResult = function() {
        return { ua: this.getUA(), browser: this.getBrowser(), engine: this.getEngine(), os: this.getOS(), device: this.getDevice(), cpu: this.getCPU() };
      }, this.getUA = function() {
        return n2;
      }, this.setUA = function(t4) {
        return n2 = typeof t4 == "string" && t4.length > 255 ? v(t4, 255) : t4, this;
      }, this.setUA(n2), this;
    };
    T.VERSION = "1.0.2", T.BROWSER = f([a, h, "major"]), T.CPU = f(["architecture"]), T.DEVICE = f([s2, u, l, "console", c, p, d, "wearable", "embedded"]), T.ENGINE = T.OS = f([a, h]), e2 !== void 0 ? (t2 !== void 0 && t2.exports && (e2 = t2.exports = T), e2.UAParser = T) : n(64) ? (i = function() {
      return T;
    }.call(e2, n, e2, t2)) === void 0 || (t2.exports = i) : r2 !== void 0 && (r2.UAParser = T);
    var w = r2 !== void 0 && (r2.jQuery || r2.Zepto);
    if (w && !w.ua) {
      var S = new T();
      w.ua = S.getResult(), w.ua.get = function() {
        return S.getUA();
      }, w.ua.set = function(t3) {
        S.setUA(t3);
        var e3 = S.getResult();
        for (var n2 in e3)
          w.ua[n2] = e3[n2];
      };
    }
  }(typeof window == "object" ? window : this);
}, function(t2, e2, n) {
  (function(t3) {
    var i = t3 !== void 0 && t3 || typeof self != "undefined" && self || window, r2 = Function.prototype.apply;
    function o2(t4, e3) {
      this._id = t4, this._clearFn = e3;
    }
    e2.setTimeout = function() {
      return new o2(r2.call(setTimeout, i, arguments), clearTimeout);
    }, e2.setInterval = function() {
      return new o2(r2.call(setInterval, i, arguments), clearInterval);
    }, e2.clearTimeout = e2.clearInterval = function(t4) {
      t4 && t4.close();
    }, o2.prototype.unref = o2.prototype.ref = function() {
    }, o2.prototype.close = function() {
      this._clearFn.call(i, this._id);
    }, e2.enroll = function(t4, e3) {
      clearTimeout(t4._idleTimeoutId), t4._idleTimeout = e3;
    }, e2.unenroll = function(t4) {
      clearTimeout(t4._idleTimeoutId), t4._idleTimeout = -1;
    }, e2._unrefActive = e2.active = function(t4) {
      clearTimeout(t4._idleTimeoutId);
      var e3 = t4._idleTimeout;
      e3 >= 0 && (t4._idleTimeoutId = setTimeout(function() {
        t4._onTimeout && t4._onTimeout();
      }, e3));
    }, n(56), e2.setImmediate = typeof self != "undefined" && self.setImmediate || t3 !== void 0 && t3.setImmediate || this && this.setImmediate, e2.clearImmediate = typeof self != "undefined" && self.clearImmediate || t3 !== void 0 && t3.clearImmediate || this && this.clearImmediate;
  }).call(this, n(4));
}, function(t2, e2, n) {
  (function(t3, e3) {
    !function(t4, n2) {
      if (!t4.setImmediate) {
        var i, r2, o2, s2, a, l = 1, u = {}, h = false, c = t4.document, d = Object.getPrototypeOf && Object.getPrototypeOf(t4);
        d = d && d.setTimeout ? d : t4, {}.toString.call(t4.process) === "[object process]" ? i = function(t5) {
          e3.nextTick(function() {
            f(t5);
          });
        } : !function() {
          if (t4.postMessage && !t4.importScripts) {
            var e4 = true, n3 = t4.onmessage;
            return t4.onmessage = function() {
              e4 = false;
            }, t4.postMessage("", "*"), t4.onmessage = n3, e4;
          }
        }() ? t4.MessageChannel ? ((o2 = new MessageChannel()).port1.onmessage = function(t5) {
          f(t5.data);
        }, i = function(t5) {
          o2.port2.postMessage(t5);
        }) : c && "onreadystatechange" in c.createElement("script") ? (r2 = c.documentElement, i = function(t5) {
          var e4 = c.createElement("script");
          e4.onreadystatechange = function() {
            f(t5), e4.onreadystatechange = null, r2.removeChild(e4), e4 = null;
          }, r2.appendChild(e4);
        }) : i = function(t5) {
          setTimeout(f, 0, t5);
        } : (s2 = "setImmediate$" + Math.random() + "$", a = function(e4) {
          e4.source === t4 && typeof e4.data == "string" && e4.data.indexOf(s2) === 0 && f(+e4.data.slice(s2.length));
        }, t4.addEventListener ? t4.addEventListener("message", a, false) : t4.attachEvent("onmessage", a), i = function(e4) {
          t4.postMessage(s2 + e4, "*");
        }), d.setImmediate = function(t5) {
          typeof t5 != "function" && (t5 = new Function("" + t5));
          for (var e4 = new Array(arguments.length - 1), n3 = 0; n3 < e4.length; n3++)
            e4[n3] = arguments[n3 + 1];
          var r3 = { callback: t5, args: e4 };
          return u[l] = r3, i(l), l++;
        }, d.clearImmediate = p;
      }
      function p(t5) {
        delete u[t5];
      }
      function f(t5) {
        if (h)
          setTimeout(f, 0, t5);
        else {
          var e4 = u[t5];
          if (e4) {
            h = true;
            try {
              !function(t6) {
                var e5 = t6.callback, n3 = t6.args;
                switch (n3.length) {
                  case 0:
                    e5();
                    break;
                  case 1:
                    e5(n3[0]);
                    break;
                  case 2:
                    e5(n3[0], n3[1]);
                    break;
                  case 3:
                    e5(n3[0], n3[1], n3[2]);
                    break;
                  default:
                    e5.apply(void 0, n3);
                }
              }(e4);
            } finally {
              p(t5), h = false;
            }
          }
        }
      }
    }(typeof self == "undefined" ? t3 === void 0 ? this : t3 : self);
  }).call(this, n(4), n(57));
}, function(t2, e2) {
  var n, i, r2 = t2.exports = {};
  function o2() {
    throw new Error("setTimeout has not been defined");
  }
  function s2() {
    throw new Error("clearTimeout has not been defined");
  }
  function a(t3) {
    if (n === setTimeout)
      return setTimeout(t3, 0);
    if ((n === o2 || !n) && setTimeout)
      return n = setTimeout, setTimeout(t3, 0);
    try {
      return n(t3, 0);
    } catch (e3) {
      try {
        return n.call(null, t3, 0);
      } catch (e4) {
        return n.call(this, t3, 0);
      }
    }
  }
  !function() {
    try {
      n = typeof setTimeout == "function" ? setTimeout : o2;
    } catch (t3) {
      n = o2;
    }
    try {
      i = typeof clearTimeout == "function" ? clearTimeout : s2;
    } catch (t3) {
      i = s2;
    }
  }();
  var l, u = [], h = false, c = -1;
  function d() {
    h && l && (h = false, l.length ? u = l.concat(u) : c = -1, u.length && p());
  }
  function p() {
    if (!h) {
      var t3 = a(d);
      h = true;
      for (var e3 = u.length; e3; ) {
        for (l = u, u = []; ++c < e3; )
          l && l[c].run();
        c = -1, e3 = u.length;
      }
      l = null, h = false, function(t4) {
        if (i === clearTimeout)
          return clearTimeout(t4);
        if ((i === s2 || !i) && clearTimeout)
          return i = clearTimeout, clearTimeout(t4);
        try {
          i(t4);
        } catch (e4) {
          try {
            return i.call(null, t4);
          } catch (e5) {
            return i.call(this, t4);
          }
        }
      }(t3);
    }
  }
  function f(t3, e3) {
    this.fun = t3, this.array = e3;
  }
  function m() {
  }
  r2.nextTick = function(t3) {
    var e3 = new Array(arguments.length - 1);
    if (arguments.length > 1)
      for (var n2 = 1; n2 < arguments.length; n2++)
        e3[n2 - 1] = arguments[n2];
    u.push(new f(t3, e3)), u.length !== 1 || h || a(p);
  }, f.prototype.run = function() {
    this.fun.apply(null, this.array);
  }, r2.title = "browser", r2.browser = true, r2.env = {}, r2.argv = [], r2.version = "", r2.versions = {}, r2.on = m, r2.addListener = m, r2.once = m, r2.off = m, r2.removeListener = m, r2.removeAllListeners = m, r2.emit = m, r2.prependListener = m, r2.prependOnceListener = m, r2.listeners = function(t3) {
    return [];
  }, r2.binding = function(t3) {
    throw new Error("process.binding is not supported");
  }, r2.cwd = function() {
    return "/";
  }, r2.chdir = function(t3) {
    throw new Error("process.chdir is not supported");
  }, r2.umask = function() {
    return 0;
  };
}, function(t2, e2, n) {
  (function(t3, i) {
    var r2;
    /*! https://mths.be/punycode v1.4.1 by @mathias */
    !function(o2) {
      e2 && e2.nodeType, t3 && t3.nodeType;
      var s2 = typeof i == "object" && i;
      s2.global !== s2 && s2.window !== s2 && s2.self;
      var a, l = 2147483647, u = /^xn--/, h = /[^\x20-\x7E]/, c = /[\x2E\u3002\uFF0E\uFF61]/g, d = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" }, p = Math.floor, f = String.fromCharCode;
      function m(t4) {
        throw new RangeError(d[t4]);
      }
      function g(t4, e3) {
        for (var n2 = t4.length, i2 = []; n2--; )
          i2[n2] = e3(t4[n2]);
        return i2;
      }
      function v(t4, e3) {
        var n2 = t4.split("@"), i2 = "";
        return n2.length > 1 && (i2 = n2[0] + "@", t4 = n2[1]), i2 + g((t4 = t4.replace(c, ".")).split("."), e3).join(".");
      }
      function _(t4) {
        for (var e3, n2, i2 = [], r3 = 0, o3 = t4.length; r3 < o3; )
          (e3 = t4.charCodeAt(r3++)) >= 55296 && e3 <= 56319 && r3 < o3 ? (64512 & (n2 = t4.charCodeAt(r3++))) == 56320 ? i2.push(((1023 & e3) << 10) + (1023 & n2) + 65536) : (i2.push(e3), r3--) : i2.push(e3);
        return i2;
      }
      function y(t4) {
        return g(t4, function(t5) {
          var e3 = "";
          return t5 > 65535 && (e3 += f((t5 -= 65536) >>> 10 & 1023 | 55296), t5 = 56320 | 1023 & t5), e3 += f(t5);
        }).join("");
      }
      function x(t4, e3) {
        return t4 + 22 + 75 * (t4 < 26) - ((e3 != 0) << 5);
      }
      function b(t4, e3, n2) {
        var i2 = 0;
        for (t4 = n2 ? p(t4 / 700) : t4 >> 1, t4 += p(t4 / e3); t4 > 455; i2 += 36)
          t4 = p(t4 / 35);
        return p(i2 + 36 * t4 / (t4 + 38));
      }
      function T(t4) {
        var e3, n2, i2, r3, o3, s3, a2, u2, h2, c2, d2, f2 = [], g2 = t4.length, v2 = 0, _2 = 128, x2 = 72;
        for ((n2 = t4.lastIndexOf("-")) < 0 && (n2 = 0), i2 = 0; i2 < n2; ++i2)
          t4.charCodeAt(i2) >= 128 && m("not-basic"), f2.push(t4.charCodeAt(i2));
        for (r3 = n2 > 0 ? n2 + 1 : 0; r3 < g2; ) {
          for (o3 = v2, s3 = 1, a2 = 36; r3 >= g2 && m("invalid-input"), ((u2 = (d2 = t4.charCodeAt(r3++)) - 48 < 10 ? d2 - 22 : d2 - 65 < 26 ? d2 - 65 : d2 - 97 < 26 ? d2 - 97 : 36) >= 36 || u2 > p((l - v2) / s3)) && m("overflow"), v2 += u2 * s3, !(u2 < (h2 = a2 <= x2 ? 1 : a2 >= x2 + 26 ? 26 : a2 - x2)); a2 += 36)
            s3 > p(l / (c2 = 36 - h2)) && m("overflow"), s3 *= c2;
          x2 = b(v2 - o3, e3 = f2.length + 1, o3 == 0), p(v2 / e3) > l - _2 && m("overflow"), _2 += p(v2 / e3), v2 %= e3, f2.splice(v2++, 0, _2);
        }
        return y(f2);
      }
      function w(t4) {
        var e3, n2, i2, r3, o3, s3, a2, u2, h2, c2, d2, g2, v2, y2, T2, w2 = [];
        for (g2 = (t4 = _(t4)).length, e3 = 128, n2 = 0, o3 = 72, s3 = 0; s3 < g2; ++s3)
          (d2 = t4[s3]) < 128 && w2.push(f(d2));
        for (i2 = r3 = w2.length, r3 && w2.push("-"); i2 < g2; ) {
          for (a2 = l, s3 = 0; s3 < g2; ++s3)
            (d2 = t4[s3]) >= e3 && d2 < a2 && (a2 = d2);
          for (a2 - e3 > p((l - n2) / (v2 = i2 + 1)) && m("overflow"), n2 += (a2 - e3) * v2, e3 = a2, s3 = 0; s3 < g2; ++s3)
            if ((d2 = t4[s3]) < e3 && ++n2 > l && m("overflow"), d2 == e3) {
              for (u2 = n2, h2 = 36; !(u2 < (c2 = h2 <= o3 ? 1 : h2 >= o3 + 26 ? 26 : h2 - o3)); h2 += 36)
                T2 = u2 - c2, y2 = 36 - c2, w2.push(f(x(c2 + T2 % y2, 0))), u2 = p(T2 / y2);
              w2.push(f(x(u2, 0))), o3 = b(n2, v2, i2 == r3), n2 = 0, ++i2;
            }
          ++n2, ++e3;
        }
        return w2.join("");
      }
      a = { version: "1.4.1", ucs2: { decode: _, encode: y }, decode: T, encode: w, toASCII: function(t4) {
        return v(t4, function(t5) {
          return h.test(t5) ? "xn--" + w(t5) : t5;
        });
      }, toUnicode: function(t4) {
        return v(t4, function(t5) {
          return u.test(t5) ? T(t5.slice(4).toLowerCase()) : t5;
        });
      } }, (r2 = function() {
        return a;
      }.call(e2, n, e2, t3)) === void 0 || (t3.exports = r2);
    }();
  }).call(this, n(8)(t2), n(4));
}, function(t2, e2, n) {
  t2.exports = { isString: function(t3) {
    return typeof t3 == "string";
  }, isObject: function(t3) {
    return typeof t3 == "object" && t3 !== null;
  }, isNull: function(t3) {
    return t3 === null;
  }, isNullOrUndefined: function(t3) {
    return t3 == null;
  } };
}, function(t2, e2, n) {
  e2.decode = e2.parse = n(61), e2.encode = e2.stringify = n(62);
}, function(t2, e2, n) {
  function i(t3, e3) {
    return Object.prototype.hasOwnProperty.call(t3, e3);
  }
  t2.exports = function(t3, e3, n2, o2) {
    e3 = e3 || "&", n2 = n2 || "=";
    var s2 = {};
    if (typeof t3 != "string" || t3.length === 0)
      return s2;
    var a = /\+/g;
    t3 = t3.split(e3);
    var l = 1e3;
    o2 && typeof o2.maxKeys == "number" && (l = o2.maxKeys);
    var u = t3.length;
    l > 0 && u > l && (u = l);
    for (var h = 0; h < u; ++h) {
      var c, d, p, f, m = t3[h].replace(a, "%20"), g = m.indexOf(n2);
      g >= 0 ? (c = m.substr(0, g), d = m.substr(g + 1)) : (c = m, d = ""), p = decodeURIComponent(c), f = decodeURIComponent(d), i(s2, p) ? r2(s2[p]) ? s2[p].push(f) : s2[p] = [s2[p], f] : s2[p] = f;
    }
    return s2;
  };
  var r2 = Array.isArray || function(t3) {
    return Object.prototype.toString.call(t3) === "[object Array]";
  };
}, function(t2, e2, n) {
  var i = function(t3) {
    switch (typeof t3) {
      case "string":
        return t3;
      case "boolean":
        return t3 ? "true" : "false";
      case "number":
        return isFinite(t3) ? t3 : "";
      default:
        return "";
    }
  };
  t2.exports = function(t3, e3, n2, a) {
    return e3 = e3 || "&", n2 = n2 || "=", t3 === null && (t3 = void 0), typeof t3 == "object" ? o2(s2(t3), function(s3) {
      var a2 = encodeURIComponent(i(s3)) + n2;
      return r2(t3[s3]) ? o2(t3[s3], function(t4) {
        return a2 + encodeURIComponent(i(t4));
      }).join(e3) : a2 + encodeURIComponent(i(t3[s3]));
    }).join(e3) : a ? encodeURIComponent(i(a)) + n2 + encodeURIComponent(i(t3)) : "";
  };
  var r2 = Array.isArray || function(t3) {
    return Object.prototype.toString.call(t3) === "[object Array]";
  };
  function o2(t3, e3) {
    if (t3.map)
      return t3.map(e3);
    for (var n2 = [], i2 = 0; i2 < t3.length; i2++)
      n2.push(e3(t3[i2], i2));
    return n2;
  }
  var s2 = Object.keys || function(t3) {
    var e3 = [];
    for (var n2 in t3)
      Object.prototype.hasOwnProperty.call(t3, n2) && e3.push(n2);
    return e3;
  };
}, function(t2, e2) {
  var n = function() {
  };
  n.prototype = { fit: function(t3) {
    var e3, n2, i, r2, o2 = t3.length, s2 = o2 > 0 ? t3[0].width : 0, a = o2 > 0 ? t3[0].height : 0;
    for (this.root = { x: 0, y: 0, width: s2, height: a }, e3 = 0; e3 < o2; e3++)
      i = t3[e3], (n2 = this.findNode(this.root, i.width, i.height)) ? (r2 = this.splitNode(n2, i.width, i.height), i.x = r2.x, i.y = r2.y) : (r2 = this.growNode(i.width, i.height), i.x = r2.x, i.y = r2.y);
  }, findNode: function(t3, e3, n2) {
    return t3.used ? this.findNode(t3.right, e3, n2) || this.findNode(t3.down, e3, n2) : e3 <= t3.width && n2 <= t3.height ? t3 : null;
  }, splitNode: function(t3, e3, n2) {
    return t3.used = true, t3.down = { x: t3.x, y: t3.y + n2, width: t3.width, height: t3.height - n2 }, t3.right = { x: t3.x + e3, y: t3.y, width: t3.width - e3, height: n2 }, t3;
  }, growNode: function(t3, e3) {
    var n2 = t3 <= this.root.width, i = e3 <= this.root.height, r2 = i && this.root.height >= this.root.width + t3, o2 = n2 && this.root.width >= this.root.height + e3;
    return r2 ? this.growRight(t3, e3) : o2 ? this.growDown(t3, e3) : i ? this.growRight(t3, e3) : n2 ? this.growDown(t3, e3) : null;
  }, growRight: function(t3, e3) {
    var n2;
    return this.root = { used: true, x: 0, y: 0, width: this.root.width + t3, height: this.root.height, down: this.root, right: { x: this.root.width, y: 0, width: t3, height: this.root.height } }, (n2 = this.findNode(this.root, t3, e3)) ? this.splitNode(n2, t3, e3) : null;
  }, growDown: function(t3, e3) {
    var n2;
    return this.root = { used: true, x: 0, y: 0, width: this.root.width, height: this.root.height + e3, down: { x: 0, y: this.root.height, width: this.root.width, height: e3 }, right: this.root }, (n2 = this.findNode(this.root, t3, e3)) ? this.splitNode(n2, t3, e3) : null;
  } }, t2.exports = n;
}, function(t2, e2) {
  (function(e3) {
    t2.exports = e3;
  }).call(this, {});
}, function(t2, e2, n) {
  n.r(e2), n.d(e2, "delay", function() {
    return oI;
  }), n.d(e2, "waitUntil", function() {
    return sI;
  }), n.d(e2, "SLIDE_EVENTS", function() {
    return aI;
  }), n.d(e2, "Slide", function() {
    return hI;
  });
  var i = {};
  n.r(i), n.d(i, "ACESFilmicToneMapping", function() {
    return lt;
  }), n.d(i, "AddEquation", function() {
    return I;
  }), n.d(i, "AddOperation", function() {
    return it;
  }), n.d(i, "AdditiveAnimationBlendMode", function() {
    return Ke;
  }), n.d(i, "AdditiveBlending", function() {
    return A;
  }), n.d(i, "AlphaFormat", function() {
    return zt;
  }), n.d(i, "AlwaysDepth", function() {
    return Y;
  }), n.d(i, "AlwaysStencilFunc", function() {
    return Cn;
  }), n.d(i, "AmbientLight", function() {
    return Uc;
  }), n.d(i, "AmbientLightProbe", function() {
    return sd;
  }), n.d(i, "AnimationClip", function() {
    return oc;
  }), n.d(i, "AnimationLoader", function() {
    return pc;
  }), n.d(i, "AnimationMixer", function() {
    return Fd;
  }), n.d(i, "AnimationObjectGroup", function() {
    return Nd;
  }), n.d(i, "AnimationUtils", function() {
    return Xh;
  }), n.d(i, "ArcCurve", function() {
    return Au;
  }), n.d(i, "ArrayCamera", function() {
    return Ka;
  }), n.d(i, "ArrowHelper", function() {
    return Ep;
  }), n.d(i, "Audio", function() {
    return vd;
  }), n.d(i, "AudioAnalyser", function() {
    return wd;
  }), n.d(i, "AudioContext", function() {
    return id;
  }), n.d(i, "AudioListener", function() {
    return gd;
  }), n.d(i, "AudioLoader", function() {
    return rd;
  }), n.d(i, "AxesHelper", function() {
    return Mp;
  }), n.d(i, "AxisHelper", function() {
    return Mf;
  }), n.d(i, "BackSide", function() {
    return b;
  }), n.d(i, "BasicDepthPacking", function() {
    return cn;
  }), n.d(i, "BasicShadowMap", function() {
    return g;
  }), n.d(i, "BinaryTextureLoader", function() {
    return If;
  }), n.d(i, "Bone", function() {
    return Bl;
  }), n.d(i, "BooleanKeyframeTrack", function() {
    return Kh;
  }), n.d(i, "BoundingBoxHelper", function() {
    return Af;
  }), n.d(i, "Box2", function() {
    return Xd;
  }), n.d(i, "Box3", function() {
    return gi;
  }), n.d(i, "Box3Helper", function() {
    return xp;
  }), n.d(i, "BoxBufferGeometry", function() {
    return Ao;
  }), n.d(i, "BoxGeometry", function() {
    return Ao;
  }), n.d(i, "BoxHelper", function() {
    return yp;
  }), n.d(i, "BufferAttribute", function() {
    return kr;
  }), n.d(i, "BufferGeometry", function() {
    return so;
  }), n.d(i, "BufferGeometryLoader", function() {
    return Xc;
  }), n.d(i, "ByteType", function() {
    return It;
  }), n.d(i, "Cache", function() {
    return ac;
  }), n.d(i, "Camera", function() {
    return Oo;
  }), n.d(i, "CameraHelper", function() {
    return gp;
  }), n.d(i, "CanvasRenderer", function() {
    return Lf;
  }), n.d(i, "CanvasTexture", function() {
    return pu;
  }), n.d(i, "CatmullRomCurve3", function() {
    return Lu;
  }), n.d(i, "CineonToneMapping", function() {
    return at;
  }), n.d(i, "CircleBufferGeometry", function() {
    return mu;
  }), n.d(i, "CircleGeometry", function() {
    return mu;
  }), n.d(i, "ClampToEdgeWrapping", function() {
    return _t;
  }), n.d(i, "Clock", function() {
    return hd;
  }), n.d(i, "Color", function() {
    return Dr;
  }), n.d(i, "ColorKeyframeTrack", function() {
    return Qh;
  }), n.d(i, "CompressedTexture", function() {
    return du;
  }), n.d(i, "CompressedTextureLoader", function() {
    return fc;
  }), n.d(i, "ConeBufferGeometry", function() {
    return vu;
  }), n.d(i, "ConeGeometry", function() {
    return vu;
  }), n.d(i, "CubeCamera", function() {
    return No;
  }), n.d(i, "CubeReflectionMapping", function() {
    return ct;
  }), n.d(i, "CubeRefractionMapping", function() {
    return dt;
  }), n.d(i, "CubeTexture", function() {
    return Do;
  }), n.d(i, "CubeTextureLoader", function() {
    return gc;
  }), n.d(i, "CubeUVReflectionMapping", function() {
    return mt;
  }), n.d(i, "CubeUVRefractionMapping", function() {
    return gt;
  }), n.d(i, "CubicBezierCurve", function() {
    return Bu;
  }), n.d(i, "CubicBezierCurve3", function() {
    return Uu;
  }), n.d(i, "CubicInterpolant", function() {
    return Yh;
  }), n.d(i, "CullFaceBack", function() {
    return p;
  }), n.d(i, "CullFaceFront", function() {
    return f;
  }), n.d(i, "CullFaceFrontBack", function() {
    return m;
  }), n.d(i, "CullFaceNone", function() {
    return d;
  }), n.d(i, "Curve", function() {
    return Eu;
  }), n.d(i, "CurvePath", function() {
    return yc;
  }), n.d(i, "CustomBlending", function() {
    return C;
  }), n.d(i, "CustomToneMapping", function() {
    return ut;
  }), n.d(i, "CylinderBufferGeometry", function() {
    return gu;
  }), n.d(i, "CylinderGeometry", function() {
    return gu;
  }), n.d(i, "Cylindrical", function() {
    return Vd;
  }), n.d(i, "DataTexture", function() {
    return Ul;
  }), n.d(i, "DataTexture2DArray", function() {
    return hs;
  }), n.d(i, "DataTexture3D", function() {
    return cs2;
  }), n.d(i, "DataTextureLoader", function() {
    return vc;
  }), n.d(i, "DataUtils", function() {
    return Pp;
  }), n.d(i, "DecrementStencilOp", function() {
    return yn;
  }), n.d(i, "DecrementWrapStencilOp", function() {
    return bn;
  }), n.d(i, "DefaultLoadingManager", function() {
    return uc;
  }), n.d(i, "DepthFormat", function() {
    return Yt;
  }), n.d(i, "DepthStencilFormat", function() {
    return Zt;
  }), n.d(i, "DepthTexture", function() {
    return fu;
  }), n.d(i, "DirectionalLight", function() {
    return Bc;
  }), n.d(i, "DirectionalLightHelper", function() {
    return pp;
  }), n.d(i, "DiscreteInterpolant", function() {
    return Jh;
  }), n.d(i, "DodecahedronBufferGeometry", function() {
    return yu;
  }), n.d(i, "DodecahedronGeometry", function() {
    return yu;
  }), n.d(i, "DoubleSide", function() {
    return T;
  }), n.d(i, "DstAlphaFactor", function() {
    return z;
  }), n.d(i, "DstColorFactor", function() {
    return V;
  }), n.d(i, "DynamicBufferAttribute", function() {
    return gf;
  }), n.d(i, "DynamicCopyUsage", function() {
    return Un;
  }), n.d(i, "DynamicDrawUsage", function() {
    return On;
  }), n.d(i, "DynamicReadUsage", function() {
    return Dn;
  }), n.d(i, "EdgesGeometry", function() {
    return Su;
  }), n.d(i, "EdgesHelper", function() {
    return Rf;
  }), n.d(i, "EllipseCurve", function() {
    return Mu;
  }), n.d(i, "EqualDepth", function() {
    return $;
  }), n.d(i, "EqualStencilFunc", function() {
    return En;
  }), n.d(i, "EquirectangularReflectionMapping", function() {
    return pt;
  }), n.d(i, "EquirectangularRefractionMapping", function() {
    return ft;
  }), n.d(i, "Euler", function() {
    return tr;
  }), n.d(i, "EventDispatcher", function() {
    return zn;
  }), n.d(i, "ExtrudeBufferGeometry", function() {
    return yh;
  }), n.d(i, "ExtrudeGeometry", function() {
    return yh;
  }), n.d(i, "FaceColors", function() {
    return of;
  }), n.d(i, "FileLoader", function() {
    return dc;
  }), n.d(i, "FlatShading", function() {
    return w;
  }), n.d(i, "Float16BufferAttribute", function() {
    return qr;
  }), n.d(i, "Float32Attribute", function() {
    return Sf;
  }), n.d(i, "Float32BufferAttribute", function() {
    return Yr;
  }), n.d(i, "Float64Attribute", function() {
    return Ef;
  }), n.d(i, "Float64BufferAttribute", function() {
    return Zr;
  }), n.d(i, "FloatType", function() {
    return Ft;
  }), n.d(i, "Fog", function() {
    return al;
  }), n.d(i, "FogExp2", function() {
    return sl;
  }), n.d(i, "Font", function() {
    return Qc;
  }), n.d(i, "FontLoader", function() {
    return ed;
  }), n.d(i, "FrontSide", function() {
    return x;
  }), n.d(i, "Frustum", function() {
    return jo;
  }), n.d(i, "GLBufferAttribute", function() {
    return kd;
  }), n.d(i, "GLSL1", function() {
    return Gn;
  }), n.d(i, "GLSL3", function() {
    return Hn;
  }), n.d(i, "GammaEncoding", function() {
    return on;
  }), n.d(i, "GreaterDepth", function() {
    return Q;
  }), n.d(i, "GreaterEqualDepth", function() {
    return K;
  }), n.d(i, "GreaterEqualStencilFunc", function() {
    return Pn;
  }), n.d(i, "GreaterStencilFunc", function() {
    return An;
  }), n.d(i, "GridHelper", function() {
    return lp;
  }), n.d(i, "Group", function() {
    return Qa;
  }), n.d(i, "HalfFloatType", function() {
    return Bt;
  }), n.d(i, "HemisphereLight", function() {
    return wc;
  }), n.d(i, "HemisphereLightHelper", function() {
    return ap;
  }), n.d(i, "HemisphereLightProbe", function() {
    return od;
  }), n.d(i, "IcosahedronBufferGeometry", function() {
    return bh;
  }), n.d(i, "IcosahedronGeometry", function() {
    return bh;
  }), n.d(i, "ImageBitmapLoader", function() {
    return $c;
  }), n.d(i, "ImageLoader", function() {
    return mc;
  }), n.d(i, "ImageUtils", function() {
    return ri;
  }), n.d(i, "ImmediateRenderObject", function() {
    return Jd;
  }), n.d(i, "IncrementStencilOp", function() {
    return _n;
  }), n.d(i, "IncrementWrapStencilOp", function() {
    return xn;
  }), n.d(i, "InstancedBufferAttribute", function() {
    return Wc;
  }), n.d(i, "InstancedBufferGeometry", function() {
    return Vc;
  }), n.d(i, "InstancedInterleavedBuffer", function() {
    return Ud;
  }), n.d(i, "InstancedMesh", function() {
    return Xl;
  }), n.d(i, "Int16Attribute", function() {
    return xf;
  }), n.d(i, "Int16BufferAttribute", function() {
    return jr;
  }), n.d(i, "Int32Attribute", function() {
    return Tf;
  }), n.d(i, "Int32BufferAttribute", function() {
    return Wr;
  }), n.d(i, "Int8Attribute", function() {
    return vf;
  }), n.d(i, "Int8BufferAttribute", function() {
    return Gr;
  }), n.d(i, "IntType", function() {
    return Nt;
  }), n.d(i, "InterleavedBuffer", function() {
    return ul;
  }), n.d(i, "InterleavedBufferAttribute", function() {
    return cl;
  }), n.d(i, "Interpolant", function() {
    return qh;
  }), n.d(i, "InterpolateDiscrete", function() {
    return We;
  }), n.d(i, "InterpolateLinear", function() {
    return Xe;
  }), n.d(i, "InterpolateSmooth", function() {
    return qe;
  }), n.d(i, "InvertStencilOp", function() {
    return Tn;
  }), n.d(i, "JSONLoader", function() {
    return Nf;
  }), n.d(i, "KeepStencilOp", function() {
    return gn;
  }), n.d(i, "KeyframeTrack", function() {
    return $h;
  }), n.d(i, "LOD", function() {
    return Cl;
  }), n.d(i, "LatheBufferGeometry", function() {
    return Th;
  }), n.d(i, "LatheGeometry", function() {
    return Th;
  }), n.d(i, "Layers", function() {
    return er;
  }), n.d(i, "LensFlare", function() {
    return Ff;
  }), n.d(i, "LessDepth", function() {
    return Z;
  }), n.d(i, "LessEqualDepth", function() {
    return J;
  }), n.d(i, "LessEqualStencilFunc", function() {
    return Mn;
  }), n.d(i, "LessStencilFunc", function() {
    return Sn;
  }), n.d(i, "Light", function() {
    return Tc;
  }), n.d(i, "LightProbe", function() {
    return Hc;
  }), n.d(i, "Line", function() {
    return Ql;
  }), n.d(i, "Line3", function() {
    return Zd;
  }), n.d(i, "LineBasicMaterial", function() {
    return ql;
  }), n.d(i, "LineCurve", function() {
    return ku;
  }), n.d(i, "LineCurve3", function() {
    return Gu;
  }), n.d(i, "LineDashedMaterial", function() {
    return Vh;
  }), n.d(i, "LineLoop", function() {
    return iu;
  }), n.d(i, "LinePieces", function() {
    return nf;
  }), n.d(i, "LineSegments", function() {
    return nu;
  }), n.d(i, "LineStrip", function() {
    return ef;
  }), n.d(i, "LinearEncoding", function() {
    return nn;
  }), n.d(i, "LinearFilter", function() {
    return Et;
  }), n.d(i, "LinearInterpolant", function() {
    return Zh;
  }), n.d(i, "LinearMipMapLinearFilter", function() {
    return Pt;
  }), n.d(i, "LinearMipMapNearestFilter", function() {
    return At;
  }), n.d(i, "LinearMipmapLinearFilter", function() {
    return Rt;
  }), n.d(i, "LinearMipmapNearestFilter", function() {
    return Mt;
  }), n.d(i, "LinearToneMapping", function() {
    return ot;
  }), n.d(i, "Loader", function() {
    return hc;
  }), n.d(i, "LoaderUtils", function() {
    return jc;
  }), n.d(i, "LoadingManager", function() {
    return lc;
  }), n.d(i, "LogLuvEncoding", function() {
    return an;
  }), n.d(i, "LoopOnce", function() {
    return ze;
  }), n.d(i, "LoopPingPong", function() {
    return Ve;
  }), n.d(i, "LoopRepeat", function() {
    return je;
  }), n.d(i, "LuminanceAlphaFormat", function() {
    return Xt;
  }), n.d(i, "LuminanceFormat", function() {
    return Wt;
  }), n.d(i, "MOUSE", function() {
    return h;
  }), n.d(i, "Material", function() {
    return Rr;
  }), n.d(i, "MaterialLoader", function() {
    return zc;
  }), n.d(i, "Math", function() {
    return ti;
  }), n.d(i, "MathUtils", function() {
    return ti;
  }), n.d(i, "Matrix3", function() {
    return ni;
  }), n.d(i, "Matrix4", function() {
    return Vi;
  }), n.d(i, "MaxEquation", function() {
    return D;
  }), n.d(i, "Mesh", function() {
    return Eo;
  }), n.d(i, "MeshBasicMaterial", function() {
    return Fr;
  }), n.d(i, "MeshDepthMaterial", function() {
    return Xa;
  }), n.d(i, "MeshDistanceMaterial", function() {
    return qa;
  }), n.d(i, "MeshFaceMaterial", function() {
    return af;
  }), n.d(i, "MeshLambertMaterial", function() {
    return zh;
  }), n.d(i, "MeshMatcapMaterial", function() {
    return jh;
  }), n.d(i, "MeshNormalMaterial", function() {
    return Hh;
  }), n.d(i, "MeshPhongMaterial", function() {
    return kh;
  }), n.d(i, "MeshPhysicalMaterial", function() {
    return Uh;
  }), n.d(i, "MeshStandardMaterial", function() {
    return Bh;
  }), n.d(i, "MeshToonMaterial", function() {
    return Gh;
  }), n.d(i, "MinEquation", function() {
    return N;
  }), n.d(i, "MirroredRepeatWrapping", function() {
    return yt;
  }), n.d(i, "MixOperation", function() {
    return nt;
  }), n.d(i, "MultiMaterial", function() {
    return lf;
  }), n.d(i, "MultiplyBlending", function() {
    return P;
  }), n.d(i, "MultiplyOperation", function() {
    return et;
  }), n.d(i, "NearestFilter", function() {
    return xt;
  }), n.d(i, "NearestMipMapLinearFilter", function() {
    return St;
  }), n.d(i, "NearestMipMapNearestFilter", function() {
    return Tt;
  }), n.d(i, "NearestMipmapLinearFilter", function() {
    return wt;
  }), n.d(i, "NearestMipmapNearestFilter", function() {
    return bt;
  }), n.d(i, "NeverDepth", function() {
    return q;
  }), n.d(i, "NeverStencilFunc", function() {
    return wn;
  }), n.d(i, "NoBlending", function() {
    return E;
  }), n.d(i, "NoColors", function() {
    return rf;
  }), n.d(i, "NoToneMapping", function() {
    return rt;
  }), n.d(i, "NormalAnimationBlendMode", function() {
    return $e;
  }), n.d(i, "NormalBlending", function() {
    return M;
  }), n.d(i, "NotEqualDepth", function() {
    return tt;
  }), n.d(i, "NotEqualStencilFunc", function() {
    return Rn;
  }), n.d(i, "NumberKeyframeTrack", function() {
    return tc;
  }), n.d(i, "Object3D", function() {
    return mr;
  }), n.d(i, "ObjectLoader", function() {
    return qc;
  }), n.d(i, "ObjectSpaceNormalMap", function() {
    return fn;
  }), n.d(i, "OctahedronBufferGeometry", function() {
    return wh;
  }), n.d(i, "OctahedronGeometry", function() {
    return wh;
  }), n.d(i, "OneFactor", function() {
    return B;
  }), n.d(i, "OneMinusDstAlphaFactor", function() {
    return j;
  }), n.d(i, "OneMinusDstColorFactor", function() {
    return W;
  }), n.d(i, "OneMinusSrcAlphaFactor", function() {
    return H;
  }), n.d(i, "OneMinusSrcColorFactor", function() {
    return k;
  }), n.d(i, "OrthographicCamera", function() {
    return Dc;
  }), n.d(i, "PCFShadowMap", function() {
    return v;
  }), n.d(i, "PCFSoftShadowMap", function() {
    return _;
  }), n.d(i, "PMREMGenerator", function() {
    return Xp;
  }), n.d(i, "ParametricBufferGeometry", function() {
    return Sh;
  }), n.d(i, "ParametricGeometry", function() {
    return Sh;
  }), n.d(i, "Particle", function() {
    return hf;
  }), n.d(i, "ParticleBasicMaterial", function() {
    return pf;
  }), n.d(i, "ParticleSystem", function() {
    return cf;
  }), n.d(i, "ParticleSystemMaterial", function() {
    return ff;
  }), n.d(i, "Path", function() {
    return xc;
  }), n.d(i, "PerspectiveCamera", function() {
    return Lo;
  }), n.d(i, "Plane", function() {
    return Go;
  }), n.d(i, "PlaneBufferGeometry", function() {
    return Xo;
  }), n.d(i, "PlaneGeometry", function() {
    return Xo;
  }), n.d(i, "PlaneHelper", function() {
    return bp;
  }), n.d(i, "PointCloud", function() {
    return uf;
  }), n.d(i, "PointCloudMaterial", function() {
    return df;
  }), n.d(i, "PointLight", function() {
    return Nc;
  }), n.d(i, "PointLightHelper", function() {
    return ip;
  }), n.d(i, "Points", function() {
    return uu;
  }), n.d(i, "PointsMaterial", function() {
    return ru;
  }), n.d(i, "PolarGridHelper", function() {
    return up;
  }), n.d(i, "PolyhedronBufferGeometry", function() {
    return _u;
  }), n.d(i, "PolyhedronGeometry", function() {
    return _u;
  }), n.d(i, "PositionalAudio", function() {
    return Td;
  }), n.d(i, "PropertyBinding", function() {
    return Ld;
  }), n.d(i, "PropertyMixer", function() {
    return Sd;
  }), n.d(i, "QuadraticBezierCurve", function() {
    return Hu;
  }), n.d(i, "QuadraticBezierCurve3", function() {
    return zu;
  }), n.d(i, "Quaternion", function() {
    return di;
  }), n.d(i, "QuaternionKeyframeTrack", function() {
    return nc;
  }), n.d(i, "QuaternionLinearInterpolant", function() {
    return ec;
  }), n.d(i, "REVISION", function() {
    return u;
  }), n.d(i, "RGBADepthPacking", function() {
    return dn;
  }), n.d(i, "RGBAFormat", function() {
    return Vt;
  }), n.d(i, "RGBAIntegerFormat", function() {
    return ee;
  }), n.d(i, "RGBA_ASTC_10x10_Format", function() {
    return Se;
  }), n.d(i, "RGBA_ASTC_10x5_Format", function() {
    return be;
  }), n.d(i, "RGBA_ASTC_10x6_Format", function() {
    return Te;
  }), n.d(i, "RGBA_ASTC_10x8_Format", function() {
    return we;
  }), n.d(i, "RGBA_ASTC_12x10_Format", function() {
    return Ee;
  }), n.d(i, "RGBA_ASTC_12x12_Format", function() {
    return Me;
  }), n.d(i, "RGBA_ASTC_4x4_Format", function() {
    return pe;
  }), n.d(i, "RGBA_ASTC_5x4_Format", function() {
    return fe;
  }), n.d(i, "RGBA_ASTC_5x5_Format", function() {
    return me;
  }), n.d(i, "RGBA_ASTC_6x5_Format", function() {
    return ge;
  }), n.d(i, "RGBA_ASTC_6x6_Format", function() {
    return ve;
  }), n.d(i, "RGBA_ASTC_8x5_Format", function() {
    return _e;
  }), n.d(i, "RGBA_ASTC_8x6_Format", function() {
    return ye;
  }), n.d(i, "RGBA_ASTC_8x8_Format", function() {
    return xe;
  }), n.d(i, "RGBA_BPTC_Format", function() {
    return Ae;
  }), n.d(i, "RGBA_ETC2_EAC_Format", function() {
    return de;
  }), n.d(i, "RGBA_PVRTC_2BPPV1_Format", function() {
    return ue;
  }), n.d(i, "RGBA_PVRTC_4BPPV1_Format", function() {
    return le;
  }), n.d(i, "RGBA_S3TC_DXT1_Format", function() {
    return ie;
  }), n.d(i, "RGBA_S3TC_DXT3_Format", function() {
    return re;
  }), n.d(i, "RGBA_S3TC_DXT5_Format", function() {
    return oe;
  }), n.d(i, "RGBDEncoding", function() {
    return hn;
  }), n.d(i, "RGBEEncoding", function() {
    return sn;
  }), n.d(i, "RGBEFormat", function() {
    return qt;
  }), n.d(i, "RGBFormat", function() {
    return jt;
  }), n.d(i, "RGBIntegerFormat", function() {
    return te;
  }), n.d(i, "RGBM16Encoding", function() {
    return un;
  }), n.d(i, "RGBM7Encoding", function() {
    return ln;
  }), n.d(i, "RGB_ETC1_Format", function() {
    return he;
  }), n.d(i, "RGB_ETC2_Format", function() {
    return ce;
  }), n.d(i, "RGB_PVRTC_2BPPV1_Format", function() {
    return ae;
  }), n.d(i, "RGB_PVRTC_4BPPV1_Format", function() {
    return se;
  }), n.d(i, "RGB_S3TC_DXT1_Format", function() {
    return ne;
  }), n.d(i, "RGFormat", function() {
    return Kt;
  }), n.d(i, "RGIntegerFormat", function() {
    return Qt;
  }), n.d(i, "RawShaderMaterial", function() {
    return Fh;
  }), n.d(i, "Ray", function() {
    return ji;
  }), n.d(i, "Raycaster", function() {
    return Gd;
  }), n.d(i, "RectAreaLight", function() {
    return kc;
  }), n.d(i, "RedFormat", function() {
    return Jt;
  }), n.d(i, "RedIntegerFormat", function() {
    return $t;
  }), n.d(i, "ReinhardToneMapping", function() {
    return st;
  }), n.d(i, "RepeatWrapping", function() {
    return vt;
  }), n.d(i, "ReplaceStencilOp", function() {
    return vn;
  }), n.d(i, "ReverseSubtractEquation", function() {
    return L;
  }), n.d(i, "RingBufferGeometry", function() {
    return Eh;
  }), n.d(i, "RingGeometry", function() {
    return Eh;
  }), n.d(i, "SRGB8_ALPHA8_ASTC_10x10_Format", function() {
    return ke;
  }), n.d(i, "SRGB8_ALPHA8_ASTC_10x5_Format", function() {
    return Fe;
  }), n.d(i, "SRGB8_ALPHA8_ASTC_10x6_Format", function() {
    return Be;
  }), n.d(i, "SRGB8_ALPHA8_ASTC_10x8_Format", function() {
    return Ue;
  }), n.d(i, "SRGB8_ALPHA8_ASTC_12x10_Format", function() {
    return Ge;
  }), n.d(i, "SRGB8_ALPHA8_ASTC_12x12_Format", function() {
    return He;
  }), n.d(i, "SRGB8_ALPHA8_ASTC_4x4_Format", function() {
    return Re;
  }), n.d(i, "SRGB8_ALPHA8_ASTC_5x4_Format", function() {
    return Pe;
  }), n.d(i, "SRGB8_ALPHA8_ASTC_5x5_Format", function() {
    return Ce;
  }), n.d(i, "SRGB8_ALPHA8_ASTC_6x5_Format", function() {
    return Ie;
  }), n.d(i, "SRGB8_ALPHA8_ASTC_6x6_Format", function() {
    return Oe;
  }), n.d(i, "SRGB8_ALPHA8_ASTC_8x5_Format", function() {
    return Le;
  }), n.d(i, "SRGB8_ALPHA8_ASTC_8x6_Format", function() {
    return Ne;
  }), n.d(i, "SRGB8_ALPHA8_ASTC_8x8_Format", function() {
    return De;
  }), n.d(i, "Scene", function() {
    return ll;
  }), n.d(i, "SceneUtils", function() {
    return Df;
  }), n.d(i, "ShaderChunk", function() {
    return qo;
  }), n.d(i, "ShaderLib", function() {
    return Zo;
  }), n.d(i, "ShaderMaterial", function() {
    return Io;
  }), n.d(i, "ShadowMaterial", function() {
    return Dh;
  }), n.d(i, "Shape", function() {
    return bc;
  }), n.d(i, "ShapeBufferGeometry", function() {
    return Mh;
  }), n.d(i, "ShapeGeometry", function() {
    return Mh;
  }), n.d(i, "ShapePath", function() {
    return Kc;
  }), n.d(i, "ShapeUtils", function() {
    return gh;
  }), n.d(i, "ShortType", function() {
    return Ot;
  }), n.d(i, "Skeleton", function() {
    return Hl;
  }), n.d(i, "SkeletonHelper", function() {
    return np;
  }), n.d(i, "SkinnedMesh", function() {
    return Fl;
  }), n.d(i, "SmoothShading", function() {
    return S;
  }), n.d(i, "Sphere", function() {
    return Di;
  }), n.d(i, "SphereBufferGeometry", function() {
    return Ah;
  }), n.d(i, "SphereGeometry", function() {
    return Ah;
  }), n.d(i, "Spherical", function() {
    return jd;
  }), n.d(i, "SphericalHarmonics3", function() {
    return Gc;
  }), n.d(i, "SplineCurve", function() {
    return ju;
  }), n.d(i, "SpotLight", function() {
    return Pc;
  }), n.d(i, "SpotLightHelper", function() {
    return Kd;
  }), n.d(i, "Sprite", function() {
    return Ml;
  }), n.d(i, "SpriteMaterial", function() {
    return dl;
  }), n.d(i, "SrcAlphaFactor", function() {
    return G;
  }), n.d(i, "SrcAlphaSaturateFactor", function() {
    return X;
  }), n.d(i, "SrcColorFactor", function() {
    return U;
  }), n.d(i, "StaticCopyUsage", function() {
    return Bn;
  }), n.d(i, "StaticDrawUsage", function() {
    return In;
  }), n.d(i, "StaticReadUsage", function() {
    return Nn;
  }), n.d(i, "StereoCamera", function() {
    return ud;
  }), n.d(i, "StreamCopyUsage", function() {
    return kn;
  }), n.d(i, "StreamDrawUsage", function() {
    return Ln;
  }), n.d(i, "StreamReadUsage", function() {
    return Fn;
  }), n.d(i, "StringKeyframeTrack", function() {
    return ic;
  }), n.d(i, "SubtractEquation", function() {
    return O;
  }), n.d(i, "SubtractiveBlending", function() {
    return R;
  }), n.d(i, "TOUCH", function() {
    return c;
  }), n.d(i, "TangentSpaceNormalMap", function() {
    return pn;
  }), n.d(i, "TetrahedronBufferGeometry", function() {
    return Rh;
  }), n.d(i, "TetrahedronGeometry", function() {
    return Rh;
  }), n.d(i, "TextBufferGeometry", function() {
    return Ph;
  }), n.d(i, "TextGeometry", function() {
    return Ph;
  }), n.d(i, "Texture", function() {
    return si;
  }), n.d(i, "TextureLoader", function() {
    return _c;
  }), n.d(i, "TorusBufferGeometry", function() {
    return Ch;
  }), n.d(i, "TorusGeometry", function() {
    return Ch;
  }), n.d(i, "TorusKnotBufferGeometry", function() {
    return Ih;
  }), n.d(i, "TorusKnotGeometry", function() {
    return Ih;
  }), n.d(i, "Triangle", function() {
    return Mr;
  }), n.d(i, "TriangleFanDrawMode", function() {
    return en;
  }), n.d(i, "TriangleStripDrawMode", function() {
    return tn;
  }), n.d(i, "TrianglesDrawMode", function() {
    return Qe;
  }), n.d(i, "TubeBufferGeometry", function() {
    return Oh;
  }), n.d(i, "TubeGeometry", function() {
    return Oh;
  }), n.d(i, "UVMapping", function() {
    return ht;
  }), n.d(i, "Uint16Attribute", function() {
    return bf;
  }), n.d(i, "Uint16BufferAttribute", function() {
    return Vr;
  }), n.d(i, "Uint32Attribute", function() {
    return wf;
  }), n.d(i, "Uint32BufferAttribute", function() {
    return Xr;
  }), n.d(i, "Uint8Attribute", function() {
    return _f;
  }), n.d(i, "Uint8BufferAttribute", function() {
    return Hr;
  }), n.d(i, "Uint8ClampedAttribute", function() {
    return yf;
  }), n.d(i, "Uint8ClampedBufferAttribute", function() {
    return zr;
  }), n.d(i, "Uniform", function() {
    return Bd;
  }), n.d(i, "UniformsLib", function() {
    return Yo;
  }), n.d(i, "UniformsUtils", function() {
    return Co;
  }), n.d(i, "UnsignedByteType", function() {
    return Ct;
  }), n.d(i, "UnsignedInt248Type", function() {
    return Ht;
  }), n.d(i, "UnsignedIntType", function() {
    return Dt;
  }), n.d(i, "UnsignedShort4444Type", function() {
    return Ut;
  }), n.d(i, "UnsignedShort5551Type", function() {
    return kt;
  }), n.d(i, "UnsignedShort565Type", function() {
    return Gt;
  }), n.d(i, "UnsignedShortType", function() {
    return Lt;
  }), n.d(i, "VSMShadowMap", function() {
    return y;
  }), n.d(i, "Vector2", function() {
    return ei;
  }), n.d(i, "Vector3", function() {
    return pi;
  }), n.d(i, "Vector4", function() {
    return li;
  }), n.d(i, "VectorKeyframeTrack", function() {
    return rc;
  }), n.d(i, "Vertex", function() {
    return mf;
  }), n.d(i, "VertexColors", function() {
    return sf;
  }), n.d(i, "VideoTexture", function() {
    return cu;
  }), n.d(i, "WebGL1Renderer", function() {
    return ol;
  }), n.d(i, "WebGLCubeRenderTarget", function() {
    return Fo;
  }), n.d(i, "WebGLMultipleRenderTargets", function() {
    return hi;
  }), n.d(i, "WebGLMultisampleRenderTarget", function() {
    return ci;
  }), n.d(i, "WebGLRenderTarget", function() {
    return ui;
  }), n.d(i, "WebGLRenderTargetCube", function() {
    return Of;
  }), n.d(i, "WebGLRenderer", function() {
    return rl;
  }), n.d(i, "WebGLUtils", function() {
    return $a;
  }), n.d(i, "WireframeGeometry", function() {
    return Lh;
  }), n.d(i, "WireframeHelper", function() {
    return Pf;
  }), n.d(i, "WrapAroundEnding", function() {
    return Je;
  }), n.d(i, "XHRLoader", function() {
    return Cf;
  }), n.d(i, "ZeroCurvatureEnding", function() {
    return Ye;
  }), n.d(i, "ZeroFactor", function() {
    return F;
  }), n.d(i, "ZeroSlopeEnding", function() {
    return Ze;
  }), n.d(i, "ZeroStencilOp", function() {
    return mn;
  }), n.d(i, "sRGBEncoding", function() {
    return rn;
  });
  var r2 = {};
  n.r(r2), n.d(r2, "isMobile", function() {
    return Zg;
  }), n.d(r2, "EventEmitter", function() {
    return vv.a;
  }), n.d(r2, "earcut", function() {
    return yv.a;
  }), n.d(r2, "BaseTextureCache", function() {
    return Kv;
  }), n.d(r2, "CanvasRenderTarget", function() {
    return e_;
  }), n.d(r2, "DATA_URI", function() {
    return r_;
  }), n.d(r2, "ProgramCache", function() {
    return Jv;
  }), n.d(r2, "TextureCache", function() {
    return $v;
  }), n.d(r2, "clearTextureCache", function() {
    return t_;
  }), n.d(r2, "correctBlendMode", function() {
    return Lv;
  }), n.d(r2, "createIndicesForQuads", function() {
    return Bv;
  }), n.d(r2, "decomposeDataUri", function() {
    return o_;
  }), n.d(r2, "deprecation", function() {
    return Zv;
  }), n.d(r2, "destroyTextureCache", function() {
    return Qv;
  }), n.d(r2, "determineCrossOrigin", function() {
    return s_;
  }), n.d(r2, "getBufferType", function() {
    return Uv;
  }), n.d(r2, "getResolutionOfUrl", function() {
    return a_;
  }), n.d(r2, "hex2rgb", function() {
    return Rv;
  }), n.d(r2, "hex2string", function() {
    return Pv;
  }), n.d(r2, "interleaveTypedArrays", function() {
    return Gv;
  }), n.d(r2, "isPow2", function() {
    return zv;
  }), n.d(r2, "isWebGLSupported", function() {
    return Mv;
  }), n.d(r2, "log2", function() {
    return jv;
  }), n.d(r2, "nextPow2", function() {
    return Hv;
  }), n.d(r2, "premultiplyBlendMode", function() {
    return Ov;
  }), n.d(r2, "premultiplyRgba", function() {
    return Nv;
  }), n.d(r2, "premultiplyTint", function() {
    return Dv;
  }), n.d(r2, "premultiplyTintToRgba", function() {
    return Fv;
  }), n.d(r2, "removeItems", function() {
    return Vv;
  }), n.d(r2, "rgb2hex", function() {
    return Iv;
  }), n.d(r2, "sayHello", function() {
    return Ev;
  }), n.d(r2, "sign", function() {
    return Wv;
  }), n.d(r2, "skipHello", function() {
    return Sv;
  }), n.d(r2, "string2hex", function() {
    return Cv;
  }), n.d(r2, "trimCanvas", function() {
    return n_;
  }), n.d(r2, "uid", function() {
    return qv;
  }), n.d(r2, "url", function() {
    return bv;
  });
  var o2 = n(6), s2 = n(0), a = n.n(s2), l = n(1);
  /**
   * @license
   * Copyright 2010-2021 Three.js Authors
   * SPDX-License-Identifier: MIT
   */
  const u = "130", h = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, c = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, d = 0, p = 1, f = 2, m = 3, g = 0, v = 1, _ = 2, y = 3, x = 0, b = 1, T = 2, w = 1, S = 2, E = 0, M = 1, A = 2, R = 3, P = 4, C = 5, I = 100, O = 101, L = 102, N = 103, D = 104, F = 200, B = 201, U = 202, k = 203, G = 204, H = 205, z = 206, j = 207, V = 208, W = 209, X = 210, q = 0, Y = 1, Z = 2, J = 3, $ = 4, K = 5, Q = 6, tt = 7, et = 0, nt = 1, it = 2, rt = 0, ot = 1, st = 2, at = 3, lt = 4, ut = 5, ht = 300, ct = 301, dt = 302, pt = 303, ft = 304, mt = 306, gt = 307, vt = 1e3, _t = 1001, yt = 1002, xt = 1003, bt = 1004, Tt = 1004, wt = 1005, St = 1005, Et = 1006, Mt = 1007, At = 1007, Rt = 1008, Pt = 1008, Ct = 1009, It = 1010, Ot = 1011, Lt = 1012, Nt = 1013, Dt = 1014, Ft = 1015, Bt = 1016, Ut = 1017, kt = 1018, Gt = 1019, Ht = 1020, zt = 1021, jt = 1022, Vt = 1023, Wt = 1024, Xt = 1025, qt = Vt, Yt = 1026, Zt = 1027, Jt = 1028, $t = 1029, Kt = 1030, Qt = 1031, te = 1032, ee = 1033, ne = 33776, ie = 33777, re = 33778, oe = 33779, se = 35840, ae = 35841, le = 35842, ue = 35843, he = 36196, ce = 37492, de = 37496, pe = 37808, fe = 37809, me = 37810, ge = 37811, ve = 37812, _e = 37813, ye = 37814, xe = 37815, be = 37816, Te = 37817, we = 37818, Se = 37819, Ee = 37820, Me = 37821, Ae = 36492, Re = 37840, Pe = 37841, Ce = 37842, Ie = 37843, Oe = 37844, Le = 37845, Ne = 37846, De = 37847, Fe = 37848, Be = 37849, Ue = 37850, ke = 37851, Ge = 37852, He = 37853, ze = 2200, je = 2201, Ve = 2202, We = 2300, Xe = 2301, qe = 2302, Ye = 2400, Ze = 2401, Je = 2402, $e = 2500, Ke = 2501, Qe = 0, tn = 1, en = 2, nn = 3e3, rn = 3001, on = 3007, sn = 3002, an = 3003, ln = 3004, un = 3005, hn = 3006, cn = 3200, dn = 3201, pn = 0, fn = 1, mn = 0, gn = 7680, vn = 7681, _n = 7682, yn = 7683, xn = 34055, bn = 34056, Tn = 5386, wn = 512, Sn = 513, En = 514, Mn = 515, An = 516, Rn = 517, Pn = 518, Cn = 519, In = 35044, On = 35048, Ln = 35040, Nn = 35045, Dn = 35049, Fn = 35041, Bn = 35046, Un = 35050, kn = 35042, Gn = "100", Hn = "300 es";
  class zn {
    addEventListener(t3, e3) {
      this._listeners === void 0 && (this._listeners = {});
      const n2 = this._listeners;
      n2[t3] === void 0 && (n2[t3] = []), n2[t3].indexOf(e3) === -1 && n2[t3].push(e3);
    }
    hasEventListener(t3, e3) {
      if (this._listeners === void 0)
        return false;
      const n2 = this._listeners;
      return n2[t3] !== void 0 && n2[t3].indexOf(e3) !== -1;
    }
    removeEventListener(t3, e3) {
      if (this._listeners === void 0)
        return;
      const n2 = this._listeners[t3];
      if (n2 !== void 0) {
        const t4 = n2.indexOf(e3);
        t4 !== -1 && n2.splice(t4, 1);
      }
    }
    dispatchEvent(t3) {
      if (this._listeners === void 0)
        return;
      const e3 = this._listeners[t3.type];
      if (e3 !== void 0) {
        t3.target = this;
        const n2 = e3.slice(0);
        for (let e4 = 0, i2 = n2.length; e4 < i2; e4++)
          n2[e4].call(this, t3);
        t3.target = null;
      }
    }
  }
  const jn = [];
  for (let t3 = 0; t3 < 256; t3++)
    jn[t3] = (t3 < 16 ? "0" : "") + t3.toString(16);
  let Vn = 1234567;
  const Wn = Math.PI / 180, Xn = 180 / Math.PI;
  function qn() {
    const t3 = 4294967295 * Math.random() | 0, e3 = 4294967295 * Math.random() | 0, n2 = 4294967295 * Math.random() | 0, i2 = 4294967295 * Math.random() | 0;
    return (jn[255 & t3] + jn[t3 >> 8 & 255] + jn[t3 >> 16 & 255] + jn[t3 >> 24 & 255] + "-" + jn[255 & e3] + jn[e3 >> 8 & 255] + "-" + jn[e3 >> 16 & 15 | 64] + jn[e3 >> 24 & 255] + "-" + jn[63 & n2 | 128] + jn[n2 >> 8 & 255] + "-" + jn[n2 >> 16 & 255] + jn[n2 >> 24 & 255] + jn[255 & i2] + jn[i2 >> 8 & 255] + jn[i2 >> 16 & 255] + jn[i2 >> 24 & 255]).toUpperCase();
  }
  function Yn(t3, e3, n2) {
    return Math.max(e3, Math.min(n2, t3));
  }
  function Zn(t3, e3) {
    return (t3 % e3 + e3) % e3;
  }
  function Jn(t3, e3, n2) {
    return (1 - n2) * t3 + n2 * e3;
  }
  function $n(t3) {
    return (t3 & t3 - 1) == 0 && t3 !== 0;
  }
  function Kn(t3) {
    return Math.pow(2, Math.ceil(Math.log(t3) / Math.LN2));
  }
  function Qn(t3) {
    return Math.pow(2, Math.floor(Math.log(t3) / Math.LN2));
  }
  var ti = Object.freeze({ __proto__: null, DEG2RAD: Wn, RAD2DEG: Xn, generateUUID: qn, clamp: Yn, euclideanModulo: Zn, mapLinear: function(t3, e3, n2, i2, r3) {
    return i2 + (t3 - e3) * (r3 - i2) / (n2 - e3);
  }, inverseLerp: function(t3, e3, n2) {
    return t3 !== e3 ? (n2 - t3) / (e3 - t3) : 0;
  }, lerp: Jn, damp: function(t3, e3, n2, i2) {
    return Jn(t3, e3, 1 - Math.exp(-n2 * i2));
  }, pingpong: function(t3, e3 = 1) {
    return e3 - Math.abs(Zn(t3, 2 * e3) - e3);
  }, smoothstep: function(t3, e3, n2) {
    return t3 <= e3 ? 0 : t3 >= n2 ? 1 : (t3 = (t3 - e3) / (n2 - e3)) * t3 * (3 - 2 * t3);
  }, smootherstep: function(t3, e3, n2) {
    return t3 <= e3 ? 0 : t3 >= n2 ? 1 : (t3 = (t3 - e3) / (n2 - e3)) * t3 * t3 * (t3 * (6 * t3 - 15) + 10);
  }, randInt: function(t3, e3) {
    return t3 + Math.floor(Math.random() * (e3 - t3 + 1));
  }, randFloat: function(t3, e3) {
    return t3 + Math.random() * (e3 - t3);
  }, randFloatSpread: function(t3) {
    return t3 * (0.5 - Math.random());
  }, seededRandom: function(t3) {
    return t3 !== void 0 && (Vn = t3 % 2147483647), Vn = 16807 * Vn % 2147483647, (Vn - 1) / 2147483646;
  }, degToRad: function(t3) {
    return t3 * Wn;
  }, radToDeg: function(t3) {
    return t3 * Xn;
  }, isPowerOfTwo: $n, ceilPowerOfTwo: Kn, floorPowerOfTwo: Qn, setQuaternionFromProperEuler: function(t3, e3, n2, i2, r3) {
    const o3 = Math.cos, s3 = Math.sin, a2 = o3(n2 / 2), l2 = s3(n2 / 2), u2 = o3((e3 + i2) / 2), h2 = s3((e3 + i2) / 2), c2 = o3((e3 - i2) / 2), d2 = s3((e3 - i2) / 2), p2 = o3((i2 - e3) / 2), f2 = s3((i2 - e3) / 2);
    switch (r3) {
      case "XYX":
        t3.set(a2 * h2, l2 * c2, l2 * d2, a2 * u2);
        break;
      case "YZY":
        t3.set(l2 * d2, a2 * h2, l2 * c2, a2 * u2);
        break;
      case "ZXZ":
        t3.set(l2 * c2, l2 * d2, a2 * h2, a2 * u2);
        break;
      case "XZX":
        t3.set(a2 * h2, l2 * f2, l2 * p2, a2 * u2);
        break;
      case "YXY":
        t3.set(l2 * p2, a2 * h2, l2 * f2, a2 * u2);
        break;
      case "ZYZ":
        t3.set(l2 * f2, l2 * p2, a2 * h2, a2 * u2);
        break;
      default:
        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r3);
    }
  } });
  class ei {
    constructor(t3 = 0, e3 = 0) {
      this.x = t3, this.y = e3;
    }
    get width() {
      return this.x;
    }
    set width(t3) {
      this.x = t3;
    }
    get height() {
      return this.y;
    }
    set height(t3) {
      this.y = t3;
    }
    set(t3, e3) {
      return this.x = t3, this.y = e3, this;
    }
    setScalar(t3) {
      return this.x = t3, this.y = t3, this;
    }
    setX(t3) {
      return this.x = t3, this;
    }
    setY(t3) {
      return this.y = t3, this;
    }
    setComponent(t3, e3) {
      switch (t3) {
        case 0:
          this.x = e3;
          break;
        case 1:
          this.y = e3;
          break;
        default:
          throw new Error("index is out of range: " + t3);
      }
      return this;
    }
    getComponent(t3) {
      switch (t3) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        default:
          throw new Error("index is out of range: " + t3);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y);
    }
    copy(t3) {
      return this.x = t3.x, this.y = t3.y, this;
    }
    add(t3, e3) {
      return e3 !== void 0 ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t3, e3)) : (this.x += t3.x, this.y += t3.y, this);
    }
    addScalar(t3) {
      return this.x += t3, this.y += t3, this;
    }
    addVectors(t3, e3) {
      return this.x = t3.x + e3.x, this.y = t3.y + e3.y, this;
    }
    addScaledVector(t3, e3) {
      return this.x += t3.x * e3, this.y += t3.y * e3, this;
    }
    sub(t3, e3) {
      return e3 !== void 0 ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t3, e3)) : (this.x -= t3.x, this.y -= t3.y, this);
    }
    subScalar(t3) {
      return this.x -= t3, this.y -= t3, this;
    }
    subVectors(t3, e3) {
      return this.x = t3.x - e3.x, this.y = t3.y - e3.y, this;
    }
    multiply(t3) {
      return this.x *= t3.x, this.y *= t3.y, this;
    }
    multiplyScalar(t3) {
      return this.x *= t3, this.y *= t3, this;
    }
    divide(t3) {
      return this.x /= t3.x, this.y /= t3.y, this;
    }
    divideScalar(t3) {
      return this.multiplyScalar(1 / t3);
    }
    applyMatrix3(t3) {
      const e3 = this.x, n2 = this.y, i2 = t3.elements;
      return this.x = i2[0] * e3 + i2[3] * n2 + i2[6], this.y = i2[1] * e3 + i2[4] * n2 + i2[7], this;
    }
    min(t3) {
      return this.x = Math.min(this.x, t3.x), this.y = Math.min(this.y, t3.y), this;
    }
    max(t3) {
      return this.x = Math.max(this.x, t3.x), this.y = Math.max(this.y, t3.y), this;
    }
    clamp(t3, e3) {
      return this.x = Math.max(t3.x, Math.min(e3.x, this.x)), this.y = Math.max(t3.y, Math.min(e3.y, this.y)), this;
    }
    clampScalar(t3, e3) {
      return this.x = Math.max(t3, Math.min(e3, this.x)), this.y = Math.max(t3, Math.min(e3, this.y)), this;
    }
    clampLength(t3, e3) {
      const n2 = this.length();
      return this.divideScalar(n2 || 1).multiplyScalar(Math.max(t3, Math.min(e3, n2)));
    }
    floor() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
    }
    ceil() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
    }
    round() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
    }
    roundToZero() {
      return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this;
    }
    negate() {
      return this.x = -this.x, this.y = -this.y, this;
    }
    dot(t3) {
      return this.x * t3.x + this.y * t3.y;
    }
    cross(t3) {
      return this.x * t3.y - this.y * t3.x;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    angle() {
      return Math.atan2(-this.y, -this.x) + Math.PI;
    }
    distanceTo(t3) {
      return Math.sqrt(this.distanceToSquared(t3));
    }
    distanceToSquared(t3) {
      const e3 = this.x - t3.x, n2 = this.y - t3.y;
      return e3 * e3 + n2 * n2;
    }
    manhattanDistanceTo(t3) {
      return Math.abs(this.x - t3.x) + Math.abs(this.y - t3.y);
    }
    setLength(t3) {
      return this.normalize().multiplyScalar(t3);
    }
    lerp(t3, e3) {
      return this.x += (t3.x - this.x) * e3, this.y += (t3.y - this.y) * e3, this;
    }
    lerpVectors(t3, e3, n2) {
      return this.x = t3.x + (e3.x - t3.x) * n2, this.y = t3.y + (e3.y - t3.y) * n2, this;
    }
    equals(t3) {
      return t3.x === this.x && t3.y === this.y;
    }
    fromArray(t3, e3 = 0) {
      return this.x = t3[e3], this.y = t3[e3 + 1], this;
    }
    toArray(t3 = [], e3 = 0) {
      return t3[e3] = this.x, t3[e3 + 1] = this.y, t3;
    }
    fromBufferAttribute(t3, e3, n2) {
      return n2 !== void 0 && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t3.getX(e3), this.y = t3.getY(e3), this;
    }
    rotateAround(t3, e3) {
      const n2 = Math.cos(e3), i2 = Math.sin(e3), r3 = this.x - t3.x, o3 = this.y - t3.y;
      return this.x = r3 * n2 - o3 * i2 + t3.x, this.y = r3 * i2 + o3 * n2 + t3.y, this;
    }
    random() {
      return this.x = Math.random(), this.y = Math.random(), this;
    }
  }
  ei.prototype.isVector2 = true;
  class ni {
    constructor() {
      this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
    }
    set(t3, e3, n2, i2, r3, o3, s3, a2, l2) {
      const u2 = this.elements;
      return u2[0] = t3, u2[1] = i2, u2[2] = s3, u2[3] = e3, u2[4] = r3, u2[5] = a2, u2[6] = n2, u2[7] = o3, u2[8] = l2, this;
    }
    identity() {
      return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
    }
    copy(t3) {
      const e3 = this.elements, n2 = t3.elements;
      return e3[0] = n2[0], e3[1] = n2[1], e3[2] = n2[2], e3[3] = n2[3], e3[4] = n2[4], e3[5] = n2[5], e3[6] = n2[6], e3[7] = n2[7], e3[8] = n2[8], this;
    }
    extractBasis(t3, e3, n2) {
      return t3.setFromMatrix3Column(this, 0), e3.setFromMatrix3Column(this, 1), n2.setFromMatrix3Column(this, 2), this;
    }
    setFromMatrix4(t3) {
      const e3 = t3.elements;
      return this.set(e3[0], e3[4], e3[8], e3[1], e3[5], e3[9], e3[2], e3[6], e3[10]), this;
    }
    multiply(t3) {
      return this.multiplyMatrices(this, t3);
    }
    premultiply(t3) {
      return this.multiplyMatrices(t3, this);
    }
    multiplyMatrices(t3, e3) {
      const n2 = t3.elements, i2 = e3.elements, r3 = this.elements, o3 = n2[0], s3 = n2[3], a2 = n2[6], l2 = n2[1], u2 = n2[4], h2 = n2[7], c2 = n2[2], d2 = n2[5], p2 = n2[8], f2 = i2[0], m2 = i2[3], g2 = i2[6], v2 = i2[1], _2 = i2[4], y2 = i2[7], x2 = i2[2], b2 = i2[5], T2 = i2[8];
      return r3[0] = o3 * f2 + s3 * v2 + a2 * x2, r3[3] = o3 * m2 + s3 * _2 + a2 * b2, r3[6] = o3 * g2 + s3 * y2 + a2 * T2, r3[1] = l2 * f2 + u2 * v2 + h2 * x2, r3[4] = l2 * m2 + u2 * _2 + h2 * b2, r3[7] = l2 * g2 + u2 * y2 + h2 * T2, r3[2] = c2 * f2 + d2 * v2 + p2 * x2, r3[5] = c2 * m2 + d2 * _2 + p2 * b2, r3[8] = c2 * g2 + d2 * y2 + p2 * T2, this;
    }
    multiplyScalar(t3) {
      const e3 = this.elements;
      return e3[0] *= t3, e3[3] *= t3, e3[6] *= t3, e3[1] *= t3, e3[4] *= t3, e3[7] *= t3, e3[2] *= t3, e3[5] *= t3, e3[8] *= t3, this;
    }
    determinant() {
      const t3 = this.elements, e3 = t3[0], n2 = t3[1], i2 = t3[2], r3 = t3[3], o3 = t3[4], s3 = t3[5], a2 = t3[6], l2 = t3[7], u2 = t3[8];
      return e3 * o3 * u2 - e3 * s3 * l2 - n2 * r3 * u2 + n2 * s3 * a2 + i2 * r3 * l2 - i2 * o3 * a2;
    }
    invert() {
      const t3 = this.elements, e3 = t3[0], n2 = t3[1], i2 = t3[2], r3 = t3[3], o3 = t3[4], s3 = t3[5], a2 = t3[6], l2 = t3[7], u2 = t3[8], h2 = u2 * o3 - s3 * l2, c2 = s3 * a2 - u2 * r3, d2 = l2 * r3 - o3 * a2, p2 = e3 * h2 + n2 * c2 + i2 * d2;
      if (p2 === 0)
        return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
      const f2 = 1 / p2;
      return t3[0] = h2 * f2, t3[1] = (i2 * l2 - u2 * n2) * f2, t3[2] = (s3 * n2 - i2 * o3) * f2, t3[3] = c2 * f2, t3[4] = (u2 * e3 - i2 * a2) * f2, t3[5] = (i2 * r3 - s3 * e3) * f2, t3[6] = d2 * f2, t3[7] = (n2 * a2 - l2 * e3) * f2, t3[8] = (o3 * e3 - n2 * r3) * f2, this;
    }
    transpose() {
      let t3;
      const e3 = this.elements;
      return t3 = e3[1], e3[1] = e3[3], e3[3] = t3, t3 = e3[2], e3[2] = e3[6], e3[6] = t3, t3 = e3[5], e3[5] = e3[7], e3[7] = t3, this;
    }
    getNormalMatrix(t3) {
      return this.setFromMatrix4(t3).invert().transpose();
    }
    transposeIntoArray(t3) {
      const e3 = this.elements;
      return t3[0] = e3[0], t3[1] = e3[3], t3[2] = e3[6], t3[3] = e3[1], t3[4] = e3[4], t3[5] = e3[7], t3[6] = e3[2], t3[7] = e3[5], t3[8] = e3[8], this;
    }
    setUvTransform(t3, e3, n2, i2, r3, o3, s3) {
      const a2 = Math.cos(r3), l2 = Math.sin(r3);
      return this.set(n2 * a2, n2 * l2, -n2 * (a2 * o3 + l2 * s3) + o3 + t3, -i2 * l2, i2 * a2, -i2 * (-l2 * o3 + a2 * s3) + s3 + e3, 0, 0, 1), this;
    }
    scale(t3, e3) {
      const n2 = this.elements;
      return n2[0] *= t3, n2[3] *= t3, n2[6] *= t3, n2[1] *= e3, n2[4] *= e3, n2[7] *= e3, this;
    }
    rotate(t3) {
      const e3 = Math.cos(t3), n2 = Math.sin(t3), i2 = this.elements, r3 = i2[0], o3 = i2[3], s3 = i2[6], a2 = i2[1], l2 = i2[4], u2 = i2[7];
      return i2[0] = e3 * r3 + n2 * a2, i2[3] = e3 * o3 + n2 * l2, i2[6] = e3 * s3 + n2 * u2, i2[1] = -n2 * r3 + e3 * a2, i2[4] = -n2 * o3 + e3 * l2, i2[7] = -n2 * s3 + e3 * u2, this;
    }
    translate(t3, e3) {
      const n2 = this.elements;
      return n2[0] += t3 * n2[2], n2[3] += t3 * n2[5], n2[6] += t3 * n2[8], n2[1] += e3 * n2[2], n2[4] += e3 * n2[5], n2[7] += e3 * n2[8], this;
    }
    equals(t3) {
      const e3 = this.elements, n2 = t3.elements;
      for (let t4 = 0; t4 < 9; t4++)
        if (e3[t4] !== n2[t4])
          return false;
      return true;
    }
    fromArray(t3, e3 = 0) {
      for (let n2 = 0; n2 < 9; n2++)
        this.elements[n2] = t3[n2 + e3];
      return this;
    }
    toArray(t3 = [], e3 = 0) {
      const n2 = this.elements;
      return t3[e3] = n2[0], t3[e3 + 1] = n2[1], t3[e3 + 2] = n2[2], t3[e3 + 3] = n2[3], t3[e3 + 4] = n2[4], t3[e3 + 5] = n2[5], t3[e3 + 6] = n2[6], t3[e3 + 7] = n2[7], t3[e3 + 8] = n2[8], t3;
    }
    clone() {
      return new this.constructor().fromArray(this.elements);
    }
  }
  let ii;
  ni.prototype.isMatrix3 = true;
  class ri {
    static getDataURL(t3) {
      if (/^data:/i.test(t3.src))
        return t3.src;
      if (typeof HTMLCanvasElement == "undefined")
        return t3.src;
      let e3;
      if (t3 instanceof HTMLCanvasElement)
        e3 = t3;
      else {
        ii === void 0 && (ii = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), ii.width = t3.width, ii.height = t3.height;
        const n2 = ii.getContext("2d");
        t3 instanceof ImageData ? n2.putImageData(t3, 0, 0) : n2.drawImage(t3, 0, 0, t3.width, t3.height), e3 = ii;
      }
      return e3.width > 2048 || e3.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t3), e3.toDataURL("image/jpeg", 0.6)) : e3.toDataURL("image/png");
    }
  }
  let oi = 0;
  class si extends zn {
    constructor(t3 = si.DEFAULT_IMAGE, e3 = si.DEFAULT_MAPPING, n2 = _t, i2 = _t, r3 = Et, o3 = Rt, s3 = Vt, a2 = Ct, l2 = 1, u2 = nn) {
      super(), Object.defineProperty(this, "id", { value: oi++ }), this.uuid = qn(), this.name = "", this.image = t3, this.mipmaps = [], this.mapping = e3, this.wrapS = n2, this.wrapT = i2, this.magFilter = r3, this.minFilter = o3, this.anisotropy = l2, this.format = s3, this.internalFormat = null, this.type = a2, this.offset = new ei(0, 0), this.repeat = new ei(1, 1), this.center = new ei(0, 0), this.rotation = 0, this.matrixAutoUpdate = true, this.matrix = new ni(), this.generateMipmaps = true, this.premultiplyAlpha = false, this.flipY = true, this.unpackAlignment = 4, this.encoding = u2, this.version = 0, this.onUpdate = null;
    }
    updateMatrix() {
      this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t3) {
      return this.name = t3.name, this.image = t3.image, this.mipmaps = t3.mipmaps.slice(0), this.mapping = t3.mapping, this.wrapS = t3.wrapS, this.wrapT = t3.wrapT, this.magFilter = t3.magFilter, this.minFilter = t3.minFilter, this.anisotropy = t3.anisotropy, this.format = t3.format, this.internalFormat = t3.internalFormat, this.type = t3.type, this.offset.copy(t3.offset), this.repeat.copy(t3.repeat), this.center.copy(t3.center), this.rotation = t3.rotation, this.matrixAutoUpdate = t3.matrixAutoUpdate, this.matrix.copy(t3.matrix), this.generateMipmaps = t3.generateMipmaps, this.premultiplyAlpha = t3.premultiplyAlpha, this.flipY = t3.flipY, this.unpackAlignment = t3.unpackAlignment, this.encoding = t3.encoding, this;
    }
    toJSON(t3) {
      const e3 = t3 === void 0 || typeof t3 == "string";
      if (!e3 && t3.textures[this.uuid] !== void 0)
        return t3.textures[this.uuid];
      const n2 = { metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment };
      if (this.image !== void 0) {
        const i2 = this.image;
        if (i2.uuid === void 0 && (i2.uuid = qn()), !e3 && t3.images[i2.uuid] === void 0) {
          let e4;
          if (Array.isArray(i2)) {
            e4 = [];
            for (let t4 = 0, n3 = i2.length; t4 < n3; t4++)
              i2[t4].isDataTexture ? e4.push(ai(i2[t4].image)) : e4.push(ai(i2[t4]));
          } else
            e4 = ai(i2);
          t3.images[i2.uuid] = { uuid: i2.uuid, url: e4 };
        }
        n2.image = i2.uuid;
      }
      return e3 || (t3.textures[this.uuid] = n2), n2;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
    transformUv(t3) {
      if (this.mapping !== ht)
        return t3;
      if (t3.applyMatrix3(this.matrix), t3.x < 0 || t3.x > 1)
        switch (this.wrapS) {
          case vt:
            t3.x = t3.x - Math.floor(t3.x);
            break;
          case _t:
            t3.x = t3.x < 0 ? 0 : 1;
            break;
          case yt:
            Math.abs(Math.floor(t3.x) % 2) === 1 ? t3.x = Math.ceil(t3.x) - t3.x : t3.x = t3.x - Math.floor(t3.x);
        }
      if (t3.y < 0 || t3.y > 1)
        switch (this.wrapT) {
          case vt:
            t3.y = t3.y - Math.floor(t3.y);
            break;
          case _t:
            t3.y = t3.y < 0 ? 0 : 1;
            break;
          case yt:
            Math.abs(Math.floor(t3.y) % 2) === 1 ? t3.y = Math.ceil(t3.y) - t3.y : t3.y = t3.y - Math.floor(t3.y);
        }
      return this.flipY && (t3.y = 1 - t3.y), t3;
    }
    set needsUpdate(t3) {
      t3 === true && this.version++;
    }
  }
  function ai(t3) {
    return typeof HTMLImageElement != "undefined" && t3 instanceof HTMLImageElement || typeof HTMLCanvasElement != "undefined" && t3 instanceof HTMLCanvasElement || typeof ImageBitmap != "undefined" && t3 instanceof ImageBitmap ? ri.getDataURL(t3) : t3.data ? { data: Array.prototype.slice.call(t3.data), width: t3.width, height: t3.height, type: t3.data.constructor.name } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
  }
  si.DEFAULT_IMAGE = void 0, si.DEFAULT_MAPPING = ht, si.prototype.isTexture = true;
  class li {
    constructor(t3 = 0, e3 = 0, n2 = 0, i2 = 1) {
      this.x = t3, this.y = e3, this.z = n2, this.w = i2;
    }
    get width() {
      return this.z;
    }
    set width(t3) {
      this.z = t3;
    }
    get height() {
      return this.w;
    }
    set height(t3) {
      this.w = t3;
    }
    set(t3, e3, n2, i2) {
      return this.x = t3, this.y = e3, this.z = n2, this.w = i2, this;
    }
    setScalar(t3) {
      return this.x = t3, this.y = t3, this.z = t3, this.w = t3, this;
    }
    setX(t3) {
      return this.x = t3, this;
    }
    setY(t3) {
      return this.y = t3, this;
    }
    setZ(t3) {
      return this.z = t3, this;
    }
    setW(t3) {
      return this.w = t3, this;
    }
    setComponent(t3, e3) {
      switch (t3) {
        case 0:
          this.x = e3;
          break;
        case 1:
          this.y = e3;
          break;
        case 2:
          this.z = e3;
          break;
        case 3:
          this.w = e3;
          break;
        default:
          throw new Error("index is out of range: " + t3);
      }
      return this;
    }
    getComponent(t3) {
      switch (t3) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        case 3:
          return this.w;
        default:
          throw new Error("index is out of range: " + t3);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z, this.w);
    }
    copy(t3) {
      return this.x = t3.x, this.y = t3.y, this.z = t3.z, this.w = t3.w !== void 0 ? t3.w : 1, this;
    }
    add(t3, e3) {
      return e3 !== void 0 ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t3, e3)) : (this.x += t3.x, this.y += t3.y, this.z += t3.z, this.w += t3.w, this);
    }
    addScalar(t3) {
      return this.x += t3, this.y += t3, this.z += t3, this.w += t3, this;
    }
    addVectors(t3, e3) {
      return this.x = t3.x + e3.x, this.y = t3.y + e3.y, this.z = t3.z + e3.z, this.w = t3.w + e3.w, this;
    }
    addScaledVector(t3, e3) {
      return this.x += t3.x * e3, this.y += t3.y * e3, this.z += t3.z * e3, this.w += t3.w * e3, this;
    }
    sub(t3, e3) {
      return e3 !== void 0 ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t3, e3)) : (this.x -= t3.x, this.y -= t3.y, this.z -= t3.z, this.w -= t3.w, this);
    }
    subScalar(t3) {
      return this.x -= t3, this.y -= t3, this.z -= t3, this.w -= t3, this;
    }
    subVectors(t3, e3) {
      return this.x = t3.x - e3.x, this.y = t3.y - e3.y, this.z = t3.z - e3.z, this.w = t3.w - e3.w, this;
    }
    multiply(t3) {
      return this.x *= t3.x, this.y *= t3.y, this.z *= t3.z, this.w *= t3.w, this;
    }
    multiplyScalar(t3) {
      return this.x *= t3, this.y *= t3, this.z *= t3, this.w *= t3, this;
    }
    applyMatrix4(t3) {
      const e3 = this.x, n2 = this.y, i2 = this.z, r3 = this.w, o3 = t3.elements;
      return this.x = o3[0] * e3 + o3[4] * n2 + o3[8] * i2 + o3[12] * r3, this.y = o3[1] * e3 + o3[5] * n2 + o3[9] * i2 + o3[13] * r3, this.z = o3[2] * e3 + o3[6] * n2 + o3[10] * i2 + o3[14] * r3, this.w = o3[3] * e3 + o3[7] * n2 + o3[11] * i2 + o3[15] * r3, this;
    }
    divideScalar(t3) {
      return this.multiplyScalar(1 / t3);
    }
    setAxisAngleFromQuaternion(t3) {
      this.w = 2 * Math.acos(t3.w);
      const e3 = Math.sqrt(1 - t3.w * t3.w);
      return e3 < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t3.x / e3, this.y = t3.y / e3, this.z = t3.z / e3), this;
    }
    setAxisAngleFromRotationMatrix(t3) {
      let e3, n2, i2, r3;
      const o3 = t3.elements, s3 = o3[0], a2 = o3[4], l2 = o3[8], u2 = o3[1], h2 = o3[5], c2 = o3[9], d2 = o3[2], p2 = o3[6], f2 = o3[10];
      if (Math.abs(a2 - u2) < 0.01 && Math.abs(l2 - d2) < 0.01 && Math.abs(c2 - p2) < 0.01) {
        if (Math.abs(a2 + u2) < 0.1 && Math.abs(l2 + d2) < 0.1 && Math.abs(c2 + p2) < 0.1 && Math.abs(s3 + h2 + f2 - 3) < 0.1)
          return this.set(1, 0, 0, 0), this;
        e3 = Math.PI;
        const t4 = (s3 + 1) / 2, o4 = (h2 + 1) / 2, m3 = (f2 + 1) / 2, g2 = (a2 + u2) / 4, v2 = (l2 + d2) / 4, _2 = (c2 + p2) / 4;
        return t4 > o4 && t4 > m3 ? t4 < 0.01 ? (n2 = 0, i2 = 0.707106781, r3 = 0.707106781) : (n2 = Math.sqrt(t4), i2 = g2 / n2, r3 = v2 / n2) : o4 > m3 ? o4 < 0.01 ? (n2 = 0.707106781, i2 = 0, r3 = 0.707106781) : (i2 = Math.sqrt(o4), n2 = g2 / i2, r3 = _2 / i2) : m3 < 0.01 ? (n2 = 0.707106781, i2 = 0.707106781, r3 = 0) : (r3 = Math.sqrt(m3), n2 = v2 / r3, i2 = _2 / r3), this.set(n2, i2, r3, e3), this;
      }
      let m2 = Math.sqrt((p2 - c2) * (p2 - c2) + (l2 - d2) * (l2 - d2) + (u2 - a2) * (u2 - a2));
      return Math.abs(m2) < 1e-3 && (m2 = 1), this.x = (p2 - c2) / m2, this.y = (l2 - d2) / m2, this.z = (u2 - a2) / m2, this.w = Math.acos((s3 + h2 + f2 - 1) / 2), this;
    }
    min(t3) {
      return this.x = Math.min(this.x, t3.x), this.y = Math.min(this.y, t3.y), this.z = Math.min(this.z, t3.z), this.w = Math.min(this.w, t3.w), this;
    }
    max(t3) {
      return this.x = Math.max(this.x, t3.x), this.y = Math.max(this.y, t3.y), this.z = Math.max(this.z, t3.z), this.w = Math.max(this.w, t3.w), this;
    }
    clamp(t3, e3) {
      return this.x = Math.max(t3.x, Math.min(e3.x, this.x)), this.y = Math.max(t3.y, Math.min(e3.y, this.y)), this.z = Math.max(t3.z, Math.min(e3.z, this.z)), this.w = Math.max(t3.w, Math.min(e3.w, this.w)), this;
    }
    clampScalar(t3, e3) {
      return this.x = Math.max(t3, Math.min(e3, this.x)), this.y = Math.max(t3, Math.min(e3, this.y)), this.z = Math.max(t3, Math.min(e3, this.z)), this.w = Math.max(t3, Math.min(e3, this.w)), this;
    }
    clampLength(t3, e3) {
      const n2 = this.length();
      return this.divideScalar(n2 || 1).multiplyScalar(Math.max(t3, Math.min(e3, n2)));
    }
    floor() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
    }
    ceil() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
    }
    round() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
    }
    roundToZero() {
      return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this;
    }
    negate() {
      return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
    }
    dot(t3) {
      return this.x * t3.x + this.y * t3.y + this.z * t3.z + this.w * t3.w;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(t3) {
      return this.normalize().multiplyScalar(t3);
    }
    lerp(t3, e3) {
      return this.x += (t3.x - this.x) * e3, this.y += (t3.y - this.y) * e3, this.z += (t3.z - this.z) * e3, this.w += (t3.w - this.w) * e3, this;
    }
    lerpVectors(t3, e3, n2) {
      return this.x = t3.x + (e3.x - t3.x) * n2, this.y = t3.y + (e3.y - t3.y) * n2, this.z = t3.z + (e3.z - t3.z) * n2, this.w = t3.w + (e3.w - t3.w) * n2, this;
    }
    equals(t3) {
      return t3.x === this.x && t3.y === this.y && t3.z === this.z && t3.w === this.w;
    }
    fromArray(t3, e3 = 0) {
      return this.x = t3[e3], this.y = t3[e3 + 1], this.z = t3[e3 + 2], this.w = t3[e3 + 3], this;
    }
    toArray(t3 = [], e3 = 0) {
      return t3[e3] = this.x, t3[e3 + 1] = this.y, t3[e3 + 2] = this.z, t3[e3 + 3] = this.w, t3;
    }
    fromBufferAttribute(t3, e3, n2) {
      return n2 !== void 0 && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t3.getX(e3), this.y = t3.getY(e3), this.z = t3.getZ(e3), this.w = t3.getW(e3), this;
    }
    random() {
      return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
    }
  }
  li.prototype.isVector4 = true;
  class ui extends zn {
    constructor(t3, e3, n2 = {}) {
      super(), this.width = t3, this.height = e3, this.depth = 1, this.scissor = new li(0, 0, t3, e3), this.scissorTest = false, this.viewport = new li(0, 0, t3, e3), this.texture = new si(void 0, n2.mapping, n2.wrapS, n2.wrapT, n2.magFilter, n2.minFilter, n2.format, n2.type, n2.anisotropy, n2.encoding), this.texture.image = { width: t3, height: e3, depth: 1 }, this.texture.generateMipmaps = n2.generateMipmaps !== void 0 && n2.generateMipmaps, this.texture.minFilter = n2.minFilter !== void 0 ? n2.minFilter : Et, this.depthBuffer = n2.depthBuffer === void 0 || n2.depthBuffer, this.stencilBuffer = n2.stencilBuffer !== void 0 && n2.stencilBuffer, this.depthTexture = n2.depthTexture !== void 0 ? n2.depthTexture : null;
    }
    setTexture(t3) {
      t3.image = { width: this.width, height: this.height, depth: this.depth }, this.texture = t3;
    }
    setSize(t3, e3, n2 = 1) {
      this.width === t3 && this.height === e3 && this.depth === n2 || (this.width = t3, this.height = e3, this.depth = n2, this.texture.image.width = t3, this.texture.image.height = e3, this.texture.image.depth = n2, this.dispose()), this.viewport.set(0, 0, t3, e3), this.scissor.set(0, 0, t3, e3);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t3) {
      return this.width = t3.width, this.height = t3.height, this.depth = t3.depth, this.viewport.copy(t3.viewport), this.texture = t3.texture.clone(), this.texture.image = __spreadValues({}, this.texture.image), this.depthBuffer = t3.depthBuffer, this.stencilBuffer = t3.stencilBuffer, this.depthTexture = t3.depthTexture, this;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  }
  ui.prototype.isWebGLRenderTarget = true;
  class hi extends ui {
    constructor(t3, e3, n2) {
      super(t3, e3);
      const i2 = this.texture;
      this.texture = [];
      for (let t4 = 0; t4 < n2; t4++)
        this.texture[t4] = i2.clone();
    }
    setSize(t3, e3, n2 = 1) {
      if (this.width !== t3 || this.height !== e3 || this.depth !== n2) {
        this.width = t3, this.height = e3, this.depth = n2;
        for (let i2 = 0, r3 = this.texture.length; i2 < r3; i2++)
          this.texture[i2].image.width = t3, this.texture[i2].image.height = e3, this.texture[i2].image.depth = n2;
        this.dispose();
      }
      return this.viewport.set(0, 0, t3, e3), this.scissor.set(0, 0, t3, e3), this;
    }
    copy(t3) {
      this.dispose(), this.width = t3.width, this.height = t3.height, this.depth = t3.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = t3.depthBuffer, this.stencilBuffer = t3.stencilBuffer, this.depthTexture = t3.depthTexture, this.texture.length = 0;
      for (let e3 = 0, n2 = t3.texture.length; e3 < n2; e3++)
        this.texture[e3] = t3.texture[e3].clone();
      return this;
    }
  }
  hi.prototype.isWebGLMultipleRenderTargets = true;
  class ci extends ui {
    constructor(t3, e3, n2) {
      super(t3, e3, n2), this.samples = 4;
    }
    copy(t3) {
      return super.copy.call(this, t3), this.samples = t3.samples, this;
    }
  }
  ci.prototype.isWebGLMultisampleRenderTarget = true;
  class di {
    constructor(t3 = 0, e3 = 0, n2 = 0, i2 = 1) {
      this._x = t3, this._y = e3, this._z = n2, this._w = i2;
    }
    static slerp(t3, e3, n2, i2) {
      return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."), n2.slerpQuaternions(t3, e3, i2);
    }
    static slerpFlat(t3, e3, n2, i2, r3, o3, s3) {
      let a2 = n2[i2 + 0], l2 = n2[i2 + 1], u2 = n2[i2 + 2], h2 = n2[i2 + 3];
      const c2 = r3[o3 + 0], d2 = r3[o3 + 1], p2 = r3[o3 + 2], f2 = r3[o3 + 3];
      if (s3 === 0)
        return t3[e3 + 0] = a2, t3[e3 + 1] = l2, t3[e3 + 2] = u2, void (t3[e3 + 3] = h2);
      if (s3 === 1)
        return t3[e3 + 0] = c2, t3[e3 + 1] = d2, t3[e3 + 2] = p2, void (t3[e3 + 3] = f2);
      if (h2 !== f2 || a2 !== c2 || l2 !== d2 || u2 !== p2) {
        let t4 = 1 - s3;
        const e4 = a2 * c2 + l2 * d2 + u2 * p2 + h2 * f2, n3 = e4 >= 0 ? 1 : -1, i3 = 1 - e4 * e4;
        if (i3 > Number.EPSILON) {
          const r5 = Math.sqrt(i3), o4 = Math.atan2(r5, e4 * n3);
          t4 = Math.sin(t4 * o4) / r5, s3 = Math.sin(s3 * o4) / r5;
        }
        const r4 = s3 * n3;
        if (a2 = a2 * t4 + c2 * r4, l2 = l2 * t4 + d2 * r4, u2 = u2 * t4 + p2 * r4, h2 = h2 * t4 + f2 * r4, t4 === 1 - s3) {
          const t5 = 1 / Math.sqrt(a2 * a2 + l2 * l2 + u2 * u2 + h2 * h2);
          a2 *= t5, l2 *= t5, u2 *= t5, h2 *= t5;
        }
      }
      t3[e3] = a2, t3[e3 + 1] = l2, t3[e3 + 2] = u2, t3[e3 + 3] = h2;
    }
    static multiplyQuaternionsFlat(t3, e3, n2, i2, r3, o3) {
      const s3 = n2[i2], a2 = n2[i2 + 1], l2 = n2[i2 + 2], u2 = n2[i2 + 3], h2 = r3[o3], c2 = r3[o3 + 1], d2 = r3[o3 + 2], p2 = r3[o3 + 3];
      return t3[e3] = s3 * p2 + u2 * h2 + a2 * d2 - l2 * c2, t3[e3 + 1] = a2 * p2 + u2 * c2 + l2 * h2 - s3 * d2, t3[e3 + 2] = l2 * p2 + u2 * d2 + s3 * c2 - a2 * h2, t3[e3 + 3] = u2 * p2 - s3 * h2 - a2 * c2 - l2 * d2, t3;
    }
    get x() {
      return this._x;
    }
    set x(t3) {
      this._x = t3, this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(t3) {
      this._y = t3, this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(t3) {
      this._z = t3, this._onChangeCallback();
    }
    get w() {
      return this._w;
    }
    set w(t3) {
      this._w = t3, this._onChangeCallback();
    }
    set(t3, e3, n2, i2) {
      return this._x = t3, this._y = e3, this._z = n2, this._w = i2, this._onChangeCallback(), this;
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._w);
    }
    copy(t3) {
      return this._x = t3.x, this._y = t3.y, this._z = t3.z, this._w = t3.w, this._onChangeCallback(), this;
    }
    setFromEuler(t3, e3) {
      if (!t3 || !t3.isEuler)
        throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
      const n2 = t3._x, i2 = t3._y, r3 = t3._z, o3 = t3._order, s3 = Math.cos, a2 = Math.sin, l2 = s3(n2 / 2), u2 = s3(i2 / 2), h2 = s3(r3 / 2), c2 = a2(n2 / 2), d2 = a2(i2 / 2), p2 = a2(r3 / 2);
      switch (o3) {
        case "XYZ":
          this._x = c2 * u2 * h2 + l2 * d2 * p2, this._y = l2 * d2 * h2 - c2 * u2 * p2, this._z = l2 * u2 * p2 + c2 * d2 * h2, this._w = l2 * u2 * h2 - c2 * d2 * p2;
          break;
        case "YXZ":
          this._x = c2 * u2 * h2 + l2 * d2 * p2, this._y = l2 * d2 * h2 - c2 * u2 * p2, this._z = l2 * u2 * p2 - c2 * d2 * h2, this._w = l2 * u2 * h2 + c2 * d2 * p2;
          break;
        case "ZXY":
          this._x = c2 * u2 * h2 - l2 * d2 * p2, this._y = l2 * d2 * h2 + c2 * u2 * p2, this._z = l2 * u2 * p2 + c2 * d2 * h2, this._w = l2 * u2 * h2 - c2 * d2 * p2;
          break;
        case "ZYX":
          this._x = c2 * u2 * h2 - l2 * d2 * p2, this._y = l2 * d2 * h2 + c2 * u2 * p2, this._z = l2 * u2 * p2 - c2 * d2 * h2, this._w = l2 * u2 * h2 + c2 * d2 * p2;
          break;
        case "YZX":
          this._x = c2 * u2 * h2 + l2 * d2 * p2, this._y = l2 * d2 * h2 + c2 * u2 * p2, this._z = l2 * u2 * p2 - c2 * d2 * h2, this._w = l2 * u2 * h2 - c2 * d2 * p2;
          break;
        case "XZY":
          this._x = c2 * u2 * h2 - l2 * d2 * p2, this._y = l2 * d2 * h2 - c2 * u2 * p2, this._z = l2 * u2 * p2 + c2 * d2 * h2, this._w = l2 * u2 * h2 + c2 * d2 * p2;
          break;
        default:
          console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o3);
      }
      return e3 !== false && this._onChangeCallback(), this;
    }
    setFromAxisAngle(t3, e3) {
      const n2 = e3 / 2, i2 = Math.sin(n2);
      return this._x = t3.x * i2, this._y = t3.y * i2, this._z = t3.z * i2, this._w = Math.cos(n2), this._onChangeCallback(), this;
    }
    setFromRotationMatrix(t3) {
      const e3 = t3.elements, n2 = e3[0], i2 = e3[4], r3 = e3[8], o3 = e3[1], s3 = e3[5], a2 = e3[9], l2 = e3[2], u2 = e3[6], h2 = e3[10], c2 = n2 + s3 + h2;
      if (c2 > 0) {
        const t4 = 0.5 / Math.sqrt(c2 + 1);
        this._w = 0.25 / t4, this._x = (u2 - a2) * t4, this._y = (r3 - l2) * t4, this._z = (o3 - i2) * t4;
      } else if (n2 > s3 && n2 > h2) {
        const t4 = 2 * Math.sqrt(1 + n2 - s3 - h2);
        this._w = (u2 - a2) / t4, this._x = 0.25 * t4, this._y = (i2 + o3) / t4, this._z = (r3 + l2) / t4;
      } else if (s3 > h2) {
        const t4 = 2 * Math.sqrt(1 + s3 - n2 - h2);
        this._w = (r3 - l2) / t4, this._x = (i2 + o3) / t4, this._y = 0.25 * t4, this._z = (a2 + u2) / t4;
      } else {
        const t4 = 2 * Math.sqrt(1 + h2 - n2 - s3);
        this._w = (o3 - i2) / t4, this._x = (r3 + l2) / t4, this._y = (a2 + u2) / t4, this._z = 0.25 * t4;
      }
      return this._onChangeCallback(), this;
    }
    setFromUnitVectors(t3, e3) {
      let n2 = t3.dot(e3) + 1;
      return n2 < Number.EPSILON ? (n2 = 0, Math.abs(t3.x) > Math.abs(t3.z) ? (this._x = -t3.y, this._y = t3.x, this._z = 0, this._w = n2) : (this._x = 0, this._y = -t3.z, this._z = t3.y, this._w = n2)) : (this._x = t3.y * e3.z - t3.z * e3.y, this._y = t3.z * e3.x - t3.x * e3.z, this._z = t3.x * e3.y - t3.y * e3.x, this._w = n2), this.normalize();
    }
    angleTo(t3) {
      return 2 * Math.acos(Math.abs(Yn(this.dot(t3), -1, 1)));
    }
    rotateTowards(t3, e3) {
      const n2 = this.angleTo(t3);
      if (n2 === 0)
        return this;
      const i2 = Math.min(1, e3 / n2);
      return this.slerp(t3, i2), this;
    }
    identity() {
      return this.set(0, 0, 0, 1);
    }
    invert() {
      return this.conjugate();
    }
    conjugate() {
      return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
    }
    dot(t3) {
      return this._x * t3._x + this._y * t3._y + this._z * t3._z + this._w * t3._w;
    }
    lengthSq() {
      return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    }
    length() {
      return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
    }
    normalize() {
      let t3 = this.length();
      return t3 === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t3 = 1 / t3, this._x = this._x * t3, this._y = this._y * t3, this._z = this._z * t3, this._w = this._w * t3), this._onChangeCallback(), this;
    }
    multiply(t3, e3) {
      return e3 !== void 0 ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t3, e3)) : this.multiplyQuaternions(this, t3);
    }
    premultiply(t3) {
      return this.multiplyQuaternions(t3, this);
    }
    multiplyQuaternions(t3, e3) {
      const n2 = t3._x, i2 = t3._y, r3 = t3._z, o3 = t3._w, s3 = e3._x, a2 = e3._y, l2 = e3._z, u2 = e3._w;
      return this._x = n2 * u2 + o3 * s3 + i2 * l2 - r3 * a2, this._y = i2 * u2 + o3 * a2 + r3 * s3 - n2 * l2, this._z = r3 * u2 + o3 * l2 + n2 * a2 - i2 * s3, this._w = o3 * u2 - n2 * s3 - i2 * a2 - r3 * l2, this._onChangeCallback(), this;
    }
    slerp(t3, e3) {
      if (e3 === 0)
        return this;
      if (e3 === 1)
        return this.copy(t3);
      const n2 = this._x, i2 = this._y, r3 = this._z, o3 = this._w;
      let s3 = o3 * t3._w + n2 * t3._x + i2 * t3._y + r3 * t3._z;
      if (s3 < 0 ? (this._w = -t3._w, this._x = -t3._x, this._y = -t3._y, this._z = -t3._z, s3 = -s3) : this.copy(t3), s3 >= 1)
        return this._w = o3, this._x = n2, this._y = i2, this._z = r3, this;
      const a2 = 1 - s3 * s3;
      if (a2 <= Number.EPSILON) {
        const t4 = 1 - e3;
        return this._w = t4 * o3 + e3 * this._w, this._x = t4 * n2 + e3 * this._x, this._y = t4 * i2 + e3 * this._y, this._z = t4 * r3 + e3 * this._z, this.normalize(), this._onChangeCallback(), this;
      }
      const l2 = Math.sqrt(a2), u2 = Math.atan2(l2, s3), h2 = Math.sin((1 - e3) * u2) / l2, c2 = Math.sin(e3 * u2) / l2;
      return this._w = o3 * h2 + this._w * c2, this._x = n2 * h2 + this._x * c2, this._y = i2 * h2 + this._y * c2, this._z = r3 * h2 + this._z * c2, this._onChangeCallback(), this;
    }
    slerpQuaternions(t3, e3, n2) {
      this.copy(t3).slerp(e3, n2);
    }
    equals(t3) {
      return t3._x === this._x && t3._y === this._y && t3._z === this._z && t3._w === this._w;
    }
    fromArray(t3, e3 = 0) {
      return this._x = t3[e3], this._y = t3[e3 + 1], this._z = t3[e3 + 2], this._w = t3[e3 + 3], this._onChangeCallback(), this;
    }
    toArray(t3 = [], e3 = 0) {
      return t3[e3] = this._x, t3[e3 + 1] = this._y, t3[e3 + 2] = this._z, t3[e3 + 3] = this._w, t3;
    }
    fromBufferAttribute(t3, e3) {
      return this._x = t3.getX(e3), this._y = t3.getY(e3), this._z = t3.getZ(e3), this._w = t3.getW(e3), this;
    }
    _onChange(t3) {
      return this._onChangeCallback = t3, this;
    }
    _onChangeCallback() {
    }
  }
  di.prototype.isQuaternion = true;
  class pi {
    constructor(t3 = 0, e3 = 0, n2 = 0) {
      this.x = t3, this.y = e3, this.z = n2;
    }
    set(t3, e3, n2) {
      return n2 === void 0 && (n2 = this.z), this.x = t3, this.y = e3, this.z = n2, this;
    }
    setScalar(t3) {
      return this.x = t3, this.y = t3, this.z = t3, this;
    }
    setX(t3) {
      return this.x = t3, this;
    }
    setY(t3) {
      return this.y = t3, this;
    }
    setZ(t3) {
      return this.z = t3, this;
    }
    setComponent(t3, e3) {
      switch (t3) {
        case 0:
          this.x = e3;
          break;
        case 1:
          this.y = e3;
          break;
        case 2:
          this.z = e3;
          break;
        default:
          throw new Error("index is out of range: " + t3);
      }
      return this;
    }
    getComponent(t3) {
      switch (t3) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        default:
          throw new Error("index is out of range: " + t3);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z);
    }
    copy(t3) {
      return this.x = t3.x, this.y = t3.y, this.z = t3.z, this;
    }
    add(t3, e3) {
      return e3 !== void 0 ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t3, e3)) : (this.x += t3.x, this.y += t3.y, this.z += t3.z, this);
    }
    addScalar(t3) {
      return this.x += t3, this.y += t3, this.z += t3, this;
    }
    addVectors(t3, e3) {
      return this.x = t3.x + e3.x, this.y = t3.y + e3.y, this.z = t3.z + e3.z, this;
    }
    addScaledVector(t3, e3) {
      return this.x += t3.x * e3, this.y += t3.y * e3, this.z += t3.z * e3, this;
    }
    sub(t3, e3) {
      return e3 !== void 0 ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t3, e3)) : (this.x -= t3.x, this.y -= t3.y, this.z -= t3.z, this);
    }
    subScalar(t3) {
      return this.x -= t3, this.y -= t3, this.z -= t3, this;
    }
    subVectors(t3, e3) {
      return this.x = t3.x - e3.x, this.y = t3.y - e3.y, this.z = t3.z - e3.z, this;
    }
    multiply(t3, e3) {
      return e3 !== void 0 ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t3, e3)) : (this.x *= t3.x, this.y *= t3.y, this.z *= t3.z, this);
    }
    multiplyScalar(t3) {
      return this.x *= t3, this.y *= t3, this.z *= t3, this;
    }
    multiplyVectors(t3, e3) {
      return this.x = t3.x * e3.x, this.y = t3.y * e3.y, this.z = t3.z * e3.z, this;
    }
    applyEuler(t3) {
      return t3 && t3.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(mi.setFromEuler(t3));
    }
    applyAxisAngle(t3, e3) {
      return this.applyQuaternion(mi.setFromAxisAngle(t3, e3));
    }
    applyMatrix3(t3) {
      const e3 = this.x, n2 = this.y, i2 = this.z, r3 = t3.elements;
      return this.x = r3[0] * e3 + r3[3] * n2 + r3[6] * i2, this.y = r3[1] * e3 + r3[4] * n2 + r3[7] * i2, this.z = r3[2] * e3 + r3[5] * n2 + r3[8] * i2, this;
    }
    applyNormalMatrix(t3) {
      return this.applyMatrix3(t3).normalize();
    }
    applyMatrix4(t3) {
      const e3 = this.x, n2 = this.y, i2 = this.z, r3 = t3.elements, o3 = 1 / (r3[3] * e3 + r3[7] * n2 + r3[11] * i2 + r3[15]);
      return this.x = (r3[0] * e3 + r3[4] * n2 + r3[8] * i2 + r3[12]) * o3, this.y = (r3[1] * e3 + r3[5] * n2 + r3[9] * i2 + r3[13]) * o3, this.z = (r3[2] * e3 + r3[6] * n2 + r3[10] * i2 + r3[14]) * o3, this;
    }
    applyQuaternion(t3) {
      const e3 = this.x, n2 = this.y, i2 = this.z, r3 = t3.x, o3 = t3.y, s3 = t3.z, a2 = t3.w, l2 = a2 * e3 + o3 * i2 - s3 * n2, u2 = a2 * n2 + s3 * e3 - r3 * i2, h2 = a2 * i2 + r3 * n2 - o3 * e3, c2 = -r3 * e3 - o3 * n2 - s3 * i2;
      return this.x = l2 * a2 + c2 * -r3 + u2 * -s3 - h2 * -o3, this.y = u2 * a2 + c2 * -o3 + h2 * -r3 - l2 * -s3, this.z = h2 * a2 + c2 * -s3 + l2 * -o3 - u2 * -r3, this;
    }
    project(t3) {
      return this.applyMatrix4(t3.matrixWorldInverse).applyMatrix4(t3.projectionMatrix);
    }
    unproject(t3) {
      return this.applyMatrix4(t3.projectionMatrixInverse).applyMatrix4(t3.matrixWorld);
    }
    transformDirection(t3) {
      const e3 = this.x, n2 = this.y, i2 = this.z, r3 = t3.elements;
      return this.x = r3[0] * e3 + r3[4] * n2 + r3[8] * i2, this.y = r3[1] * e3 + r3[5] * n2 + r3[9] * i2, this.z = r3[2] * e3 + r3[6] * n2 + r3[10] * i2, this.normalize();
    }
    divide(t3) {
      return this.x /= t3.x, this.y /= t3.y, this.z /= t3.z, this;
    }
    divideScalar(t3) {
      return this.multiplyScalar(1 / t3);
    }
    min(t3) {
      return this.x = Math.min(this.x, t3.x), this.y = Math.min(this.y, t3.y), this.z = Math.min(this.z, t3.z), this;
    }
    max(t3) {
      return this.x = Math.max(this.x, t3.x), this.y = Math.max(this.y, t3.y), this.z = Math.max(this.z, t3.z), this;
    }
    clamp(t3, e3) {
      return this.x = Math.max(t3.x, Math.min(e3.x, this.x)), this.y = Math.max(t3.y, Math.min(e3.y, this.y)), this.z = Math.max(t3.z, Math.min(e3.z, this.z)), this;
    }
    clampScalar(t3, e3) {
      return this.x = Math.max(t3, Math.min(e3, this.x)), this.y = Math.max(t3, Math.min(e3, this.y)), this.z = Math.max(t3, Math.min(e3, this.z)), this;
    }
    clampLength(t3, e3) {
      const n2 = this.length();
      return this.divideScalar(n2 || 1).multiplyScalar(Math.max(t3, Math.min(e3, n2)));
    }
    floor() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
    }
    ceil() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
    }
    round() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
    }
    roundToZero() {
      return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this;
    }
    negate() {
      return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
    }
    dot(t3) {
      return this.x * t3.x + this.y * t3.y + this.z * t3.z;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(t3) {
      return this.normalize().multiplyScalar(t3);
    }
    lerp(t3, e3) {
      return this.x += (t3.x - this.x) * e3, this.y += (t3.y - this.y) * e3, this.z += (t3.z - this.z) * e3, this;
    }
    lerpVectors(t3, e3, n2) {
      return this.x = t3.x + (e3.x - t3.x) * n2, this.y = t3.y + (e3.y - t3.y) * n2, this.z = t3.z + (e3.z - t3.z) * n2, this;
    }
    cross(t3, e3) {
      return e3 !== void 0 ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t3, e3)) : this.crossVectors(this, t3);
    }
    crossVectors(t3, e3) {
      const n2 = t3.x, i2 = t3.y, r3 = t3.z, o3 = e3.x, s3 = e3.y, a2 = e3.z;
      return this.x = i2 * a2 - r3 * s3, this.y = r3 * o3 - n2 * a2, this.z = n2 * s3 - i2 * o3, this;
    }
    projectOnVector(t3) {
      const e3 = t3.lengthSq();
      if (e3 === 0)
        return this.set(0, 0, 0);
      const n2 = t3.dot(this) / e3;
      return this.copy(t3).multiplyScalar(n2);
    }
    projectOnPlane(t3) {
      return fi.copy(this).projectOnVector(t3), this.sub(fi);
    }
    reflect(t3) {
      return this.sub(fi.copy(t3).multiplyScalar(2 * this.dot(t3)));
    }
    angleTo(t3) {
      const e3 = Math.sqrt(this.lengthSq() * t3.lengthSq());
      if (e3 === 0)
        return Math.PI / 2;
      const n2 = this.dot(t3) / e3;
      return Math.acos(Yn(n2, -1, 1));
    }
    distanceTo(t3) {
      return Math.sqrt(this.distanceToSquared(t3));
    }
    distanceToSquared(t3) {
      const e3 = this.x - t3.x, n2 = this.y - t3.y, i2 = this.z - t3.z;
      return e3 * e3 + n2 * n2 + i2 * i2;
    }
    manhattanDistanceTo(t3) {
      return Math.abs(this.x - t3.x) + Math.abs(this.y - t3.y) + Math.abs(this.z - t3.z);
    }
    setFromSpherical(t3) {
      return this.setFromSphericalCoords(t3.radius, t3.phi, t3.theta);
    }
    setFromSphericalCoords(t3, e3, n2) {
      const i2 = Math.sin(e3) * t3;
      return this.x = i2 * Math.sin(n2), this.y = Math.cos(e3) * t3, this.z = i2 * Math.cos(n2), this;
    }
    setFromCylindrical(t3) {
      return this.setFromCylindricalCoords(t3.radius, t3.theta, t3.y);
    }
    setFromCylindricalCoords(t3, e3, n2) {
      return this.x = t3 * Math.sin(e3), this.y = n2, this.z = t3 * Math.cos(e3), this;
    }
    setFromMatrixPosition(t3) {
      const e3 = t3.elements;
      return this.x = e3[12], this.y = e3[13], this.z = e3[14], this;
    }
    setFromMatrixScale(t3) {
      const e3 = this.setFromMatrixColumn(t3, 0).length(), n2 = this.setFromMatrixColumn(t3, 1).length(), i2 = this.setFromMatrixColumn(t3, 2).length();
      return this.x = e3, this.y = n2, this.z = i2, this;
    }
    setFromMatrixColumn(t3, e3) {
      return this.fromArray(t3.elements, 4 * e3);
    }
    setFromMatrix3Column(t3, e3) {
      return this.fromArray(t3.elements, 3 * e3);
    }
    equals(t3) {
      return t3.x === this.x && t3.y === this.y && t3.z === this.z;
    }
    fromArray(t3, e3 = 0) {
      return this.x = t3[e3], this.y = t3[e3 + 1], this.z = t3[e3 + 2], this;
    }
    toArray(t3 = [], e3 = 0) {
      return t3[e3] = this.x, t3[e3 + 1] = this.y, t3[e3 + 2] = this.z, t3;
    }
    fromBufferAttribute(t3, e3, n2) {
      return n2 !== void 0 && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t3.getX(e3), this.y = t3.getY(e3), this.z = t3.getZ(e3), this;
    }
    random() {
      return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
    }
  }
  pi.prototype.isVector3 = true;
  const fi = new pi(), mi = new di();
  class gi {
    constructor(t3 = new pi(1 / 0, 1 / 0, 1 / 0), e3 = new pi(-1 / 0, -1 / 0, -1 / 0)) {
      this.min = t3, this.max = e3;
    }
    set(t3, e3) {
      return this.min.copy(t3), this.max.copy(e3), this;
    }
    setFromArray(t3) {
      let e3 = 1 / 0, n2 = 1 / 0, i2 = 1 / 0, r3 = -1 / 0, o3 = -1 / 0, s3 = -1 / 0;
      for (let a2 = 0, l2 = t3.length; a2 < l2; a2 += 3) {
        const l3 = t3[a2], u2 = t3[a2 + 1], h2 = t3[a2 + 2];
        l3 < e3 && (e3 = l3), u2 < n2 && (n2 = u2), h2 < i2 && (i2 = h2), l3 > r3 && (r3 = l3), u2 > o3 && (o3 = u2), h2 > s3 && (s3 = h2);
      }
      return this.min.set(e3, n2, i2), this.max.set(r3, o3, s3), this;
    }
    setFromBufferAttribute(t3) {
      let e3 = 1 / 0, n2 = 1 / 0, i2 = 1 / 0, r3 = -1 / 0, o3 = -1 / 0, s3 = -1 / 0;
      for (let a2 = 0, l2 = t3.count; a2 < l2; a2++) {
        const l3 = t3.getX(a2), u2 = t3.getY(a2), h2 = t3.getZ(a2);
        l3 < e3 && (e3 = l3), u2 < n2 && (n2 = u2), h2 < i2 && (i2 = h2), l3 > r3 && (r3 = l3), u2 > o3 && (o3 = u2), h2 > s3 && (s3 = h2);
      }
      return this.min.set(e3, n2, i2), this.max.set(r3, o3, s3), this;
    }
    setFromPoints(t3) {
      this.makeEmpty();
      for (let e3 = 0, n2 = t3.length; e3 < n2; e3++)
        this.expandByPoint(t3[e3]);
      return this;
    }
    setFromCenterAndSize(t3, e3) {
      const n2 = _i.copy(e3).multiplyScalar(0.5);
      return this.min.copy(t3).sub(n2), this.max.copy(t3).add(n2), this;
    }
    setFromObject(t3) {
      return this.makeEmpty(), this.expandByObject(t3);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t3) {
      return this.min.copy(t3.min), this.max.copy(t3.max), this;
    }
    makeEmpty() {
      return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
    }
    isEmpty() {
      return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
    }
    getCenter(t3) {
      return this.isEmpty() ? t3.set(0, 0, 0) : t3.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
    getSize(t3) {
      return this.isEmpty() ? t3.set(0, 0, 0) : t3.subVectors(this.max, this.min);
    }
    expandByPoint(t3) {
      return this.min.min(t3), this.max.max(t3), this;
    }
    expandByVector(t3) {
      return this.min.sub(t3), this.max.add(t3), this;
    }
    expandByScalar(t3) {
      return this.min.addScalar(-t3), this.max.addScalar(t3), this;
    }
    expandByObject(t3) {
      t3.updateWorldMatrix(false, false);
      const e3 = t3.geometry;
      e3 !== void 0 && (e3.boundingBox === null && e3.computeBoundingBox(), yi.copy(e3.boundingBox), yi.applyMatrix4(t3.matrixWorld), this.union(yi));
      const n2 = t3.children;
      for (let t4 = 0, e4 = n2.length; t4 < e4; t4++)
        this.expandByObject(n2[t4]);
      return this;
    }
    containsPoint(t3) {
      return !(t3.x < this.min.x || t3.x > this.max.x || t3.y < this.min.y || t3.y > this.max.y || t3.z < this.min.z || t3.z > this.max.z);
    }
    containsBox(t3) {
      return this.min.x <= t3.min.x && t3.max.x <= this.max.x && this.min.y <= t3.min.y && t3.max.y <= this.max.y && this.min.z <= t3.min.z && t3.max.z <= this.max.z;
    }
    getParameter(t3, e3) {
      return e3.set((t3.x - this.min.x) / (this.max.x - this.min.x), (t3.y - this.min.y) / (this.max.y - this.min.y), (t3.z - this.min.z) / (this.max.z - this.min.z));
    }
    intersectsBox(t3) {
      return !(t3.max.x < this.min.x || t3.min.x > this.max.x || t3.max.y < this.min.y || t3.min.y > this.max.y || t3.max.z < this.min.z || t3.min.z > this.max.z);
    }
    intersectsSphere(t3) {
      return this.clampPoint(t3.center, _i), _i.distanceToSquared(t3.center) <= t3.radius * t3.radius;
    }
    intersectsPlane(t3) {
      let e3, n2;
      return t3.normal.x > 0 ? (e3 = t3.normal.x * this.min.x, n2 = t3.normal.x * this.max.x) : (e3 = t3.normal.x * this.max.x, n2 = t3.normal.x * this.min.x), t3.normal.y > 0 ? (e3 += t3.normal.y * this.min.y, n2 += t3.normal.y * this.max.y) : (e3 += t3.normal.y * this.max.y, n2 += t3.normal.y * this.min.y), t3.normal.z > 0 ? (e3 += t3.normal.z * this.min.z, n2 += t3.normal.z * this.max.z) : (e3 += t3.normal.z * this.max.z, n2 += t3.normal.z * this.min.z), e3 <= -t3.constant && n2 >= -t3.constant;
    }
    intersectsTriangle(t3) {
      if (this.isEmpty())
        return false;
      this.getCenter(Mi), Ai.subVectors(this.max, Mi), xi.subVectors(t3.a, Mi), bi.subVectors(t3.b, Mi), Ti.subVectors(t3.c, Mi), wi.subVectors(bi, xi), Si.subVectors(Ti, bi), Ei.subVectors(xi, Ti);
      let e3 = [0, -wi.z, wi.y, 0, -Si.z, Si.y, 0, -Ei.z, Ei.y, wi.z, 0, -wi.x, Si.z, 0, -Si.x, Ei.z, 0, -Ei.x, -wi.y, wi.x, 0, -Si.y, Si.x, 0, -Ei.y, Ei.x, 0];
      return !!Ci(e3, xi, bi, Ti, Ai) && (e3 = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!Ci(e3, xi, bi, Ti, Ai) && (Ri.crossVectors(wi, Si), e3 = [Ri.x, Ri.y, Ri.z], Ci(e3, xi, bi, Ti, Ai)));
    }
    clampPoint(t3, e3) {
      return e3.copy(t3).clamp(this.min, this.max);
    }
    distanceToPoint(t3) {
      return _i.copy(t3).clamp(this.min, this.max).sub(t3).length();
    }
    getBoundingSphere(t3) {
      return this.getCenter(t3.center), t3.radius = 0.5 * this.getSize(_i).length(), t3;
    }
    intersect(t3) {
      return this.min.max(t3.min), this.max.min(t3.max), this.isEmpty() && this.makeEmpty(), this;
    }
    union(t3) {
      return this.min.min(t3.min), this.max.max(t3.max), this;
    }
    applyMatrix4(t3) {
      return this.isEmpty() || (vi[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t3), vi[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t3), vi[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t3), vi[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t3), vi[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t3), vi[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t3), vi[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t3), vi[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t3), this.setFromPoints(vi)), this;
    }
    translate(t3) {
      return this.min.add(t3), this.max.add(t3), this;
    }
    equals(t3) {
      return t3.min.equals(this.min) && t3.max.equals(this.max);
    }
  }
  gi.prototype.isBox3 = true;
  const vi = [new pi(), new pi(), new pi(), new pi(), new pi(), new pi(), new pi(), new pi()], _i = new pi(), yi = new gi(), xi = new pi(), bi = new pi(), Ti = new pi(), wi = new pi(), Si = new pi(), Ei = new pi(), Mi = new pi(), Ai = new pi(), Ri = new pi(), Pi = new pi();
  function Ci(t3, e3, n2, i2, r3) {
    for (let o3 = 0, s3 = t3.length - 3; o3 <= s3; o3 += 3) {
      Pi.fromArray(t3, o3);
      const s4 = r3.x * Math.abs(Pi.x) + r3.y * Math.abs(Pi.y) + r3.z * Math.abs(Pi.z), a2 = e3.dot(Pi), l2 = n2.dot(Pi), u2 = i2.dot(Pi);
      if (Math.max(-Math.max(a2, l2, u2), Math.min(a2, l2, u2)) > s4)
        return false;
    }
    return true;
  }
  const Ii = new gi(), Oi = new pi(), Li = new pi(), Ni = new pi();
  class Di {
    constructor(t3 = new pi(), e3 = -1) {
      this.center = t3, this.radius = e3;
    }
    set(t3, e3) {
      return this.center.copy(t3), this.radius = e3, this;
    }
    setFromPoints(t3, e3) {
      const n2 = this.center;
      e3 !== void 0 ? n2.copy(e3) : Ii.setFromPoints(t3).getCenter(n2);
      let i2 = 0;
      for (let e4 = 0, r3 = t3.length; e4 < r3; e4++)
        i2 = Math.max(i2, n2.distanceToSquared(t3[e4]));
      return this.radius = Math.sqrt(i2), this;
    }
    copy(t3) {
      return this.center.copy(t3.center), this.radius = t3.radius, this;
    }
    isEmpty() {
      return this.radius < 0;
    }
    makeEmpty() {
      return this.center.set(0, 0, 0), this.radius = -1, this;
    }
    containsPoint(t3) {
      return t3.distanceToSquared(this.center) <= this.radius * this.radius;
    }
    distanceToPoint(t3) {
      return t3.distanceTo(this.center) - this.radius;
    }
    intersectsSphere(t3) {
      const e3 = this.radius + t3.radius;
      return t3.center.distanceToSquared(this.center) <= e3 * e3;
    }
    intersectsBox(t3) {
      return t3.intersectsSphere(this);
    }
    intersectsPlane(t3) {
      return Math.abs(t3.distanceToPoint(this.center)) <= this.radius;
    }
    clampPoint(t3, e3) {
      const n2 = this.center.distanceToSquared(t3);
      return e3.copy(t3), n2 > this.radius * this.radius && (e3.sub(this.center).normalize(), e3.multiplyScalar(this.radius).add(this.center)), e3;
    }
    getBoundingBox(t3) {
      return this.isEmpty() ? (t3.makeEmpty(), t3) : (t3.set(this.center, this.center), t3.expandByScalar(this.radius), t3);
    }
    applyMatrix4(t3) {
      return this.center.applyMatrix4(t3), this.radius = this.radius * t3.getMaxScaleOnAxis(), this;
    }
    translate(t3) {
      return this.center.add(t3), this;
    }
    expandByPoint(t3) {
      Ni.subVectors(t3, this.center);
      const e3 = Ni.lengthSq();
      if (e3 > this.radius * this.radius) {
        const t4 = Math.sqrt(e3), n2 = 0.5 * (t4 - this.radius);
        this.center.add(Ni.multiplyScalar(n2 / t4)), this.radius += n2;
      }
      return this;
    }
    union(t3) {
      return Li.subVectors(t3.center, this.center).normalize().multiplyScalar(t3.radius), this.expandByPoint(Oi.copy(t3.center).add(Li)), this.expandByPoint(Oi.copy(t3.center).sub(Li)), this;
    }
    equals(t3) {
      return t3.center.equals(this.center) && t3.radius === this.radius;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  const Fi = new pi(), Bi = new pi(), Ui = new pi(), ki = new pi(), Gi = new pi(), Hi = new pi(), zi = new pi();
  class ji {
    constructor(t3 = new pi(), e3 = new pi(0, 0, -1)) {
      this.origin = t3, this.direction = e3;
    }
    set(t3, e3) {
      return this.origin.copy(t3), this.direction.copy(e3), this;
    }
    copy(t3) {
      return this.origin.copy(t3.origin), this.direction.copy(t3.direction), this;
    }
    at(t3, e3) {
      return e3.copy(this.direction).multiplyScalar(t3).add(this.origin);
    }
    lookAt(t3) {
      return this.direction.copy(t3).sub(this.origin).normalize(), this;
    }
    recast(t3) {
      return this.origin.copy(this.at(t3, Fi)), this;
    }
    closestPointToPoint(t3, e3) {
      e3.subVectors(t3, this.origin);
      const n2 = e3.dot(this.direction);
      return n2 < 0 ? e3.copy(this.origin) : e3.copy(this.direction).multiplyScalar(n2).add(this.origin);
    }
    distanceToPoint(t3) {
      return Math.sqrt(this.distanceSqToPoint(t3));
    }
    distanceSqToPoint(t3) {
      const e3 = Fi.subVectors(t3, this.origin).dot(this.direction);
      return e3 < 0 ? this.origin.distanceToSquared(t3) : (Fi.copy(this.direction).multiplyScalar(e3).add(this.origin), Fi.distanceToSquared(t3));
    }
    distanceSqToSegment(t3, e3, n2, i2) {
      Bi.copy(t3).add(e3).multiplyScalar(0.5), Ui.copy(e3).sub(t3).normalize(), ki.copy(this.origin).sub(Bi);
      const r3 = 0.5 * t3.distanceTo(e3), o3 = -this.direction.dot(Ui), s3 = ki.dot(this.direction), a2 = -ki.dot(Ui), l2 = ki.lengthSq(), u2 = Math.abs(1 - o3 * o3);
      let h2, c2, d2, p2;
      if (u2 > 0)
        if (h2 = o3 * a2 - s3, c2 = o3 * s3 - a2, p2 = r3 * u2, h2 >= 0)
          if (c2 >= -p2)
            if (c2 <= p2) {
              const t4 = 1 / u2;
              h2 *= t4, c2 *= t4, d2 = h2 * (h2 + o3 * c2 + 2 * s3) + c2 * (o3 * h2 + c2 + 2 * a2) + l2;
            } else
              c2 = r3, h2 = Math.max(0, -(o3 * c2 + s3)), d2 = -h2 * h2 + c2 * (c2 + 2 * a2) + l2;
          else
            c2 = -r3, h2 = Math.max(0, -(o3 * c2 + s3)), d2 = -h2 * h2 + c2 * (c2 + 2 * a2) + l2;
        else
          c2 <= -p2 ? (h2 = Math.max(0, -(-o3 * r3 + s3)), c2 = h2 > 0 ? -r3 : Math.min(Math.max(-r3, -a2), r3), d2 = -h2 * h2 + c2 * (c2 + 2 * a2) + l2) : c2 <= p2 ? (h2 = 0, c2 = Math.min(Math.max(-r3, -a2), r3), d2 = c2 * (c2 + 2 * a2) + l2) : (h2 = Math.max(0, -(o3 * r3 + s3)), c2 = h2 > 0 ? r3 : Math.min(Math.max(-r3, -a2), r3), d2 = -h2 * h2 + c2 * (c2 + 2 * a2) + l2);
      else
        c2 = o3 > 0 ? -r3 : r3, h2 = Math.max(0, -(o3 * c2 + s3)), d2 = -h2 * h2 + c2 * (c2 + 2 * a2) + l2;
      return n2 && n2.copy(this.direction).multiplyScalar(h2).add(this.origin), i2 && i2.copy(Ui).multiplyScalar(c2).add(Bi), d2;
    }
    intersectSphere(t3, e3) {
      Fi.subVectors(t3.center, this.origin);
      const n2 = Fi.dot(this.direction), i2 = Fi.dot(Fi) - n2 * n2, r3 = t3.radius * t3.radius;
      if (i2 > r3)
        return null;
      const o3 = Math.sqrt(r3 - i2), s3 = n2 - o3, a2 = n2 + o3;
      return s3 < 0 && a2 < 0 ? null : s3 < 0 ? this.at(a2, e3) : this.at(s3, e3);
    }
    intersectsSphere(t3) {
      return this.distanceSqToPoint(t3.center) <= t3.radius * t3.radius;
    }
    distanceToPlane(t3) {
      const e3 = t3.normal.dot(this.direction);
      if (e3 === 0)
        return t3.distanceToPoint(this.origin) === 0 ? 0 : null;
      const n2 = -(this.origin.dot(t3.normal) + t3.constant) / e3;
      return n2 >= 0 ? n2 : null;
    }
    intersectPlane(t3, e3) {
      const n2 = this.distanceToPlane(t3);
      return n2 === null ? null : this.at(n2, e3);
    }
    intersectsPlane(t3) {
      const e3 = t3.distanceToPoint(this.origin);
      if (e3 === 0)
        return true;
      return t3.normal.dot(this.direction) * e3 < 0;
    }
    intersectBox(t3, e3) {
      let n2, i2, r3, o3, s3, a2;
      const l2 = 1 / this.direction.x, u2 = 1 / this.direction.y, h2 = 1 / this.direction.z, c2 = this.origin;
      return l2 >= 0 ? (n2 = (t3.min.x - c2.x) * l2, i2 = (t3.max.x - c2.x) * l2) : (n2 = (t3.max.x - c2.x) * l2, i2 = (t3.min.x - c2.x) * l2), u2 >= 0 ? (r3 = (t3.min.y - c2.y) * u2, o3 = (t3.max.y - c2.y) * u2) : (r3 = (t3.max.y - c2.y) * u2, o3 = (t3.min.y - c2.y) * u2), n2 > o3 || r3 > i2 ? null : ((r3 > n2 || n2 != n2) && (n2 = r3), (o3 < i2 || i2 != i2) && (i2 = o3), h2 >= 0 ? (s3 = (t3.min.z - c2.z) * h2, a2 = (t3.max.z - c2.z) * h2) : (s3 = (t3.max.z - c2.z) * h2, a2 = (t3.min.z - c2.z) * h2), n2 > a2 || s3 > i2 ? null : ((s3 > n2 || n2 != n2) && (n2 = s3), (a2 < i2 || i2 != i2) && (i2 = a2), i2 < 0 ? null : this.at(n2 >= 0 ? n2 : i2, e3)));
    }
    intersectsBox(t3) {
      return this.intersectBox(t3, Fi) !== null;
    }
    intersectTriangle(t3, e3, n2, i2, r3) {
      Gi.subVectors(e3, t3), Hi.subVectors(n2, t3), zi.crossVectors(Gi, Hi);
      let o3, s3 = this.direction.dot(zi);
      if (s3 > 0) {
        if (i2)
          return null;
        o3 = 1;
      } else {
        if (!(s3 < 0))
          return null;
        o3 = -1, s3 = -s3;
      }
      ki.subVectors(this.origin, t3);
      const a2 = o3 * this.direction.dot(Hi.crossVectors(ki, Hi));
      if (a2 < 0)
        return null;
      const l2 = o3 * this.direction.dot(Gi.cross(ki));
      if (l2 < 0)
        return null;
      if (a2 + l2 > s3)
        return null;
      const u2 = -o3 * ki.dot(zi);
      return u2 < 0 ? null : this.at(u2 / s3, r3);
    }
    applyMatrix4(t3) {
      return this.origin.applyMatrix4(t3), this.direction.transformDirection(t3), this;
    }
    equals(t3) {
      return t3.origin.equals(this.origin) && t3.direction.equals(this.direction);
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  class Vi {
    constructor() {
      this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
    }
    set(t3, e3, n2, i2, r3, o3, s3, a2, l2, u2, h2, c2, d2, p2, f2, m2) {
      const g2 = this.elements;
      return g2[0] = t3, g2[4] = e3, g2[8] = n2, g2[12] = i2, g2[1] = r3, g2[5] = o3, g2[9] = s3, g2[13] = a2, g2[2] = l2, g2[6] = u2, g2[10] = h2, g2[14] = c2, g2[3] = d2, g2[7] = p2, g2[11] = f2, g2[15] = m2, this;
    }
    identity() {
      return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }
    clone() {
      return new Vi().fromArray(this.elements);
    }
    copy(t3) {
      const e3 = this.elements, n2 = t3.elements;
      return e3[0] = n2[0], e3[1] = n2[1], e3[2] = n2[2], e3[3] = n2[3], e3[4] = n2[4], e3[5] = n2[5], e3[6] = n2[6], e3[7] = n2[7], e3[8] = n2[8], e3[9] = n2[9], e3[10] = n2[10], e3[11] = n2[11], e3[12] = n2[12], e3[13] = n2[13], e3[14] = n2[14], e3[15] = n2[15], this;
    }
    copyPosition(t3) {
      const e3 = this.elements, n2 = t3.elements;
      return e3[12] = n2[12], e3[13] = n2[13], e3[14] = n2[14], this;
    }
    setFromMatrix3(t3) {
      const e3 = t3.elements;
      return this.set(e3[0], e3[3], e3[6], 0, e3[1], e3[4], e3[7], 0, e3[2], e3[5], e3[8], 0, 0, 0, 0, 1), this;
    }
    extractBasis(t3, e3, n2) {
      return t3.setFromMatrixColumn(this, 0), e3.setFromMatrixColumn(this, 1), n2.setFromMatrixColumn(this, 2), this;
    }
    makeBasis(t3, e3, n2) {
      return this.set(t3.x, e3.x, n2.x, 0, t3.y, e3.y, n2.y, 0, t3.z, e3.z, n2.z, 0, 0, 0, 0, 1), this;
    }
    extractRotation(t3) {
      const e3 = this.elements, n2 = t3.elements, i2 = 1 / Wi.setFromMatrixColumn(t3, 0).length(), r3 = 1 / Wi.setFromMatrixColumn(t3, 1).length(), o3 = 1 / Wi.setFromMatrixColumn(t3, 2).length();
      return e3[0] = n2[0] * i2, e3[1] = n2[1] * i2, e3[2] = n2[2] * i2, e3[3] = 0, e3[4] = n2[4] * r3, e3[5] = n2[5] * r3, e3[6] = n2[6] * r3, e3[7] = 0, e3[8] = n2[8] * o3, e3[9] = n2[9] * o3, e3[10] = n2[10] * o3, e3[11] = 0, e3[12] = 0, e3[13] = 0, e3[14] = 0, e3[15] = 1, this;
    }
    makeRotationFromEuler(t3) {
      t3 && t3.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
      const e3 = this.elements, n2 = t3.x, i2 = t3.y, r3 = t3.z, o3 = Math.cos(n2), s3 = Math.sin(n2), a2 = Math.cos(i2), l2 = Math.sin(i2), u2 = Math.cos(r3), h2 = Math.sin(r3);
      if (t3.order === "XYZ") {
        const t4 = o3 * u2, n3 = o3 * h2, i3 = s3 * u2, r4 = s3 * h2;
        e3[0] = a2 * u2, e3[4] = -a2 * h2, e3[8] = l2, e3[1] = n3 + i3 * l2, e3[5] = t4 - r4 * l2, e3[9] = -s3 * a2, e3[2] = r4 - t4 * l2, e3[6] = i3 + n3 * l2, e3[10] = o3 * a2;
      } else if (t3.order === "YXZ") {
        const t4 = a2 * u2, n3 = a2 * h2, i3 = l2 * u2, r4 = l2 * h2;
        e3[0] = t4 + r4 * s3, e3[4] = i3 * s3 - n3, e3[8] = o3 * l2, e3[1] = o3 * h2, e3[5] = o3 * u2, e3[9] = -s3, e3[2] = n3 * s3 - i3, e3[6] = r4 + t4 * s3, e3[10] = o3 * a2;
      } else if (t3.order === "ZXY") {
        const t4 = a2 * u2, n3 = a2 * h2, i3 = l2 * u2, r4 = l2 * h2;
        e3[0] = t4 - r4 * s3, e3[4] = -o3 * h2, e3[8] = i3 + n3 * s3, e3[1] = n3 + i3 * s3, e3[5] = o3 * u2, e3[9] = r4 - t4 * s3, e3[2] = -o3 * l2, e3[6] = s3, e3[10] = o3 * a2;
      } else if (t3.order === "ZYX") {
        const t4 = o3 * u2, n3 = o3 * h2, i3 = s3 * u2, r4 = s3 * h2;
        e3[0] = a2 * u2, e3[4] = i3 * l2 - n3, e3[8] = t4 * l2 + r4, e3[1] = a2 * h2, e3[5] = r4 * l2 + t4, e3[9] = n3 * l2 - i3, e3[2] = -l2, e3[6] = s3 * a2, e3[10] = o3 * a2;
      } else if (t3.order === "YZX") {
        const t4 = o3 * a2, n3 = o3 * l2, i3 = s3 * a2, r4 = s3 * l2;
        e3[0] = a2 * u2, e3[4] = r4 - t4 * h2, e3[8] = i3 * h2 + n3, e3[1] = h2, e3[5] = o3 * u2, e3[9] = -s3 * u2, e3[2] = -l2 * u2, e3[6] = n3 * h2 + i3, e3[10] = t4 - r4 * h2;
      } else if (t3.order === "XZY") {
        const t4 = o3 * a2, n3 = o3 * l2, i3 = s3 * a2, r4 = s3 * l2;
        e3[0] = a2 * u2, e3[4] = -h2, e3[8] = l2 * u2, e3[1] = t4 * h2 + r4, e3[5] = o3 * u2, e3[9] = n3 * h2 - i3, e3[2] = i3 * h2 - n3, e3[6] = s3 * u2, e3[10] = r4 * h2 + t4;
      }
      return e3[3] = 0, e3[7] = 0, e3[11] = 0, e3[12] = 0, e3[13] = 0, e3[14] = 0, e3[15] = 1, this;
    }
    makeRotationFromQuaternion(t3) {
      return this.compose(qi, t3, Yi);
    }
    lookAt(t3, e3, n2) {
      const i2 = this.elements;
      return $i.subVectors(t3, e3), $i.lengthSq() === 0 && ($i.z = 1), $i.normalize(), Zi.crossVectors(n2, $i), Zi.lengthSq() === 0 && (Math.abs(n2.z) === 1 ? $i.x += 1e-4 : $i.z += 1e-4, $i.normalize(), Zi.crossVectors(n2, $i)), Zi.normalize(), Ji.crossVectors($i, Zi), i2[0] = Zi.x, i2[4] = Ji.x, i2[8] = $i.x, i2[1] = Zi.y, i2[5] = Ji.y, i2[9] = $i.y, i2[2] = Zi.z, i2[6] = Ji.z, i2[10] = $i.z, this;
    }
    multiply(t3, e3) {
      return e3 !== void 0 ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t3, e3)) : this.multiplyMatrices(this, t3);
    }
    premultiply(t3) {
      return this.multiplyMatrices(t3, this);
    }
    multiplyMatrices(t3, e3) {
      const n2 = t3.elements, i2 = e3.elements, r3 = this.elements, o3 = n2[0], s3 = n2[4], a2 = n2[8], l2 = n2[12], u2 = n2[1], h2 = n2[5], c2 = n2[9], d2 = n2[13], p2 = n2[2], f2 = n2[6], m2 = n2[10], g2 = n2[14], v2 = n2[3], _2 = n2[7], y2 = n2[11], x2 = n2[15], b2 = i2[0], T2 = i2[4], w2 = i2[8], S2 = i2[12], E2 = i2[1], M2 = i2[5], A2 = i2[9], R2 = i2[13], P2 = i2[2], C2 = i2[6], I2 = i2[10], O2 = i2[14], L2 = i2[3], N2 = i2[7], D2 = i2[11], F2 = i2[15];
      return r3[0] = o3 * b2 + s3 * E2 + a2 * P2 + l2 * L2, r3[4] = o3 * T2 + s3 * M2 + a2 * C2 + l2 * N2, r3[8] = o3 * w2 + s3 * A2 + a2 * I2 + l2 * D2, r3[12] = o3 * S2 + s3 * R2 + a2 * O2 + l2 * F2, r3[1] = u2 * b2 + h2 * E2 + c2 * P2 + d2 * L2, r3[5] = u2 * T2 + h2 * M2 + c2 * C2 + d2 * N2, r3[9] = u2 * w2 + h2 * A2 + c2 * I2 + d2 * D2, r3[13] = u2 * S2 + h2 * R2 + c2 * O2 + d2 * F2, r3[2] = p2 * b2 + f2 * E2 + m2 * P2 + g2 * L2, r3[6] = p2 * T2 + f2 * M2 + m2 * C2 + g2 * N2, r3[10] = p2 * w2 + f2 * A2 + m2 * I2 + g2 * D2, r3[14] = p2 * S2 + f2 * R2 + m2 * O2 + g2 * F2, r3[3] = v2 * b2 + _2 * E2 + y2 * P2 + x2 * L2, r3[7] = v2 * T2 + _2 * M2 + y2 * C2 + x2 * N2, r3[11] = v2 * w2 + _2 * A2 + y2 * I2 + x2 * D2, r3[15] = v2 * S2 + _2 * R2 + y2 * O2 + x2 * F2, this;
    }
    multiplyScalar(t3) {
      const e3 = this.elements;
      return e3[0] *= t3, e3[4] *= t3, e3[8] *= t3, e3[12] *= t3, e3[1] *= t3, e3[5] *= t3, e3[9] *= t3, e3[13] *= t3, e3[2] *= t3, e3[6] *= t3, e3[10] *= t3, e3[14] *= t3, e3[3] *= t3, e3[7] *= t3, e3[11] *= t3, e3[15] *= t3, this;
    }
    determinant() {
      const t3 = this.elements, e3 = t3[0], n2 = t3[4], i2 = t3[8], r3 = t3[12], o3 = t3[1], s3 = t3[5], a2 = t3[9], l2 = t3[13], u2 = t3[2], h2 = t3[6], c2 = t3[10], d2 = t3[14];
      return t3[3] * (+r3 * a2 * h2 - i2 * l2 * h2 - r3 * s3 * c2 + n2 * l2 * c2 + i2 * s3 * d2 - n2 * a2 * d2) + t3[7] * (+e3 * a2 * d2 - e3 * l2 * c2 + r3 * o3 * c2 - i2 * o3 * d2 + i2 * l2 * u2 - r3 * a2 * u2) + t3[11] * (+e3 * l2 * h2 - e3 * s3 * d2 - r3 * o3 * h2 + n2 * o3 * d2 + r3 * s3 * u2 - n2 * l2 * u2) + t3[15] * (-i2 * s3 * u2 - e3 * a2 * h2 + e3 * s3 * c2 + i2 * o3 * h2 - n2 * o3 * c2 + n2 * a2 * u2);
    }
    transpose() {
      const t3 = this.elements;
      let e3;
      return e3 = t3[1], t3[1] = t3[4], t3[4] = e3, e3 = t3[2], t3[2] = t3[8], t3[8] = e3, e3 = t3[6], t3[6] = t3[9], t3[9] = e3, e3 = t3[3], t3[3] = t3[12], t3[12] = e3, e3 = t3[7], t3[7] = t3[13], t3[13] = e3, e3 = t3[11], t3[11] = t3[14], t3[14] = e3, this;
    }
    setPosition(t3, e3, n2) {
      const i2 = this.elements;
      return t3.isVector3 ? (i2[12] = t3.x, i2[13] = t3.y, i2[14] = t3.z) : (i2[12] = t3, i2[13] = e3, i2[14] = n2), this;
    }
    invert() {
      const t3 = this.elements, e3 = t3[0], n2 = t3[1], i2 = t3[2], r3 = t3[3], o3 = t3[4], s3 = t3[5], a2 = t3[6], l2 = t3[7], u2 = t3[8], h2 = t3[9], c2 = t3[10], d2 = t3[11], p2 = t3[12], f2 = t3[13], m2 = t3[14], g2 = t3[15], v2 = h2 * m2 * l2 - f2 * c2 * l2 + f2 * a2 * d2 - s3 * m2 * d2 - h2 * a2 * g2 + s3 * c2 * g2, _2 = p2 * c2 * l2 - u2 * m2 * l2 - p2 * a2 * d2 + o3 * m2 * d2 + u2 * a2 * g2 - o3 * c2 * g2, y2 = u2 * f2 * l2 - p2 * h2 * l2 + p2 * s3 * d2 - o3 * f2 * d2 - u2 * s3 * g2 + o3 * h2 * g2, x2 = p2 * h2 * a2 - u2 * f2 * a2 - p2 * s3 * c2 + o3 * f2 * c2 + u2 * s3 * m2 - o3 * h2 * m2, b2 = e3 * v2 + n2 * _2 + i2 * y2 + r3 * x2;
      if (b2 === 0)
        return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      const T2 = 1 / b2;
      return t3[0] = v2 * T2, t3[1] = (f2 * c2 * r3 - h2 * m2 * r3 - f2 * i2 * d2 + n2 * m2 * d2 + h2 * i2 * g2 - n2 * c2 * g2) * T2, t3[2] = (s3 * m2 * r3 - f2 * a2 * r3 + f2 * i2 * l2 - n2 * m2 * l2 - s3 * i2 * g2 + n2 * a2 * g2) * T2, t3[3] = (h2 * a2 * r3 - s3 * c2 * r3 - h2 * i2 * l2 + n2 * c2 * l2 + s3 * i2 * d2 - n2 * a2 * d2) * T2, t3[4] = _2 * T2, t3[5] = (u2 * m2 * r3 - p2 * c2 * r3 + p2 * i2 * d2 - e3 * m2 * d2 - u2 * i2 * g2 + e3 * c2 * g2) * T2, t3[6] = (p2 * a2 * r3 - o3 * m2 * r3 - p2 * i2 * l2 + e3 * m2 * l2 + o3 * i2 * g2 - e3 * a2 * g2) * T2, t3[7] = (o3 * c2 * r3 - u2 * a2 * r3 + u2 * i2 * l2 - e3 * c2 * l2 - o3 * i2 * d2 + e3 * a2 * d2) * T2, t3[8] = y2 * T2, t3[9] = (p2 * h2 * r3 - u2 * f2 * r3 - p2 * n2 * d2 + e3 * f2 * d2 + u2 * n2 * g2 - e3 * h2 * g2) * T2, t3[10] = (o3 * f2 * r3 - p2 * s3 * r3 + p2 * n2 * l2 - e3 * f2 * l2 - o3 * n2 * g2 + e3 * s3 * g2) * T2, t3[11] = (u2 * s3 * r3 - o3 * h2 * r3 - u2 * n2 * l2 + e3 * h2 * l2 + o3 * n2 * d2 - e3 * s3 * d2) * T2, t3[12] = x2 * T2, t3[13] = (u2 * f2 * i2 - p2 * h2 * i2 + p2 * n2 * c2 - e3 * f2 * c2 - u2 * n2 * m2 + e3 * h2 * m2) * T2, t3[14] = (p2 * s3 * i2 - o3 * f2 * i2 - p2 * n2 * a2 + e3 * f2 * a2 + o3 * n2 * m2 - e3 * s3 * m2) * T2, t3[15] = (o3 * h2 * i2 - u2 * s3 * i2 + u2 * n2 * a2 - e3 * h2 * a2 - o3 * n2 * c2 + e3 * s3 * c2) * T2, this;
    }
    scale(t3) {
      const e3 = this.elements, n2 = t3.x, i2 = t3.y, r3 = t3.z;
      return e3[0] *= n2, e3[4] *= i2, e3[8] *= r3, e3[1] *= n2, e3[5] *= i2, e3[9] *= r3, e3[2] *= n2, e3[6] *= i2, e3[10] *= r3, e3[3] *= n2, e3[7] *= i2, e3[11] *= r3, this;
    }
    getMaxScaleOnAxis() {
      const t3 = this.elements, e3 = t3[0] * t3[0] + t3[1] * t3[1] + t3[2] * t3[2], n2 = t3[4] * t3[4] + t3[5] * t3[5] + t3[6] * t3[6], i2 = t3[8] * t3[8] + t3[9] * t3[9] + t3[10] * t3[10];
      return Math.sqrt(Math.max(e3, n2, i2));
    }
    makeTranslation(t3, e3, n2) {
      return this.set(1, 0, 0, t3, 0, 1, 0, e3, 0, 0, 1, n2, 0, 0, 0, 1), this;
    }
    makeRotationX(t3) {
      const e3 = Math.cos(t3), n2 = Math.sin(t3);
      return this.set(1, 0, 0, 0, 0, e3, -n2, 0, 0, n2, e3, 0, 0, 0, 0, 1), this;
    }
    makeRotationY(t3) {
      const e3 = Math.cos(t3), n2 = Math.sin(t3);
      return this.set(e3, 0, n2, 0, 0, 1, 0, 0, -n2, 0, e3, 0, 0, 0, 0, 1), this;
    }
    makeRotationZ(t3) {
      const e3 = Math.cos(t3), n2 = Math.sin(t3);
      return this.set(e3, -n2, 0, 0, n2, e3, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }
    makeRotationAxis(t3, e3) {
      const n2 = Math.cos(e3), i2 = Math.sin(e3), r3 = 1 - n2, o3 = t3.x, s3 = t3.y, a2 = t3.z, l2 = r3 * o3, u2 = r3 * s3;
      return this.set(l2 * o3 + n2, l2 * s3 - i2 * a2, l2 * a2 + i2 * s3, 0, l2 * s3 + i2 * a2, u2 * s3 + n2, u2 * a2 - i2 * o3, 0, l2 * a2 - i2 * s3, u2 * a2 + i2 * o3, r3 * a2 * a2 + n2, 0, 0, 0, 0, 1), this;
    }
    makeScale(t3, e3, n2) {
      return this.set(t3, 0, 0, 0, 0, e3, 0, 0, 0, 0, n2, 0, 0, 0, 0, 1), this;
    }
    makeShear(t3, e3, n2, i2, r3, o3) {
      return this.set(1, n2, r3, 0, t3, 1, o3, 0, e3, i2, 1, 0, 0, 0, 0, 1), this;
    }
    compose(t3, e3, n2) {
      const i2 = this.elements, r3 = e3._x, o3 = e3._y, s3 = e3._z, a2 = e3._w, l2 = r3 + r3, u2 = o3 + o3, h2 = s3 + s3, c2 = r3 * l2, d2 = r3 * u2, p2 = r3 * h2, f2 = o3 * u2, m2 = o3 * h2, g2 = s3 * h2, v2 = a2 * l2, _2 = a2 * u2, y2 = a2 * h2, x2 = n2.x, b2 = n2.y, T2 = n2.z;
      return i2[0] = (1 - (f2 + g2)) * x2, i2[1] = (d2 + y2) * x2, i2[2] = (p2 - _2) * x2, i2[3] = 0, i2[4] = (d2 - y2) * b2, i2[5] = (1 - (c2 + g2)) * b2, i2[6] = (m2 + v2) * b2, i2[7] = 0, i2[8] = (p2 + _2) * T2, i2[9] = (m2 - v2) * T2, i2[10] = (1 - (c2 + f2)) * T2, i2[11] = 0, i2[12] = t3.x, i2[13] = t3.y, i2[14] = t3.z, i2[15] = 1, this;
    }
    decompose(t3, e3, n2) {
      const i2 = this.elements;
      let r3 = Wi.set(i2[0], i2[1], i2[2]).length();
      const o3 = Wi.set(i2[4], i2[5], i2[6]).length(), s3 = Wi.set(i2[8], i2[9], i2[10]).length();
      this.determinant() < 0 && (r3 = -r3), t3.x = i2[12], t3.y = i2[13], t3.z = i2[14], Xi.copy(this);
      const a2 = 1 / r3, l2 = 1 / o3, u2 = 1 / s3;
      return Xi.elements[0] *= a2, Xi.elements[1] *= a2, Xi.elements[2] *= a2, Xi.elements[4] *= l2, Xi.elements[5] *= l2, Xi.elements[6] *= l2, Xi.elements[8] *= u2, Xi.elements[9] *= u2, Xi.elements[10] *= u2, e3.setFromRotationMatrix(Xi), n2.x = r3, n2.y = o3, n2.z = s3, this;
    }
    makePerspective(t3, e3, n2, i2, r3, o3) {
      o3 === void 0 && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
      const s3 = this.elements, a2 = 2 * r3 / (e3 - t3), l2 = 2 * r3 / (n2 - i2), u2 = (e3 + t3) / (e3 - t3), h2 = (n2 + i2) / (n2 - i2), c2 = -(o3 + r3) / (o3 - r3), d2 = -2 * o3 * r3 / (o3 - r3);
      return s3[0] = a2, s3[4] = 0, s3[8] = u2, s3[12] = 0, s3[1] = 0, s3[5] = l2, s3[9] = h2, s3[13] = 0, s3[2] = 0, s3[6] = 0, s3[10] = c2, s3[14] = d2, s3[3] = 0, s3[7] = 0, s3[11] = -1, s3[15] = 0, this;
    }
    makeOrthographic(t3, e3, n2, i2, r3, o3) {
      const s3 = this.elements, a2 = 1 / (e3 - t3), l2 = 1 / (n2 - i2), u2 = 1 / (o3 - r3), h2 = (e3 + t3) * a2, c2 = (n2 + i2) * l2, d2 = (o3 + r3) * u2;
      return s3[0] = 2 * a2, s3[4] = 0, s3[8] = 0, s3[12] = -h2, s3[1] = 0, s3[5] = 2 * l2, s3[9] = 0, s3[13] = -c2, s3[2] = 0, s3[6] = 0, s3[10] = -2 * u2, s3[14] = -d2, s3[3] = 0, s3[7] = 0, s3[11] = 0, s3[15] = 1, this;
    }
    equals(t3) {
      const e3 = this.elements, n2 = t3.elements;
      for (let t4 = 0; t4 < 16; t4++)
        if (e3[t4] !== n2[t4])
          return false;
      return true;
    }
    fromArray(t3, e3 = 0) {
      for (let n2 = 0; n2 < 16; n2++)
        this.elements[n2] = t3[n2 + e3];
      return this;
    }
    toArray(t3 = [], e3 = 0) {
      const n2 = this.elements;
      return t3[e3] = n2[0], t3[e3 + 1] = n2[1], t3[e3 + 2] = n2[2], t3[e3 + 3] = n2[3], t3[e3 + 4] = n2[4], t3[e3 + 5] = n2[5], t3[e3 + 6] = n2[6], t3[e3 + 7] = n2[7], t3[e3 + 8] = n2[8], t3[e3 + 9] = n2[9], t3[e3 + 10] = n2[10], t3[e3 + 11] = n2[11], t3[e3 + 12] = n2[12], t3[e3 + 13] = n2[13], t3[e3 + 14] = n2[14], t3[e3 + 15] = n2[15], t3;
    }
  }
  Vi.prototype.isMatrix4 = true;
  const Wi = new pi(), Xi = new Vi(), qi = new pi(0, 0, 0), Yi = new pi(1, 1, 1), Zi = new pi(), Ji = new pi(), $i = new pi(), Ki = new Vi(), Qi = new di();
  class tr {
    constructor(t3 = 0, e3 = 0, n2 = 0, i2 = tr.DefaultOrder) {
      this._x = t3, this._y = e3, this._z = n2, this._order = i2;
    }
    get x() {
      return this._x;
    }
    set x(t3) {
      this._x = t3, this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(t3) {
      this._y = t3, this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(t3) {
      this._z = t3, this._onChangeCallback();
    }
    get order() {
      return this._order;
    }
    set order(t3) {
      this._order = t3, this._onChangeCallback();
    }
    set(t3, e3, n2, i2 = this._order) {
      return this._x = t3, this._y = e3, this._z = n2, this._order = i2, this._onChangeCallback(), this;
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._order);
    }
    copy(t3) {
      return this._x = t3._x, this._y = t3._y, this._z = t3._z, this._order = t3._order, this._onChangeCallback(), this;
    }
    setFromRotationMatrix(t3, e3 = this._order, n2 = true) {
      const i2 = t3.elements, r3 = i2[0], o3 = i2[4], s3 = i2[8], a2 = i2[1], l2 = i2[5], u2 = i2[9], h2 = i2[2], c2 = i2[6], d2 = i2[10];
      switch (e3) {
        case "XYZ":
          this._y = Math.asin(Yn(s3, -1, 1)), Math.abs(s3) < 0.9999999 ? (this._x = Math.atan2(-u2, d2), this._z = Math.atan2(-o3, r3)) : (this._x = Math.atan2(c2, l2), this._z = 0);
          break;
        case "YXZ":
          this._x = Math.asin(-Yn(u2, -1, 1)), Math.abs(u2) < 0.9999999 ? (this._y = Math.atan2(s3, d2), this._z = Math.atan2(a2, l2)) : (this._y = Math.atan2(-h2, r3), this._z = 0);
          break;
        case "ZXY":
          this._x = Math.asin(Yn(c2, -1, 1)), Math.abs(c2) < 0.9999999 ? (this._y = Math.atan2(-h2, d2), this._z = Math.atan2(-o3, l2)) : (this._y = 0, this._z = Math.atan2(a2, r3));
          break;
        case "ZYX":
          this._y = Math.asin(-Yn(h2, -1, 1)), Math.abs(h2) < 0.9999999 ? (this._x = Math.atan2(c2, d2), this._z = Math.atan2(a2, r3)) : (this._x = 0, this._z = Math.atan2(-o3, l2));
          break;
        case "YZX":
          this._z = Math.asin(Yn(a2, -1, 1)), Math.abs(a2) < 0.9999999 ? (this._x = Math.atan2(-u2, l2), this._y = Math.atan2(-h2, r3)) : (this._x = 0, this._y = Math.atan2(s3, d2));
          break;
        case "XZY":
          this._z = Math.asin(-Yn(o3, -1, 1)), Math.abs(o3) < 0.9999999 ? (this._x = Math.atan2(c2, l2), this._y = Math.atan2(s3, r3)) : (this._x = Math.atan2(-u2, d2), this._y = 0);
          break;
        default:
          console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e3);
      }
      return this._order = e3, n2 === true && this._onChangeCallback(), this;
    }
    setFromQuaternion(t3, e3, n2) {
      return Ki.makeRotationFromQuaternion(t3), this.setFromRotationMatrix(Ki, e3, n2);
    }
    setFromVector3(t3, e3 = this._order) {
      return this.set(t3.x, t3.y, t3.z, e3);
    }
    reorder(t3) {
      return Qi.setFromEuler(this), this.setFromQuaternion(Qi, t3);
    }
    equals(t3) {
      return t3._x === this._x && t3._y === this._y && t3._z === this._z && t3._order === this._order;
    }
    fromArray(t3) {
      return this._x = t3[0], this._y = t3[1], this._z = t3[2], t3[3] !== void 0 && (this._order = t3[3]), this._onChangeCallback(), this;
    }
    toArray(t3 = [], e3 = 0) {
      return t3[e3] = this._x, t3[e3 + 1] = this._y, t3[e3 + 2] = this._z, t3[e3 + 3] = this._order, t3;
    }
    toVector3(t3) {
      return t3 ? t3.set(this._x, this._y, this._z) : new pi(this._x, this._y, this._z);
    }
    _onChange(t3) {
      return this._onChangeCallback = t3, this;
    }
    _onChangeCallback() {
    }
  }
  tr.prototype.isEuler = true, tr.DefaultOrder = "XYZ", tr.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
  class er {
    constructor() {
      this.mask = 1;
    }
    set(t3) {
      this.mask = 1 << t3 | 0;
    }
    enable(t3) {
      this.mask |= 1 << t3 | 0;
    }
    enableAll() {
      this.mask = -1;
    }
    toggle(t3) {
      this.mask ^= 1 << t3 | 0;
    }
    disable(t3) {
      this.mask &= ~(1 << t3 | 0);
    }
    disableAll() {
      this.mask = 0;
    }
    test(t3) {
      return (this.mask & t3.mask) != 0;
    }
  }
  let nr = 0;
  const ir = new pi(), rr = new di(), or = new Vi(), sr = new pi(), ar = new pi(), lr = new pi(), ur = new di(), hr = new pi(1, 0, 0), cr = new pi(0, 1, 0), dr = new pi(0, 0, 1), pr = { type: "added" }, fr = { type: "removed" };
  class mr extends zn {
    constructor() {
      super(), Object.defineProperty(this, "id", { value: nr++ }), this.uuid = qn(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = mr.DefaultUp.clone();
      const t3 = new pi(), e3 = new tr(), n2 = new di(), i2 = new pi(1, 1, 1);
      e3._onChange(function() {
        n2.setFromEuler(e3, false);
      }), n2._onChange(function() {
        e3.setFromQuaternion(n2, void 0, false);
      }), Object.defineProperties(this, { position: { configurable: true, enumerable: true, value: t3 }, rotation: { configurable: true, enumerable: true, value: e3 }, quaternion: { configurable: true, enumerable: true, value: n2 }, scale: { configurable: true, enumerable: true, value: i2 }, modelViewMatrix: { value: new Vi() }, normalMatrix: { value: new ni() } }), this.matrix = new Vi(), this.matrixWorld = new Vi(), this.matrixAutoUpdate = mr.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = false, this.layers = new er(), this.visible = true, this.castShadow = false, this.receiveShadow = false, this.frustumCulled = true, this.renderOrder = 0, this.animations = [], this.userData = {};
    }
    onBeforeRender() {
    }
    onAfterRender() {
    }
    applyMatrix4(t3) {
      this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t3), this.matrix.decompose(this.position, this.quaternion, this.scale);
    }
    applyQuaternion(t3) {
      return this.quaternion.premultiply(t3), this;
    }
    setRotationFromAxisAngle(t3, e3) {
      this.quaternion.setFromAxisAngle(t3, e3);
    }
    setRotationFromEuler(t3) {
      this.quaternion.setFromEuler(t3, true);
    }
    setRotationFromMatrix(t3) {
      this.quaternion.setFromRotationMatrix(t3);
    }
    setRotationFromQuaternion(t3) {
      this.quaternion.copy(t3);
    }
    rotateOnAxis(t3, e3) {
      return rr.setFromAxisAngle(t3, e3), this.quaternion.multiply(rr), this;
    }
    rotateOnWorldAxis(t3, e3) {
      return rr.setFromAxisAngle(t3, e3), this.quaternion.premultiply(rr), this;
    }
    rotateX(t3) {
      return this.rotateOnAxis(hr, t3);
    }
    rotateY(t3) {
      return this.rotateOnAxis(cr, t3);
    }
    rotateZ(t3) {
      return this.rotateOnAxis(dr, t3);
    }
    translateOnAxis(t3, e3) {
      return ir.copy(t3).applyQuaternion(this.quaternion), this.position.add(ir.multiplyScalar(e3)), this;
    }
    translateX(t3) {
      return this.translateOnAxis(hr, t3);
    }
    translateY(t3) {
      return this.translateOnAxis(cr, t3);
    }
    translateZ(t3) {
      return this.translateOnAxis(dr, t3);
    }
    localToWorld(t3) {
      return t3.applyMatrix4(this.matrixWorld);
    }
    worldToLocal(t3) {
      return t3.applyMatrix4(or.copy(this.matrixWorld).invert());
    }
    lookAt(t3, e3, n2) {
      t3.isVector3 ? sr.copy(t3) : sr.set(t3, e3, n2);
      const i2 = this.parent;
      this.updateWorldMatrix(true, false), ar.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? or.lookAt(ar, sr, this.up) : or.lookAt(sr, ar, this.up), this.quaternion.setFromRotationMatrix(or), i2 && (or.extractRotation(i2.matrixWorld), rr.setFromRotationMatrix(or), this.quaternion.premultiply(rr.invert()));
    }
    add(t3) {
      if (arguments.length > 1) {
        for (let t4 = 0; t4 < arguments.length; t4++)
          this.add(arguments[t4]);
        return this;
      }
      return t3 === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t3), this) : (t3 && t3.isObject3D ? (t3.parent !== null && t3.parent.remove(t3), t3.parent = this, this.children.push(t3), t3.dispatchEvent(pr)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t3), this);
    }
    remove(t3) {
      if (arguments.length > 1) {
        for (let t4 = 0; t4 < arguments.length; t4++)
          this.remove(arguments[t4]);
        return this;
      }
      const e3 = this.children.indexOf(t3);
      return e3 !== -1 && (t3.parent = null, this.children.splice(e3, 1), t3.dispatchEvent(fr)), this;
    }
    removeFromParent() {
      const t3 = this.parent;
      return t3 !== null && t3.remove(this), this;
    }
    clear() {
      for (let t3 = 0; t3 < this.children.length; t3++) {
        const e3 = this.children[t3];
        e3.parent = null, e3.dispatchEvent(fr);
      }
      return this.children.length = 0, this;
    }
    attach(t3) {
      return this.updateWorldMatrix(true, false), or.copy(this.matrixWorld).invert(), t3.parent !== null && (t3.parent.updateWorldMatrix(true, false), or.multiply(t3.parent.matrixWorld)), t3.applyMatrix4(or), this.add(t3), t3.updateWorldMatrix(false, true), this;
    }
    getObjectById(t3) {
      return this.getObjectByProperty("id", t3);
    }
    getObjectByName(t3) {
      return this.getObjectByProperty("name", t3);
    }
    getObjectByProperty(t3, e3) {
      if (this[t3] === e3)
        return this;
      for (let n2 = 0, i2 = this.children.length; n2 < i2; n2++) {
        const i3 = this.children[n2].getObjectByProperty(t3, e3);
        if (i3 !== void 0)
          return i3;
      }
    }
    getWorldPosition(t3) {
      return this.updateWorldMatrix(true, false), t3.setFromMatrixPosition(this.matrixWorld);
    }
    getWorldQuaternion(t3) {
      return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(ar, t3, lr), t3;
    }
    getWorldScale(t3) {
      return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(ar, ur, t3), t3;
    }
    getWorldDirection(t3) {
      this.updateWorldMatrix(true, false);
      const e3 = this.matrixWorld.elements;
      return t3.set(e3[8], e3[9], e3[10]).normalize();
    }
    raycast() {
    }
    traverse(t3) {
      t3(this);
      const e3 = this.children;
      for (let n2 = 0, i2 = e3.length; n2 < i2; n2++)
        e3[n2].traverse(t3);
    }
    traverseVisible(t3) {
      if (this.visible === false)
        return;
      t3(this);
      const e3 = this.children;
      for (let n2 = 0, i2 = e3.length; n2 < i2; n2++)
        e3[n2].traverseVisible(t3);
    }
    traverseAncestors(t3) {
      const e3 = this.parent;
      e3 !== null && (t3(e3), e3.traverseAncestors(t3));
    }
    updateMatrix() {
      this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = true;
    }
    updateMatrixWorld(t3) {
      this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t3) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = false, t3 = true);
      const e3 = this.children;
      for (let n2 = 0, i2 = e3.length; n2 < i2; n2++)
        e3[n2].updateMatrixWorld(t3);
    }
    updateWorldMatrix(t3, e3) {
      const n2 = this.parent;
      if (t3 === true && n2 !== null && n2.updateWorldMatrix(true, false), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), e3 === true) {
        const t4 = this.children;
        for (let e4 = 0, n3 = t4.length; e4 < n3; e4++)
          t4[e4].updateWorldMatrix(false, true);
      }
    }
    toJSON(t3) {
      const e3 = t3 === void 0 || typeof t3 == "string", n2 = {};
      e3 && (t3 = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {} }, n2.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" });
      const i2 = {};
      function r3(e4, n3) {
        return e4[n3.uuid] === void 0 && (e4[n3.uuid] = n3.toJSON(t3)), n3.uuid;
      }
      if (i2.uuid = this.uuid, i2.type = this.type, this.name !== "" && (i2.name = this.name), this.castShadow === true && (i2.castShadow = true), this.receiveShadow === true && (i2.receiveShadow = true), this.visible === false && (i2.visible = false), this.frustumCulled === false && (i2.frustumCulled = false), this.renderOrder !== 0 && (i2.renderOrder = this.renderOrder), JSON.stringify(this.userData) !== "{}" && (i2.userData = this.userData), i2.layers = this.layers.mask, i2.matrix = this.matrix.toArray(), this.matrixAutoUpdate === false && (i2.matrixAutoUpdate = false), this.isInstancedMesh && (i2.type = "InstancedMesh", i2.count = this.count, i2.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (i2.instanceColor = this.instanceColor.toJSON())), this.isScene)
        this.background && (this.background.isColor ? i2.background = this.background.toJSON() : this.background.isTexture && (i2.background = this.background.toJSON(t3).uuid)), this.environment && this.environment.isTexture && (i2.environment = this.environment.toJSON(t3).uuid);
      else if (this.isMesh || this.isLine || this.isPoints) {
        i2.geometry = r3(t3.geometries, this.geometry);
        const e4 = this.geometry.parameters;
        if (e4 !== void 0 && e4.shapes !== void 0) {
          const n3 = e4.shapes;
          if (Array.isArray(n3))
            for (let e5 = 0, i3 = n3.length; e5 < i3; e5++) {
              const i4 = n3[e5];
              r3(t3.shapes, i4);
            }
          else
            r3(t3.shapes, n3);
        }
      }
      if (this.isSkinnedMesh && (i2.bindMode = this.bindMode, i2.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (r3(t3.skeletons, this.skeleton), i2.skeleton = this.skeleton.uuid)), this.material !== void 0)
        if (Array.isArray(this.material)) {
          const e4 = [];
          for (let n3 = 0, i3 = this.material.length; n3 < i3; n3++)
            e4.push(r3(t3.materials, this.material[n3]));
          i2.material = e4;
        } else
          i2.material = r3(t3.materials, this.material);
      if (this.children.length > 0) {
        i2.children = [];
        for (let e4 = 0; e4 < this.children.length; e4++)
          i2.children.push(this.children[e4].toJSON(t3).object);
      }
      if (this.animations.length > 0) {
        i2.animations = [];
        for (let e4 = 0; e4 < this.animations.length; e4++) {
          const n3 = this.animations[e4];
          i2.animations.push(r3(t3.animations, n3));
        }
      }
      if (e3) {
        const e4 = o3(t3.geometries), i3 = o3(t3.materials), r4 = o3(t3.textures), s3 = o3(t3.images), a2 = o3(t3.shapes), l2 = o3(t3.skeletons), u2 = o3(t3.animations);
        e4.length > 0 && (n2.geometries = e4), i3.length > 0 && (n2.materials = i3), r4.length > 0 && (n2.textures = r4), s3.length > 0 && (n2.images = s3), a2.length > 0 && (n2.shapes = a2), l2.length > 0 && (n2.skeletons = l2), u2.length > 0 && (n2.animations = u2);
      }
      return n2.object = i2, n2;
      function o3(t4) {
        const e4 = [];
        for (const n3 in t4) {
          const i3 = t4[n3];
          delete i3.metadata, e4.push(i3);
        }
        return e4;
      }
    }
    clone(t3) {
      return new this.constructor().copy(this, t3);
    }
    copy(t3, e3 = true) {
      if (this.name = t3.name, this.up.copy(t3.up), this.position.copy(t3.position), this.rotation.order = t3.rotation.order, this.quaternion.copy(t3.quaternion), this.scale.copy(t3.scale), this.matrix.copy(t3.matrix), this.matrixWorld.copy(t3.matrixWorld), this.matrixAutoUpdate = t3.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t3.matrixWorldNeedsUpdate, this.layers.mask = t3.layers.mask, this.visible = t3.visible, this.castShadow = t3.castShadow, this.receiveShadow = t3.receiveShadow, this.frustumCulled = t3.frustumCulled, this.renderOrder = t3.renderOrder, this.userData = JSON.parse(JSON.stringify(t3.userData)), e3 === true)
        for (let e4 = 0; e4 < t3.children.length; e4++) {
          const n2 = t3.children[e4];
          this.add(n2.clone());
        }
      return this;
    }
  }
  mr.DefaultUp = new pi(0, 1, 0), mr.DefaultMatrixAutoUpdate = true, mr.prototype.isObject3D = true;
  const gr = new pi(), vr = new pi(), _r = new pi(), yr = new pi(), xr = new pi(), br = new pi(), Tr = new pi(), wr = new pi(), Sr = new pi(), Er = new pi();
  class Mr {
    constructor(t3 = new pi(), e3 = new pi(), n2 = new pi()) {
      this.a = t3, this.b = e3, this.c = n2;
    }
    static getNormal(t3, e3, n2, i2) {
      i2.subVectors(n2, e3), gr.subVectors(t3, e3), i2.cross(gr);
      const r3 = i2.lengthSq();
      return r3 > 0 ? i2.multiplyScalar(1 / Math.sqrt(r3)) : i2.set(0, 0, 0);
    }
    static getBarycoord(t3, e3, n2, i2, r3) {
      gr.subVectors(i2, e3), vr.subVectors(n2, e3), _r.subVectors(t3, e3);
      const o3 = gr.dot(gr), s3 = gr.dot(vr), a2 = gr.dot(_r), l2 = vr.dot(vr), u2 = vr.dot(_r), h2 = o3 * l2 - s3 * s3;
      if (h2 === 0)
        return r3.set(-2, -1, -1);
      const c2 = 1 / h2, d2 = (l2 * a2 - s3 * u2) * c2, p2 = (o3 * u2 - s3 * a2) * c2;
      return r3.set(1 - d2 - p2, p2, d2);
    }
    static containsPoint(t3, e3, n2, i2) {
      return this.getBarycoord(t3, e3, n2, i2, yr), yr.x >= 0 && yr.y >= 0 && yr.x + yr.y <= 1;
    }
    static getUV(t3, e3, n2, i2, r3, o3, s3, a2) {
      return this.getBarycoord(t3, e3, n2, i2, yr), a2.set(0, 0), a2.addScaledVector(r3, yr.x), a2.addScaledVector(o3, yr.y), a2.addScaledVector(s3, yr.z), a2;
    }
    static isFrontFacing(t3, e3, n2, i2) {
      return gr.subVectors(n2, e3), vr.subVectors(t3, e3), gr.cross(vr).dot(i2) < 0;
    }
    set(t3, e3, n2) {
      return this.a.copy(t3), this.b.copy(e3), this.c.copy(n2), this;
    }
    setFromPointsAndIndices(t3, e3, n2, i2) {
      return this.a.copy(t3[e3]), this.b.copy(t3[n2]), this.c.copy(t3[i2]), this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t3) {
      return this.a.copy(t3.a), this.b.copy(t3.b), this.c.copy(t3.c), this;
    }
    getArea() {
      return gr.subVectors(this.c, this.b), vr.subVectors(this.a, this.b), 0.5 * gr.cross(vr).length();
    }
    getMidpoint(t3) {
      return t3.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
    }
    getNormal(t3) {
      return Mr.getNormal(this.a, this.b, this.c, t3);
    }
    getPlane(t3) {
      return t3.setFromCoplanarPoints(this.a, this.b, this.c);
    }
    getBarycoord(t3, e3) {
      return Mr.getBarycoord(t3, this.a, this.b, this.c, e3);
    }
    getUV(t3, e3, n2, i2, r3) {
      return Mr.getUV(t3, this.a, this.b, this.c, e3, n2, i2, r3);
    }
    containsPoint(t3) {
      return Mr.containsPoint(t3, this.a, this.b, this.c);
    }
    isFrontFacing(t3) {
      return Mr.isFrontFacing(this.a, this.b, this.c, t3);
    }
    intersectsBox(t3) {
      return t3.intersectsTriangle(this);
    }
    closestPointToPoint(t3, e3) {
      const n2 = this.a, i2 = this.b, r3 = this.c;
      let o3, s3;
      xr.subVectors(i2, n2), br.subVectors(r3, n2), wr.subVectors(t3, n2);
      const a2 = xr.dot(wr), l2 = br.dot(wr);
      if (a2 <= 0 && l2 <= 0)
        return e3.copy(n2);
      Sr.subVectors(t3, i2);
      const u2 = xr.dot(Sr), h2 = br.dot(Sr);
      if (u2 >= 0 && h2 <= u2)
        return e3.copy(i2);
      const c2 = a2 * h2 - u2 * l2;
      if (c2 <= 0 && a2 >= 0 && u2 <= 0)
        return o3 = a2 / (a2 - u2), e3.copy(n2).addScaledVector(xr, o3);
      Er.subVectors(t3, r3);
      const d2 = xr.dot(Er), p2 = br.dot(Er);
      if (p2 >= 0 && d2 <= p2)
        return e3.copy(r3);
      const f2 = d2 * l2 - a2 * p2;
      if (f2 <= 0 && l2 >= 0 && p2 <= 0)
        return s3 = l2 / (l2 - p2), e3.copy(n2).addScaledVector(br, s3);
      const m2 = u2 * p2 - d2 * h2;
      if (m2 <= 0 && h2 - u2 >= 0 && d2 - p2 >= 0)
        return Tr.subVectors(r3, i2), s3 = (h2 - u2) / (h2 - u2 + (d2 - p2)), e3.copy(i2).addScaledVector(Tr, s3);
      const g2 = 1 / (m2 + f2 + c2);
      return o3 = f2 * g2, s3 = c2 * g2, e3.copy(n2).addScaledVector(xr, o3).addScaledVector(br, s3);
    }
    equals(t3) {
      return t3.a.equals(this.a) && t3.b.equals(this.b) && t3.c.equals(this.c);
    }
  }
  let Ar = 0;
  class Rr extends zn {
    constructor() {
      super(), Object.defineProperty(this, "id", { value: Ar++ }), this.uuid = qn(), this.name = "", this.type = "Material", this.fog = true, this.blending = M, this.side = x, this.vertexColors = false, this.opacity = 1, this.transparent = false, this.blendSrc = G, this.blendDst = H, this.blendEquation = I, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = J, this.depthTest = true, this.depthWrite = true, this.stencilWriteMask = 255, this.stencilFunc = Cn, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = gn, this.stencilZFail = gn, this.stencilZPass = gn, this.stencilWrite = false, this.clippingPlanes = null, this.clipIntersection = false, this.clipShadows = false, this.shadowSide = null, this.colorWrite = true, this.precision = null, this.polygonOffset = false, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = false, this.alphaTest = 0, this.alphaToCoverage = false, this.premultipliedAlpha = false, this.visible = true, this.toneMapped = true, this.userData = {}, this.version = 0;
    }
    onBuild() {
    }
    onBeforeCompile() {
    }
    customProgramCacheKey() {
      return this.onBeforeCompile.toString();
    }
    setValues(t3) {
      if (t3 !== void 0)
        for (const e3 in t3) {
          const n2 = t3[e3];
          if (n2 === void 0) {
            console.warn("THREE.Material: '" + e3 + "' parameter is undefined.");
            continue;
          }
          if (e3 === "shading") {
            console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = n2 === w;
            continue;
          }
          const i2 = this[e3];
          i2 !== void 0 ? i2 && i2.isColor ? i2.set(n2) : i2 && i2.isVector3 && n2 && n2.isVector3 ? i2.copy(n2) : this[e3] = n2 : console.warn("THREE." + this.type + ": '" + e3 + "' is not a property of this material.");
        }
    }
    toJSON(t3) {
      const e3 = t3 === void 0 || typeof t3 == "string";
      e3 && (t3 = { textures: {}, images: {} });
      const n2 = { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } };
      function i2(t4) {
        const e4 = [];
        for (const n3 in t4) {
          const i3 = t4[n3];
          delete i3.metadata, e4.push(i3);
        }
        return e4;
      }
      if (n2.uuid = this.uuid, n2.type = this.type, this.name !== "" && (n2.name = this.name), this.color && this.color.isColor && (n2.color = this.color.getHex()), this.roughness !== void 0 && (n2.roughness = this.roughness), this.metalness !== void 0 && (n2.metalness = this.metalness), this.sheen && this.sheen.isColor && (n2.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (n2.emissive = this.emissive.getHex()), this.emissiveIntensity && this.emissiveIntensity !== 1 && (n2.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n2.specular = this.specular.getHex()), this.shininess !== void 0 && (n2.shininess = this.shininess), this.clearcoat !== void 0 && (n2.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (n2.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n2.clearcoatMap = this.clearcoatMap.toJSON(t3).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n2.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t3).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n2.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t3).uuid, n2.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n2.map = this.map.toJSON(t3).uuid), this.matcap && this.matcap.isTexture && (n2.matcap = this.matcap.toJSON(t3).uuid), this.alphaMap && this.alphaMap.isTexture && (n2.alphaMap = this.alphaMap.toJSON(t3).uuid), this.lightMap && this.lightMap.isTexture && (n2.lightMap = this.lightMap.toJSON(t3).uuid, n2.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n2.aoMap = this.aoMap.toJSON(t3).uuid, n2.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n2.bumpMap = this.bumpMap.toJSON(t3).uuid, n2.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n2.normalMap = this.normalMap.toJSON(t3).uuid, n2.normalMapType = this.normalMapType, n2.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n2.displacementMap = this.displacementMap.toJSON(t3).uuid, n2.displacementScale = this.displacementScale, n2.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n2.roughnessMap = this.roughnessMap.toJSON(t3).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n2.metalnessMap = this.metalnessMap.toJSON(t3).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n2.emissiveMap = this.emissiveMap.toJSON(t3).uuid), this.specularMap && this.specularMap.isTexture && (n2.specularMap = this.specularMap.toJSON(t3).uuid), this.envMap && this.envMap.isTexture && (n2.envMap = this.envMap.toJSON(t3).uuid, this.combine !== void 0 && (n2.combine = this.combine)), this.envMapIntensity !== void 0 && (n2.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (n2.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (n2.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n2.gradientMap = this.gradientMap.toJSON(t3).uuid), this.transmission !== void 0 && (n2.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n2.transmissionMap = this.transmissionMap.toJSON(t3).uuid), this.thickness !== void 0 && (n2.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n2.thicknessMap = this.thicknessMap.toJSON(t3).uuid), this.attenuationDistance !== void 0 && (n2.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (n2.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (n2.size = this.size), this.shadowSide !== null && (n2.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (n2.sizeAttenuation = this.sizeAttenuation), this.blending !== M && (n2.blending = this.blending), this.side !== x && (n2.side = this.side), this.vertexColors && (n2.vertexColors = true), this.opacity < 1 && (n2.opacity = this.opacity), this.transparent === true && (n2.transparent = this.transparent), n2.depthFunc = this.depthFunc, n2.depthTest = this.depthTest, n2.depthWrite = this.depthWrite, n2.colorWrite = this.colorWrite, n2.stencilWrite = this.stencilWrite, n2.stencilWriteMask = this.stencilWriteMask, n2.stencilFunc = this.stencilFunc, n2.stencilRef = this.stencilRef, n2.stencilFuncMask = this.stencilFuncMask, n2.stencilFail = this.stencilFail, n2.stencilZFail = this.stencilZFail, n2.stencilZPass = this.stencilZPass, this.rotation && this.rotation !== 0 && (n2.rotation = this.rotation), this.polygonOffset === true && (n2.polygonOffset = true), this.polygonOffsetFactor !== 0 && (n2.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (n2.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && this.linewidth !== 1 && (n2.linewidth = this.linewidth), this.dashSize !== void 0 && (n2.dashSize = this.dashSize), this.gapSize !== void 0 && (n2.gapSize = this.gapSize), this.scale !== void 0 && (n2.scale = this.scale), this.dithering === true && (n2.dithering = true), this.alphaTest > 0 && (n2.alphaTest = this.alphaTest), this.alphaToCoverage === true && (n2.alphaToCoverage = this.alphaToCoverage), this.premultipliedAlpha === true && (n2.premultipliedAlpha = this.premultipliedAlpha), this.wireframe === true && (n2.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n2.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (n2.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (n2.wireframeLinejoin = this.wireframeLinejoin), this.morphTargets === true && (n2.morphTargets = true), this.morphNormals === true && (n2.morphNormals = true), this.flatShading === true && (n2.flatShading = this.flatShading), this.visible === false && (n2.visible = false), this.toneMapped === false && (n2.toneMapped = false), JSON.stringify(this.userData) !== "{}" && (n2.userData = this.userData), e3) {
        const e4 = i2(t3.textures), r3 = i2(t3.images);
        e4.length > 0 && (n2.textures = e4), r3.length > 0 && (n2.images = r3);
      }
      return n2;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t3) {
      this.name = t3.name, this.fog = t3.fog, this.blending = t3.blending, this.side = t3.side, this.vertexColors = t3.vertexColors, this.opacity = t3.opacity, this.transparent = t3.transparent, this.blendSrc = t3.blendSrc, this.blendDst = t3.blendDst, this.blendEquation = t3.blendEquation, this.blendSrcAlpha = t3.blendSrcAlpha, this.blendDstAlpha = t3.blendDstAlpha, this.blendEquationAlpha = t3.blendEquationAlpha, this.depthFunc = t3.depthFunc, this.depthTest = t3.depthTest, this.depthWrite = t3.depthWrite, this.stencilWriteMask = t3.stencilWriteMask, this.stencilFunc = t3.stencilFunc, this.stencilRef = t3.stencilRef, this.stencilFuncMask = t3.stencilFuncMask, this.stencilFail = t3.stencilFail, this.stencilZFail = t3.stencilZFail, this.stencilZPass = t3.stencilZPass, this.stencilWrite = t3.stencilWrite;
      const e3 = t3.clippingPlanes;
      let n2 = null;
      if (e3 !== null) {
        const t4 = e3.length;
        n2 = new Array(t4);
        for (let i2 = 0; i2 !== t4; ++i2)
          n2[i2] = e3[i2].clone();
      }
      return this.clippingPlanes = n2, this.clipIntersection = t3.clipIntersection, this.clipShadows = t3.clipShadows, this.shadowSide = t3.shadowSide, this.colorWrite = t3.colorWrite, this.precision = t3.precision, this.polygonOffset = t3.polygonOffset, this.polygonOffsetFactor = t3.polygonOffsetFactor, this.polygonOffsetUnits = t3.polygonOffsetUnits, this.dithering = t3.dithering, this.alphaTest = t3.alphaTest, this.alphaToCoverage = t3.alphaToCoverage, this.premultipliedAlpha = t3.premultipliedAlpha, this.visible = t3.visible, this.toneMapped = t3.toneMapped, this.userData = JSON.parse(JSON.stringify(t3.userData)), this;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
    set needsUpdate(t3) {
      t3 === true && this.version++;
    }
  }
  Rr.prototype.isMaterial = true;
  const Pr = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }, Cr = { h: 0, s: 0, l: 0 }, Ir = { h: 0, s: 0, l: 0 };
  function Or(t3, e3, n2) {
    return n2 < 0 && (n2 += 1), n2 > 1 && (n2 -= 1), n2 < 1 / 6 ? t3 + 6 * (e3 - t3) * n2 : n2 < 0.5 ? e3 : n2 < 2 / 3 ? t3 + 6 * (e3 - t3) * (2 / 3 - n2) : t3;
  }
  function Lr(t3) {
    return t3 < 0.04045 ? 0.0773993808 * t3 : Math.pow(0.9478672986 * t3 + 0.0521327014, 2.4);
  }
  function Nr(t3) {
    return t3 < 31308e-7 ? 12.92 * t3 : 1.055 * Math.pow(t3, 0.41666) - 0.055;
  }
  class Dr {
    constructor(t3, e3, n2) {
      return e3 === void 0 && n2 === void 0 ? this.set(t3) : this.setRGB(t3, e3, n2);
    }
    set(t3) {
      return t3 && t3.isColor ? this.copy(t3) : typeof t3 == "number" ? this.setHex(t3) : typeof t3 == "string" && this.setStyle(t3), this;
    }
    setScalar(t3) {
      return this.r = t3, this.g = t3, this.b = t3, this;
    }
    setHex(t3) {
      return t3 = Math.floor(t3), this.r = (t3 >> 16 & 255) / 255, this.g = (t3 >> 8 & 255) / 255, this.b = (255 & t3) / 255, this;
    }
    setRGB(t3, e3, n2) {
      return this.r = t3, this.g = e3, this.b = n2, this;
    }
    setHSL(t3, e3, n2) {
      if (t3 = Zn(t3, 1), e3 = Yn(e3, 0, 1), n2 = Yn(n2, 0, 1), e3 === 0)
        this.r = this.g = this.b = n2;
      else {
        const i2 = n2 <= 0.5 ? n2 * (1 + e3) : n2 + e3 - n2 * e3, r3 = 2 * n2 - i2;
        this.r = Or(r3, i2, t3 + 1 / 3), this.g = Or(r3, i2, t3), this.b = Or(r3, i2, t3 - 1 / 3);
      }
      return this;
    }
    setStyle(t3) {
      function e3(e4) {
        e4 !== void 0 && parseFloat(e4) < 1 && console.warn("THREE.Color: Alpha component of " + t3 + " will be ignored.");
      }
      let n2;
      if (n2 = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t3)) {
        let t4;
        const i2 = n2[1], r3 = n2[2];
        switch (i2) {
          case "rgb":
          case "rgba":
            if (t4 = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r3))
              return this.r = Math.min(255, parseInt(t4[1], 10)) / 255, this.g = Math.min(255, parseInt(t4[2], 10)) / 255, this.b = Math.min(255, parseInt(t4[3], 10)) / 255, e3(t4[4]), this;
            if (t4 = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r3))
              return this.r = Math.min(100, parseInt(t4[1], 10)) / 100, this.g = Math.min(100, parseInt(t4[2], 10)) / 100, this.b = Math.min(100, parseInt(t4[3], 10)) / 100, e3(t4[4]), this;
            break;
          case "hsl":
          case "hsla":
            if (t4 = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r3)) {
              const n3 = parseFloat(t4[1]) / 360, i3 = parseInt(t4[2], 10) / 100, r4 = parseInt(t4[3], 10) / 100;
              return e3(t4[4]), this.setHSL(n3, i3, r4);
            }
        }
      } else if (n2 = /^\#([A-Fa-f\d]+)$/.exec(t3)) {
        const t4 = n2[1], e4 = t4.length;
        if (e4 === 3)
          return this.r = parseInt(t4.charAt(0) + t4.charAt(0), 16) / 255, this.g = parseInt(t4.charAt(1) + t4.charAt(1), 16) / 255, this.b = parseInt(t4.charAt(2) + t4.charAt(2), 16) / 255, this;
        if (e4 === 6)
          return this.r = parseInt(t4.charAt(0) + t4.charAt(1), 16) / 255, this.g = parseInt(t4.charAt(2) + t4.charAt(3), 16) / 255, this.b = parseInt(t4.charAt(4) + t4.charAt(5), 16) / 255, this;
      }
      return t3 && t3.length > 0 ? this.setColorName(t3) : this;
    }
    setColorName(t3) {
      const e3 = Pr[t3.toLowerCase()];
      return e3 !== void 0 ? this.setHex(e3) : console.warn("THREE.Color: Unknown color " + t3), this;
    }
    clone() {
      return new this.constructor(this.r, this.g, this.b);
    }
    copy(t3) {
      return this.r = t3.r, this.g = t3.g, this.b = t3.b, this;
    }
    copyGammaToLinear(t3, e3 = 2) {
      return this.r = Math.pow(t3.r, e3), this.g = Math.pow(t3.g, e3), this.b = Math.pow(t3.b, e3), this;
    }
    copyLinearToGamma(t3, e3 = 2) {
      const n2 = e3 > 0 ? 1 / e3 : 1;
      return this.r = Math.pow(t3.r, n2), this.g = Math.pow(t3.g, n2), this.b = Math.pow(t3.b, n2), this;
    }
    convertGammaToLinear(t3) {
      return this.copyGammaToLinear(this, t3), this;
    }
    convertLinearToGamma(t3) {
      return this.copyLinearToGamma(this, t3), this;
    }
    copySRGBToLinear(t3) {
      return this.r = Lr(t3.r), this.g = Lr(t3.g), this.b = Lr(t3.b), this;
    }
    copyLinearToSRGB(t3) {
      return this.r = Nr(t3.r), this.g = Nr(t3.g), this.b = Nr(t3.b), this;
    }
    convertSRGBToLinear() {
      return this.copySRGBToLinear(this), this;
    }
    convertLinearToSRGB() {
      return this.copyLinearToSRGB(this), this;
    }
    getHex() {
      return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0;
    }
    getHexString() {
      return ("000000" + this.getHex().toString(16)).slice(-6);
    }
    getHSL(t3) {
      const e3 = this.r, n2 = this.g, i2 = this.b, r3 = Math.max(e3, n2, i2), o3 = Math.min(e3, n2, i2);
      let s3, a2;
      const l2 = (o3 + r3) / 2;
      if (o3 === r3)
        s3 = 0, a2 = 0;
      else {
        const t4 = r3 - o3;
        switch (a2 = l2 <= 0.5 ? t4 / (r3 + o3) : t4 / (2 - r3 - o3), r3) {
          case e3:
            s3 = (n2 - i2) / t4 + (n2 < i2 ? 6 : 0);
            break;
          case n2:
            s3 = (i2 - e3) / t4 + 2;
            break;
          case i2:
            s3 = (e3 - n2) / t4 + 4;
        }
        s3 /= 6;
      }
      return t3.h = s3, t3.s = a2, t3.l = l2, t3;
    }
    getStyle() {
      return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")";
    }
    offsetHSL(t3, e3, n2) {
      return this.getHSL(Cr), Cr.h += t3, Cr.s += e3, Cr.l += n2, this.setHSL(Cr.h, Cr.s, Cr.l), this;
    }
    add(t3) {
      return this.r += t3.r, this.g += t3.g, this.b += t3.b, this;
    }
    addColors(t3, e3) {
      return this.r = t3.r + e3.r, this.g = t3.g + e3.g, this.b = t3.b + e3.b, this;
    }
    addScalar(t3) {
      return this.r += t3, this.g += t3, this.b += t3, this;
    }
    sub(t3) {
      return this.r = Math.max(0, this.r - t3.r), this.g = Math.max(0, this.g - t3.g), this.b = Math.max(0, this.b - t3.b), this;
    }
    multiply(t3) {
      return this.r *= t3.r, this.g *= t3.g, this.b *= t3.b, this;
    }
    multiplyScalar(t3) {
      return this.r *= t3, this.g *= t3, this.b *= t3, this;
    }
    lerp(t3, e3) {
      return this.r += (t3.r - this.r) * e3, this.g += (t3.g - this.g) * e3, this.b += (t3.b - this.b) * e3, this;
    }
    lerpColors(t3, e3, n2) {
      return this.r = t3.r + (e3.r - t3.r) * n2, this.g = t3.g + (e3.g - t3.g) * n2, this.b = t3.b + (e3.b - t3.b) * n2, this;
    }
    lerpHSL(t3, e3) {
      this.getHSL(Cr), t3.getHSL(Ir);
      const n2 = Jn(Cr.h, Ir.h, e3), i2 = Jn(Cr.s, Ir.s, e3), r3 = Jn(Cr.l, Ir.l, e3);
      return this.setHSL(n2, i2, r3), this;
    }
    equals(t3) {
      return t3.r === this.r && t3.g === this.g && t3.b === this.b;
    }
    fromArray(t3, e3 = 0) {
      return this.r = t3[e3], this.g = t3[e3 + 1], this.b = t3[e3 + 2], this;
    }
    toArray(t3 = [], e3 = 0) {
      return t3[e3] = this.r, t3[e3 + 1] = this.g, t3[e3 + 2] = this.b, t3;
    }
    fromBufferAttribute(t3, e3) {
      return this.r = t3.getX(e3), this.g = t3.getY(e3), this.b = t3.getZ(e3), t3.normalized === true && (this.r /= 255, this.g /= 255, this.b /= 255), this;
    }
    toJSON() {
      return this.getHex();
    }
  }
  Dr.NAMES = Pr, Dr.prototype.isColor = true, Dr.prototype.r = 1, Dr.prototype.g = 1, Dr.prototype.b = 1;
  class Fr extends Rr {
    constructor(t3) {
      super(), this.type = "MeshBasicMaterial", this.color = new Dr(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = et, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.morphTargets = false, this.setValues(t3);
    }
    copy(t3) {
      return super.copy(t3), this.color.copy(t3.color), this.map = t3.map, this.lightMap = t3.lightMap, this.lightMapIntensity = t3.lightMapIntensity, this.aoMap = t3.aoMap, this.aoMapIntensity = t3.aoMapIntensity, this.specularMap = t3.specularMap, this.alphaMap = t3.alphaMap, this.envMap = t3.envMap, this.combine = t3.combine, this.reflectivity = t3.reflectivity, this.refractionRatio = t3.refractionRatio, this.wireframe = t3.wireframe, this.wireframeLinewidth = t3.wireframeLinewidth, this.wireframeLinecap = t3.wireframeLinecap, this.wireframeLinejoin = t3.wireframeLinejoin, this.morphTargets = t3.morphTargets, this;
    }
  }
  Fr.prototype.isMeshBasicMaterial = true;
  const Br = new pi(), Ur = new ei();
  class kr {
    constructor(t3, e3, n2) {
      if (Array.isArray(t3))
        throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
      this.name = "", this.array = t3, this.itemSize = e3, this.count = t3 !== void 0 ? t3.length / e3 : 0, this.normalized = n2 === true, this.usage = In, this.updateRange = { offset: 0, count: -1 }, this.version = 0;
    }
    onUploadCallback() {
    }
    set needsUpdate(t3) {
      t3 === true && this.version++;
    }
    setUsage(t3) {
      return this.usage = t3, this;
    }
    copy(t3) {
      return this.name = t3.name, this.array = new t3.array.constructor(t3.array), this.itemSize = t3.itemSize, this.count = t3.count, this.normalized = t3.normalized, this.usage = t3.usage, this;
    }
    copyAt(t3, e3, n2) {
      t3 *= this.itemSize, n2 *= e3.itemSize;
      for (let i2 = 0, r3 = this.itemSize; i2 < r3; i2++)
        this.array[t3 + i2] = e3.array[n2 + i2];
      return this;
    }
    copyArray(t3) {
      return this.array.set(t3), this;
    }
    copyColorsArray(t3) {
      const e3 = this.array;
      let n2 = 0;
      for (let i2 = 0, r3 = t3.length; i2 < r3; i2++) {
        let r4 = t3[i2];
        r4 === void 0 && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i2), r4 = new Dr()), e3[n2++] = r4.r, e3[n2++] = r4.g, e3[n2++] = r4.b;
      }
      return this;
    }
    copyVector2sArray(t3) {
      const e3 = this.array;
      let n2 = 0;
      for (let i2 = 0, r3 = t3.length; i2 < r3; i2++) {
        let r4 = t3[i2];
        r4 === void 0 && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i2), r4 = new ei()), e3[n2++] = r4.x, e3[n2++] = r4.y;
      }
      return this;
    }
    copyVector3sArray(t3) {
      const e3 = this.array;
      let n2 = 0;
      for (let i2 = 0, r3 = t3.length; i2 < r3; i2++) {
        let r4 = t3[i2];
        r4 === void 0 && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i2), r4 = new pi()), e3[n2++] = r4.x, e3[n2++] = r4.y, e3[n2++] = r4.z;
      }
      return this;
    }
    copyVector4sArray(t3) {
      const e3 = this.array;
      let n2 = 0;
      for (let i2 = 0, r3 = t3.length; i2 < r3; i2++) {
        let r4 = t3[i2];
        r4 === void 0 && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i2), r4 = new li()), e3[n2++] = r4.x, e3[n2++] = r4.y, e3[n2++] = r4.z, e3[n2++] = r4.w;
      }
      return this;
    }
    applyMatrix3(t3) {
      if (this.itemSize === 2)
        for (let e3 = 0, n2 = this.count; e3 < n2; e3++)
          Ur.fromBufferAttribute(this, e3), Ur.applyMatrix3(t3), this.setXY(e3, Ur.x, Ur.y);
      else if (this.itemSize === 3)
        for (let e3 = 0, n2 = this.count; e3 < n2; e3++)
          Br.fromBufferAttribute(this, e3), Br.applyMatrix3(t3), this.setXYZ(e3, Br.x, Br.y, Br.z);
      return this;
    }
    applyMatrix4(t3) {
      for (let e3 = 0, n2 = this.count; e3 < n2; e3++)
        Br.x = this.getX(e3), Br.y = this.getY(e3), Br.z = this.getZ(e3), Br.applyMatrix4(t3), this.setXYZ(e3, Br.x, Br.y, Br.z);
      return this;
    }
    applyNormalMatrix(t3) {
      for (let e3 = 0, n2 = this.count; e3 < n2; e3++)
        Br.x = this.getX(e3), Br.y = this.getY(e3), Br.z = this.getZ(e3), Br.applyNormalMatrix(t3), this.setXYZ(e3, Br.x, Br.y, Br.z);
      return this;
    }
    transformDirection(t3) {
      for (let e3 = 0, n2 = this.count; e3 < n2; e3++)
        Br.x = this.getX(e3), Br.y = this.getY(e3), Br.z = this.getZ(e3), Br.transformDirection(t3), this.setXYZ(e3, Br.x, Br.y, Br.z);
      return this;
    }
    set(t3, e3 = 0) {
      return this.array.set(t3, e3), this;
    }
    getX(t3) {
      return this.array[t3 * this.itemSize];
    }
    setX(t3, e3) {
      return this.array[t3 * this.itemSize] = e3, this;
    }
    getY(t3) {
      return this.array[t3 * this.itemSize + 1];
    }
    setY(t3, e3) {
      return this.array[t3 * this.itemSize + 1] = e3, this;
    }
    getZ(t3) {
      return this.array[t3 * this.itemSize + 2];
    }
    setZ(t3, e3) {
      return this.array[t3 * this.itemSize + 2] = e3, this;
    }
    getW(t3) {
      return this.array[t3 * this.itemSize + 3];
    }
    setW(t3, e3) {
      return this.array[t3 * this.itemSize + 3] = e3, this;
    }
    setXY(t3, e3, n2) {
      return t3 *= this.itemSize, this.array[t3 + 0] = e3, this.array[t3 + 1] = n2, this;
    }
    setXYZ(t3, e3, n2, i2) {
      return t3 *= this.itemSize, this.array[t3 + 0] = e3, this.array[t3 + 1] = n2, this.array[t3 + 2] = i2, this;
    }
    setXYZW(t3, e3, n2, i2, r3) {
      return t3 *= this.itemSize, this.array[t3 + 0] = e3, this.array[t3 + 1] = n2, this.array[t3 + 2] = i2, this.array[t3 + 3] = r3, this;
    }
    onUpload(t3) {
      return this.onUploadCallback = t3, this;
    }
    clone() {
      return new this.constructor(this.array, this.itemSize).copy(this);
    }
    toJSON() {
      const t3 = { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.prototype.slice.call(this.array), normalized: this.normalized };
      return this.name !== "" && (t3.name = this.name), this.usage !== In && (t3.usage = this.usage), this.updateRange.offset === 0 && this.updateRange.count === -1 || (t3.updateRange = this.updateRange), t3;
    }
  }
  kr.prototype.isBufferAttribute = true;
  class Gr extends kr {
    constructor(t3, e3, n2) {
      super(new Int8Array(t3), e3, n2);
    }
  }
  class Hr extends kr {
    constructor(t3, e3, n2) {
      super(new Uint8Array(t3), e3, n2);
    }
  }
  class zr extends kr {
    constructor(t3, e3, n2) {
      super(new Uint8ClampedArray(t3), e3, n2);
    }
  }
  class jr extends kr {
    constructor(t3, e3, n2) {
      super(new Int16Array(t3), e3, n2);
    }
  }
  class Vr extends kr {
    constructor(t3, e3, n2) {
      super(new Uint16Array(t3), e3, n2);
    }
  }
  class Wr extends kr {
    constructor(t3, e3, n2) {
      super(new Int32Array(t3), e3, n2);
    }
  }
  class Xr extends kr {
    constructor(t3, e3, n2) {
      super(new Uint32Array(t3), e3, n2);
    }
  }
  class qr extends kr {
    constructor(t3, e3, n2) {
      super(new Uint16Array(t3), e3, n2);
    }
  }
  qr.prototype.isFloat16BufferAttribute = true;
  class Yr extends kr {
    constructor(t3, e3, n2) {
      super(new Float32Array(t3), e3, n2);
    }
  }
  class Zr extends kr {
    constructor(t3, e3, n2) {
      super(new Float64Array(t3), e3, n2);
    }
  }
  function Jr(t3) {
    if (t3.length === 0)
      return -1 / 0;
    let e3 = t3[0];
    for (let n2 = 1, i2 = t3.length; n2 < i2; ++n2)
      t3[n2] > e3 && (e3 = t3[n2]);
    return e3;
  }
  const $r = { Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array };
  function Kr(t3, e3) {
    return new $r[t3](e3);
  }
  let Qr = 0;
  const to = new Vi(), eo = new mr(), no = new pi(), io = new gi(), ro = new gi(), oo = new pi();
  class so extends zn {
    constructor() {
      super(), Object.defineProperty(this, "id", { value: Qr++ }), this.uuid = qn(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = false, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
    }
    getIndex() {
      return this.index;
    }
    setIndex(t3) {
      return Array.isArray(t3) ? this.index = new (Jr(t3) > 65535 ? Xr : Vr)(t3, 1) : this.index = t3, this;
    }
    getAttribute(t3) {
      return this.attributes[t3];
    }
    setAttribute(t3, e3) {
      return this.attributes[t3] = e3, this;
    }
    deleteAttribute(t3) {
      return delete this.attributes[t3], this;
    }
    hasAttribute(t3) {
      return this.attributes[t3] !== void 0;
    }
    addGroup(t3, e3, n2 = 0) {
      this.groups.push({ start: t3, count: e3, materialIndex: n2 });
    }
    clearGroups() {
      this.groups = [];
    }
    setDrawRange(t3, e3) {
      this.drawRange.start = t3, this.drawRange.count = e3;
    }
    applyMatrix4(t3) {
      const e3 = this.attributes.position;
      e3 !== void 0 && (e3.applyMatrix4(t3), e3.needsUpdate = true);
      const n2 = this.attributes.normal;
      if (n2 !== void 0) {
        const e4 = new ni().getNormalMatrix(t3);
        n2.applyNormalMatrix(e4), n2.needsUpdate = true;
      }
      const i2 = this.attributes.tangent;
      return i2 !== void 0 && (i2.transformDirection(t3), i2.needsUpdate = true), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
    }
    applyQuaternion(t3) {
      return to.makeRotationFromQuaternion(t3), this.applyMatrix4(to), this;
    }
    rotateX(t3) {
      return to.makeRotationX(t3), this.applyMatrix4(to), this;
    }
    rotateY(t3) {
      return to.makeRotationY(t3), this.applyMatrix4(to), this;
    }
    rotateZ(t3) {
      return to.makeRotationZ(t3), this.applyMatrix4(to), this;
    }
    translate(t3, e3, n2) {
      return to.makeTranslation(t3, e3, n2), this.applyMatrix4(to), this;
    }
    scale(t3, e3, n2) {
      return to.makeScale(t3, e3, n2), this.applyMatrix4(to), this;
    }
    lookAt(t3) {
      return eo.lookAt(t3), eo.updateMatrix(), this.applyMatrix4(eo.matrix), this;
    }
    center() {
      return this.computeBoundingBox(), this.boundingBox.getCenter(no).negate(), this.translate(no.x, no.y, no.z), this;
    }
    setFromPoints(t3) {
      const e3 = [];
      for (let n2 = 0, i2 = t3.length; n2 < i2; n2++) {
        const i3 = t3[n2];
        e3.push(i3.x, i3.y, i3.z || 0);
      }
      return this.setAttribute("position", new Yr(e3, 3)), this;
    }
    computeBoundingBox() {
      this.boundingBox === null && (this.boundingBox = new gi());
      const t3 = this.attributes.position, e3 = this.morphAttributes.position;
      if (t3 && t3.isGLBufferAttribute)
        return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new pi(-1 / 0, -1 / 0, -1 / 0), new pi(1 / 0, 1 / 0, 1 / 0));
      if (t3 !== void 0) {
        if (this.boundingBox.setFromBufferAttribute(t3), e3)
          for (let t4 = 0, n2 = e3.length; t4 < n2; t4++) {
            const n3 = e3[t4];
            io.setFromBufferAttribute(n3), this.morphTargetsRelative ? (oo.addVectors(this.boundingBox.min, io.min), this.boundingBox.expandByPoint(oo), oo.addVectors(this.boundingBox.max, io.max), this.boundingBox.expandByPoint(oo)) : (this.boundingBox.expandByPoint(io.min), this.boundingBox.expandByPoint(io.max));
          }
      } else
        this.boundingBox.makeEmpty();
      (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
    computeBoundingSphere() {
      this.boundingSphere === null && (this.boundingSphere = new Di());
      const t3 = this.attributes.position, e3 = this.morphAttributes.position;
      if (t3 && t3.isGLBufferAttribute)
        return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new pi(), 1 / 0);
      if (t3) {
        const n2 = this.boundingSphere.center;
        if (io.setFromBufferAttribute(t3), e3)
          for (let t4 = 0, n3 = e3.length; t4 < n3; t4++) {
            const n4 = e3[t4];
            ro.setFromBufferAttribute(n4), this.morphTargetsRelative ? (oo.addVectors(io.min, ro.min), io.expandByPoint(oo), oo.addVectors(io.max, ro.max), io.expandByPoint(oo)) : (io.expandByPoint(ro.min), io.expandByPoint(ro.max));
          }
        io.getCenter(n2);
        let i2 = 0;
        for (let e4 = 0, r3 = t3.count; e4 < r3; e4++)
          oo.fromBufferAttribute(t3, e4), i2 = Math.max(i2, n2.distanceToSquared(oo));
        if (e3)
          for (let r3 = 0, o3 = e3.length; r3 < o3; r3++) {
            const o4 = e3[r3], s3 = this.morphTargetsRelative;
            for (let e4 = 0, r4 = o4.count; e4 < r4; e4++)
              oo.fromBufferAttribute(o4, e4), s3 && (no.fromBufferAttribute(t3, e4), oo.add(no)), i2 = Math.max(i2, n2.distanceToSquared(oo));
          }
        this.boundingSphere.radius = Math.sqrt(i2), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
      }
    }
    computeFaceNormals() {
    }
    computeTangents() {
      const t3 = this.index, e3 = this.attributes;
      if (t3 === null || e3.position === void 0 || e3.normal === void 0 || e3.uv === void 0)
        return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      const n2 = t3.array, i2 = e3.position.array, r3 = e3.normal.array, o3 = e3.uv.array, s3 = i2.length / 3;
      e3.tangent === void 0 && this.setAttribute("tangent", new kr(new Float32Array(4 * s3), 4));
      const a2 = e3.tangent.array, l2 = [], u2 = [];
      for (let t4 = 0; t4 < s3; t4++)
        l2[t4] = new pi(), u2[t4] = new pi();
      const h2 = new pi(), c2 = new pi(), d2 = new pi(), p2 = new ei(), f2 = new ei(), m2 = new ei(), g2 = new pi(), v2 = new pi();
      function _2(t4, e4, n3) {
        h2.fromArray(i2, 3 * t4), c2.fromArray(i2, 3 * e4), d2.fromArray(i2, 3 * n3), p2.fromArray(o3, 2 * t4), f2.fromArray(o3, 2 * e4), m2.fromArray(o3, 2 * n3), c2.sub(h2), d2.sub(h2), f2.sub(p2), m2.sub(p2);
        const r4 = 1 / (f2.x * m2.y - m2.x * f2.y);
        isFinite(r4) && (g2.copy(c2).multiplyScalar(m2.y).addScaledVector(d2, -f2.y).multiplyScalar(r4), v2.copy(d2).multiplyScalar(f2.x).addScaledVector(c2, -m2.x).multiplyScalar(r4), l2[t4].add(g2), l2[e4].add(g2), l2[n3].add(g2), u2[t4].add(v2), u2[e4].add(v2), u2[n3].add(v2));
      }
      let y2 = this.groups;
      y2.length === 0 && (y2 = [{ start: 0, count: n2.length }]);
      for (let t4 = 0, e4 = y2.length; t4 < e4; ++t4) {
        const e5 = y2[t4], i3 = e5.start;
        for (let t5 = i3, r4 = i3 + e5.count; t5 < r4; t5 += 3)
          _2(n2[t5 + 0], n2[t5 + 1], n2[t5 + 2]);
      }
      const x2 = new pi(), b2 = new pi(), T2 = new pi(), w2 = new pi();
      function S2(t4) {
        T2.fromArray(r3, 3 * t4), w2.copy(T2);
        const e4 = l2[t4];
        x2.copy(e4), x2.sub(T2.multiplyScalar(T2.dot(e4))).normalize(), b2.crossVectors(w2, e4);
        const n3 = b2.dot(u2[t4]) < 0 ? -1 : 1;
        a2[4 * t4] = x2.x, a2[4 * t4 + 1] = x2.y, a2[4 * t4 + 2] = x2.z, a2[4 * t4 + 3] = n3;
      }
      for (let t4 = 0, e4 = y2.length; t4 < e4; ++t4) {
        const e5 = y2[t4], i3 = e5.start;
        for (let t5 = i3, r4 = i3 + e5.count; t5 < r4; t5 += 3)
          S2(n2[t5 + 0]), S2(n2[t5 + 1]), S2(n2[t5 + 2]);
      }
    }
    computeVertexNormals() {
      const t3 = this.index, e3 = this.getAttribute("position");
      if (e3 !== void 0) {
        let n2 = this.getAttribute("normal");
        if (n2 === void 0)
          n2 = new kr(new Float32Array(3 * e3.count), 3), this.setAttribute("normal", n2);
        else
          for (let t4 = 0, e4 = n2.count; t4 < e4; t4++)
            n2.setXYZ(t4, 0, 0, 0);
        const i2 = new pi(), r3 = new pi(), o3 = new pi(), s3 = new pi(), a2 = new pi(), l2 = new pi(), u2 = new pi(), h2 = new pi();
        if (t3)
          for (let c2 = 0, d2 = t3.count; c2 < d2; c2 += 3) {
            const d3 = t3.getX(c2 + 0), p2 = t3.getX(c2 + 1), f2 = t3.getX(c2 + 2);
            i2.fromBufferAttribute(e3, d3), r3.fromBufferAttribute(e3, p2), o3.fromBufferAttribute(e3, f2), u2.subVectors(o3, r3), h2.subVectors(i2, r3), u2.cross(h2), s3.fromBufferAttribute(n2, d3), a2.fromBufferAttribute(n2, p2), l2.fromBufferAttribute(n2, f2), s3.add(u2), a2.add(u2), l2.add(u2), n2.setXYZ(d3, s3.x, s3.y, s3.z), n2.setXYZ(p2, a2.x, a2.y, a2.z), n2.setXYZ(f2, l2.x, l2.y, l2.z);
          }
        else
          for (let t4 = 0, s4 = e3.count; t4 < s4; t4 += 3)
            i2.fromBufferAttribute(e3, t4 + 0), r3.fromBufferAttribute(e3, t4 + 1), o3.fromBufferAttribute(e3, t4 + 2), u2.subVectors(o3, r3), h2.subVectors(i2, r3), u2.cross(h2), n2.setXYZ(t4 + 0, u2.x, u2.y, u2.z), n2.setXYZ(t4 + 1, u2.x, u2.y, u2.z), n2.setXYZ(t4 + 2, u2.x, u2.y, u2.z);
        this.normalizeNormals(), n2.needsUpdate = true;
      }
    }
    merge(t3, e3) {
      if (!t3 || !t3.isBufferGeometry)
        return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t3);
      e3 === void 0 && (e3 = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
      const n2 = this.attributes;
      for (const i2 in n2) {
        if (t3.attributes[i2] === void 0)
          continue;
        const r3 = n2[i2].array, o3 = t3.attributes[i2], s3 = o3.array, a2 = o3.itemSize * e3, l2 = Math.min(s3.length, r3.length - a2);
        for (let t4 = 0, e4 = a2; t4 < l2; t4++, e4++)
          r3[e4] = s3[t4];
      }
      return this;
    }
    normalizeNormals() {
      const t3 = this.attributes.normal;
      for (let e3 = 0, n2 = t3.count; e3 < n2; e3++)
        oo.fromBufferAttribute(t3, e3), oo.normalize(), t3.setXYZ(e3, oo.x, oo.y, oo.z);
    }
    toNonIndexed() {
      function t3(t4, e4) {
        const n3 = t4.array, i3 = t4.itemSize, r4 = t4.normalized, o4 = new n3.constructor(e4.length * i3);
        let s3 = 0, a2 = 0;
        for (let r5 = 0, l2 = e4.length; r5 < l2; r5++) {
          s3 = t4.isInterleavedBufferAttribute ? e4[r5] * t4.data.stride + t4.offset : e4[r5] * i3;
          for (let t5 = 0; t5 < i3; t5++)
            o4[a2++] = n3[s3++];
        }
        return new kr(o4, i3, r4);
      }
      if (this.index === null)
        return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
      const e3 = new so(), n2 = this.index.array, i2 = this.attributes;
      for (const r4 in i2) {
        const o4 = t3(i2[r4], n2);
        e3.setAttribute(r4, o4);
      }
      const r3 = this.morphAttributes;
      for (const i3 in r3) {
        const o4 = [], s3 = r3[i3];
        for (let e4 = 0, i4 = s3.length; e4 < i4; e4++) {
          const i5 = t3(s3[e4], n2);
          o4.push(i5);
        }
        e3.morphAttributes[i3] = o4;
      }
      e3.morphTargetsRelative = this.morphTargetsRelative;
      const o3 = this.groups;
      for (let t4 = 0, n3 = o3.length; t4 < n3; t4++) {
        const n4 = o3[t4];
        e3.addGroup(n4.start, n4.count, n4.materialIndex);
      }
      return e3;
    }
    toJSON() {
      const t3 = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } };
      if (t3.uuid = this.uuid, t3.type = this.type, this.name !== "" && (t3.name = this.name), Object.keys(this.userData).length > 0 && (t3.userData = this.userData), this.parameters !== void 0) {
        const e4 = this.parameters;
        for (const n3 in e4)
          e4[n3] !== void 0 && (t3[n3] = e4[n3]);
        return t3;
      }
      t3.data = { attributes: {} };
      const e3 = this.index;
      e3 !== null && (t3.data.index = { type: e3.array.constructor.name, array: Array.prototype.slice.call(e3.array) });
      const n2 = this.attributes;
      for (const e4 in n2) {
        const i3 = n2[e4];
        t3.data.attributes[e4] = i3.toJSON(t3.data);
      }
      const i2 = {};
      let r3 = false;
      for (const e4 in this.morphAttributes) {
        const n3 = this.morphAttributes[e4], o4 = [];
        for (let e5 = 0, i3 = n3.length; e5 < i3; e5++) {
          const i4 = n3[e5];
          o4.push(i4.toJSON(t3.data));
        }
        o4.length > 0 && (i2[e4] = o4, r3 = true);
      }
      r3 && (t3.data.morphAttributes = i2, t3.data.morphTargetsRelative = this.morphTargetsRelative);
      const o3 = this.groups;
      o3.length > 0 && (t3.data.groups = JSON.parse(JSON.stringify(o3)));
      const s3 = this.boundingSphere;
      return s3 !== null && (t3.data.boundingSphere = { center: s3.center.toArray(), radius: s3.radius }), t3;
    }
    clone() {
      return new so().copy(this);
    }
    copy(t3) {
      this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
      const e3 = {};
      this.name = t3.name;
      const n2 = t3.index;
      n2 !== null && this.setIndex(n2.clone(e3));
      const i2 = t3.attributes;
      for (const t4 in i2) {
        const n3 = i2[t4];
        this.setAttribute(t4, n3.clone(e3));
      }
      const r3 = t3.morphAttributes;
      for (const t4 in r3) {
        const n3 = [], i3 = r3[t4];
        for (let t5 = 0, r4 = i3.length; t5 < r4; t5++)
          n3.push(i3[t5].clone(e3));
        this.morphAttributes[t4] = n3;
      }
      this.morphTargetsRelative = t3.morphTargetsRelative;
      const o3 = t3.groups;
      for (let t4 = 0, e4 = o3.length; t4 < e4; t4++) {
        const e5 = o3[t4];
        this.addGroup(e5.start, e5.count, e5.materialIndex);
      }
      const s3 = t3.boundingBox;
      s3 !== null && (this.boundingBox = s3.clone());
      const a2 = t3.boundingSphere;
      return a2 !== null && (this.boundingSphere = a2.clone()), this.drawRange.start = t3.drawRange.start, this.drawRange.count = t3.drawRange.count, this.userData = t3.userData, this;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  }
  so.prototype.isBufferGeometry = true;
  const ao = new Vi(), lo = new ji(), uo = new Di(), ho = new pi(), co = new pi(), po = new pi(), fo = new pi(), mo = new pi(), go = new pi(), vo = new pi(), _o = new pi(), yo = new pi(), xo = new ei(), bo = new ei(), To = new ei(), wo = new pi(), So = new pi();
  class Eo extends mr {
    constructor(t3 = new so(), e3 = new Fr()) {
      super(), this.type = "Mesh", this.geometry = t3, this.material = e3, this.updateMorphTargets();
    }
    copy(t3) {
      return super.copy(t3), t3.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = t3.morphTargetInfluences.slice()), t3.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, t3.morphTargetDictionary)), this.material = t3.material, this.geometry = t3.geometry, this;
    }
    updateMorphTargets() {
      const t3 = this.geometry;
      if (t3.isBufferGeometry) {
        const e3 = t3.morphAttributes, n2 = Object.keys(e3);
        if (n2.length > 0) {
          const t4 = e3[n2[0]];
          if (t4 !== void 0) {
            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
            for (let e4 = 0, n3 = t4.length; e4 < n3; e4++) {
              const n4 = t4[e4].name || String(e4);
              this.morphTargetInfluences.push(0), this.morphTargetDictionary[n4] = e4;
            }
          }
        }
      } else {
        const e3 = t3.morphTargets;
        e3 !== void 0 && e3.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
    raycast(t3, e3) {
      const n2 = this.geometry, i2 = this.material, r3 = this.matrixWorld;
      if (i2 === void 0)
        return;
      if (n2.boundingSphere === null && n2.computeBoundingSphere(), uo.copy(n2.boundingSphere), uo.applyMatrix4(r3), t3.ray.intersectsSphere(uo) === false)
        return;
      if (ao.copy(r3).invert(), lo.copy(t3.ray).applyMatrix4(ao), n2.boundingBox !== null && lo.intersectsBox(n2.boundingBox) === false)
        return;
      let o3;
      if (n2.isBufferGeometry) {
        const r4 = n2.index, s3 = n2.attributes.position, a2 = n2.morphAttributes.position, l2 = n2.morphTargetsRelative, u2 = n2.attributes.uv, h2 = n2.attributes.uv2, c2 = n2.groups, d2 = n2.drawRange;
        if (r4 !== null)
          if (Array.isArray(i2))
            for (let n3 = 0, p2 = c2.length; n3 < p2; n3++) {
              const p3 = c2[n3], f2 = i2[p3.materialIndex];
              for (let n4 = Math.max(p3.start, d2.start), i3 = Math.min(p3.start + p3.count, d2.start + d2.count); n4 < i3; n4 += 3) {
                const i4 = r4.getX(n4), c3 = r4.getX(n4 + 1), d3 = r4.getX(n4 + 2);
                o3 = Mo(this, f2, t3, lo, s3, a2, l2, u2, h2, i4, c3, d3), o3 && (o3.faceIndex = Math.floor(n4 / 3), o3.face.materialIndex = p3.materialIndex, e3.push(o3));
              }
            }
          else {
            for (let n3 = Math.max(0, d2.start), c3 = Math.min(r4.count, d2.start + d2.count); n3 < c3; n3 += 3) {
              const c4 = r4.getX(n3), d3 = r4.getX(n3 + 1), p2 = r4.getX(n3 + 2);
              o3 = Mo(this, i2, t3, lo, s3, a2, l2, u2, h2, c4, d3, p2), o3 && (o3.faceIndex = Math.floor(n3 / 3), e3.push(o3));
            }
          }
        else if (s3 !== void 0)
          if (Array.isArray(i2))
            for (let n3 = 0, r5 = c2.length; n3 < r5; n3++) {
              const r6 = c2[n3], p2 = i2[r6.materialIndex];
              for (let n4 = Math.max(r6.start, d2.start), i3 = Math.min(r6.start + r6.count, d2.start + d2.count); n4 < i3; n4 += 3) {
                o3 = Mo(this, p2, t3, lo, s3, a2, l2, u2, h2, n4, n4 + 1, n4 + 2), o3 && (o3.faceIndex = Math.floor(n4 / 3), o3.face.materialIndex = r6.materialIndex, e3.push(o3));
              }
            }
          else {
            for (let n3 = Math.max(0, d2.start), r5 = Math.min(s3.count, d2.start + d2.count); n3 < r5; n3 += 3) {
              o3 = Mo(this, i2, t3, lo, s3, a2, l2, u2, h2, n3, n3 + 1, n3 + 2), o3 && (o3.faceIndex = Math.floor(n3 / 3), e3.push(o3));
            }
          }
      } else
        n2.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  }
  function Mo(t3, e3, n2, i2, r3, o3, s3, a2, l2, u2, h2, c2) {
    ho.fromBufferAttribute(r3, u2), co.fromBufferAttribute(r3, h2), po.fromBufferAttribute(r3, c2);
    const d2 = t3.morphTargetInfluences;
    if (e3.morphTargets && o3 && d2) {
      vo.set(0, 0, 0), _o.set(0, 0, 0), yo.set(0, 0, 0);
      for (let t4 = 0, e4 = o3.length; t4 < e4; t4++) {
        const e5 = d2[t4], n3 = o3[t4];
        e5 !== 0 && (fo.fromBufferAttribute(n3, u2), mo.fromBufferAttribute(n3, h2), go.fromBufferAttribute(n3, c2), s3 ? (vo.addScaledVector(fo, e5), _o.addScaledVector(mo, e5), yo.addScaledVector(go, e5)) : (vo.addScaledVector(fo.sub(ho), e5), _o.addScaledVector(mo.sub(co), e5), yo.addScaledVector(go.sub(po), e5)));
      }
      ho.add(vo), co.add(_o), po.add(yo);
    }
    t3.isSkinnedMesh && (t3.boneTransform(u2, ho), t3.boneTransform(h2, co), t3.boneTransform(c2, po));
    const p2 = function(t4, e4, n3, i3, r4, o4, s4, a3) {
      let l3;
      if (l3 = e4.side === b ? i3.intersectTriangle(s4, o4, r4, true, a3) : i3.intersectTriangle(r4, o4, s4, e4.side !== T, a3), l3 === null)
        return null;
      So.copy(a3), So.applyMatrix4(t4.matrixWorld);
      const u3 = n3.ray.origin.distanceTo(So);
      return u3 < n3.near || u3 > n3.far ? null : { distance: u3, point: So.clone(), object: t4 };
    }(t3, e3, n2, i2, ho, co, po, wo);
    if (p2) {
      a2 && (xo.fromBufferAttribute(a2, u2), bo.fromBufferAttribute(a2, h2), To.fromBufferAttribute(a2, c2), p2.uv = Mr.getUV(wo, ho, co, po, xo, bo, To, new ei())), l2 && (xo.fromBufferAttribute(l2, u2), bo.fromBufferAttribute(l2, h2), To.fromBufferAttribute(l2, c2), p2.uv2 = Mr.getUV(wo, ho, co, po, xo, bo, To, new ei()));
      const t4 = { a: u2, b: h2, c: c2, normal: new pi(), materialIndex: 0 };
      Mr.getNormal(ho, co, po, t4.normal), p2.face = t4;
    }
    return p2;
  }
  Eo.prototype.isMesh = true;
  class Ao extends so {
    constructor(t3 = 1, e3 = 1, n2 = 1, i2 = 1, r3 = 1, o3 = 1) {
      super(), this.type = "BoxGeometry", this.parameters = { width: t3, height: e3, depth: n2, widthSegments: i2, heightSegments: r3, depthSegments: o3 };
      const s3 = this;
      i2 = Math.floor(i2), r3 = Math.floor(r3), o3 = Math.floor(o3);
      const a2 = [], l2 = [], u2 = [], h2 = [];
      let c2 = 0, d2 = 0;
      function p2(t4, e4, n3, i3, r4, o4, p3, f2, m2, g2, v2) {
        const _2 = o4 / m2, y2 = p3 / g2, x2 = o4 / 2, b2 = p3 / 2, T2 = f2 / 2, w2 = m2 + 1, S2 = g2 + 1;
        let E2 = 0, M2 = 0;
        const A2 = new pi();
        for (let o5 = 0; o5 < S2; o5++) {
          const s4 = o5 * y2 - b2;
          for (let a3 = 0; a3 < w2; a3++) {
            const c3 = a3 * _2 - x2;
            A2[t4] = c3 * i3, A2[e4] = s4 * r4, A2[n3] = T2, l2.push(A2.x, A2.y, A2.z), A2[t4] = 0, A2[e4] = 0, A2[n3] = f2 > 0 ? 1 : -1, u2.push(A2.x, A2.y, A2.z), h2.push(a3 / m2), h2.push(1 - o5 / g2), E2 += 1;
          }
        }
        for (let t5 = 0; t5 < g2; t5++)
          for (let e5 = 0; e5 < m2; e5++) {
            const n4 = c2 + e5 + w2 * t5, i4 = c2 + e5 + w2 * (t5 + 1), r5 = c2 + (e5 + 1) + w2 * (t5 + 1), o5 = c2 + (e5 + 1) + w2 * t5;
            a2.push(n4, i4, o5), a2.push(i4, r5, o5), M2 += 6;
          }
        s3.addGroup(d2, M2, v2), d2 += M2, c2 += E2;
      }
      p2("z", "y", "x", -1, -1, n2, e3, t3, o3, r3, 0), p2("z", "y", "x", 1, -1, n2, e3, -t3, o3, r3, 1), p2("x", "z", "y", 1, 1, t3, n2, e3, i2, o3, 2), p2("x", "z", "y", 1, -1, t3, n2, -e3, i2, o3, 3), p2("x", "y", "z", 1, -1, t3, e3, n2, i2, r3, 4), p2("x", "y", "z", -1, -1, t3, e3, -n2, i2, r3, 5), this.setIndex(a2), this.setAttribute("position", new Yr(l2, 3)), this.setAttribute("normal", new Yr(u2, 3)), this.setAttribute("uv", new Yr(h2, 2));
    }
    static fromJSON(t3) {
      return new Ao(t3.width, t3.height, t3.depth, t3.widthSegments, t3.heightSegments, t3.depthSegments);
    }
  }
  function Ro(t3) {
    const e3 = {};
    for (const n2 in t3) {
      e3[n2] = {};
      for (const i2 in t3[n2]) {
        const r3 = t3[n2][i2];
        r3 && (r3.isColor || r3.isMatrix3 || r3.isMatrix4 || r3.isVector2 || r3.isVector3 || r3.isVector4 || r3.isTexture || r3.isQuaternion) ? e3[n2][i2] = r3.clone() : Array.isArray(r3) ? e3[n2][i2] = r3.slice() : e3[n2][i2] = r3;
      }
    }
    return e3;
  }
  function Po(t3) {
    const e3 = {};
    for (let n2 = 0; n2 < t3.length; n2++) {
      const i2 = Ro(t3[n2]);
      for (const t4 in i2)
        e3[t4] = i2[t4];
    }
    return e3;
  }
  const Co = { clone: Ro, merge: Po };
  class Io extends Rr {
    constructor(t3) {
      super(), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.lights = false, this.clipping = false, this.morphTargets = false, this.morphNormals = false, this.extensions = { derivatives: false, fragDepth: false, drawBuffers: false, shaderTextureLOD: false }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = false, this.glslVersion = null, t3 !== void 0 && (t3.attributes !== void 0 && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t3));
    }
    copy(t3) {
      return super.copy(t3), this.fragmentShader = t3.fragmentShader, this.vertexShader = t3.vertexShader, this.uniforms = Ro(t3.uniforms), this.defines = Object.assign({}, t3.defines), this.wireframe = t3.wireframe, this.wireframeLinewidth = t3.wireframeLinewidth, this.lights = t3.lights, this.clipping = t3.clipping, this.morphTargets = t3.morphTargets, this.morphNormals = t3.morphNormals, this.extensions = Object.assign({}, t3.extensions), this.glslVersion = t3.glslVersion, this;
    }
    toJSON(t3) {
      const e3 = super.toJSON(t3);
      e3.glslVersion = this.glslVersion, e3.uniforms = {};
      for (const n3 in this.uniforms) {
        const i2 = this.uniforms[n3].value;
        i2 && i2.isTexture ? e3.uniforms[n3] = { type: "t", value: i2.toJSON(t3).uuid } : i2 && i2.isColor ? e3.uniforms[n3] = { type: "c", value: i2.getHex() } : i2 && i2.isVector2 ? e3.uniforms[n3] = { type: "v2", value: i2.toArray() } : i2 && i2.isVector3 ? e3.uniforms[n3] = { type: "v3", value: i2.toArray() } : i2 && i2.isVector4 ? e3.uniforms[n3] = { type: "v4", value: i2.toArray() } : i2 && i2.isMatrix3 ? e3.uniforms[n3] = { type: "m3", value: i2.toArray() } : i2 && i2.isMatrix4 ? e3.uniforms[n3] = { type: "m4", value: i2.toArray() } : e3.uniforms[n3] = { value: i2 };
      }
      Object.keys(this.defines).length > 0 && (e3.defines = this.defines), e3.vertexShader = this.vertexShader, e3.fragmentShader = this.fragmentShader;
      const n2 = {};
      for (const t4 in this.extensions)
        this.extensions[t4] === true && (n2[t4] = true);
      return Object.keys(n2).length > 0 && (e3.extensions = n2), e3;
    }
  }
  Io.prototype.isShaderMaterial = true;
  class Oo extends mr {
    constructor() {
      super(), this.type = "Camera", this.matrixWorldInverse = new Vi(), this.projectionMatrix = new Vi(), this.projectionMatrixInverse = new Vi();
    }
    copy(t3, e3) {
      return super.copy(t3, e3), this.matrixWorldInverse.copy(t3.matrixWorldInverse), this.projectionMatrix.copy(t3.projectionMatrix), this.projectionMatrixInverse.copy(t3.projectionMatrixInverse), this;
    }
    getWorldDirection(t3) {
      this.updateWorldMatrix(true, false);
      const e3 = this.matrixWorld.elements;
      return t3.set(-e3[8], -e3[9], -e3[10]).normalize();
    }
    updateMatrixWorld(t3) {
      super.updateMatrixWorld(t3), this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    updateWorldMatrix(t3, e3) {
      super.updateWorldMatrix(t3, e3), this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  Oo.prototype.isCamera = true;
  class Lo extends Oo {
    constructor(t3 = 50, e3 = 1, n2 = 0.1, i2 = 2e3) {
      super(), this.type = "PerspectiveCamera", this.fov = t3, this.zoom = 1, this.near = n2, this.far = i2, this.focus = 10, this.aspect = e3, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
    }
    copy(t3, e3) {
      return super.copy(t3, e3), this.fov = t3.fov, this.zoom = t3.zoom, this.near = t3.near, this.far = t3.far, this.focus = t3.focus, this.aspect = t3.aspect, this.view = t3.view === null ? null : Object.assign({}, t3.view), this.filmGauge = t3.filmGauge, this.filmOffset = t3.filmOffset, this;
    }
    setFocalLength(t3) {
      const e3 = 0.5 * this.getFilmHeight() / t3;
      this.fov = 2 * Xn * Math.atan(e3), this.updateProjectionMatrix();
    }
    getFocalLength() {
      const t3 = Math.tan(0.5 * Wn * this.fov);
      return 0.5 * this.getFilmHeight() / t3;
    }
    getEffectiveFOV() {
      return 2 * Xn * Math.atan(Math.tan(0.5 * Wn * this.fov) / this.zoom);
    }
    getFilmWidth() {
      return this.filmGauge * Math.min(this.aspect, 1);
    }
    getFilmHeight() {
      return this.filmGauge / Math.max(this.aspect, 1);
    }
    setViewOffset(t3, e3, n2, i2, r3, o3) {
      this.aspect = t3 / e3, this.view === null && (this.view = { enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = true, this.view.fullWidth = t3, this.view.fullHeight = e3, this.view.offsetX = n2, this.view.offsetY = i2, this.view.width = r3, this.view.height = o3, this.updateProjectionMatrix();
    }
    clearViewOffset() {
      this.view !== null && (this.view.enabled = false), this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
      const t3 = this.near;
      let e3 = t3 * Math.tan(0.5 * Wn * this.fov) / this.zoom, n2 = 2 * e3, i2 = this.aspect * n2, r3 = -0.5 * i2;
      const o3 = this.view;
      if (this.view !== null && this.view.enabled) {
        const t4 = o3.fullWidth, s4 = o3.fullHeight;
        r3 += o3.offsetX * i2 / t4, e3 -= o3.offsetY * n2 / s4, i2 *= o3.width / t4, n2 *= o3.height / s4;
      }
      const s3 = this.filmOffset;
      s3 !== 0 && (r3 += t3 * s3 / this.getFilmWidth()), this.projectionMatrix.makePerspective(r3, r3 + i2, e3, e3 - n2, t3, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(t3) {
      const e3 = super.toJSON(t3);
      return e3.object.fov = this.fov, e3.object.zoom = this.zoom, e3.object.near = this.near, e3.object.far = this.far, e3.object.focus = this.focus, e3.object.aspect = this.aspect, this.view !== null && (e3.object.view = Object.assign({}, this.view)), e3.object.filmGauge = this.filmGauge, e3.object.filmOffset = this.filmOffset, e3;
    }
  }
  Lo.prototype.isPerspectiveCamera = true;
  class No extends mr {
    constructor(t3, e3, n2) {
      if (super(), this.type = "CubeCamera", n2.isWebGLCubeRenderTarget !== true)
        return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
      this.renderTarget = n2;
      const i2 = new Lo(90, 1, t3, e3);
      i2.layers = this.layers, i2.up.set(0, -1, 0), i2.lookAt(new pi(1, 0, 0)), this.add(i2);
      const r3 = new Lo(90, 1, t3, e3);
      r3.layers = this.layers, r3.up.set(0, -1, 0), r3.lookAt(new pi(-1, 0, 0)), this.add(r3);
      const o3 = new Lo(90, 1, t3, e3);
      o3.layers = this.layers, o3.up.set(0, 0, 1), o3.lookAt(new pi(0, 1, 0)), this.add(o3);
      const s3 = new Lo(90, 1, t3, e3);
      s3.layers = this.layers, s3.up.set(0, 0, -1), s3.lookAt(new pi(0, -1, 0)), this.add(s3);
      const a2 = new Lo(90, 1, t3, e3);
      a2.layers = this.layers, a2.up.set(0, -1, 0), a2.lookAt(new pi(0, 0, 1)), this.add(a2);
      const l2 = new Lo(90, 1, t3, e3);
      l2.layers = this.layers, l2.up.set(0, -1, 0), l2.lookAt(new pi(0, 0, -1)), this.add(l2);
    }
    update(t3, e3) {
      this.parent === null && this.updateMatrixWorld();
      const n2 = this.renderTarget, [i2, r3, o3, s3, a2, l2] = this.children, u2 = t3.xr.enabled, h2 = t3.getRenderTarget();
      t3.xr.enabled = false;
      const c2 = n2.texture.generateMipmaps;
      n2.texture.generateMipmaps = false, t3.setRenderTarget(n2, 0), t3.render(e3, i2), t3.setRenderTarget(n2, 1), t3.render(e3, r3), t3.setRenderTarget(n2, 2), t3.render(e3, o3), t3.setRenderTarget(n2, 3), t3.render(e3, s3), t3.setRenderTarget(n2, 4), t3.render(e3, a2), n2.texture.generateMipmaps = c2, t3.setRenderTarget(n2, 5), t3.render(e3, l2), t3.setRenderTarget(h2), t3.xr.enabled = u2;
    }
  }
  class Do extends si {
    constructor(t3, e3, n2, i2, r3, o3, s3, a2, l2, u2) {
      super(t3 = t3 !== void 0 ? t3 : [], e3 = e3 !== void 0 ? e3 : ct, n2, i2, r3, o3, s3 = s3 !== void 0 ? s3 : jt, a2, l2, u2), this._needsFlipEnvMap = true, this.flipY = false;
    }
    get images() {
      return this.image;
    }
    set images(t3) {
      this.image = t3;
    }
  }
  Do.prototype.isCubeTexture = true;
  class Fo extends ui {
    constructor(t3, e3, n2) {
      Number.isInteger(e3) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), e3 = n2), super(t3, t3, e3), e3 = e3 || {}, this.texture = new Do(void 0, e3.mapping, e3.wrapS, e3.wrapT, e3.magFilter, e3.minFilter, e3.format, e3.type, e3.anisotropy, e3.encoding), this.texture.generateMipmaps = e3.generateMipmaps !== void 0 && e3.generateMipmaps, this.texture.minFilter = e3.minFilter !== void 0 ? e3.minFilter : Et, this.texture._needsFlipEnvMap = false;
    }
    fromEquirectangularTexture(t3, e3) {
      this.texture.type = e3.type, this.texture.format = Vt, this.texture.encoding = e3.encoding, this.texture.generateMipmaps = e3.generateMipmaps, this.texture.minFilter = e3.minFilter, this.texture.magFilter = e3.magFilter;
      const n2 = { uniforms: { tEquirect: { value: null } }, vertexShader: "\n\n				varying vec3 vWorldDirection;\n\n				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n				}\n\n				void main() {\n\n					vWorldDirection = transformDirection( position, modelMatrix );\n\n					#include <begin_vertex>\n					#include <project_vertex>\n\n				}\n			", fragmentShader: "\n\n				uniform sampler2D tEquirect;\n\n				varying vec3 vWorldDirection;\n\n				#include <common>\n\n				void main() {\n\n					vec3 direction = normalize( vWorldDirection );\n\n					vec2 sampleUV = equirectUv( direction );\n\n					gl_FragColor = texture2D( tEquirect, sampleUV );\n\n				}\n			" }, i2 = new Ao(5, 5, 5), r3 = new Io({ name: "CubemapFromEquirect", uniforms: Ro(n2.uniforms), vertexShader: n2.vertexShader, fragmentShader: n2.fragmentShader, side: b, blending: E });
      r3.uniforms.tEquirect.value = e3;
      const o3 = new Eo(i2, r3), s3 = e3.minFilter;
      e3.minFilter === Rt && (e3.minFilter = Et);
      return new No(1, 10, this).update(t3, o3), e3.minFilter = s3, o3.geometry.dispose(), o3.material.dispose(), this;
    }
    clear(t3, e3, n2, i2) {
      const r3 = t3.getRenderTarget();
      for (let r4 = 0; r4 < 6; r4++)
        t3.setRenderTarget(this, r4), t3.clear(e3, n2, i2);
      t3.setRenderTarget(r3);
    }
  }
  Fo.prototype.isWebGLCubeRenderTarget = true;
  const Bo = new pi(), Uo = new pi(), ko = new ni();
  class Go {
    constructor(t3 = new pi(1, 0, 0), e3 = 0) {
      this.normal = t3, this.constant = e3;
    }
    set(t3, e3) {
      return this.normal.copy(t3), this.constant = e3, this;
    }
    setComponents(t3, e3, n2, i2) {
      return this.normal.set(t3, e3, n2), this.constant = i2, this;
    }
    setFromNormalAndCoplanarPoint(t3, e3) {
      return this.normal.copy(t3), this.constant = -e3.dot(this.normal), this;
    }
    setFromCoplanarPoints(t3, e3, n2) {
      const i2 = Bo.subVectors(n2, e3).cross(Uo.subVectors(t3, e3)).normalize();
      return this.setFromNormalAndCoplanarPoint(i2, t3), this;
    }
    copy(t3) {
      return this.normal.copy(t3.normal), this.constant = t3.constant, this;
    }
    normalize() {
      const t3 = 1 / this.normal.length();
      return this.normal.multiplyScalar(t3), this.constant *= t3, this;
    }
    negate() {
      return this.constant *= -1, this.normal.negate(), this;
    }
    distanceToPoint(t3) {
      return this.normal.dot(t3) + this.constant;
    }
    distanceToSphere(t3) {
      return this.distanceToPoint(t3.center) - t3.radius;
    }
    projectPoint(t3, e3) {
      return e3.copy(this.normal).multiplyScalar(-this.distanceToPoint(t3)).add(t3);
    }
    intersectLine(t3, e3) {
      const n2 = t3.delta(Bo), i2 = this.normal.dot(n2);
      if (i2 === 0)
        return this.distanceToPoint(t3.start) === 0 ? e3.copy(t3.start) : null;
      const r3 = -(t3.start.dot(this.normal) + this.constant) / i2;
      return r3 < 0 || r3 > 1 ? null : e3.copy(n2).multiplyScalar(r3).add(t3.start);
    }
    intersectsLine(t3) {
      const e3 = this.distanceToPoint(t3.start), n2 = this.distanceToPoint(t3.end);
      return e3 < 0 && n2 > 0 || n2 < 0 && e3 > 0;
    }
    intersectsBox(t3) {
      return t3.intersectsPlane(this);
    }
    intersectsSphere(t3) {
      return t3.intersectsPlane(this);
    }
    coplanarPoint(t3) {
      return t3.copy(this.normal).multiplyScalar(-this.constant);
    }
    applyMatrix4(t3, e3) {
      const n2 = e3 || ko.getNormalMatrix(t3), i2 = this.coplanarPoint(Bo).applyMatrix4(t3), r3 = this.normal.applyMatrix3(n2).normalize();
      return this.constant = -i2.dot(r3), this;
    }
    translate(t3) {
      return this.constant -= t3.dot(this.normal), this;
    }
    equals(t3) {
      return t3.normal.equals(this.normal) && t3.constant === this.constant;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  Go.prototype.isPlane = true;
  const Ho = new Di(), zo = new pi();
  class jo {
    constructor(t3 = new Go(), e3 = new Go(), n2 = new Go(), i2 = new Go(), r3 = new Go(), o3 = new Go()) {
      this.planes = [t3, e3, n2, i2, r3, o3];
    }
    set(t3, e3, n2, i2, r3, o3) {
      const s3 = this.planes;
      return s3[0].copy(t3), s3[1].copy(e3), s3[2].copy(n2), s3[3].copy(i2), s3[4].copy(r3), s3[5].copy(o3), this;
    }
    copy(t3) {
      const e3 = this.planes;
      for (let n2 = 0; n2 < 6; n2++)
        e3[n2].copy(t3.planes[n2]);
      return this;
    }
    setFromProjectionMatrix(t3) {
      const e3 = this.planes, n2 = t3.elements, i2 = n2[0], r3 = n2[1], o3 = n2[2], s3 = n2[3], a2 = n2[4], l2 = n2[5], u2 = n2[6], h2 = n2[7], c2 = n2[8], d2 = n2[9], p2 = n2[10], f2 = n2[11], m2 = n2[12], g2 = n2[13], v2 = n2[14], _2 = n2[15];
      return e3[0].setComponents(s3 - i2, h2 - a2, f2 - c2, _2 - m2).normalize(), e3[1].setComponents(s3 + i2, h2 + a2, f2 + c2, _2 + m2).normalize(), e3[2].setComponents(s3 + r3, h2 + l2, f2 + d2, _2 + g2).normalize(), e3[3].setComponents(s3 - r3, h2 - l2, f2 - d2, _2 - g2).normalize(), e3[4].setComponents(s3 - o3, h2 - u2, f2 - p2, _2 - v2).normalize(), e3[5].setComponents(s3 + o3, h2 + u2, f2 + p2, _2 + v2).normalize(), this;
    }
    intersectsObject(t3) {
      const e3 = t3.geometry;
      return e3.boundingSphere === null && e3.computeBoundingSphere(), Ho.copy(e3.boundingSphere).applyMatrix4(t3.matrixWorld), this.intersectsSphere(Ho);
    }
    intersectsSprite(t3) {
      return Ho.center.set(0, 0, 0), Ho.radius = 0.7071067811865476, Ho.applyMatrix4(t3.matrixWorld), this.intersectsSphere(Ho);
    }
    intersectsSphere(t3) {
      const e3 = this.planes, n2 = t3.center, i2 = -t3.radius;
      for (let t4 = 0; t4 < 6; t4++) {
        if (e3[t4].distanceToPoint(n2) < i2)
          return false;
      }
      return true;
    }
    intersectsBox(t3) {
      const e3 = this.planes;
      for (let n2 = 0; n2 < 6; n2++) {
        const i2 = e3[n2];
        if (zo.x = i2.normal.x > 0 ? t3.max.x : t3.min.x, zo.y = i2.normal.y > 0 ? t3.max.y : t3.min.y, zo.z = i2.normal.z > 0 ? t3.max.z : t3.min.z, i2.distanceToPoint(zo) < 0)
          return false;
      }
      return true;
    }
    containsPoint(t3) {
      const e3 = this.planes;
      for (let n2 = 0; n2 < 6; n2++)
        if (e3[n2].distanceToPoint(t3) < 0)
          return false;
      return true;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  function Vo() {
    let t3 = null, e3 = false, n2 = null, i2 = null;
    function r3(e4, o3) {
      n2(e4, o3), i2 = t3.requestAnimationFrame(r3);
    }
    return { start: function() {
      e3 !== true && n2 !== null && (i2 = t3.requestAnimationFrame(r3), e3 = true);
    }, stop: function() {
      t3.cancelAnimationFrame(i2), e3 = false;
    }, setAnimationLoop: function(t4) {
      n2 = t4;
    }, setContext: function(e4) {
      t3 = e4;
    } };
  }
  function Wo(t3, e3) {
    const n2 = e3.isWebGL2, i2 = new WeakMap();
    return { get: function(t4) {
      return t4.isInterleavedBufferAttribute && (t4 = t4.data), i2.get(t4);
    }, remove: function(e4) {
      e4.isInterleavedBufferAttribute && (e4 = e4.data);
      const n3 = i2.get(e4);
      n3 && (t3.deleteBuffer(n3.buffer), i2.delete(e4));
    }, update: function(e4, r3) {
      if (e4.isGLBufferAttribute) {
        const t4 = i2.get(e4);
        return void ((!t4 || t4.version < e4.version) && i2.set(e4, { buffer: e4.buffer, type: e4.type, bytesPerElement: e4.elementSize, version: e4.version }));
      }
      e4.isInterleavedBufferAttribute && (e4 = e4.data);
      const o3 = i2.get(e4);
      o3 === void 0 ? i2.set(e4, function(e5, i3) {
        const r4 = e5.array, o4 = e5.usage, s3 = t3.createBuffer();
        t3.bindBuffer(i3, s3), t3.bufferData(i3, r4, o4), e5.onUploadCallback();
        let a2 = 5126;
        return r4 instanceof Float32Array ? a2 = 5126 : r4 instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : r4 instanceof Uint16Array ? e5.isFloat16BufferAttribute ? n2 ? a2 = 5131 : console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : a2 = 5123 : r4 instanceof Int16Array ? a2 = 5122 : r4 instanceof Uint32Array ? a2 = 5125 : r4 instanceof Int32Array ? a2 = 5124 : r4 instanceof Int8Array ? a2 = 5120 : (r4 instanceof Uint8Array || r4 instanceof Uint8ClampedArray) && (a2 = 5121), { buffer: s3, type: a2, bytesPerElement: r4.BYTES_PER_ELEMENT, version: e5.version };
      }(e4, r3)) : o3.version < e4.version && (!function(e5, i3, r4) {
        const o4 = i3.array, s3 = i3.updateRange;
        t3.bindBuffer(r4, e5), s3.count === -1 ? t3.bufferSubData(r4, 0, o4) : (n2 ? t3.bufferSubData(r4, s3.offset * o4.BYTES_PER_ELEMENT, o4, s3.offset, s3.count) : t3.bufferSubData(r4, s3.offset * o4.BYTES_PER_ELEMENT, o4.subarray(s3.offset, s3.offset + s3.count)), s3.count = -1);
      }(o3.buffer, e4, r3), o3.version = e4.version);
    } };
  }
  class Xo extends so {
    constructor(t3 = 1, e3 = 1, n2 = 1, i2 = 1) {
      super(), this.type = "PlaneGeometry", this.parameters = { width: t3, height: e3, widthSegments: n2, heightSegments: i2 };
      const r3 = t3 / 2, o3 = e3 / 2, s3 = Math.floor(n2), a2 = Math.floor(i2), l2 = s3 + 1, u2 = a2 + 1, h2 = t3 / s3, c2 = e3 / a2, d2 = [], p2 = [], f2 = [], m2 = [];
      for (let t4 = 0; t4 < u2; t4++) {
        const e4 = t4 * c2 - o3;
        for (let n3 = 0; n3 < l2; n3++) {
          const i3 = n3 * h2 - r3;
          p2.push(i3, -e4, 0), f2.push(0, 0, 1), m2.push(n3 / s3), m2.push(1 - t4 / a2);
        }
      }
      for (let t4 = 0; t4 < a2; t4++)
        for (let e4 = 0; e4 < s3; e4++) {
          const n3 = e4 + l2 * t4, i3 = e4 + l2 * (t4 + 1), r4 = e4 + 1 + l2 * (t4 + 1), o4 = e4 + 1 + l2 * t4;
          d2.push(n3, i3, o4), d2.push(i3, r4, o4);
        }
      this.setIndex(d2), this.setAttribute("position", new Yr(p2, 3)), this.setAttribute("normal", new Yr(f2, 3)), this.setAttribute("uv", new Yr(m2, 2));
    }
    static fromJSON(t3) {
      return new Xo(t3.width, t3.height, t3.widthSegments, t3.heightSegments);
    }
  }
  const qo = { alphamap_fragment: "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif", alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif", alphatest_fragment: "#ifdef ALPHATEST\n	if ( diffuseColor.a < ALPHATEST ) discard;\n#endif", aomap_fragment: "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n	#endif\n#endif", aomap_pars_fragment: "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif", begin_vertex: "vec3 transformed = vec3( position );", beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif", bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	return vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n	if( cutoffDistance > 0.0 ) {\n		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n	}\n	return distanceFalloff;\n#else\n	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n	}\n	return 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotVH ) {\n	float fresnel = exp2( ( -5.55473 * dotVH - 6.98316 ) * dotVH );\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n	return Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	return 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( incidentLight.direction + viewDir );\n	float dotNL = saturate( dot( normal, incidentLight.direction ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n	return specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n	vec3 FssEss = F * brdf.x + brdf.y;\n	float Ess = brdf.x + brdf.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n	float invAlpha = 1.0 / roughness;\n	float cos2h = NoH * NoH;\n	float sin2h = max(1.0 - cos2h, 0.0078125);	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n	vec3 N = geometry.normal;\n	vec3 V = geometry.viewDir;\n	vec3 H = normalize( V + L );\n	float dotNH = saturate( dot( N, H ) );\n	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif", bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif", clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif", clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif", clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif", clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif", color_fragment: "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif", color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif", color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif", color_vertex: "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif", common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	float distance = dot( planeNormal, point - pointOnPlane );\n	return - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n	return dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}", cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_maxMipLevel 8.0\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_maxTileSize 256.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n		vec2 f = fract( uv );\n		uv += 0.5 - f;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		if ( mipInt < cubeUV_maxMipLevel ) {\n			uv.y += 2.0 * cubeUV_maxTileSize;\n		}\n		uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n		uv *= texelSize;\n		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x += texelSize;\n		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.y += texelSize;\n		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x -= texelSize;\n		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		vec3 tm = mix( tl, tr, f.x );\n		vec3 bm = mix( bl, br, f.x );\n		return mix( tm, bm, f.y );\n	}\n	#define r0 1.0\n	#define v0 0.339\n	#define m0 - 2.0\n	#define r1 0.8\n	#define v1 0.276\n	#define m1 - 1.0\n	#define r4 0.4\n	#define v4 0.046\n	#define m4 2.0\n	#define r5 0.305\n	#define v5 0.016\n	#define m5 3.0\n	#define r6 0.21\n	#define v6 0.0038\n	#define m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= r1 ) {\n			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n		} else if ( roughness >= r4 ) {\n			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n		} else if ( roughness >= r5 ) {\n			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n		} else if ( roughness >= r6 ) {\n			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif", defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif", displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif", displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif", emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif", emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif", encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );", encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n	float maxComponent = max( max( value.r, value.g ), value.b );\n	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n	M = ceil( M * 255.0 ) / 255.0;\n	return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float D = max( maxRange / maxRGB, 1.0 );\n	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n	vec4 vResult;\n	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n	vResult.w = fract( Le );\n	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n	return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n	float Le = value.z * 255.0 + value.w;\n	vec3 Xp_Y_XYZp;\n	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n	return vec4( max( vRGB, 0.0 ), 1.0 );\n}", envmap_fragment: "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifndef ENVMAP_TYPE_CUBE_UV\n		envColor = envMapTexelToLinear( envColor );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif", envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	uniform int maxMipLevel;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif", envmap_pars_fragment: "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif", envmap_pars_vertex: "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif", envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n	#ifdef ENVMAP_MODE_REFRACTION\n		uniform float refractionRatio;\n	#endif\n	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n		#else\n			vec4 envMapColor = vec4( 0.0 );\n		#endif\n		return PI * envMapColor.rgb * envMapIntensity;\n	}\n	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n		float maxMIPLevelScalar = float( maxMIPLevel );\n		float sigma = PI * roughness * roughness / ( 1.0 + roughness );\n		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n	}\n	vec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( -viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n		#else\n			vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n		#endif\n		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n		#endif\n		return envMapColor.rgb * envMapIntensity;\n	}\n#endif", envmap_vertex: "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif", fog_vertex: "#ifdef USE_FOG\n	fogDepth = - mvPosition.z;\n#endif", fog_pars_vertex: "#ifdef USE_FOG\n	varying float fogDepth;\n#endif", fog_fragment: "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif", fog_pars_fragment: "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float fogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif", gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return texture2D( gradientMap, coord ).rgb;\n	#else\n		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n	#endif\n}", lightmap_fragment: "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif", lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif", lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		#ifdef DOUBLE_SIDED\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif", lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	return irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		directLight.color = directionalLight.color;\n		directLight.direction = directionalLight.direction;\n		directLight.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		directLight.color = pointLight.color;\n		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n		directLight.visible = ( directLight.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		float angleCos = dot( directLight.direction, spotLight.direction );\n		if ( angleCos > spotLight.coneCos ) {\n			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n			directLight.color = spotLight.color;\n			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n			directLight.visible = true;\n		} else {\n			directLight.color = vec3( 0.0 );\n			directLight.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n		float dotNL = dot( geometry.normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			irradiance *= PI;\n		#endif\n		return irradiance;\n	}\n#endif", lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;", lights_toon_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )	(0)", lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;", lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)", lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheen;\n#endif", lights_physical_pars_fragment: "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float specularRoughness;\n	vec3 specularColor;\n#ifdef CLEARCOAT\n	float clearcoat;\n	float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	vec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.specularRoughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	#ifdef CLEARCOAT\n		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = ccDotNL * directLight.color;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			ccIrradiance *= PI;\n		#endif\n		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n	#else\n		float clearcoatDHR = 0.0;\n	#endif\n	#ifdef USE_SHEEN\n		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n			material.specularRoughness,\n			directLight.direction,\n			geometry,\n			material.sheenColor\n		);\n	#else\n		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n	#endif\n	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef CLEARCOAT\n		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n		float ccDotNL = ccDotNV;\n		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n	#else\n		float clearcoatDHR = 0.0;\n	#endif\n	float clearcoatInv = 1.0 - clearcoatDHR;\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}", lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointDirectLightIrradiance( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif", lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			lightMapIrradiance *= PI;\n		#endif\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n	#ifdef CLEARCOAT\n		clearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n	#endif\n#endif", lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif", logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif", logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif", logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif", logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif", map_fragment: "#ifdef USE_MAP\n	vec4 texelColor = texture2D( map, vUv );\n	texelColor = mapTexelToLinear( texelColor );\n	diffuseColor *= texelColor;\n#endif", map_pars_fragment: "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif", map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	vec4 mapTexel = texture2D( map, uv );\n	diffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif", map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif", metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif", metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif", morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif", morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifndef USE_MORPHNORMALS\n		uniform float morphTargetInfluences[ 8 ];\n	#else\n		uniform float morphTargetInfluences[ 4 ];\n	#endif\n#endif", morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n	transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n	transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n	transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n	#ifndef USE_MORPHNORMALS\n		transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n		transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n		transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n		transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n	#endif\n#endif", normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * faceDirection;\n			bitangent = bitangent * faceDirection;\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;", normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif", normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n	}\n#endif", clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif", clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n	#endif\n#endif", clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif", packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}", premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif", project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;", dithering_fragment: "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif", dithering_pars_fragment: "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif", roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif", roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif", shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif", shadowmap_vertex: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		vec4 shadowWorldPosition;\n	#endif\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n#endif", shadowmask_pars_fragment: "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}", skinbase_vertex: "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex: "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform highp sampler2D boneTexture;\n		uniform int boneTextureSize;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureSize ) );\n			float y = floor( j / float( boneTextureSize ) );\n			float dx = 1.0 / float( boneTextureSize );\n			float dy = 1.0 / float( boneTextureSize );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif", skinning_vertex: "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif", skinnormal_vertex: "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif", specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif", specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif", tonemapping_fragment: "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif", tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }", transmission_fragment: "#ifdef USE_TRANSMISSION\n	float transmissionFactor = transmission;\n	float thicknessFactor = thickness;\n	#ifdef USE_TRANSMISSIONMAP\n		transmissionFactor *= texture2D( transmissionMap, vUv ).r;\n	#endif\n	#ifdef USE_THICKNESSNMAP\n		thicknessFactor *= texture2D( thicknessMap, vUv ).g;\n	#endif\n	vec3 pos = vWorldPosition.xyz / vWorldPosition.w;\n	vec3 v = normalize( cameraPosition - pos );\n	float ior = ( 1.0 + 0.4 * reflectivity ) / ( 1.0 - 0.4 * reflectivity );\n	vec3 transmission = transmissionFactor * getIBLVolumeRefraction(\n		normal, v, roughnessFactor, material.diffuseColor, totalSpecular,\n		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n		attenuationColor, attenuationDistance );\n	totalDiffuse = mix( totalDiffuse, transmission, transmissionFactor );\n#endif", transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec4 vWorldPosition;\n	vec3 getVolumeTransmissionRay(vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix) {\n		vec3 refractionVector = refract(-v, normalize(n), 1.0 / ior);\n		vec3 modelScale;\n		modelScale.x = length(vec3(modelMatrix[0].xyz));\n		modelScale.y = length(vec3(modelMatrix[1].xyz));\n		modelScale.z = length(vec3(modelMatrix[2].xyz));\n		return normalize(refractionVector) * thickness * modelScale;\n	}\n	float applyIorToRoughness(float roughness, float ior) {\n		return roughness * clamp(ior * 2.0 - 2.0, 0.0, 1.0);\n	}\n	vec3 getTransmissionSample(vec2 fragCoord, float roughness, float ior) {\n		float framebufferLod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness, ior);\n		return texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod).rgb;\n	}\n	vec3 applyVolumeAttenuation(vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance) {\n		if (attenuationDistance == 0.0) {\n			return radiance;\n		} else {\n			vec3 attenuationCoefficient = -log(attenuationColor) / attenuationDistance;\n			vec3 transmittance = exp(-attenuationCoefficient * transmissionDistance);			return transmittance * radiance;\n		}\n	}\n	vec3 getIBLVolumeRefraction(vec3 n, vec3 v, float perceptualRoughness, vec3 baseColor, vec3 specularColor,\n		vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n		vec3 attenuationColor, float attenuationDistance) {\n		vec3 transmissionRay = getVolumeTransmissionRay(n, v, thickness, ior, modelMatrix);\n		vec3 refractedRayExit = position + transmissionRay;\n		vec4 ndcPos = projMatrix * viewMatrix * vec4(refractedRayExit, 1.0);\n		vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n		refractionCoords += 1.0;\n		refractionCoords /= 2.0;\n		vec3 transmittedLight = getTransmissionSample(refractionCoords, perceptualRoughness, ior);\n		vec3 attenuatedColor = applyVolumeAttenuation(transmittedLight, length(transmissionRay), attenuationColor, attenuationDistance);\n		return (1.0 - specularColor) * attenuatedColor * baseColor;\n	}\n#endif", uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif", uv_pars_vertex: "#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif", uv_vertex: "#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif", uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif", uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif", uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif", worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif", background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}", background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}", cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}", cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}", depth_frag: "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}", depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}", distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}", distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}", equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	vec4 texColor = texture2D( tEquirect, sampleUV );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}", equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}", linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}", linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}", meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n	\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_ENVMAP\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}", meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	#ifdef DOUBLE_SIDED\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n	#else\n		reflectedLight.indirectDiffuse += vIndirectFront;\n	#endif\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n		matcapColor = matcapTexelToLinear( matcapColor );\n	#else\n		vec4 matcapColor = vec4( 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#ifndef FLAT_SHADED\n		vNormal = normalize( transformedNormal );\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}", meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n	#define REFLECTIVITY\n	#define CLEARCOAT\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform vec3 attenuationColor;\n	uniform float attenuationDistance;\n#endif\n#ifdef REFLECTIVITY\n	uniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <transmission_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#ifdef USE_TRANSMISSION\n	varying vec4 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition;\n#endif\n}", normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}", normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}", points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}", points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}", shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}", shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <begin_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}", sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}" }, Yo = { common: { diffuse: { value: new Dr(16777215) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new ni() }, uv2Transform: { value: new ni() }, alphaMap: { value: null } }, specularmap: { specularMap: { value: null } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, refractionRatio: { value: 0.98 }, maxMipLevel: { value: 0 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new ei(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new Dr(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotShadowMap: { value: [] }, spotShadowMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new Dr(16777215) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, uvTransform: { value: new ni() } }, sprite: { diffuse: { value: new Dr(16777215) }, opacity: { value: 1 }, center: { value: new ei(0.5, 0.5) }, rotation: { value: 0 }, map: { value: null }, alphaMap: { value: null }, uvTransform: { value: new ni() } } }, Zo = { basic: { uniforms: Po([Yo.common, Yo.specularmap, Yo.envmap, Yo.aomap, Yo.lightmap, Yo.fog]), vertexShader: qo.meshbasic_vert, fragmentShader: qo.meshbasic_frag }, lambert: { uniforms: Po([Yo.common, Yo.specularmap, Yo.envmap, Yo.aomap, Yo.lightmap, Yo.emissivemap, Yo.fog, Yo.lights, { emissive: { value: new Dr(0) } }]), vertexShader: qo.meshlambert_vert, fragmentShader: qo.meshlambert_frag }, phong: { uniforms: Po([Yo.common, Yo.specularmap, Yo.envmap, Yo.aomap, Yo.lightmap, Yo.emissivemap, Yo.bumpmap, Yo.normalmap, Yo.displacementmap, Yo.fog, Yo.lights, { emissive: { value: new Dr(0) }, specular: { value: new Dr(1118481) }, shininess: { value: 30 } }]), vertexShader: qo.meshphong_vert, fragmentShader: qo.meshphong_frag }, standard: { uniforms: Po([Yo.common, Yo.envmap, Yo.aomap, Yo.lightmap, Yo.emissivemap, Yo.bumpmap, Yo.normalmap, Yo.displacementmap, Yo.roughnessmap, Yo.metalnessmap, Yo.fog, Yo.lights, { emissive: { value: new Dr(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: qo.meshphysical_vert, fragmentShader: qo.meshphysical_frag }, toon: { uniforms: Po([Yo.common, Yo.aomap, Yo.lightmap, Yo.emissivemap, Yo.bumpmap, Yo.normalmap, Yo.displacementmap, Yo.gradientmap, Yo.fog, Yo.lights, { emissive: { value: new Dr(0) } }]), vertexShader: qo.meshtoon_vert, fragmentShader: qo.meshtoon_frag }, matcap: { uniforms: Po([Yo.common, Yo.bumpmap, Yo.normalmap, Yo.displacementmap, Yo.fog, { matcap: { value: null } }]), vertexShader: qo.meshmatcap_vert, fragmentShader: qo.meshmatcap_frag }, points: { uniforms: Po([Yo.points, Yo.fog]), vertexShader: qo.points_vert, fragmentShader: qo.points_frag }, dashed: { uniforms: Po([Yo.common, Yo.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: qo.linedashed_vert, fragmentShader: qo.linedashed_frag }, depth: { uniforms: Po([Yo.common, Yo.displacementmap]), vertexShader: qo.depth_vert, fragmentShader: qo.depth_frag }, normal: { uniforms: Po([Yo.common, Yo.bumpmap, Yo.normalmap, Yo.displacementmap, { opacity: { value: 1 } }]), vertexShader: qo.normal_vert, fragmentShader: qo.normal_frag }, sprite: { uniforms: Po([Yo.sprite, Yo.fog]), vertexShader: qo.sprite_vert, fragmentShader: qo.sprite_frag }, background: { uniforms: { uvTransform: { value: new ni() }, t2D: { value: null } }, vertexShader: qo.background_vert, fragmentShader: qo.background_frag }, cube: { uniforms: Po([Yo.envmap, { opacity: { value: 1 } }]), vertexShader: qo.cube_vert, fragmentShader: qo.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: qo.equirect_vert, fragmentShader: qo.equirect_frag }, distanceRGBA: { uniforms: Po([Yo.common, Yo.displacementmap, { referencePosition: { value: new pi() }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: qo.distanceRGBA_vert, fragmentShader: qo.distanceRGBA_frag }, shadow: { uniforms: Po([Yo.lights, Yo.fog, { color: { value: new Dr(0) }, opacity: { value: 1 } }]), vertexShader: qo.shadow_vert, fragmentShader: qo.shadow_frag } };
  function Jo(t3, e3, n2, i2, r3) {
    const o3 = new Dr(0);
    let s3, a2, l2 = 0, u2 = null, h2 = 0, c2 = null;
    function d2(t4, e4) {
      n2.buffers.color.setClear(t4.r, t4.g, t4.b, e4, r3);
    }
    return { getClearColor: function() {
      return o3;
    }, setClearColor: function(t4, e4 = 1) {
      o3.set(t4), l2 = e4, d2(o3, l2);
    }, getClearAlpha: function() {
      return l2;
    }, setClearAlpha: function(t4) {
      l2 = t4, d2(o3, l2);
    }, render: function(n3, r4) {
      let p2 = false, f2 = r4.isScene === true ? r4.background : null;
      f2 && f2.isTexture && (f2 = e3.get(f2));
      const m2 = t3.xr, g2 = m2.getSession && m2.getSession();
      g2 && g2.environmentBlendMode === "additive" && (f2 = null), f2 === null ? d2(o3, l2) : f2 && f2.isColor && (d2(f2, 1), p2 = true), (t3.autoClear || p2) && t3.clear(t3.autoClearColor, t3.autoClearDepth, t3.autoClearStencil), f2 && (f2.isCubeTexture || f2.mapping === mt) ? (a2 === void 0 && (a2 = new Eo(new Ao(1, 1, 1), new Io({ name: "BackgroundCubeMaterial", uniforms: Ro(Zo.cube.uniforms), vertexShader: Zo.cube.vertexShader, fragmentShader: Zo.cube.fragmentShader, side: b, depthTest: false, depthWrite: false, fog: false })), a2.geometry.deleteAttribute("normal"), a2.geometry.deleteAttribute("uv"), a2.onBeforeRender = function(t4, e4, n4) {
        this.matrixWorld.copyPosition(n4.matrixWorld);
      }, Object.defineProperty(a2.material, "envMap", { get: function() {
        return this.uniforms.envMap.value;
      } }), i2.update(a2)), a2.material.uniforms.envMap.value = f2, a2.material.uniforms.flipEnvMap.value = f2.isCubeTexture && f2._needsFlipEnvMap ? -1 : 1, u2 === f2 && h2 === f2.version && c2 === t3.toneMapping || (a2.material.needsUpdate = true, u2 = f2, h2 = f2.version, c2 = t3.toneMapping), n3.unshift(a2, a2.geometry, a2.material, 0, 0, null)) : f2 && f2.isTexture && (s3 === void 0 && (s3 = new Eo(new Xo(2, 2), new Io({ name: "BackgroundMaterial", uniforms: Ro(Zo.background.uniforms), vertexShader: Zo.background.vertexShader, fragmentShader: Zo.background.fragmentShader, side: x, depthTest: false, depthWrite: false, fog: false })), s3.geometry.deleteAttribute("normal"), Object.defineProperty(s3.material, "map", { get: function() {
        return this.uniforms.t2D.value;
      } }), i2.update(s3)), s3.material.uniforms.t2D.value = f2, f2.matrixAutoUpdate === true && f2.updateMatrix(), s3.material.uniforms.uvTransform.value.copy(f2.matrix), u2 === f2 && h2 === f2.version && c2 === t3.toneMapping || (s3.material.needsUpdate = true, u2 = f2, h2 = f2.version, c2 = t3.toneMapping), n3.unshift(s3, s3.geometry, s3.material, 0, 0, null));
    } };
  }
  function $o(t3, e3, n2, i2) {
    const r3 = t3.getParameter(34921), o3 = i2.isWebGL2 ? null : e3.get("OES_vertex_array_object"), s3 = i2.isWebGL2 || o3 !== null, a2 = {}, l2 = d2(null);
    let u2 = l2;
    function h2(e4) {
      return i2.isWebGL2 ? t3.bindVertexArray(e4) : o3.bindVertexArrayOES(e4);
    }
    function c2(e4) {
      return i2.isWebGL2 ? t3.deleteVertexArray(e4) : o3.deleteVertexArrayOES(e4);
    }
    function d2(t4) {
      const e4 = [], n3 = [], i3 = [];
      for (let t5 = 0; t5 < r3; t5++)
        e4[t5] = 0, n3[t5] = 0, i3[t5] = 0;
      return { geometry: null, program: null, wireframe: false, newAttributes: e4, enabledAttributes: n3, attributeDivisors: i3, object: t4, attributes: {}, index: null };
    }
    function p2() {
      const t4 = u2.newAttributes;
      for (let e4 = 0, n3 = t4.length; e4 < n3; e4++)
        t4[e4] = 0;
    }
    function f2(t4) {
      m2(t4, 0);
    }
    function m2(n3, r4) {
      const o4 = u2.newAttributes, s4 = u2.enabledAttributes, a3 = u2.attributeDivisors;
      if (o4[n3] = 1, s4[n3] === 0 && (t3.enableVertexAttribArray(n3), s4[n3] = 1), a3[n3] !== r4) {
        (i2.isWebGL2 ? t3 : e3.get("ANGLE_instanced_arrays"))[i2.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n3, r4), a3[n3] = r4;
      }
    }
    function g2() {
      const e4 = u2.newAttributes, n3 = u2.enabledAttributes;
      for (let i3 = 0, r4 = n3.length; i3 < r4; i3++)
        n3[i3] !== e4[i3] && (t3.disableVertexAttribArray(i3), n3[i3] = 0);
    }
    function v2(e4, n3, r4, o4, s4, a3) {
      i2.isWebGL2 !== true || r4 !== 5124 && r4 !== 5125 ? t3.vertexAttribPointer(e4, n3, r4, o4, s4, a3) : t3.vertexAttribIPointer(e4, n3, r4, s4, a3);
    }
    function _2() {
      y2(), u2 !== l2 && (u2 = l2, h2(u2.object));
    }
    function y2() {
      l2.geometry = null, l2.program = null, l2.wireframe = false;
    }
    return { setup: function(r4, l3, c3, _3, y3) {
      let x2 = false;
      if (s3) {
        const e4 = function(e5, n3, r5) {
          const s4 = r5.wireframe === true;
          let l4 = a2[e5.id];
          l4 === void 0 && (l4 = {}, a2[e5.id] = l4);
          let u3 = l4[n3.id];
          u3 === void 0 && (u3 = {}, l4[n3.id] = u3);
          let h3 = u3[s4];
          h3 === void 0 && (h3 = d2(i2.isWebGL2 ? t3.createVertexArray() : o3.createVertexArrayOES()), u3[s4] = h3);
          return h3;
        }(_3, c3, l3);
        u2 !== e4 && (u2 = e4, h2(u2.object)), x2 = function(t4, e5) {
          const n3 = u2.attributes, i3 = t4.attributes;
          let r5 = 0;
          for (const t5 in i3) {
            const e6 = n3[t5], o4 = i3[t5];
            if (e6 === void 0)
              return true;
            if (e6.attribute !== o4)
              return true;
            if (e6.data !== o4.data)
              return true;
            r5++;
          }
          return u2.attributesNum !== r5 || u2.index !== e5;
        }(_3, y3), x2 && function(t4, e5) {
          const n3 = {}, i3 = t4.attributes;
          let r5 = 0;
          for (const t5 in i3) {
            const e6 = i3[t5], o4 = {};
            o4.attribute = e6, e6.data && (o4.data = e6.data), n3[t5] = o4, r5++;
          }
          u2.attributes = n3, u2.attributesNum = r5, u2.index = e5;
        }(_3, y3);
      } else {
        const t4 = l3.wireframe === true;
        u2.geometry === _3.id && u2.program === c3.id && u2.wireframe === t4 || (u2.geometry = _3.id, u2.program = c3.id, u2.wireframe = t4, x2 = true);
      }
      r4.isInstancedMesh === true && (x2 = true), y3 !== null && n2.update(y3, 34963), x2 && (!function(r5, o4, s4, a3) {
        if (i2.isWebGL2 === false && (r5.isInstancedMesh || a3.isInstancedBufferGeometry) && e3.get("ANGLE_instanced_arrays") === null)
          return;
        p2();
        const l4 = a3.attributes, u3 = s4.getAttributes(), h3 = o4.defaultAttributeValues;
        for (const e4 in u3) {
          const i3 = u3[e4];
          if (i3 >= 0) {
            const o5 = l4[e4];
            if (o5 !== void 0) {
              const e5 = o5.normalized, r6 = o5.itemSize, s5 = n2.get(o5);
              if (s5 === void 0)
                continue;
              const l5 = s5.buffer, u4 = s5.type, h4 = s5.bytesPerElement;
              if (o5.isInterleavedBufferAttribute) {
                const n3 = o5.data, s6 = n3.stride, c4 = o5.offset;
                n3 && n3.isInstancedInterleavedBuffer ? (m2(i3, n3.meshPerAttribute), a3._maxInstanceCount === void 0 && (a3._maxInstanceCount = n3.meshPerAttribute * n3.count)) : f2(i3), t3.bindBuffer(34962, l5), v2(i3, r6, u4, e5, s6 * h4, c4 * h4);
              } else
                o5.isInstancedBufferAttribute ? (m2(i3, o5.meshPerAttribute), a3._maxInstanceCount === void 0 && (a3._maxInstanceCount = o5.meshPerAttribute * o5.count)) : f2(i3), t3.bindBuffer(34962, l5), v2(i3, r6, u4, e5, 0, 0);
            } else if (e4 === "instanceMatrix") {
              const e5 = n2.get(r5.instanceMatrix);
              if (e5 === void 0)
                continue;
              const o6 = e5.buffer, s5 = e5.type;
              m2(i3 + 0, 1), m2(i3 + 1, 1), m2(i3 + 2, 1), m2(i3 + 3, 1), t3.bindBuffer(34962, o6), t3.vertexAttribPointer(i3 + 0, 4, s5, false, 64, 0), t3.vertexAttribPointer(i3 + 1, 4, s5, false, 64, 16), t3.vertexAttribPointer(i3 + 2, 4, s5, false, 64, 32), t3.vertexAttribPointer(i3 + 3, 4, s5, false, 64, 48);
            } else if (e4 === "instanceColor") {
              const e5 = n2.get(r5.instanceColor);
              if (e5 === void 0)
                continue;
              const o6 = e5.buffer, s5 = e5.type;
              m2(i3, 1), t3.bindBuffer(34962, o6), t3.vertexAttribPointer(i3, 3, s5, false, 12, 0);
            } else if (h3 !== void 0) {
              const n3 = h3[e4];
              if (n3 !== void 0)
                switch (n3.length) {
                  case 2:
                    t3.vertexAttrib2fv(i3, n3);
                    break;
                  case 3:
                    t3.vertexAttrib3fv(i3, n3);
                    break;
                  case 4:
                    t3.vertexAttrib4fv(i3, n3);
                    break;
                  default:
                    t3.vertexAttrib1fv(i3, n3);
                }
            }
          }
        }
        g2();
      }(r4, l3, c3, _3), y3 !== null && t3.bindBuffer(34963, n2.get(y3).buffer));
    }, reset: _2, resetDefaultState: y2, dispose: function() {
      _2();
      for (const t4 in a2) {
        const e4 = a2[t4];
        for (const t5 in e4) {
          const n3 = e4[t5];
          for (const t6 in n3)
            c2(n3[t6].object), delete n3[t6];
          delete e4[t5];
        }
        delete a2[t4];
      }
    }, releaseStatesOfGeometry: function(t4) {
      if (a2[t4.id] === void 0)
        return;
      const e4 = a2[t4.id];
      for (const t5 in e4) {
        const n3 = e4[t5];
        for (const t6 in n3)
          c2(n3[t6].object), delete n3[t6];
        delete e4[t5];
      }
      delete a2[t4.id];
    }, releaseStatesOfProgram: function(t4) {
      for (const e4 in a2) {
        const n3 = a2[e4];
        if (n3[t4.id] === void 0)
          continue;
        const i3 = n3[t4.id];
        for (const t5 in i3)
          c2(i3[t5].object), delete i3[t5];
        delete n3[t4.id];
      }
    }, initAttributes: p2, enableAttribute: f2, disableUnusedAttributes: g2 };
  }
  function Ko(t3, e3, n2, i2) {
    const r3 = i2.isWebGL2;
    let o3;
    this.setMode = function(t4) {
      o3 = t4;
    }, this.render = function(e4, i3) {
      t3.drawArrays(o3, e4, i3), n2.update(i3, o3, 1);
    }, this.renderInstances = function(i3, s3, a2) {
      if (a2 === 0)
        return;
      let l2, u2;
      if (r3)
        l2 = t3, u2 = "drawArraysInstanced";
      else if (l2 = e3.get("ANGLE_instanced_arrays"), u2 = "drawArraysInstancedANGLE", l2 === null)
        return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      l2[u2](o3, i3, s3, a2), n2.update(s3, o3, a2);
    };
  }
  function Qo(t3, e3, n2) {
    let i2;
    function r3(e4) {
      if (e4 === "highp") {
        if (t3.getShaderPrecisionFormat(35633, 36338).precision > 0 && t3.getShaderPrecisionFormat(35632, 36338).precision > 0)
          return "highp";
        e4 = "mediump";
      }
      return e4 === "mediump" && t3.getShaderPrecisionFormat(35633, 36337).precision > 0 && t3.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp";
    }
    const o3 = typeof WebGL2RenderingContext != "undefined" && t3 instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext != "undefined" && t3 instanceof WebGL2ComputeRenderingContext;
    let s3 = n2.precision !== void 0 ? n2.precision : "highp";
    const a2 = r3(s3);
    a2 !== s3 && (console.warn("THREE.WebGLRenderer:", s3, "not supported, using", a2, "instead."), s3 = a2);
    const l2 = o3 || e3.has("WEBGL_draw_buffers"), u2 = n2.logarithmicDepthBuffer === true, h2 = t3.getParameter(34930), c2 = t3.getParameter(35660), d2 = t3.getParameter(3379), p2 = t3.getParameter(34076), f2 = t3.getParameter(34921), m2 = t3.getParameter(36347), g2 = t3.getParameter(36348), v2 = t3.getParameter(36349), _2 = c2 > 0, y2 = o3 || e3.has("OES_texture_float");
    return { isWebGL2: o3, drawBuffers: l2, getMaxAnisotropy: function() {
      if (i2 !== void 0)
        return i2;
      if (e3.has("EXT_texture_filter_anisotropic") === true) {
        const n3 = e3.get("EXT_texture_filter_anisotropic");
        i2 = t3.getParameter(n3.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
      } else
        i2 = 0;
      return i2;
    }, getMaxPrecision: r3, precision: s3, logarithmicDepthBuffer: u2, maxTextures: h2, maxVertexTextures: c2, maxTextureSize: d2, maxCubemapSize: p2, maxAttributes: f2, maxVertexUniforms: m2, maxVaryings: g2, maxFragmentUniforms: v2, vertexTextures: _2, floatFragmentTextures: y2, floatVertexTextures: _2 && y2, maxSamples: o3 ? t3.getParameter(36183) : 0 };
  }
  function ts(t3) {
    const e3 = this;
    let n2 = null, i2 = 0, r3 = false, o3 = false;
    const s3 = new Go(), a2 = new ni(), l2 = { value: null, needsUpdate: false };
    function u2() {
      l2.value !== n2 && (l2.value = n2, l2.needsUpdate = i2 > 0), e3.numPlanes = i2, e3.numIntersection = 0;
    }
    function h2(t4, n3, i3, r4) {
      const o4 = t4 !== null ? t4.length : 0;
      let u3 = null;
      if (o4 !== 0) {
        if (u3 = l2.value, r4 !== true || u3 === null) {
          const e4 = i3 + 4 * o4, r5 = n3.matrixWorldInverse;
          a2.getNormalMatrix(r5), (u3 === null || u3.length < e4) && (u3 = new Float32Array(e4));
          for (let e5 = 0, n4 = i3; e5 !== o4; ++e5, n4 += 4)
            s3.copy(t4[e5]).applyMatrix4(r5, a2), s3.normal.toArray(u3, n4), u3[n4 + 3] = s3.constant;
        }
        l2.value = u3, l2.needsUpdate = true;
      }
      return e3.numPlanes = o4, e3.numIntersection = 0, u3;
    }
    this.uniform = l2, this.numPlanes = 0, this.numIntersection = 0, this.init = function(t4, e4, o4) {
      const s4 = t4.length !== 0 || e4 || i2 !== 0 || r3;
      return r3 = e4, n2 = h2(t4, o4, 0), i2 = t4.length, s4;
    }, this.beginShadows = function() {
      o3 = true, h2(null);
    }, this.endShadows = function() {
      o3 = false, u2();
    }, this.setState = function(e4, s4, a3) {
      const c2 = e4.clippingPlanes, d2 = e4.clipIntersection, p2 = e4.clipShadows, f2 = t3.get(e4);
      if (!r3 || c2 === null || c2.length === 0 || o3 && !p2)
        o3 ? h2(null) : u2();
      else {
        const t4 = o3 ? 0 : i2, e5 = 4 * t4;
        let r4 = f2.clippingState || null;
        l2.value = r4, r4 = h2(c2, s4, e5, a3);
        for (let t5 = 0; t5 !== e5; ++t5)
          r4[t5] = n2[t5];
        f2.clippingState = r4, this.numIntersection = d2 ? this.numPlanes : 0, this.numPlanes += t4;
      }
    };
  }
  function es(t3) {
    let e3 = new WeakMap();
    function n2(t4, e4) {
      return e4 === pt ? t4.mapping = ct : e4 === ft && (t4.mapping = dt), t4;
    }
    function i2(t4) {
      const n3 = t4.target;
      n3.removeEventListener("dispose", i2);
      const r3 = e3.get(n3);
      r3 !== void 0 && (e3.delete(n3), r3.dispose());
    }
    return { get: function(r3) {
      if (r3 && r3.isTexture) {
        const o3 = r3.mapping;
        if (o3 === pt || o3 === ft) {
          if (e3.has(r3)) {
            return n2(e3.get(r3).texture, r3.mapping);
          }
          {
            const o4 = r3.image;
            if (o4 && o4.height > 0) {
              const s3 = t3.getRenderTarget(), a2 = new Fo(o4.height / 2);
              return a2.fromEquirectangularTexture(t3, r3), e3.set(r3, a2), t3.setRenderTarget(s3), r3.addEventListener("dispose", i2), n2(a2.texture, r3.mapping);
            }
            return null;
          }
        }
      }
      return r3;
    }, dispose: function() {
      e3 = new WeakMap();
    } };
  }
  function ns(t3) {
    const e3 = {};
    function n2(n3) {
      if (e3[n3] !== void 0)
        return e3[n3];
      let i2;
      switch (n3) {
        case "WEBGL_depth_texture":
          i2 = t3.getExtension("WEBGL_depth_texture") || t3.getExtension("MOZ_WEBGL_depth_texture") || t3.getExtension("WEBKIT_WEBGL_depth_texture");
          break;
        case "EXT_texture_filter_anisotropic":
          i2 = t3.getExtension("EXT_texture_filter_anisotropic") || t3.getExtension("MOZ_EXT_texture_filter_anisotropic") || t3.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
          break;
        case "WEBGL_compressed_texture_s3tc":
          i2 = t3.getExtension("WEBGL_compressed_texture_s3tc") || t3.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t3.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
          break;
        case "WEBGL_compressed_texture_pvrtc":
          i2 = t3.getExtension("WEBGL_compressed_texture_pvrtc") || t3.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
          break;
        default:
          i2 = t3.getExtension(n3);
      }
      return e3[n3] = i2, i2;
    }
    return { has: function(t4) {
      return n2(t4) !== null;
    }, init: function(t4) {
      t4.isWebGL2 ? n2("EXT_color_buffer_float") : (n2("WEBGL_depth_texture"), n2("OES_texture_float"), n2("OES_texture_half_float"), n2("OES_texture_half_float_linear"), n2("OES_standard_derivatives"), n2("OES_element_index_uint"), n2("OES_vertex_array_object"), n2("ANGLE_instanced_arrays")), n2("OES_texture_float_linear"), n2("EXT_color_buffer_half_float");
    }, get: function(t4) {
      const e4 = n2(t4);
      return e4 === null && console.warn("THREE.WebGLRenderer: " + t4 + " extension not supported."), e4;
    } };
  }
  function is(t3, e3, n2, i2) {
    const r3 = {}, o3 = new WeakMap();
    function s3(t4) {
      const a3 = t4.target;
      a3.index !== null && e3.remove(a3.index);
      for (const t5 in a3.attributes)
        e3.remove(a3.attributes[t5]);
      a3.removeEventListener("dispose", s3), delete r3[a3.id];
      const l2 = o3.get(a3);
      l2 && (e3.remove(l2), o3.delete(a3)), i2.releaseStatesOfGeometry(a3), a3.isInstancedBufferGeometry === true && delete a3._maxInstanceCount, n2.memory.geometries--;
    }
    function a2(t4) {
      const n3 = [], i3 = t4.index, r4 = t4.attributes.position;
      let s4 = 0;
      if (i3 !== null) {
        const t5 = i3.array;
        s4 = i3.version;
        for (let e4 = 0, i4 = t5.length; e4 < i4; e4 += 3) {
          const i5 = t5[e4 + 0], r5 = t5[e4 + 1], o4 = t5[e4 + 2];
          n3.push(i5, r5, r5, o4, o4, i5);
        }
      } else {
        const t5 = r4.array;
        s4 = r4.version;
        for (let e4 = 0, i4 = t5.length / 3 - 1; e4 < i4; e4 += 3) {
          const t6 = e4 + 0, i5 = e4 + 1, r5 = e4 + 2;
          n3.push(t6, i5, i5, r5, r5, t6);
        }
      }
      const a3 = new (Jr(n3) > 65535 ? Xr : Vr)(n3, 1);
      a3.version = s4;
      const l2 = o3.get(t4);
      l2 && e3.remove(l2), o3.set(t4, a3);
    }
    return { get: function(t4, e4) {
      return r3[e4.id] === true || (e4.addEventListener("dispose", s3), r3[e4.id] = true, n2.memory.geometries++), e4;
    }, update: function(t4) {
      const n3 = t4.attributes;
      for (const t5 in n3)
        e3.update(n3[t5], 34962);
      const i3 = t4.morphAttributes;
      for (const t5 in i3) {
        const n4 = i3[t5];
        for (let t6 = 0, i4 = n4.length; t6 < i4; t6++)
          e3.update(n4[t6], 34962);
      }
    }, getWireframeAttribute: function(t4) {
      const e4 = o3.get(t4);
      if (e4) {
        const n3 = t4.index;
        n3 !== null && e4.version < n3.version && a2(t4);
      } else
        a2(t4);
      return o3.get(t4);
    } };
  }
  function rs(t3, e3, n2, i2) {
    const r3 = i2.isWebGL2;
    let o3, s3, a2;
    this.setMode = function(t4) {
      o3 = t4;
    }, this.setIndex = function(t4) {
      s3 = t4.type, a2 = t4.bytesPerElement;
    }, this.render = function(e4, i3) {
      t3.drawElements(o3, i3, s3, e4 * a2), n2.update(i3, o3, 1);
    }, this.renderInstances = function(i3, l2, u2) {
      if (u2 === 0)
        return;
      let h2, c2;
      if (r3)
        h2 = t3, c2 = "drawElementsInstanced";
      else if (h2 = e3.get("ANGLE_instanced_arrays"), c2 = "drawElementsInstancedANGLE", h2 === null)
        return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      h2[c2](o3, l2, s3, i3 * a2, u2), n2.update(l2, o3, u2);
    };
  }
  function os(t3) {
    const e3 = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
    return { memory: { geometries: 0, textures: 0 }, render: e3, programs: null, autoReset: true, reset: function() {
      e3.frame++, e3.calls = 0, e3.triangles = 0, e3.points = 0, e3.lines = 0;
    }, update: function(t4, n2, i2) {
      switch (e3.calls++, n2) {
        case 4:
          e3.triangles += i2 * (t4 / 3);
          break;
        case 1:
          e3.lines += i2 * (t4 / 2);
          break;
        case 3:
          e3.lines += i2 * (t4 - 1);
          break;
        case 2:
          e3.lines += i2 * t4;
          break;
        case 0:
          e3.points += i2 * t4;
          break;
        default:
          console.error("THREE.WebGLInfo: Unknown draw mode:", n2);
      }
    } };
  }
  function ss(t3, e3) {
    return t3[0] - e3[0];
  }
  function as(t3, e3) {
    return Math.abs(e3[1]) - Math.abs(t3[1]);
  }
  function ls(t3) {
    const e3 = {}, n2 = new Float32Array(8), i2 = [];
    for (let t4 = 0; t4 < 8; t4++)
      i2[t4] = [t4, 0];
    return { update: function(r3, o3, s3, a2) {
      const l2 = r3.morphTargetInfluences, u2 = l2 === void 0 ? 0 : l2.length;
      let h2 = e3[o3.id];
      if (h2 === void 0 || h2.length !== u2) {
        h2 = [];
        for (let t4 = 0; t4 < u2; t4++)
          h2[t4] = [t4, 0];
        e3[o3.id] = h2;
      }
      for (let t4 = 0; t4 < u2; t4++) {
        const e4 = h2[t4];
        e4[0] = t4, e4[1] = l2[t4];
      }
      h2.sort(as);
      for (let t4 = 0; t4 < 8; t4++)
        t4 < u2 && h2[t4][1] ? (i2[t4][0] = h2[t4][0], i2[t4][1] = h2[t4][1]) : (i2[t4][0] = Number.MAX_SAFE_INTEGER, i2[t4][1] = 0);
      i2.sort(ss);
      const c2 = s3.morphTargets && o3.morphAttributes.position, d2 = s3.morphNormals && o3.morphAttributes.normal;
      let p2 = 0;
      for (let t4 = 0; t4 < 8; t4++) {
        const e4 = i2[t4], r4 = e4[0], s4 = e4[1];
        r4 !== Number.MAX_SAFE_INTEGER && s4 ? (c2 && o3.getAttribute("morphTarget" + t4) !== c2[r4] && o3.setAttribute("morphTarget" + t4, c2[r4]), d2 && o3.getAttribute("morphNormal" + t4) !== d2[r4] && o3.setAttribute("morphNormal" + t4, d2[r4]), n2[t4] = s4, p2 += s4) : (c2 && o3.hasAttribute("morphTarget" + t4) === true && o3.deleteAttribute("morphTarget" + t4), d2 && o3.hasAttribute("morphNormal" + t4) === true && o3.deleteAttribute("morphNormal" + t4), n2[t4] = 0);
      }
      const f2 = o3.morphTargetsRelative ? 1 : 1 - p2;
      a2.getUniforms().setValue(t3, "morphTargetBaseInfluence", f2), a2.getUniforms().setValue(t3, "morphTargetInfluences", n2);
    } };
  }
  function us(t3, e3, n2, i2) {
    let r3 = new WeakMap();
    function o3(t4) {
      const e4 = t4.target;
      e4.removeEventListener("dispose", o3), n2.remove(e4.instanceMatrix), e4.instanceColor !== null && n2.remove(e4.instanceColor);
    }
    return { update: function(t4) {
      const s3 = i2.render.frame, a2 = t4.geometry, l2 = e3.get(t4, a2);
      return r3.get(l2) !== s3 && (e3.update(l2), r3.set(l2, s3)), t4.isInstancedMesh && (t4.hasEventListener("dispose", o3) === false && t4.addEventListener("dispose", o3), n2.update(t4.instanceMatrix, 34962), t4.instanceColor !== null && n2.update(t4.instanceColor, 34962)), l2;
    }, dispose: function() {
      r3 = new WeakMap();
    } };
  }
  Zo.physical = { uniforms: Po([Zo.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatNormalScale: { value: new ei(1, 1) }, clearcoatNormalMap: { value: null }, sheen: { value: new Dr(0) }, transmission: { value: 0 }, transmissionMap: { value: null }, transmissionSamplerSize: { value: new ei() }, transmissionSamplerMap: { value: null }, thickness: { value: 0 }, thicknessMap: { value: null }, attenuationDistance: { value: 0 }, attenuationColor: { value: new Dr(0) } }]), vertexShader: qo.meshphysical_vert, fragmentShader: qo.meshphysical_frag };
  class hs extends si {
    constructor(t3 = null, e3 = 1, n2 = 1, i2 = 1) {
      super(null), this.image = { data: t3, width: e3, height: n2, depth: i2 }, this.magFilter = xt, this.minFilter = xt, this.wrapR = _t, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1, this.needsUpdate = true;
    }
  }
  hs.prototype.isDataTexture2DArray = true;
  class cs2 extends si {
    constructor(t3 = null, e3 = 1, n2 = 1, i2 = 1) {
      super(null), this.image = { data: t3, width: e3, height: n2, depth: i2 }, this.magFilter = xt, this.minFilter = xt, this.wrapR = _t, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1, this.needsUpdate = true;
    }
  }
  cs2.prototype.isDataTexture3D = true;
  const ds = new si(), ps = new hs(), fs = new cs2(), ms = new Do(), gs = [], vs = [], _s = new Float32Array(16), ys = new Float32Array(9), xs = new Float32Array(4);
  function bs(t3, e3, n2) {
    const i2 = t3[0];
    if (i2 <= 0 || i2 > 0)
      return t3;
    const r3 = e3 * n2;
    let o3 = gs[r3];
    if (o3 === void 0 && (o3 = new Float32Array(r3), gs[r3] = o3), e3 !== 0) {
      i2.toArray(o3, 0);
      for (let i3 = 1, r4 = 0; i3 !== e3; ++i3)
        r4 += n2, t3[i3].toArray(o3, r4);
    }
    return o3;
  }
  function Ts(t3, e3) {
    if (t3.length !== e3.length)
      return false;
    for (let n2 = 0, i2 = t3.length; n2 < i2; n2++)
      if (t3[n2] !== e3[n2])
        return false;
    return true;
  }
  function ws(t3, e3) {
    for (let n2 = 0, i2 = e3.length; n2 < i2; n2++)
      t3[n2] = e3[n2];
  }
  function Ss(t3, e3) {
    let n2 = vs[e3];
    n2 === void 0 && (n2 = new Int32Array(e3), vs[e3] = n2);
    for (let i2 = 0; i2 !== e3; ++i2)
      n2[i2] = t3.allocateTextureUnit();
    return n2;
  }
  function Es(t3, e3) {
    const n2 = this.cache;
    n2[0] !== e3 && (t3.uniform1f(this.addr, e3), n2[0] = e3);
  }
  function Ms(t3, e3) {
    const n2 = this.cache;
    if (e3.x !== void 0)
      n2[0] === e3.x && n2[1] === e3.y || (t3.uniform2f(this.addr, e3.x, e3.y), n2[0] = e3.x, n2[1] = e3.y);
    else {
      if (Ts(n2, e3))
        return;
      t3.uniform2fv(this.addr, e3), ws(n2, e3);
    }
  }
  function As(t3, e3) {
    const n2 = this.cache;
    if (e3.x !== void 0)
      n2[0] === e3.x && n2[1] === e3.y && n2[2] === e3.z || (t3.uniform3f(this.addr, e3.x, e3.y, e3.z), n2[0] = e3.x, n2[1] = e3.y, n2[2] = e3.z);
    else if (e3.r !== void 0)
      n2[0] === e3.r && n2[1] === e3.g && n2[2] === e3.b || (t3.uniform3f(this.addr, e3.r, e3.g, e3.b), n2[0] = e3.r, n2[1] = e3.g, n2[2] = e3.b);
    else {
      if (Ts(n2, e3))
        return;
      t3.uniform3fv(this.addr, e3), ws(n2, e3);
    }
  }
  function Rs(t3, e3) {
    const n2 = this.cache;
    if (e3.x !== void 0)
      n2[0] === e3.x && n2[1] === e3.y && n2[2] === e3.z && n2[3] === e3.w || (t3.uniform4f(this.addr, e3.x, e3.y, e3.z, e3.w), n2[0] = e3.x, n2[1] = e3.y, n2[2] = e3.z, n2[3] = e3.w);
    else {
      if (Ts(n2, e3))
        return;
      t3.uniform4fv(this.addr, e3), ws(n2, e3);
    }
  }
  function Ps(t3, e3) {
    const n2 = this.cache, i2 = e3.elements;
    if (i2 === void 0) {
      if (Ts(n2, e3))
        return;
      t3.uniformMatrix2fv(this.addr, false, e3), ws(n2, e3);
    } else {
      if (Ts(n2, i2))
        return;
      xs.set(i2), t3.uniformMatrix2fv(this.addr, false, xs), ws(n2, i2);
    }
  }
  function Cs(t3, e3) {
    const n2 = this.cache, i2 = e3.elements;
    if (i2 === void 0) {
      if (Ts(n2, e3))
        return;
      t3.uniformMatrix3fv(this.addr, false, e3), ws(n2, e3);
    } else {
      if (Ts(n2, i2))
        return;
      ys.set(i2), t3.uniformMatrix3fv(this.addr, false, ys), ws(n2, i2);
    }
  }
  function Is(t3, e3) {
    const n2 = this.cache, i2 = e3.elements;
    if (i2 === void 0) {
      if (Ts(n2, e3))
        return;
      t3.uniformMatrix4fv(this.addr, false, e3), ws(n2, e3);
    } else {
      if (Ts(n2, i2))
        return;
      _s.set(i2), t3.uniformMatrix4fv(this.addr, false, _s), ws(n2, i2);
    }
  }
  function Os(t3, e3) {
    const n2 = this.cache;
    n2[0] !== e3 && (t3.uniform1i(this.addr, e3), n2[0] = e3);
  }
  function Ls(t3, e3) {
    const n2 = this.cache;
    Ts(n2, e3) || (t3.uniform2iv(this.addr, e3), ws(n2, e3));
  }
  function Ns(t3, e3) {
    const n2 = this.cache;
    Ts(n2, e3) || (t3.uniform3iv(this.addr, e3), ws(n2, e3));
  }
  function Ds(t3, e3) {
    const n2 = this.cache;
    Ts(n2, e3) || (t3.uniform4iv(this.addr, e3), ws(n2, e3));
  }
  function Fs(t3, e3) {
    const n2 = this.cache;
    n2[0] !== e3 && (t3.uniform1ui(this.addr, e3), n2[0] = e3);
  }
  function Bs(t3, e3) {
    const n2 = this.cache;
    Ts(n2, e3) || (t3.uniform2uiv(this.addr, e3), ws(n2, e3));
  }
  function Us(t3, e3) {
    const n2 = this.cache;
    Ts(n2, e3) || (t3.uniform3uiv(this.addr, e3), ws(n2, e3));
  }
  function ks(t3, e3) {
    const n2 = this.cache;
    Ts(n2, e3) || (t3.uniform4uiv(this.addr, e3), ws(n2, e3));
  }
  function Gs(t3, e3, n2) {
    const i2 = this.cache, r3 = n2.allocateTextureUnit();
    i2[0] !== r3 && (t3.uniform1i(this.addr, r3), i2[0] = r3), n2.safeSetTexture2D(e3 || ds, r3);
  }
  function Hs(t3, e3, n2) {
    const i2 = this.cache, r3 = n2.allocateTextureUnit();
    i2[0] !== r3 && (t3.uniform1i(this.addr, r3), i2[0] = r3), n2.setTexture3D(e3 || fs, r3);
  }
  function zs(t3, e3, n2) {
    const i2 = this.cache, r3 = n2.allocateTextureUnit();
    i2[0] !== r3 && (t3.uniform1i(this.addr, r3), i2[0] = r3), n2.safeSetTextureCube(e3 || ms, r3);
  }
  function js(t3, e3, n2) {
    const i2 = this.cache, r3 = n2.allocateTextureUnit();
    i2[0] !== r3 && (t3.uniform1i(this.addr, r3), i2[0] = r3), n2.setTexture2DArray(e3 || ps, r3);
  }
  function Vs(t3, e3) {
    t3.uniform1fv(this.addr, e3);
  }
  function Ws(t3, e3) {
    const n2 = bs(e3, this.size, 2);
    t3.uniform2fv(this.addr, n2);
  }
  function Xs(t3, e3) {
    const n2 = bs(e3, this.size, 3);
    t3.uniform3fv(this.addr, n2);
  }
  function qs(t3, e3) {
    const n2 = bs(e3, this.size, 4);
    t3.uniform4fv(this.addr, n2);
  }
  function Ys(t3, e3) {
    const n2 = bs(e3, this.size, 4);
    t3.uniformMatrix2fv(this.addr, false, n2);
  }
  function Zs(t3, e3) {
    const n2 = bs(e3, this.size, 9);
    t3.uniformMatrix3fv(this.addr, false, n2);
  }
  function Js(t3, e3) {
    const n2 = bs(e3, this.size, 16);
    t3.uniformMatrix4fv(this.addr, false, n2);
  }
  function $s(t3, e3) {
    t3.uniform1iv(this.addr, e3);
  }
  function Ks(t3, e3) {
    t3.uniform2iv(this.addr, e3);
  }
  function Qs(t3, e3) {
    t3.uniform3iv(this.addr, e3);
  }
  function ta(t3, e3) {
    t3.uniform4iv(this.addr, e3);
  }
  function ea(t3, e3) {
    t3.uniform1uiv(this.addr, e3);
  }
  function na(t3, e3) {
    t3.uniform2uiv(this.addr, e3);
  }
  function ia(t3, e3) {
    t3.uniform3uiv(this.addr, e3);
  }
  function ra(t3, e3) {
    t3.uniform4uiv(this.addr, e3);
  }
  function oa(t3, e3, n2) {
    const i2 = e3.length, r3 = Ss(n2, i2);
    t3.uniform1iv(this.addr, r3);
    for (let t4 = 0; t4 !== i2; ++t4)
      n2.safeSetTexture2D(e3[t4] || ds, r3[t4]);
  }
  function sa(t3, e3, n2) {
    const i2 = e3.length, r3 = Ss(n2, i2);
    t3.uniform1iv(this.addr, r3);
    for (let t4 = 0; t4 !== i2; ++t4)
      n2.safeSetTextureCube(e3[t4] || ms, r3[t4]);
  }
  function aa(t3, e3, n2) {
    this.id = t3, this.addr = n2, this.cache = [], this.setValue = function(t4) {
      switch (t4) {
        case 5126:
          return Es;
        case 35664:
          return Ms;
        case 35665:
          return As;
        case 35666:
          return Rs;
        case 35674:
          return Ps;
        case 35675:
          return Cs;
        case 35676:
          return Is;
        case 5124:
        case 35670:
          return Os;
        case 35667:
        case 35671:
          return Ls;
        case 35668:
        case 35672:
          return Ns;
        case 35669:
        case 35673:
          return Ds;
        case 5125:
          return Fs;
        case 36294:
          return Bs;
        case 36295:
          return Us;
        case 36296:
          return ks;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
          return Gs;
        case 35679:
        case 36299:
        case 36307:
          return Hs;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
          return zs;
        case 36289:
        case 36303:
        case 36311:
        case 36292:
          return js;
      }
    }(e3.type);
  }
  function la(t3, e3, n2) {
    this.id = t3, this.addr = n2, this.cache = [], this.size = e3.size, this.setValue = function(t4) {
      switch (t4) {
        case 5126:
          return Vs;
        case 35664:
          return Ws;
        case 35665:
          return Xs;
        case 35666:
          return qs;
        case 35674:
          return Ys;
        case 35675:
          return Zs;
        case 35676:
          return Js;
        case 5124:
        case 35670:
          return $s;
        case 35667:
        case 35671:
          return Ks;
        case 35668:
        case 35672:
          return Qs;
        case 35669:
        case 35673:
          return ta;
        case 5125:
          return ea;
        case 36294:
          return na;
        case 36295:
          return ia;
        case 36296:
          return ra;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
          return oa;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
          return sa;
      }
    }(e3.type);
  }
  function ua(t3) {
    this.id = t3, this.seq = [], this.map = {};
  }
  la.prototype.updateCache = function(t3) {
    const e3 = this.cache;
    t3 instanceof Float32Array && e3.length !== t3.length && (this.cache = new Float32Array(t3.length)), ws(e3, t3);
  }, ua.prototype.setValue = function(t3, e3, n2) {
    const i2 = this.seq;
    for (let r3 = 0, o3 = i2.length; r3 !== o3; ++r3) {
      const o4 = i2[r3];
      o4.setValue(t3, e3[o4.id], n2);
    }
  };
  const ha = /(\w+)(\])?(\[|\.)?/g;
  function ca(t3, e3) {
    t3.seq.push(e3), t3.map[e3.id] = e3;
  }
  function da(t3, e3, n2) {
    const i2 = t3.name, r3 = i2.length;
    for (ha.lastIndex = 0; ; ) {
      const o3 = ha.exec(i2), s3 = ha.lastIndex;
      let a2 = o3[1];
      const l2 = o3[2] === "]", u2 = o3[3];
      if (l2 && (a2 |= 0), u2 === void 0 || u2 === "[" && s3 + 2 === r3) {
        ca(n2, u2 === void 0 ? new aa(a2, t3, e3) : new la(a2, t3, e3));
        break;
      }
      {
        let t4 = n2.map[a2];
        t4 === void 0 && (t4 = new ua(a2), ca(n2, t4)), n2 = t4;
      }
    }
  }
  function pa(t3, e3) {
    this.seq = [], this.map = {};
    const n2 = t3.getProgramParameter(e3, 35718);
    for (let i2 = 0; i2 < n2; ++i2) {
      const n3 = t3.getActiveUniform(e3, i2);
      da(n3, t3.getUniformLocation(e3, n3.name), this);
    }
  }
  function fa(t3, e3, n2) {
    const i2 = t3.createShader(e3);
    return t3.shaderSource(i2, n2), t3.compileShader(i2), i2;
  }
  pa.prototype.setValue = function(t3, e3, n2, i2) {
    const r3 = this.map[e3];
    r3 !== void 0 && r3.setValue(t3, n2, i2);
  }, pa.prototype.setOptional = function(t3, e3, n2) {
    const i2 = e3[n2];
    i2 !== void 0 && this.setValue(t3, n2, i2);
  }, pa.upload = function(t3, e3, n2, i2) {
    for (let r3 = 0, o3 = e3.length; r3 !== o3; ++r3) {
      const o4 = e3[r3], s3 = n2[o4.id];
      s3.needsUpdate !== false && o4.setValue(t3, s3.value, i2);
    }
  }, pa.seqWithValue = function(t3, e3) {
    const n2 = [];
    for (let i2 = 0, r3 = t3.length; i2 !== r3; ++i2) {
      const r4 = t3[i2];
      r4.id in e3 && n2.push(r4);
    }
    return n2;
  };
  let ma = 0;
  function ga(t3) {
    switch (t3) {
      case nn:
        return ["Linear", "( value )"];
      case rn:
        return ["sRGB", "( value )"];
      case sn:
        return ["RGBE", "( value )"];
      case ln:
        return ["RGBM", "( value, 7.0 )"];
      case un:
        return ["RGBM", "( value, 16.0 )"];
      case hn:
        return ["RGBD", "( value, 256.0 )"];
      case on:
        return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
      case an:
        return ["LogLuv", "( value )"];
      default:
        return console.warn("THREE.WebGLProgram: Unsupported encoding:", t3), ["Linear", "( value )"];
    }
  }
  function va(t3, e3, n2) {
    const i2 = t3.getShaderParameter(e3, 35713), r3 = t3.getShaderInfoLog(e3).trim();
    if (i2 && r3 === "")
      return "";
    return "THREE.WebGLShader: gl.getShaderInfoLog() " + n2 + "\n" + r3 + function(t4) {
      const e4 = t4.split("\n");
      for (let t5 = 0; t5 < e4.length; t5++)
        e4[t5] = t5 + 1 + ": " + e4[t5];
      return e4.join("\n");
    }(t3.getShaderSource(e3));
  }
  function _a(t3, e3) {
    const n2 = ga(e3);
    return "vec4 " + t3 + "( vec4 value ) { return " + n2[0] + "ToLinear" + n2[1] + "; }";
  }
  function ya(t3, e3) {
    const n2 = ga(e3);
    return "vec4 " + t3 + "( vec4 value ) { return LinearTo" + n2[0] + n2[1] + "; }";
  }
  function xa(t3, e3) {
    let n2;
    switch (e3) {
      case ot:
        n2 = "Linear";
        break;
      case st:
        n2 = "Reinhard";
        break;
      case at:
        n2 = "OptimizedCineon";
        break;
      case lt:
        n2 = "ACESFilmic";
        break;
      case ut:
        n2 = "Custom";
        break;
      default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e3), n2 = "Linear";
    }
    return "vec3 " + t3 + "( vec3 color ) { return " + n2 + "ToneMapping( color ); }";
  }
  function ba(t3) {
    return t3 !== "";
  }
  function Ta(t3, e3) {
    return t3.replace(/NUM_DIR_LIGHTS/g, e3.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e3.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e3.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e3.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e3.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e3.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e3.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e3.numPointLightShadows);
  }
  function wa(t3, e3) {
    return t3.replace(/NUM_CLIPPING_PLANES/g, e3.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e3.numClippingPlanes - e3.numClipIntersection);
  }
  const Sa = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function Ea(t3) {
    return t3.replace(Sa, Ma);
  }
  function Ma(t3, e3) {
    const n2 = qo[e3];
    if (n2 === void 0)
      throw new Error("Can not resolve #include <" + e3 + ">");
    return Ea(n2);
  }
  const Aa = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, Ra = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
  function Pa(t3) {
    return t3.replace(Ra, Ia).replace(Aa, Ca);
  }
  function Ca(t3, e3, n2, i2) {
    return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), Ia(t3, e3, n2, i2);
  }
  function Ia(t3, e3, n2, i2) {
    let r3 = "";
    for (let t4 = parseInt(e3); t4 < parseInt(n2); t4++)
      r3 += i2.replace(/\[\s*i\s*\]/g, "[ " + t4 + " ]").replace(/UNROLLED_LOOP_INDEX/g, t4);
    return r3;
  }
  function Oa(t3) {
    let e3 = "precision " + t3.precision + " float;\nprecision " + t3.precision + " int;";
    return t3.precision === "highp" ? e3 += "\n#define HIGH_PRECISION" : t3.precision === "mediump" ? e3 += "\n#define MEDIUM_PRECISION" : t3.precision === "lowp" && (e3 += "\n#define LOW_PRECISION"), e3;
  }
  function La(t3, e3, n2, i2) {
    const r3 = t3.getContext(), o3 = n2.defines;
    let s3 = n2.vertexShader, a2 = n2.fragmentShader;
    const l2 = function(t4) {
      let e4 = "SHADOWMAP_TYPE_BASIC";
      return t4.shadowMapType === v ? e4 = "SHADOWMAP_TYPE_PCF" : t4.shadowMapType === _ ? e4 = "SHADOWMAP_TYPE_PCF_SOFT" : t4.shadowMapType === y && (e4 = "SHADOWMAP_TYPE_VSM"), e4;
    }(n2), u2 = function(t4) {
      let e4 = "ENVMAP_TYPE_CUBE";
      if (t4.envMap)
        switch (t4.envMapMode) {
          case ct:
          case dt:
            e4 = "ENVMAP_TYPE_CUBE";
            break;
          case mt:
          case gt:
            e4 = "ENVMAP_TYPE_CUBE_UV";
        }
      return e4;
    }(n2), h2 = function(t4) {
      let e4 = "ENVMAP_MODE_REFLECTION";
      if (t4.envMap)
        switch (t4.envMapMode) {
          case dt:
          case gt:
            e4 = "ENVMAP_MODE_REFRACTION";
        }
      return e4;
    }(n2), c2 = function(t4) {
      let e4 = "ENVMAP_BLENDING_NONE";
      if (t4.envMap)
        switch (t4.combine) {
          case et:
            e4 = "ENVMAP_BLENDING_MULTIPLY";
            break;
          case nt:
            e4 = "ENVMAP_BLENDING_MIX";
            break;
          case it:
            e4 = "ENVMAP_BLENDING_ADD";
        }
      return e4;
    }(n2), d2 = t3.gammaFactor > 0 ? t3.gammaFactor : 1, p2 = n2.isWebGL2 ? "" : function(t4) {
      return [t4.extensionDerivatives || t4.envMapCubeUV || t4.bumpMap || t4.tangentSpaceNormalMap || t4.clearcoatNormalMap || t4.flatShading || t4.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "", (t4.extensionFragDepth || t4.logarithmicDepthBuffer) && t4.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t4.extensionDrawBuffers && t4.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t4.extensionShaderTextureLOD || t4.envMap || t4.transmission > 0) && t4.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(ba).join("\n");
    }(n2), f2 = function(t4) {
      const e4 = [];
      for (const n3 in t4) {
        const i3 = t4[n3];
        i3 !== false && e4.push("#define " + n3 + " " + i3);
      }
      return e4.join("\n");
    }(o3), m2 = r3.createProgram();
    let g2, x2, b2 = n2.glslVersion ? "#version " + n2.glslVersion + "\n" : "";
    n2.isRawShaderMaterial ? (g2 = [f2].filter(ba).join("\n"), g2.length > 0 && (g2 += "\n"), x2 = [p2, f2].filter(ba).join("\n"), x2.length > 0 && (x2 += "\n")) : (g2 = [Oa(n2), "#define SHADER_NAME " + n2.shaderName, f2, n2.instancing ? "#define USE_INSTANCING" : "", n2.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n2.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + d2, "#define MAX_BONES " + n2.maxBones, n2.useFog && n2.fog ? "#define USE_FOG" : "", n2.useFog && n2.fogExp2 ? "#define FOG_EXP2" : "", n2.map ? "#define USE_MAP" : "", n2.envMap ? "#define USE_ENVMAP" : "", n2.envMap ? "#define " + h2 : "", n2.lightMap ? "#define USE_LIGHTMAP" : "", n2.aoMap ? "#define USE_AOMAP" : "", n2.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n2.bumpMap ? "#define USE_BUMPMAP" : "", n2.normalMap ? "#define USE_NORMALMAP" : "", n2.normalMap && n2.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n2.normalMap && n2.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n2.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n2.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n2.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n2.displacementMap && n2.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n2.specularMap ? "#define USE_SPECULARMAP" : "", n2.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n2.metalnessMap ? "#define USE_METALNESSMAP" : "", n2.alphaMap ? "#define USE_ALPHAMAP" : "", n2.transmission ? "#define USE_TRANSMISSION" : "", n2.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n2.thicknessMap ? "#define USE_THICKNESSMAP" : "", n2.vertexTangents ? "#define USE_TANGENT" : "", n2.vertexColors ? "#define USE_COLOR" : "", n2.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n2.vertexUvs ? "#define USE_UV" : "", n2.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n2.flatShading ? "#define FLAT_SHADED" : "", n2.skinning ? "#define USE_SKINNING" : "", n2.useVertexTexture ? "#define BONE_TEXTURE" : "", n2.morphTargets ? "#define USE_MORPHTARGETS" : "", n2.morphNormals && n2.flatShading === false ? "#define USE_MORPHNORMALS" : "", n2.doubleSided ? "#define DOUBLE_SIDED" : "", n2.flipSided ? "#define FLIP_SIDED" : "", n2.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n2.shadowMapEnabled ? "#define " + l2 : "", n2.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n2.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n2.logarithmicDepthBuffer && n2.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", "\n"].filter(ba).join("\n"), x2 = [p2, Oa(n2), "#define SHADER_NAME " + n2.shaderName, f2, n2.alphaTest ? "#define ALPHATEST " + n2.alphaTest + (n2.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + d2, n2.useFog && n2.fog ? "#define USE_FOG" : "", n2.useFog && n2.fogExp2 ? "#define FOG_EXP2" : "", n2.map ? "#define USE_MAP" : "", n2.matcap ? "#define USE_MATCAP" : "", n2.envMap ? "#define USE_ENVMAP" : "", n2.envMap ? "#define " + u2 : "", n2.envMap ? "#define " + h2 : "", n2.envMap ? "#define " + c2 : "", n2.lightMap ? "#define USE_LIGHTMAP" : "", n2.aoMap ? "#define USE_AOMAP" : "", n2.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n2.bumpMap ? "#define USE_BUMPMAP" : "", n2.normalMap ? "#define USE_NORMALMAP" : "", n2.normalMap && n2.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n2.normalMap && n2.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n2.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n2.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n2.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n2.specularMap ? "#define USE_SPECULARMAP" : "", n2.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n2.metalnessMap ? "#define USE_METALNESSMAP" : "", n2.alphaMap ? "#define USE_ALPHAMAP" : "", n2.sheen ? "#define USE_SHEEN" : "", n2.transmission ? "#define USE_TRANSMISSION" : "", n2.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n2.thicknessMap ? "#define USE_THICKNESSMAP" : "", n2.vertexTangents ? "#define USE_TANGENT" : "", n2.vertexColors || n2.instancingColor ? "#define USE_COLOR" : "", n2.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n2.vertexUvs ? "#define USE_UV" : "", n2.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n2.gradientMap ? "#define USE_GRADIENTMAP" : "", n2.flatShading ? "#define FLAT_SHADED" : "", n2.doubleSided ? "#define DOUBLE_SIDED" : "", n2.flipSided ? "#define FLIP_SIDED" : "", n2.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n2.shadowMapEnabled ? "#define " + l2 : "", n2.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n2.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n2.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n2.logarithmicDepthBuffer && n2.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n2.extensionShaderTextureLOD || n2.envMap) && n2.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n2.toneMapping !== rt ? "#define TONE_MAPPING" : "", n2.toneMapping !== rt ? qo.tonemapping_pars_fragment : "", n2.toneMapping !== rt ? xa("toneMapping", n2.toneMapping) : "", n2.dithering ? "#define DITHERING" : "", qo.encodings_pars_fragment, n2.map ? _a("mapTexelToLinear", n2.mapEncoding) : "", n2.matcap ? _a("matcapTexelToLinear", n2.matcapEncoding) : "", n2.envMap ? _a("envMapTexelToLinear", n2.envMapEncoding) : "", n2.emissiveMap ? _a("emissiveMapTexelToLinear", n2.emissiveMapEncoding) : "", n2.lightMap ? _a("lightMapTexelToLinear", n2.lightMapEncoding) : "", ya("linearToOutputTexel", n2.outputEncoding), n2.depthPacking ? "#define DEPTH_PACKING " + n2.depthPacking : "", "\n"].filter(ba).join("\n")), s3 = Ea(s3), s3 = Ta(s3, n2), s3 = wa(s3, n2), a2 = Ea(a2), a2 = Ta(a2, n2), a2 = wa(a2, n2), s3 = Pa(s3), a2 = Pa(a2), n2.isWebGL2 && n2.isRawShaderMaterial !== true && (b2 = "#version 300 es\n", g2 = ["#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g2, x2 = ["#define varying in", n2.glslVersion === Hn ? "" : "out highp vec4 pc_fragColor;", n2.glslVersion === Hn ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + x2);
    const T2 = b2 + x2 + a2, w2 = fa(r3, 35633, b2 + g2 + s3), S2 = fa(r3, 35632, T2);
    if (r3.attachShader(m2, w2), r3.attachShader(m2, S2), n2.index0AttributeName !== void 0 ? r3.bindAttribLocation(m2, 0, n2.index0AttributeName) : n2.morphTargets === true && r3.bindAttribLocation(m2, 0, "position"), r3.linkProgram(m2), t3.debug.checkShaderErrors) {
      const t4 = r3.getProgramInfoLog(m2).trim(), e4 = r3.getShaderInfoLog(w2).trim(), n3 = r3.getShaderInfoLog(S2).trim();
      let i3 = true, o4 = true;
      if (r3.getProgramParameter(m2, 35714) === false) {
        i3 = false;
        const e5 = va(r3, w2, "vertex"), n4 = va(r3, S2, "fragment");
        console.error("THREE.WebGLProgram: shader error: ", r3.getError(), "35715", r3.getProgramParameter(m2, 35715), "gl.getProgramInfoLog", t4, e5, n4);
      } else
        t4 !== "" ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", t4) : e4 !== "" && n3 !== "" || (o4 = false);
      o4 && (this.diagnostics = { runnable: i3, programLog: t4, vertexShader: { log: e4, prefix: g2 }, fragmentShader: { log: n3, prefix: x2 } });
    }
    let E2, M2;
    return r3.deleteShader(w2), r3.deleteShader(S2), this.getUniforms = function() {
      return E2 === void 0 && (E2 = new pa(r3, m2)), E2;
    }, this.getAttributes = function() {
      return M2 === void 0 && (M2 = function(t4, e4) {
        const n3 = {}, i3 = t4.getProgramParameter(e4, 35721);
        for (let r4 = 0; r4 < i3; r4++) {
          const i4 = t4.getActiveAttrib(e4, r4).name;
          n3[i4] = t4.getAttribLocation(e4, i4);
        }
        return n3;
      }(r3, m2)), M2;
    }, this.destroy = function() {
      i2.releaseStatesOfProgram(this), r3.deleteProgram(m2), this.program = void 0;
    }, this.name = n2.shaderName, this.id = ma++, this.cacheKey = e3, this.usedTimes = 1, this.program = m2, this.vertexShader = w2, this.fragmentShader = S2, this;
  }
  function Na(t3, e3, n2, i2, r3, o3) {
    const s3 = [], a2 = i2.isWebGL2, l2 = i2.logarithmicDepthBuffer, u2 = i2.floatVertexTextures, h2 = i2.maxVertexUniforms, c2 = i2.vertexTextures;
    let d2 = i2.precision;
    const p2 = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" }, f2 = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexAlphas", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen", "transmission", "transmissionMap", "thicknessMap"];
    function m2(t4) {
      let e4;
      return t4 && t4.isTexture ? e4 = t4.encoding : t4 && t4.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), e4 = t4.texture.encoding) : e4 = nn, e4;
    }
    return { getParameters: function(r4, s4, f3, g2, v2) {
      const _2 = g2.fog, y2 = r4.isMeshStandardMaterial ? g2.environment : null, x2 = e3.get(r4.envMap || y2), w2 = p2[r4.type], S2 = v2.isSkinnedMesh ? function(t4) {
        const e4 = t4.skeleton.bones;
        if (u2)
          return 1024;
        {
          const t5 = h2, n3 = Math.floor((t5 - 20) / 4), i3 = Math.min(n3, e4.length);
          return i3 < e4.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e4.length + " bones. This GPU supports " + i3 + "."), 0) : i3;
        }
      }(v2) : 0;
      let E2, M2;
      if (r4.precision !== null && (d2 = i2.getMaxPrecision(r4.precision), d2 !== r4.precision && console.warn("THREE.WebGLProgram.getParameters:", r4.precision, "not supported, using", d2, "instead.")), w2) {
        const t4 = Zo[w2];
        E2 = t4.vertexShader, M2 = t4.fragmentShader;
      } else
        E2 = r4.vertexShader, M2 = r4.fragmentShader;
      const A2 = t3.getRenderTarget();
      return { isWebGL2: a2, shaderID: w2, shaderName: r4.type, vertexShader: E2, fragmentShader: M2, defines: r4.defines, isRawShaderMaterial: r4.isRawShaderMaterial === true, glslVersion: r4.glslVersion, precision: d2, instancing: v2.isInstancedMesh === true, instancingColor: v2.isInstancedMesh === true && v2.instanceColor !== null, supportsVertexTextures: c2, outputEncoding: A2 !== null ? m2(A2.texture) : t3.outputEncoding, map: !!r4.map, mapEncoding: m2(r4.map), matcap: !!r4.matcap, matcapEncoding: m2(r4.matcap), envMap: !!x2, envMapMode: x2 && x2.mapping, envMapEncoding: m2(x2), envMapCubeUV: !!x2 && (x2.mapping === mt || x2.mapping === gt), lightMap: !!r4.lightMap, lightMapEncoding: m2(r4.lightMap), aoMap: !!r4.aoMap, emissiveMap: !!r4.emissiveMap, emissiveMapEncoding: m2(r4.emissiveMap), bumpMap: !!r4.bumpMap, normalMap: !!r4.normalMap, objectSpaceNormalMap: r4.normalMapType === fn, tangentSpaceNormalMap: r4.normalMapType === pn, clearcoatMap: !!r4.clearcoatMap, clearcoatRoughnessMap: !!r4.clearcoatRoughnessMap, clearcoatNormalMap: !!r4.clearcoatNormalMap, displacementMap: !!r4.displacementMap, roughnessMap: !!r4.roughnessMap, metalnessMap: !!r4.metalnessMap, specularMap: !!r4.specularMap, alphaMap: !!r4.alphaMap, gradientMap: !!r4.gradientMap, sheen: !!r4.sheen, transmission: !!r4.transmission, transmissionMap: !!r4.transmissionMap, thicknessMap: !!r4.thicknessMap, combine: r4.combine, vertexTangents: r4.normalMap && r4.vertexTangents, vertexColors: r4.vertexColors, vertexAlphas: r4.vertexColors === true && v2.geometry && v2.geometry.attributes.color && v2.geometry.attributes.color.itemSize === 4, vertexUvs: !!(r4.map || r4.bumpMap || r4.normalMap || r4.specularMap || r4.alphaMap || r4.emissiveMap || r4.roughnessMap || r4.metalnessMap || r4.clearcoatMap || r4.clearcoatRoughnessMap || r4.clearcoatNormalMap || r4.displacementMap || r4.transmissionMap || r4.thicknessMap), uvsVertexOnly: !(r4.map || r4.bumpMap || r4.normalMap || r4.specularMap || r4.alphaMap || r4.emissiveMap || r4.roughnessMap || r4.metalnessMap || r4.clearcoatNormalMap || r4.transmission || r4.transmissionMap || r4.thicknessMap || !r4.displacementMap), fog: !!_2, useFog: r4.fog, fogExp2: _2 && _2.isFogExp2, flatShading: !!r4.flatShading, sizeAttenuation: r4.sizeAttenuation, logarithmicDepthBuffer: l2, skinning: v2.isSkinnedMesh === true && S2 > 0, maxBones: S2, useVertexTexture: u2, morphTargets: r4.morphTargets, morphNormals: r4.morphNormals, numDirLights: s4.directional.length, numPointLights: s4.point.length, numSpotLights: s4.spot.length, numRectAreaLights: s4.rectArea.length, numHemiLights: s4.hemi.length, numDirLightShadows: s4.directionalShadowMap.length, numPointLightShadows: s4.pointShadowMap.length, numSpotLightShadows: s4.spotShadowMap.length, numClippingPlanes: o3.numPlanes, numClipIntersection: o3.numIntersection, dithering: r4.dithering, shadowMapEnabled: t3.shadowMap.enabled && f3.length > 0, shadowMapType: t3.shadowMap.type, toneMapping: r4.toneMapped ? t3.toneMapping : rt, physicallyCorrectLights: t3.physicallyCorrectLights, premultipliedAlpha: r4.premultipliedAlpha, alphaTest: r4.alphaTest, doubleSided: r4.side === T, flipSided: r4.side === b, depthPacking: r4.depthPacking !== void 0 && r4.depthPacking, index0AttributeName: r4.index0AttributeName, extensionDerivatives: r4.extensions && r4.extensions.derivatives, extensionFragDepth: r4.extensions && r4.extensions.fragDepth, extensionDrawBuffers: r4.extensions && r4.extensions.drawBuffers, extensionShaderTextureLOD: r4.extensions && r4.extensions.shaderTextureLOD, rendererExtensionFragDepth: a2 || n2.has("EXT_frag_depth"), rendererExtensionDrawBuffers: a2 || n2.has("WEBGL_draw_buffers"), rendererExtensionShaderTextureLod: a2 || n2.has("EXT_shader_texture_lod"), customProgramCacheKey: r4.customProgramCacheKey() };
    }, getProgramCacheKey: function(e4) {
      const n3 = [];
      if (e4.shaderID ? n3.push(e4.shaderID) : (n3.push(e4.fragmentShader), n3.push(e4.vertexShader)), e4.defines !== void 0)
        for (const t4 in e4.defines)
          n3.push(t4), n3.push(e4.defines[t4]);
      if (e4.isRawShaderMaterial === false) {
        for (let t4 = 0; t4 < f2.length; t4++)
          n3.push(e4[f2[t4]]);
        n3.push(t3.outputEncoding), n3.push(t3.gammaFactor);
      }
      return n3.push(e4.customProgramCacheKey), n3.join();
    }, getUniforms: function(t4) {
      const e4 = p2[t4.type];
      let n3;
      if (e4) {
        const t5 = Zo[e4];
        n3 = Co.clone(t5.uniforms);
      } else
        n3 = t4.uniforms;
      return n3;
    }, acquireProgram: function(e4, n3) {
      let i3;
      for (let t4 = 0, e5 = s3.length; t4 < e5; t4++) {
        const e6 = s3[t4];
        if (e6.cacheKey === n3) {
          i3 = e6, ++i3.usedTimes;
          break;
        }
      }
      return i3 === void 0 && (i3 = new La(t3, n3, e4, r3), s3.push(i3)), i3;
    }, releaseProgram: function(t4) {
      if (--t4.usedTimes == 0) {
        const e4 = s3.indexOf(t4);
        s3[e4] = s3[s3.length - 1], s3.pop(), t4.destroy();
      }
    }, programs: s3 };
  }
  function Da() {
    let t3 = new WeakMap();
    return { get: function(e3) {
      let n2 = t3.get(e3);
      return n2 === void 0 && (n2 = {}, t3.set(e3, n2)), n2;
    }, remove: function(e3) {
      t3.delete(e3);
    }, update: function(e3, n2, i2) {
      t3.get(e3)[n2] = i2;
    }, dispose: function() {
      t3 = new WeakMap();
    } };
  }
  function Fa(t3, e3) {
    return t3.groupOrder !== e3.groupOrder ? t3.groupOrder - e3.groupOrder : t3.renderOrder !== e3.renderOrder ? t3.renderOrder - e3.renderOrder : t3.program !== e3.program ? t3.program.id - e3.program.id : t3.material.id !== e3.material.id ? t3.material.id - e3.material.id : t3.z !== e3.z ? t3.z - e3.z : t3.id - e3.id;
  }
  function Ba(t3, e3) {
    return t3.groupOrder !== e3.groupOrder ? t3.groupOrder - e3.groupOrder : t3.renderOrder !== e3.renderOrder ? t3.renderOrder - e3.renderOrder : t3.z !== e3.z ? e3.z - t3.z : t3.id - e3.id;
  }
  function Ua(t3) {
    const e3 = [];
    let n2 = 0;
    const i2 = [], r3 = [], o3 = [], s3 = { id: -1 };
    function a2(i3, r4, o4, a3, l2, u2) {
      let h2 = e3[n2];
      const c2 = t3.get(o4);
      return h2 === void 0 ? (h2 = { id: i3.id, object: i3, geometry: r4, material: o4, program: c2.program || s3, groupOrder: a3, renderOrder: i3.renderOrder, z: l2, group: u2 }, e3[n2] = h2) : (h2.id = i3.id, h2.object = i3, h2.geometry = r4, h2.material = o4, h2.program = c2.program || s3, h2.groupOrder = a3, h2.renderOrder = i3.renderOrder, h2.z = l2, h2.group = u2), n2++, h2;
    }
    return { opaque: i2, transmissive: r3, transparent: o3, init: function() {
      n2 = 0, i2.length = 0, r3.length = 0, o3.length = 0;
    }, push: function(t4, e4, n3, s4, l2, u2) {
      const h2 = a2(t4, e4, n3, s4, l2, u2);
      n3.transmission > 0 ? r3.push(h2) : n3.transparent === true ? o3.push(h2) : i2.push(h2);
    }, unshift: function(t4, e4, n3, s4, l2, u2) {
      const h2 = a2(t4, e4, n3, s4, l2, u2);
      n3.transmission > 0 ? r3.unshift(h2) : n3.transparent === true ? o3.unshift(h2) : i2.unshift(h2);
    }, finish: function() {
      for (let t4 = n2, i3 = e3.length; t4 < i3; t4++) {
        const n3 = e3[t4];
        if (n3.id === null)
          break;
        n3.id = null, n3.object = null, n3.geometry = null, n3.material = null, n3.program = null, n3.group = null;
      }
    }, sort: function(t4, e4) {
      i2.length > 1 && i2.sort(t4 || Fa), r3.length > 1 && r3.sort(e4 || Ba), o3.length > 1 && o3.sort(e4 || Ba);
    } };
  }
  function ka(t3) {
    let e3 = new WeakMap();
    return { get: function(n2, i2) {
      let r3;
      return e3.has(n2) === false ? (r3 = new Ua(t3), e3.set(n2, [r3])) : i2 >= e3.get(n2).length ? (r3 = new Ua(t3), e3.get(n2).push(r3)) : r3 = e3.get(n2)[i2], r3;
    }, dispose: function() {
      e3 = new WeakMap();
    } };
  }
  function Ga() {
    const t3 = {};
    return { get: function(e3) {
      if (t3[e3.id] !== void 0)
        return t3[e3.id];
      let n2;
      switch (e3.type) {
        case "DirectionalLight":
          n2 = { direction: new pi(), color: new Dr() };
          break;
        case "SpotLight":
          n2 = { position: new pi(), direction: new pi(), color: new Dr(), distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 };
          break;
        case "PointLight":
          n2 = { position: new pi(), color: new Dr(), distance: 0, decay: 0 };
          break;
        case "HemisphereLight":
          n2 = { direction: new pi(), skyColor: new Dr(), groundColor: new Dr() };
          break;
        case "RectAreaLight":
          n2 = { color: new Dr(), position: new pi(), halfWidth: new pi(), halfHeight: new pi() };
      }
      return t3[e3.id] = n2, n2;
    } };
  }
  let Ha = 0;
  function za(t3, e3) {
    return (e3.castShadow ? 1 : 0) - (t3.castShadow ? 1 : 0);
  }
  function ja(t3, e3) {
    const n2 = new Ga(), i2 = function() {
      const t4 = {};
      return { get: function(e4) {
        if (t4[e4.id] !== void 0)
          return t4[e4.id];
        let n3;
        switch (e4.type) {
          case "DirectionalLight":
          case "SpotLight":
            n3 = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new ei() };
            break;
          case "PointLight":
            n3 = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new ei(), shadowCameraNear: 1, shadowCameraFar: 1e3 };
        }
        return t4[e4.id] = n3, n3;
      } };
    }(), r3 = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotShadow: [], spotShadowMap: [], spotShadowMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [] };
    for (let t4 = 0; t4 < 9; t4++)
      r3.probe.push(new pi());
    const o3 = new pi(), s3 = new Vi(), a2 = new Vi();
    return { setup: function(o4) {
      let s4 = 0, a3 = 0, l2 = 0;
      for (let t4 = 0; t4 < 9; t4++)
        r3.probe[t4].set(0, 0, 0);
      let u2 = 0, h2 = 0, c2 = 0, d2 = 0, p2 = 0, f2 = 0, m2 = 0, g2 = 0;
      o4.sort(za);
      for (let t4 = 0, e4 = o4.length; t4 < e4; t4++) {
        const e5 = o4[t4], v3 = e5.color, _2 = e5.intensity, y2 = e5.distance, x2 = e5.shadow && e5.shadow.map ? e5.shadow.map.texture : null;
        if (e5.isAmbientLight)
          s4 += v3.r * _2, a3 += v3.g * _2, l2 += v3.b * _2;
        else if (e5.isLightProbe)
          for (let t5 = 0; t5 < 9; t5++)
            r3.probe[t5].addScaledVector(e5.sh.coefficients[t5], _2);
        else if (e5.isDirectionalLight) {
          const t5 = n2.get(e5);
          if (t5.color.copy(e5.color).multiplyScalar(e5.intensity), e5.castShadow) {
            const t6 = e5.shadow, n3 = i2.get(e5);
            n3.shadowBias = t6.bias, n3.shadowNormalBias = t6.normalBias, n3.shadowRadius = t6.radius, n3.shadowMapSize = t6.mapSize, r3.directionalShadow[u2] = n3, r3.directionalShadowMap[u2] = x2, r3.directionalShadowMatrix[u2] = e5.shadow.matrix, f2++;
          }
          r3.directional[u2] = t5, u2++;
        } else if (e5.isSpotLight) {
          const t5 = n2.get(e5);
          if (t5.position.setFromMatrixPosition(e5.matrixWorld), t5.color.copy(v3).multiplyScalar(_2), t5.distance = y2, t5.coneCos = Math.cos(e5.angle), t5.penumbraCos = Math.cos(e5.angle * (1 - e5.penumbra)), t5.decay = e5.decay, e5.castShadow) {
            const t6 = e5.shadow, n3 = i2.get(e5);
            n3.shadowBias = t6.bias, n3.shadowNormalBias = t6.normalBias, n3.shadowRadius = t6.radius, n3.shadowMapSize = t6.mapSize, r3.spotShadow[c2] = n3, r3.spotShadowMap[c2] = x2, r3.spotShadowMatrix[c2] = e5.shadow.matrix, g2++;
          }
          r3.spot[c2] = t5, c2++;
        } else if (e5.isRectAreaLight) {
          const t5 = n2.get(e5);
          t5.color.copy(v3).multiplyScalar(_2), t5.halfWidth.set(0.5 * e5.width, 0, 0), t5.halfHeight.set(0, 0.5 * e5.height, 0), r3.rectArea[d2] = t5, d2++;
        } else if (e5.isPointLight) {
          const t5 = n2.get(e5);
          if (t5.color.copy(e5.color).multiplyScalar(e5.intensity), t5.distance = e5.distance, t5.decay = e5.decay, e5.castShadow) {
            const t6 = e5.shadow, n3 = i2.get(e5);
            n3.shadowBias = t6.bias, n3.shadowNormalBias = t6.normalBias, n3.shadowRadius = t6.radius, n3.shadowMapSize = t6.mapSize, n3.shadowCameraNear = t6.camera.near, n3.shadowCameraFar = t6.camera.far, r3.pointShadow[h2] = n3, r3.pointShadowMap[h2] = x2, r3.pointShadowMatrix[h2] = e5.shadow.matrix, m2++;
          }
          r3.point[h2] = t5, h2++;
        } else if (e5.isHemisphereLight) {
          const t5 = n2.get(e5);
          t5.skyColor.copy(e5.color).multiplyScalar(_2), t5.groundColor.copy(e5.groundColor).multiplyScalar(_2), r3.hemi[p2] = t5, p2++;
        }
      }
      d2 > 0 && (e3.isWebGL2 || t3.has("OES_texture_float_linear") === true ? (r3.rectAreaLTC1 = Yo.LTC_FLOAT_1, r3.rectAreaLTC2 = Yo.LTC_FLOAT_2) : t3.has("OES_texture_half_float_linear") === true ? (r3.rectAreaLTC1 = Yo.LTC_HALF_1, r3.rectAreaLTC2 = Yo.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r3.ambient[0] = s4, r3.ambient[1] = a3, r3.ambient[2] = l2;
      const v2 = r3.hash;
      v2.directionalLength === u2 && v2.pointLength === h2 && v2.spotLength === c2 && v2.rectAreaLength === d2 && v2.hemiLength === p2 && v2.numDirectionalShadows === f2 && v2.numPointShadows === m2 && v2.numSpotShadows === g2 || (r3.directional.length = u2, r3.spot.length = c2, r3.rectArea.length = d2, r3.point.length = h2, r3.hemi.length = p2, r3.directionalShadow.length = f2, r3.directionalShadowMap.length = f2, r3.pointShadow.length = m2, r3.pointShadowMap.length = m2, r3.spotShadow.length = g2, r3.spotShadowMap.length = g2, r3.directionalShadowMatrix.length = f2, r3.pointShadowMatrix.length = m2, r3.spotShadowMatrix.length = g2, v2.directionalLength = u2, v2.pointLength = h2, v2.spotLength = c2, v2.rectAreaLength = d2, v2.hemiLength = p2, v2.numDirectionalShadows = f2, v2.numPointShadows = m2, v2.numSpotShadows = g2, r3.version = Ha++);
    }, setupView: function(t4, e4) {
      let n3 = 0, i3 = 0, l2 = 0, u2 = 0, h2 = 0;
      const c2 = e4.matrixWorldInverse;
      for (let e5 = 0, d2 = t4.length; e5 < d2; e5++) {
        const d3 = t4[e5];
        if (d3.isDirectionalLight) {
          const t5 = r3.directional[n3];
          t5.direction.setFromMatrixPosition(d3.matrixWorld), o3.setFromMatrixPosition(d3.target.matrixWorld), t5.direction.sub(o3), t5.direction.transformDirection(c2), n3++;
        } else if (d3.isSpotLight) {
          const t5 = r3.spot[l2];
          t5.position.setFromMatrixPosition(d3.matrixWorld), t5.position.applyMatrix4(c2), t5.direction.setFromMatrixPosition(d3.matrixWorld), o3.setFromMatrixPosition(d3.target.matrixWorld), t5.direction.sub(o3), t5.direction.transformDirection(c2), l2++;
        } else if (d3.isRectAreaLight) {
          const t5 = r3.rectArea[u2];
          t5.position.setFromMatrixPosition(d3.matrixWorld), t5.position.applyMatrix4(c2), a2.identity(), s3.copy(d3.matrixWorld), s3.premultiply(c2), a2.extractRotation(s3), t5.halfWidth.set(0.5 * d3.width, 0, 0), t5.halfHeight.set(0, 0.5 * d3.height, 0), t5.halfWidth.applyMatrix4(a2), t5.halfHeight.applyMatrix4(a2), u2++;
        } else if (d3.isPointLight) {
          const t5 = r3.point[i3];
          t5.position.setFromMatrixPosition(d3.matrixWorld), t5.position.applyMatrix4(c2), i3++;
        } else if (d3.isHemisphereLight) {
          const t5 = r3.hemi[h2];
          t5.direction.setFromMatrixPosition(d3.matrixWorld), t5.direction.transformDirection(c2), t5.direction.normalize(), h2++;
        }
      }
    }, state: r3 };
  }
  function Va(t3, e3) {
    const n2 = new ja(t3, e3), i2 = [], r3 = [];
    return { init: function() {
      i2.length = 0, r3.length = 0;
    }, state: { lightsArray: i2, shadowsArray: r3, lights: n2 }, setupLights: function() {
      n2.setup(i2);
    }, setupLightsView: function(t4) {
      n2.setupView(i2, t4);
    }, pushLight: function(t4) {
      i2.push(t4);
    }, pushShadow: function(t4) {
      r3.push(t4);
    } };
  }
  function Wa(t3, e3) {
    let n2 = new WeakMap();
    return { get: function(i2, r3 = 0) {
      let o3;
      return n2.has(i2) === false ? (o3 = new Va(t3, e3), n2.set(i2, [o3])) : r3 >= n2.get(i2).length ? (o3 = new Va(t3, e3), n2.get(i2).push(o3)) : o3 = n2.get(i2)[r3], o3;
    }, dispose: function() {
      n2 = new WeakMap();
    } };
  }
  class Xa extends Rr {
    constructor(t3) {
      super(), this.type = "MeshDepthMaterial", this.depthPacking = cn, this.morphTargets = false, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.setValues(t3);
    }
    copy(t3) {
      return super.copy(t3), this.depthPacking = t3.depthPacking, this.morphTargets = t3.morphTargets, this.map = t3.map, this.alphaMap = t3.alphaMap, this.displacementMap = t3.displacementMap, this.displacementScale = t3.displacementScale, this.displacementBias = t3.displacementBias, this.wireframe = t3.wireframe, this.wireframeLinewidth = t3.wireframeLinewidth, this;
    }
  }
  Xa.prototype.isMeshDepthMaterial = true;
  class qa extends Rr {
    constructor(t3) {
      super(), this.type = "MeshDistanceMaterial", this.referencePosition = new pi(), this.nearDistance = 1, this.farDistance = 1e3, this.morphTargets = false, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = false, this.setValues(t3);
    }
    copy(t3) {
      return super.copy(t3), this.referencePosition.copy(t3.referencePosition), this.nearDistance = t3.nearDistance, this.farDistance = t3.farDistance, this.morphTargets = t3.morphTargets, this.map = t3.map, this.alphaMap = t3.alphaMap, this.displacementMap = t3.displacementMap, this.displacementScale = t3.displacementScale, this.displacementBias = t3.displacementBias, this;
    }
  }
  qa.prototype.isMeshDistanceMaterial = true;
  function Ya(t3, e3, n2) {
    let i2 = new jo();
    const r3 = new ei(), o3 = new ei(), s3 = new li(), a2 = [], l2 = [], u2 = {}, h2 = n2.maxTextureSize, c2 = { 0: b, 1: x, 2: T }, d2 = new Io({ defines: { SAMPLE_RATE: 2 / 8, HALF_SAMPLE_RATE: 1 / 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new ei() }, radius: { value: 4 } }, vertexShader: "void main() {\n	gl_Position = vec4( position, 1.0 );\n}", fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n	for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean * HALF_SAMPLE_RATE;\n	squared_mean = squared_mean * HALF_SAMPLE_RATE;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}" }), p2 = d2.clone();
    p2.defines.HORIZONTAL_PASS = 1;
    const f2 = new so();
    f2.setAttribute("position", new kr(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
    const m2 = new Eo(f2, d2), g2 = this;
    function _2(n3, i3) {
      const r4 = e3.update(m2);
      d2.uniforms.shadow_pass.value = n3.map.texture, d2.uniforms.resolution.value = n3.mapSize, d2.uniforms.radius.value = n3.radius, t3.setRenderTarget(n3.mapPass), t3.clear(), t3.renderBufferDirect(i3, null, r4, d2, m2, null), p2.uniforms.shadow_pass.value = n3.mapPass.texture, p2.uniforms.resolution.value = n3.mapSize, p2.uniforms.radius.value = n3.radius, t3.setRenderTarget(n3.map), t3.clear(), t3.renderBufferDirect(i3, null, r4, p2, m2, null);
    }
    function w2(t4) {
      const e4 = t4 << 0;
      let n3 = a2[e4];
      return n3 === void 0 && (n3 = new Xa({ depthPacking: dn, morphTargets: t4 }), a2[e4] = n3), n3;
    }
    function S2(t4) {
      const e4 = t4 << 0;
      let n3 = l2[e4];
      return n3 === void 0 && (n3 = new qa({ morphTargets: t4 }), l2[e4] = n3), n3;
    }
    function M2(e4, n3, i3, r4, o4, s4, a3) {
      let l3 = null, h3 = w2, d3 = e4.customDepthMaterial;
      if (r4.isPointLight === true && (h3 = S2, d3 = e4.customDistanceMaterial), d3 === void 0) {
        let t4 = false;
        i3.morphTargets === true && (t4 = n3.morphAttributes && n3.morphAttributes.position && n3.morphAttributes.position.length > 0), l3 = h3(t4);
      } else
        l3 = d3;
      if (t3.localClippingEnabled && i3.clipShadows === true && i3.clippingPlanes.length !== 0) {
        const t4 = l3.uuid, e5 = i3.uuid;
        let n4 = u2[t4];
        n4 === void 0 && (n4 = {}, u2[t4] = n4);
        let r5 = n4[e5];
        r5 === void 0 && (r5 = l3.clone(), n4[e5] = r5), l3 = r5;
      }
      return l3.visible = i3.visible, l3.wireframe = i3.wireframe, l3.side = a3 === y ? i3.shadowSide !== null ? i3.shadowSide : i3.side : i3.shadowSide !== null ? i3.shadowSide : c2[i3.side], l3.clipShadows = i3.clipShadows, l3.clippingPlanes = i3.clippingPlanes, l3.clipIntersection = i3.clipIntersection, l3.wireframeLinewidth = i3.wireframeLinewidth, l3.linewidth = i3.linewidth, r4.isPointLight === true && l3.isMeshDistanceMaterial === true && (l3.referencePosition.setFromMatrixPosition(r4.matrixWorld), l3.nearDistance = o4, l3.farDistance = s4), l3;
    }
    function A2(n3, r4, o4, s4, a3) {
      if (n3.visible === false)
        return;
      if (n3.layers.test(r4.layers) && (n3.isMesh || n3.isLine || n3.isPoints) && (n3.castShadow || n3.receiveShadow && a3 === y) && (!n3.frustumCulled || i2.intersectsObject(n3))) {
        n3.modelViewMatrix.multiplyMatrices(o4.matrixWorldInverse, n3.matrixWorld);
        const i3 = e3.update(n3), r5 = n3.material;
        if (Array.isArray(r5)) {
          const e4 = i3.groups;
          for (let l4 = 0, u3 = e4.length; l4 < u3; l4++) {
            const u4 = e4[l4], h3 = r5[u4.materialIndex];
            if (h3 && h3.visible) {
              const e5 = M2(n3, i3, h3, s4, o4.near, o4.far, a3);
              t3.renderBufferDirect(o4, null, i3, e5, n3, u4);
            }
          }
        } else if (r5.visible) {
          const e4 = M2(n3, i3, r5, s4, o4.near, o4.far, a3);
          t3.renderBufferDirect(o4, null, i3, e4, n3, null);
        }
      }
      const l3 = n3.children;
      for (let t4 = 0, e4 = l3.length; t4 < e4; t4++)
        A2(l3[t4], r4, o4, s4, a3);
    }
    this.enabled = false, this.autoUpdate = true, this.needsUpdate = false, this.type = v, this.render = function(e4, n3, a3) {
      if (g2.enabled === false)
        return;
      if (g2.autoUpdate === false && g2.needsUpdate === false)
        return;
      if (e4.length === 0)
        return;
      const l3 = t3.getRenderTarget(), u3 = t3.getActiveCubeFace(), c3 = t3.getActiveMipmapLevel(), d3 = t3.state;
      d3.setBlending(E), d3.buffers.color.setClear(1, 1, 1, 1), d3.buffers.depth.setTest(true), d3.setScissorTest(false);
      for (let l4 = 0, u4 = e4.length; l4 < u4; l4++) {
        const u5 = e4[l4], c4 = u5.shadow;
        if (c4 === void 0) {
          console.warn("THREE.WebGLShadowMap:", u5, "has no shadow.");
          continue;
        }
        if (c4.autoUpdate === false && c4.needsUpdate === false)
          continue;
        r3.copy(c4.mapSize);
        const p3 = c4.getFrameExtents();
        if (r3.multiply(p3), o3.copy(c4.mapSize), (r3.x > h2 || r3.y > h2) && (r3.x > h2 && (o3.x = Math.floor(h2 / p3.x), r3.x = o3.x * p3.x, c4.mapSize.x = o3.x), r3.y > h2 && (o3.y = Math.floor(h2 / p3.y), r3.y = o3.y * p3.y, c4.mapSize.y = o3.y)), c4.map === null && !c4.isPointLightShadow && this.type === y) {
          const t4 = { minFilter: Et, magFilter: Et, format: Vt };
          c4.map = new ui(r3.x, r3.y, t4), c4.map.texture.name = u5.name + ".shadowMap", c4.mapPass = new ui(r3.x, r3.y, t4), c4.camera.updateProjectionMatrix();
        }
        if (c4.map === null) {
          const t4 = { minFilter: xt, magFilter: xt, format: Vt };
          c4.map = new ui(r3.x, r3.y, t4), c4.map.texture.name = u5.name + ".shadowMap", c4.camera.updateProjectionMatrix();
        }
        t3.setRenderTarget(c4.map), t3.clear();
        const f3 = c4.getViewportCount();
        for (let t4 = 0; t4 < f3; t4++) {
          const e5 = c4.getViewport(t4);
          s3.set(o3.x * e5.x, o3.y * e5.y, o3.x * e5.z, o3.y * e5.w), d3.viewport(s3), c4.updateMatrices(u5, t4), i2 = c4.getFrustum(), A2(n3, a3, c4.camera, u5, this.type);
        }
        c4.isPointLightShadow || this.type !== y || _2(c4, a3), c4.needsUpdate = false;
      }
      g2.needsUpdate = false, t3.setRenderTarget(l3, u3, c3);
    };
  }
  function Za(t3, e3, n2) {
    const i2 = n2.isWebGL2;
    const r3 = new function() {
      let e4 = false;
      const n3 = new li();
      let i3 = null;
      const r4 = new li(0, 0, 0, 0);
      return { setMask: function(n4) {
        i3 === n4 || e4 || (t3.colorMask(n4, n4, n4, n4), i3 = n4);
      }, setLocked: function(t4) {
        e4 = t4;
      }, setClear: function(e5, i4, o4, s4, a3) {
        a3 === true && (e5 *= s4, i4 *= s4, o4 *= s4), n3.set(e5, i4, o4, s4), r4.equals(n3) === false && (t3.clearColor(e5, i4, o4, s4), r4.copy(n3));
      }, reset: function() {
        e4 = false, i3 = null, r4.set(-1, 0, 0, 0);
      } };
    }(), o3 = new function() {
      let e4 = false, n3 = null, i3 = null, r4 = null;
      return { setTest: function(t4) {
        t4 ? _t2(2929) : yt2(2929);
      }, setMask: function(i4) {
        n3 === i4 || e4 || (t3.depthMask(i4), n3 = i4);
      }, setFunc: function(e5) {
        if (i3 !== e5) {
          if (e5)
            switch (e5) {
              case q:
                t3.depthFunc(512);
                break;
              case Y:
                t3.depthFunc(519);
                break;
              case Z:
                t3.depthFunc(513);
                break;
              case J:
                t3.depthFunc(515);
                break;
              case $:
                t3.depthFunc(514);
                break;
              case K:
                t3.depthFunc(518);
                break;
              case Q:
                t3.depthFunc(516);
                break;
              case tt:
                t3.depthFunc(517);
                break;
              default:
                t3.depthFunc(515);
            }
          else
            t3.depthFunc(515);
          i3 = e5;
        }
      }, setLocked: function(t4) {
        e4 = t4;
      }, setClear: function(e5) {
        r4 !== e5 && (t3.clearDepth(e5), r4 = e5);
      }, reset: function() {
        e4 = false, n3 = null, i3 = null, r4 = null;
      } };
    }(), s3 = new function() {
      let e4 = false, n3 = null, i3 = null, r4 = null, o4 = null, s4 = null, a3 = null, l3 = null, u3 = null;
      return { setTest: function(t4) {
        e4 || (t4 ? _t2(2960) : yt2(2960));
      }, setMask: function(i4) {
        n3 === i4 || e4 || (t3.stencilMask(i4), n3 = i4);
      }, setFunc: function(e5, n4, s5) {
        i3 === e5 && r4 === n4 && o4 === s5 || (t3.stencilFunc(e5, n4, s5), i3 = e5, r4 = n4, o4 = s5);
      }, setOp: function(e5, n4, i4) {
        s4 === e5 && a3 === n4 && l3 === i4 || (t3.stencilOp(e5, n4, i4), s4 = e5, a3 = n4, l3 = i4);
      }, setLocked: function(t4) {
        e4 = t4;
      }, setClear: function(e5) {
        u3 !== e5 && (t3.clearStencil(e5), u3 = e5);
      }, reset: function() {
        e4 = false, n3 = null, i3 = null, r4 = null, o4 = null, s4 = null, a3 = null, l3 = null, u3 = null;
      } };
    }();
    let a2 = {}, l2 = null, u2 = {}, h2 = null, c2 = false, m2 = null, g2 = null, v2 = null, _2 = null, y2 = null, x2 = null, w2 = null, S2 = false, et2 = null, nt2 = null, it2 = null, rt2 = null, ot2 = null;
    const st2 = t3.getParameter(35661);
    let at2 = false, lt2 = 0;
    const ut2 = t3.getParameter(7938);
    ut2.indexOf("WebGL") !== -1 ? (lt2 = parseFloat(/^WebGL (\d)/.exec(ut2)[1]), at2 = lt2 >= 1) : ut2.indexOf("OpenGL ES") !== -1 && (lt2 = parseFloat(/^OpenGL ES (\d)/.exec(ut2)[1]), at2 = lt2 >= 2);
    let ht2 = null, ct2 = {};
    const dt2 = t3.getParameter(3088), pt2 = t3.getParameter(2978), ft2 = new li().fromArray(dt2), mt2 = new li().fromArray(pt2);
    function gt2(e4, n3, i3) {
      const r4 = new Uint8Array(4), o4 = t3.createTexture();
      t3.bindTexture(e4, o4), t3.texParameteri(e4, 10241, 9728), t3.texParameteri(e4, 10240, 9728);
      for (let e5 = 0; e5 < i3; e5++)
        t3.texImage2D(n3 + e5, 0, 6408, 1, 1, 0, 6408, 5121, r4);
      return o4;
    }
    const vt2 = {};
    function _t2(e4) {
      a2[e4] !== true && (t3.enable(e4), a2[e4] = true);
    }
    function yt2(e4) {
      a2[e4] !== false && (t3.disable(e4), a2[e4] = false);
    }
    vt2[3553] = gt2(3553, 3553, 1), vt2[34067] = gt2(34067, 34069, 6), r3.setClear(0, 0, 0, 1), o3.setClear(1), s3.setClear(0), _t2(2929), o3.setFunc(J), wt2(false), St2(p), _t2(2884), Tt2(E);
    const xt2 = { [I]: 32774, [O]: 32778, [L]: 32779 };
    if (i2)
      xt2[N] = 32775, xt2[D] = 32776;
    else {
      const t4 = e3.get("EXT_blend_minmax");
      t4 !== null && (xt2[N] = t4.MIN_EXT, xt2[D] = t4.MAX_EXT);
    }
    const bt2 = { [F]: 0, [B]: 1, [U]: 768, [G]: 770, [X]: 776, [V]: 774, [z]: 772, [k]: 769, [H]: 771, [W]: 775, [j]: 773 };
    function Tt2(e4, n3, i3, r4, o4, s4, a3, l3) {
      if (e4 !== E) {
        if (c2 === false && (_t2(3042), c2 = true), e4 === C)
          o4 = o4 || n3, s4 = s4 || i3, a3 = a3 || r4, n3 === g2 && o4 === y2 || (t3.blendEquationSeparate(xt2[n3], xt2[o4]), g2 = n3, y2 = o4), i3 === v2 && r4 === _2 && s4 === x2 && a3 === w2 || (t3.blendFuncSeparate(bt2[i3], bt2[r4], bt2[s4], bt2[a3]), v2 = i3, _2 = r4, x2 = s4, w2 = a3), m2 = e4, S2 = null;
        else if (e4 !== m2 || l3 !== S2) {
          if (g2 === I && y2 === I || (t3.blendEquation(32774), g2 = I, y2 = I), l3)
            switch (e4) {
              case M:
                t3.blendFuncSeparate(1, 771, 1, 771);
                break;
              case A:
                t3.blendFunc(1, 1);
                break;
              case R:
                t3.blendFuncSeparate(0, 0, 769, 771);
                break;
              case P:
                t3.blendFuncSeparate(0, 768, 0, 770);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", e4);
            }
          else
            switch (e4) {
              case M:
                t3.blendFuncSeparate(770, 771, 1, 771);
                break;
              case A:
                t3.blendFunc(770, 1);
                break;
              case R:
                t3.blendFunc(0, 769);
                break;
              case P:
                t3.blendFunc(0, 768);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", e4);
            }
          v2 = null, _2 = null, x2 = null, w2 = null, m2 = e4, S2 = l3;
        }
      } else
        c2 === true && (yt2(3042), c2 = false);
    }
    function wt2(e4) {
      et2 !== e4 && (e4 ? t3.frontFace(2304) : t3.frontFace(2305), et2 = e4);
    }
    function St2(e4) {
      e4 !== d ? (_t2(2884), e4 !== nt2 && (e4 === p ? t3.cullFace(1029) : e4 === f ? t3.cullFace(1028) : t3.cullFace(1032))) : yt2(2884), nt2 = e4;
    }
    function Et2(e4, n3, i3) {
      e4 ? (_t2(32823), rt2 === n3 && ot2 === i3 || (t3.polygonOffset(n3, i3), rt2 = n3, ot2 = i3)) : yt2(32823);
    }
    function Mt2(e4) {
      e4 === void 0 && (e4 = 33984 + st2 - 1), ht2 !== e4 && (t3.activeTexture(e4), ht2 = e4);
    }
    return { buffers: { color: r3, depth: o3, stencil: s3 }, enable: _t2, disable: yt2, bindFramebuffer: function(e4, n3) {
      return n3 === null && l2 !== null && (n3 = l2), u2[e4] !== n3 && (t3.bindFramebuffer(e4, n3), u2[e4] = n3, i2 && (e4 === 36009 && (u2[36160] = n3), e4 === 36160 && (u2[36009] = n3)), true);
    }, bindXRFramebuffer: function(e4) {
      e4 !== l2 && (t3.bindFramebuffer(36160, e4), l2 = e4);
    }, useProgram: function(e4) {
      return h2 !== e4 && (t3.useProgram(e4), h2 = e4, true);
    }, setBlending: Tt2, setMaterial: function(t4, e4) {
      t4.side === T ? yt2(2884) : _t2(2884);
      let n3 = t4.side === b;
      e4 && (n3 = !n3), wt2(n3), t4.blending === M && t4.transparent === false ? Tt2(E) : Tt2(t4.blending, t4.blendEquation, t4.blendSrc, t4.blendDst, t4.blendEquationAlpha, t4.blendSrcAlpha, t4.blendDstAlpha, t4.premultipliedAlpha), o3.setFunc(t4.depthFunc), o3.setTest(t4.depthTest), o3.setMask(t4.depthWrite), r3.setMask(t4.colorWrite);
      const i3 = t4.stencilWrite;
      s3.setTest(i3), i3 && (s3.setMask(t4.stencilWriteMask), s3.setFunc(t4.stencilFunc, t4.stencilRef, t4.stencilFuncMask), s3.setOp(t4.stencilFail, t4.stencilZFail, t4.stencilZPass)), Et2(t4.polygonOffset, t4.polygonOffsetFactor, t4.polygonOffsetUnits), t4.alphaToCoverage === true ? _t2(32926) : yt2(32926);
    }, setFlipSided: wt2, setCullFace: St2, setLineWidth: function(e4) {
      e4 !== it2 && (at2 && t3.lineWidth(e4), it2 = e4);
    }, setPolygonOffset: Et2, setScissorTest: function(t4) {
      t4 ? _t2(3089) : yt2(3089);
    }, activeTexture: Mt2, bindTexture: function(e4, n3) {
      ht2 === null && Mt2();
      let i3 = ct2[ht2];
      i3 === void 0 && (i3 = { type: void 0, texture: void 0 }, ct2[ht2] = i3), i3.type === e4 && i3.texture === n3 || (t3.bindTexture(e4, n3 || vt2[e4]), i3.type = e4, i3.texture = n3);
    }, unbindTexture: function() {
      const e4 = ct2[ht2];
      e4 !== void 0 && e4.type !== void 0 && (t3.bindTexture(e4.type, null), e4.type = void 0, e4.texture = void 0);
    }, compressedTexImage2D: function() {
      try {
        t3.compressedTexImage2D.apply(t3, arguments);
      } catch (t4) {
        console.error("THREE.WebGLState:", t4);
      }
    }, texImage2D: function() {
      try {
        t3.texImage2D.apply(t3, arguments);
      } catch (t4) {
        console.error("THREE.WebGLState:", t4);
      }
    }, texImage3D: function() {
      try {
        t3.texImage3D.apply(t3, arguments);
      } catch (t4) {
        console.error("THREE.WebGLState:", t4);
      }
    }, scissor: function(e4) {
      ft2.equals(e4) === false && (t3.scissor(e4.x, e4.y, e4.z, e4.w), ft2.copy(e4));
    }, viewport: function(e4) {
      mt2.equals(e4) === false && (t3.viewport(e4.x, e4.y, e4.z, e4.w), mt2.copy(e4));
    }, reset: function() {
      t3.disable(3042), t3.disable(2884), t3.disable(2929), t3.disable(32823), t3.disable(3089), t3.disable(2960), t3.disable(32926), t3.blendEquation(32774), t3.blendFunc(1, 0), t3.blendFuncSeparate(1, 0, 1, 0), t3.colorMask(true, true, true, true), t3.clearColor(0, 0, 0, 0), t3.depthMask(true), t3.depthFunc(513), t3.clearDepth(1), t3.stencilMask(4294967295), t3.stencilFunc(519, 0, 4294967295), t3.stencilOp(7680, 7680, 7680), t3.clearStencil(0), t3.cullFace(1029), t3.frontFace(2305), t3.polygonOffset(0, 0), t3.activeTexture(33984), t3.bindFramebuffer(36160, null), i2 === true && (t3.bindFramebuffer(36009, null), t3.bindFramebuffer(36008, null)), t3.useProgram(null), t3.lineWidth(1), t3.scissor(0, 0, t3.canvas.width, t3.canvas.height), t3.viewport(0, 0, t3.canvas.width, t3.canvas.height), a2 = {}, ht2 = null, ct2 = {}, l2 = null, u2 = {}, h2 = null, c2 = false, m2 = null, g2 = null, v2 = null, _2 = null, y2 = null, x2 = null, w2 = null, S2 = false, et2 = null, nt2 = null, it2 = null, rt2 = null, ot2 = null, ft2.set(0, 0, t3.canvas.width, t3.canvas.height), mt2.set(0, 0, t3.canvas.width, t3.canvas.height), r3.reset(), o3.reset(), s3.reset();
    } };
  }
  function Ja(t3, e3, n2, i2, r3, o3, s3) {
    const a2 = r3.isWebGL2, l2 = r3.maxTextures, u2 = r3.maxCubemapSize, h2 = r3.maxTextureSize, c2 = r3.maxSamples, d2 = new WeakMap();
    let p2, f2 = false;
    try {
      f2 = typeof OffscreenCanvas != "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
    } catch (t4) {
    }
    function m2(t4, e4) {
      return f2 ? new OffscreenCanvas(t4, e4) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
    }
    function g2(t4, e4, n3, i3) {
      let r4 = 1;
      if ((t4.width > i3 || t4.height > i3) && (r4 = i3 / Math.max(t4.width, t4.height)), r4 < 1 || e4 === true) {
        if (typeof HTMLImageElement != "undefined" && t4 instanceof HTMLImageElement || typeof HTMLCanvasElement != "undefined" && t4 instanceof HTMLCanvasElement || typeof ImageBitmap != "undefined" && t4 instanceof ImageBitmap) {
          const i4 = e4 ? Qn : Math.floor, o4 = i4(r4 * t4.width), s4 = i4(r4 * t4.height);
          p2 === void 0 && (p2 = m2(o4, s4));
          const a3 = n3 ? m2(o4, s4) : p2;
          a3.width = o4, a3.height = s4;
          return a3.getContext("2d").drawImage(t4, 0, 0, o4, s4), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t4.width + "x" + t4.height + ") to (" + o4 + "x" + s4 + ")."), a3;
        }
        return "data" in t4 && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t4.width + "x" + t4.height + ")."), t4;
      }
      return t4;
    }
    function v2(t4) {
      return $n(t4.width) && $n(t4.height);
    }
    function _2(t4, e4) {
      return t4.generateMipmaps && e4 && t4.minFilter !== xt && t4.minFilter !== Et;
    }
    function y2(e4, n3, r4, o4, s4 = 1) {
      t3.generateMipmap(e4);
      i2.get(n3).__maxMipLevel = Math.log2(Math.max(r4, o4, s4));
    }
    function x2(n3, i3, r4) {
      if (a2 === false)
        return i3;
      if (n3 !== null) {
        if (t3[n3] !== void 0)
          return t3[n3];
        console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n3 + "'");
      }
      let o4 = i3;
      return i3 === 6403 && (r4 === 5126 && (o4 = 33326), r4 === 5131 && (o4 = 33325), r4 === 5121 && (o4 = 33321)), i3 === 6407 && (r4 === 5126 && (o4 = 34837), r4 === 5131 && (o4 = 34843), r4 === 5121 && (o4 = 32849)), i3 === 6408 && (r4 === 5126 && (o4 = 34836), r4 === 5131 && (o4 = 34842), r4 === 5121 && (o4 = 32856)), o4 !== 33325 && o4 !== 33326 && o4 !== 34842 && o4 !== 34836 || e3.get("EXT_color_buffer_float"), o4;
    }
    function b2(t4) {
      return t4 === xt || t4 === bt || t4 === wt ? 9728 : 9729;
    }
    function T2(e4) {
      const n3 = e4.target;
      n3.removeEventListener("dispose", T2), function(e5) {
        const n4 = i2.get(e5);
        if (n4.__webglInit === void 0)
          return;
        t3.deleteTexture(n4.__webglTexture), i2.remove(e5);
      }(n3), n3.isVideoTexture && d2.delete(n3), s3.memory.textures--;
    }
    function w2(e4) {
      const n3 = e4.target;
      n3.removeEventListener("dispose", w2), function(e5) {
        const n4 = e5.texture, r4 = i2.get(e5), o4 = i2.get(n4);
        if (!e5)
          return;
        o4.__webglTexture !== void 0 && (t3.deleteTexture(o4.__webglTexture), s3.memory.textures--);
        e5.depthTexture && e5.depthTexture.dispose();
        if (e5.isWebGLCubeRenderTarget)
          for (let e6 = 0; e6 < 6; e6++)
            t3.deleteFramebuffer(r4.__webglFramebuffer[e6]), r4.__webglDepthbuffer && t3.deleteRenderbuffer(r4.__webglDepthbuffer[e6]);
        else
          t3.deleteFramebuffer(r4.__webglFramebuffer), r4.__webglDepthbuffer && t3.deleteRenderbuffer(r4.__webglDepthbuffer), r4.__webglMultisampledFramebuffer && t3.deleteFramebuffer(r4.__webglMultisampledFramebuffer), r4.__webglColorRenderbuffer && t3.deleteRenderbuffer(r4.__webglColorRenderbuffer), r4.__webglDepthRenderbuffer && t3.deleteRenderbuffer(r4.__webglDepthRenderbuffer);
        if (e5.isWebGLMultipleRenderTargets)
          for (let e6 = 0, r5 = n4.length; e6 < r5; e6++) {
            const r6 = i2.get(n4[e6]);
            r6.__webglTexture && (t3.deleteTexture(r6.__webglTexture), s3.memory.textures--), i2.remove(n4[e6]);
          }
        i2.remove(n4), i2.remove(e5);
      }(n3);
    }
    let S2 = 0;
    function E2(t4, e4) {
      const r4 = i2.get(t4);
      if (t4.isVideoTexture && function(t5) {
        const e5 = s3.render.frame;
        d2.get(t5) !== e5 && (d2.set(t5, e5), t5.update());
      }(t4), t4.version > 0 && r4.__version !== t4.version) {
        const n3 = t4.image;
        if (n3 === void 0)
          console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
        else {
          if (n3.complete !== false)
            return void I2(r4, t4, e4);
          console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
        }
      }
      n2.activeTexture(33984 + e4), n2.bindTexture(3553, r4.__webglTexture);
    }
    function M2(e4, r4) {
      const s4 = i2.get(e4);
      e4.version > 0 && s4.__version !== e4.version ? function(e5, i3, r5) {
        if (i3.image.length !== 6)
          return;
        C2(e5, i3), n2.activeTexture(33984 + r5), n2.bindTexture(34067, e5.__webglTexture), t3.pixelStorei(37440, i3.flipY), t3.pixelStorei(37441, i3.premultiplyAlpha), t3.pixelStorei(3317, i3.unpackAlignment), t3.pixelStorei(37443, 0);
        const s5 = i3 && (i3.isCompressedTexture || i3.image[0].isCompressedTexture), l3 = i3.image[0] && i3.image[0].isDataTexture, h3 = [];
        for (let t4 = 0; t4 < 6; t4++)
          h3[t4] = s5 || l3 ? l3 ? i3.image[t4].image : i3.image[t4] : g2(i3.image[t4], false, true, u2);
        const c3 = h3[0], d3 = v2(c3) || a2, p3 = o3.convert(i3.format), f3 = o3.convert(i3.type), m3 = x2(i3.internalFormat, p3, f3);
        let b3;
        if (P2(34067, i3, d3), s5) {
          for (let t4 = 0; t4 < 6; t4++) {
            b3 = h3[t4].mipmaps;
            for (let e6 = 0; e6 < b3.length; e6++) {
              const r6 = b3[e6];
              i3.format !== Vt && i3.format !== jt ? p3 !== null ? n2.compressedTexImage2D(34069 + t4, e6, m3, r6.width, r6.height, 0, r6.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n2.texImage2D(34069 + t4, e6, m3, r6.width, r6.height, 0, p3, f3, r6.data);
            }
          }
          e5.__maxMipLevel = b3.length - 1;
        } else {
          b3 = i3.mipmaps;
          for (let t4 = 0; t4 < 6; t4++)
            if (l3) {
              n2.texImage2D(34069 + t4, 0, m3, h3[t4].width, h3[t4].height, 0, p3, f3, h3[t4].data);
              for (let e6 = 0; e6 < b3.length; e6++) {
                const i4 = b3[e6].image[t4].image;
                n2.texImage2D(34069 + t4, e6 + 1, m3, i4.width, i4.height, 0, p3, f3, i4.data);
              }
            } else {
              n2.texImage2D(34069 + t4, 0, m3, p3, f3, h3[t4]);
              for (let e6 = 0; e6 < b3.length; e6++) {
                const i4 = b3[e6];
                n2.texImage2D(34069 + t4, e6 + 1, m3, p3, f3, i4.image[t4]);
              }
            }
          e5.__maxMipLevel = b3.length;
        }
        _2(i3, d3) && y2(34067, i3, c3.width, c3.height);
        e5.__version = i3.version, i3.onUpdate && i3.onUpdate(i3);
      }(s4, e4, r4) : (n2.activeTexture(33984 + r4), n2.bindTexture(34067, s4.__webglTexture));
    }
    const A2 = { [vt]: 10497, [_t]: 33071, [yt]: 33648 }, R2 = { [xt]: 9728, [bt]: 9984, [wt]: 9986, [Et]: 9729, [Mt]: 9985, [Rt]: 9987 };
    function P2(n3, o4, s4) {
      if (s4 ? (t3.texParameteri(n3, 10242, A2[o4.wrapS]), t3.texParameteri(n3, 10243, A2[o4.wrapT]), n3 !== 32879 && n3 !== 35866 || t3.texParameteri(n3, 32882, A2[o4.wrapR]), t3.texParameteri(n3, 10240, R2[o4.magFilter]), t3.texParameteri(n3, 10241, R2[o4.minFilter])) : (t3.texParameteri(n3, 10242, 33071), t3.texParameteri(n3, 10243, 33071), n3 !== 32879 && n3 !== 35866 || t3.texParameteri(n3, 32882, 33071), o4.wrapS === _t && o4.wrapT === _t || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t3.texParameteri(n3, 10240, b2(o4.magFilter)), t3.texParameteri(n3, 10241, b2(o4.minFilter)), o4.minFilter !== xt && o4.minFilter !== Et && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), e3.has("EXT_texture_filter_anisotropic") === true) {
        const s5 = e3.get("EXT_texture_filter_anisotropic");
        if (o4.type === Ft && e3.has("OES_texture_float_linear") === false)
          return;
        if (a2 === false && o4.type === Bt && e3.has("OES_texture_half_float_linear") === false)
          return;
        (o4.anisotropy > 1 || i2.get(o4).__currentAnisotropy) && (t3.texParameterf(n3, s5.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(o4.anisotropy, r3.getMaxAnisotropy())), i2.get(o4).__currentAnisotropy = o4.anisotropy);
      }
    }
    function C2(e4, n3) {
      e4.__webglInit === void 0 && (e4.__webglInit = true, n3.addEventListener("dispose", T2), e4.__webglTexture = t3.createTexture(), s3.memory.textures++);
    }
    function I2(e4, i3, r4) {
      let s4 = 3553;
      i3.isDataTexture2DArray && (s4 = 35866), i3.isDataTexture3D && (s4 = 32879), C2(e4, i3), n2.activeTexture(33984 + r4), n2.bindTexture(s4, e4.__webglTexture), t3.pixelStorei(37440, i3.flipY), t3.pixelStorei(37441, i3.premultiplyAlpha), t3.pixelStorei(3317, i3.unpackAlignment), t3.pixelStorei(37443, 0);
      const l3 = function(t4) {
        return !a2 && (t4.wrapS !== _t || t4.wrapT !== _t || t4.minFilter !== xt && t4.minFilter !== Et);
      }(i3) && v2(i3.image) === false, u3 = g2(i3.image, l3, false, h2), c3 = v2(u3) || a2, d3 = o3.convert(i3.format);
      let p3, f3 = o3.convert(i3.type), m3 = x2(i3.internalFormat, d3, f3);
      P2(s4, i3, c3);
      const b3 = i3.mipmaps;
      if (i3.isDepthTexture)
        m3 = 6402, a2 ? m3 = i3.type === Ft ? 36012 : i3.type === Dt ? 33190 : i3.type === Ht ? 35056 : 33189 : i3.type === Ft && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), i3.format === Yt && m3 === 6402 && i3.type !== Lt && i3.type !== Dt && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), i3.type = Lt, f3 = o3.convert(i3.type)), i3.format === Zt && m3 === 6402 && (m3 = 34041, i3.type !== Ht && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), i3.type = Ht, f3 = o3.convert(i3.type))), n2.texImage2D(3553, 0, m3, u3.width, u3.height, 0, d3, f3, null);
      else if (i3.isDataTexture)
        if (b3.length > 0 && c3) {
          for (let t4 = 0, e5 = b3.length; t4 < e5; t4++)
            p3 = b3[t4], n2.texImage2D(3553, t4, m3, p3.width, p3.height, 0, d3, f3, p3.data);
          i3.generateMipmaps = false, e4.__maxMipLevel = b3.length - 1;
        } else
          n2.texImage2D(3553, 0, m3, u3.width, u3.height, 0, d3, f3, u3.data), e4.__maxMipLevel = 0;
      else if (i3.isCompressedTexture) {
        for (let t4 = 0, e5 = b3.length; t4 < e5; t4++)
          p3 = b3[t4], i3.format !== Vt && i3.format !== jt ? d3 !== null ? n2.compressedTexImage2D(3553, t4, m3, p3.width, p3.height, 0, p3.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n2.texImage2D(3553, t4, m3, p3.width, p3.height, 0, d3, f3, p3.data);
        e4.__maxMipLevel = b3.length - 1;
      } else if (i3.isDataTexture2DArray)
        n2.texImage3D(35866, 0, m3, u3.width, u3.height, u3.depth, 0, d3, f3, u3.data), e4.__maxMipLevel = 0;
      else if (i3.isDataTexture3D)
        n2.texImage3D(32879, 0, m3, u3.width, u3.height, u3.depth, 0, d3, f3, u3.data), e4.__maxMipLevel = 0;
      else if (b3.length > 0 && c3) {
        for (let t4 = 0, e5 = b3.length; t4 < e5; t4++)
          p3 = b3[t4], n2.texImage2D(3553, t4, m3, d3, f3, p3);
        i3.generateMipmaps = false, e4.__maxMipLevel = b3.length - 1;
      } else
        n2.texImage2D(3553, 0, m3, d3, f3, u3), e4.__maxMipLevel = 0;
      _2(i3, c3) && y2(s4, i3, u3.width, u3.height), e4.__version = i3.version, i3.onUpdate && i3.onUpdate(i3);
    }
    function O2(e4, r4, s4, a3, l3) {
      const u3 = o3.convert(s4.format), h3 = o3.convert(s4.type), c3 = x2(s4.internalFormat, u3, h3);
      l3 === 32879 || l3 === 35866 ? n2.texImage3D(l3, 0, c3, r4.width, r4.height, r4.depth, 0, u3, h3, null) : n2.texImage2D(l3, 0, c3, r4.width, r4.height, 0, u3, h3, null), n2.bindFramebuffer(36160, e4), t3.framebufferTexture2D(36160, a3, l3, i2.get(s4).__webglTexture, 0), n2.bindFramebuffer(36160, null);
    }
    function L2(e4, n3, i3) {
      if (t3.bindRenderbuffer(36161, e4), n3.depthBuffer && !n3.stencilBuffer) {
        let r4 = 33189;
        if (i3) {
          const e5 = n3.depthTexture;
          e5 && e5.isDepthTexture && (e5.type === Ft ? r4 = 36012 : e5.type === Dt && (r4 = 33190));
          const i4 = D2(n3);
          t3.renderbufferStorageMultisample(36161, i4, r4, n3.width, n3.height);
        } else
          t3.renderbufferStorage(36161, r4, n3.width, n3.height);
        t3.framebufferRenderbuffer(36160, 36096, 36161, e4);
      } else if (n3.depthBuffer && n3.stencilBuffer) {
        if (i3) {
          const e5 = D2(n3);
          t3.renderbufferStorageMultisample(36161, e5, 35056, n3.width, n3.height);
        } else
          t3.renderbufferStorage(36161, 34041, n3.width, n3.height);
        t3.framebufferRenderbuffer(36160, 33306, 36161, e4);
      } else {
        const e5 = n3.isWebGLMultipleRenderTargets === true ? n3.texture[0] : n3.texture, r4 = o3.convert(e5.format), s4 = o3.convert(e5.type), a3 = x2(e5.internalFormat, r4, s4);
        if (i3) {
          const e6 = D2(n3);
          t3.renderbufferStorageMultisample(36161, e6, a3, n3.width, n3.height);
        } else
          t3.renderbufferStorage(36161, a3, n3.width, n3.height);
      }
      t3.bindRenderbuffer(36161, null);
    }
    function N2(e4) {
      const r4 = i2.get(e4), o4 = e4.isWebGLCubeRenderTarget === true;
      if (e4.depthTexture) {
        if (o4)
          throw new Error("target.depthTexture not supported in Cube render targets");
        !function(e5, r5) {
          if (r5 && r5.isWebGLCubeRenderTarget)
            throw new Error("Depth Texture with cube render targets is not supported");
          if (n2.bindFramebuffer(36160, e5), !r5.depthTexture || !r5.depthTexture.isDepthTexture)
            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
          i2.get(r5.depthTexture).__webglTexture && r5.depthTexture.image.width === r5.width && r5.depthTexture.image.height === r5.height || (r5.depthTexture.image.width = r5.width, r5.depthTexture.image.height = r5.height, r5.depthTexture.needsUpdate = true), E2(r5.depthTexture, 0);
          const o5 = i2.get(r5.depthTexture).__webglTexture;
          if (r5.depthTexture.format === Yt)
            t3.framebufferTexture2D(36160, 36096, 3553, o5, 0);
          else {
            if (r5.depthTexture.format !== Zt)
              throw new Error("Unknown depthTexture format");
            t3.framebufferTexture2D(36160, 33306, 3553, o5, 0);
          }
        }(r4.__webglFramebuffer, e4);
      } else if (o4) {
        r4.__webglDepthbuffer = [];
        for (let i3 = 0; i3 < 6; i3++)
          n2.bindFramebuffer(36160, r4.__webglFramebuffer[i3]), r4.__webglDepthbuffer[i3] = t3.createRenderbuffer(), L2(r4.__webglDepthbuffer[i3], e4, false);
      } else
        n2.bindFramebuffer(36160, r4.__webglFramebuffer), r4.__webglDepthbuffer = t3.createRenderbuffer(), L2(r4.__webglDepthbuffer, e4, false);
      n2.bindFramebuffer(36160, null);
    }
    function D2(t4) {
      return a2 && t4.isWebGLMultisampleRenderTarget ? Math.min(c2, t4.samples) : 0;
    }
    let F2 = false, B2 = false;
    this.allocateTextureUnit = function() {
      const t4 = S2;
      return t4 >= l2 && console.warn("THREE.WebGLTextures: Trying to use " + t4 + " texture units while this GPU supports only " + l2), S2 += 1, t4;
    }, this.resetTextureUnits = function() {
      S2 = 0;
    }, this.setTexture2D = E2, this.setTexture2DArray = function(t4, e4) {
      const r4 = i2.get(t4);
      t4.version > 0 && r4.__version !== t4.version ? I2(r4, t4, e4) : (n2.activeTexture(33984 + e4), n2.bindTexture(35866, r4.__webglTexture));
    }, this.setTexture3D = function(t4, e4) {
      const r4 = i2.get(t4);
      t4.version > 0 && r4.__version !== t4.version ? I2(r4, t4, e4) : (n2.activeTexture(33984 + e4), n2.bindTexture(32879, r4.__webglTexture));
    }, this.setTextureCube = M2, this.setupRenderTarget = function(e4) {
      const l3 = e4.texture, u3 = i2.get(e4), h3 = i2.get(l3);
      e4.addEventListener("dispose", w2), e4.isWebGLMultipleRenderTargets !== true && (h3.__webglTexture = t3.createTexture(), h3.__version = l3.version, s3.memory.textures++);
      const c3 = e4.isWebGLCubeRenderTarget === true, d3 = e4.isWebGLMultipleRenderTargets === true, p3 = e4.isWebGLMultisampleRenderTarget === true, f3 = l3.isDataTexture3D || l3.isDataTexture2DArray, m3 = v2(e4) || a2;
      if (!a2 || l3.format !== jt || l3.type !== Ft && l3.type !== Bt || (l3.format = Vt, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), c3) {
        u3.__webglFramebuffer = [];
        for (let e5 = 0; e5 < 6; e5++)
          u3.__webglFramebuffer[e5] = t3.createFramebuffer();
      } else if (u3.__webglFramebuffer = t3.createFramebuffer(), d3)
        if (r3.drawBuffers) {
          const n3 = e4.texture;
          for (let e5 = 0, r4 = n3.length; e5 < r4; e5++) {
            const r5 = i2.get(n3[e5]);
            r5.__webglTexture === void 0 && (r5.__webglTexture = t3.createTexture(), s3.memory.textures++);
          }
        } else
          console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
      else if (p3)
        if (a2) {
          u3.__webglMultisampledFramebuffer = t3.createFramebuffer(), u3.__webglColorRenderbuffer = t3.createRenderbuffer(), t3.bindRenderbuffer(36161, u3.__webglColorRenderbuffer);
          const i3 = o3.convert(l3.format), r4 = o3.convert(l3.type), s4 = x2(l3.internalFormat, i3, r4), a3 = D2(e4);
          t3.renderbufferStorageMultisample(36161, a3, s4, e4.width, e4.height), n2.bindFramebuffer(36160, u3.__webglMultisampledFramebuffer), t3.framebufferRenderbuffer(36160, 36064, 36161, u3.__webglColorRenderbuffer), t3.bindRenderbuffer(36161, null), e4.depthBuffer && (u3.__webglDepthRenderbuffer = t3.createRenderbuffer(), L2(u3.__webglDepthRenderbuffer, e4, true)), n2.bindFramebuffer(36160, null);
        } else
          console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
      if (c3) {
        n2.bindTexture(34067, h3.__webglTexture), P2(34067, l3, m3);
        for (let t4 = 0; t4 < 6; t4++)
          O2(u3.__webglFramebuffer[t4], e4, l3, 36064, 34069 + t4);
        _2(l3, m3) && y2(34067, l3, e4.width, e4.height), n2.bindTexture(34067, null);
      } else if (d3) {
        const t4 = e4.texture;
        for (let r4 = 0, o4 = t4.length; r4 < o4; r4++) {
          const o5 = t4[r4], s4 = i2.get(o5);
          n2.bindTexture(3553, s4.__webglTexture), P2(3553, o5, m3), O2(u3.__webglFramebuffer, e4, o5, 36064 + r4, 3553), _2(o5, m3) && y2(3553, o5, e4.width, e4.height);
        }
        n2.bindTexture(3553, null);
      } else {
        let t4 = 3553;
        if (f3)
          if (a2) {
            t4 = l3.isDataTexture3D ? 32879 : 35866;
          } else
            console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.");
        n2.bindTexture(t4, h3.__webglTexture), P2(t4, l3, m3), O2(u3.__webglFramebuffer, e4, l3, 36064, t4), _2(l3, m3) && y2(t4, l3, e4.width, e4.height, e4.depth), n2.bindTexture(t4, null);
      }
      e4.depthBuffer && N2(e4);
    }, this.updateRenderTargetMipmap = function(t4) {
      const e4 = v2(t4) || a2, r4 = t4.isWebGLMultipleRenderTargets === true ? t4.texture : [t4.texture];
      for (let o4 = 0, s4 = r4.length; o4 < s4; o4++) {
        const s5 = r4[o4];
        if (_2(s5, e4)) {
          const e5 = t4.isWebGLCubeRenderTarget ? 34067 : 3553, r5 = i2.get(s5).__webglTexture;
          n2.bindTexture(e5, r5), y2(e5, s5, t4.width, t4.height), n2.bindTexture(e5, null);
        }
      }
    }, this.updateMultisampleRenderTarget = function(e4) {
      if (e4.isWebGLMultisampleRenderTarget)
        if (a2) {
          const r4 = e4.width, o4 = e4.height;
          let s4 = 16384;
          e4.depthBuffer && (s4 |= 256), e4.stencilBuffer && (s4 |= 1024);
          const a3 = i2.get(e4);
          n2.bindFramebuffer(36008, a3.__webglMultisampledFramebuffer), n2.bindFramebuffer(36009, a3.__webglFramebuffer), t3.blitFramebuffer(0, 0, r4, o4, 0, 0, r4, o4, s4, 9728), n2.bindFramebuffer(36008, null), n2.bindFramebuffer(36009, a3.__webglMultisampledFramebuffer);
        } else
          console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
    }, this.safeSetTexture2D = function(t4, e4) {
      t4 && t4.isWebGLRenderTarget && (F2 === false && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), F2 = true), t4 = t4.texture), E2(t4, e4);
    }, this.safeSetTextureCube = function(t4, e4) {
      t4 && t4.isWebGLCubeRenderTarget && (B2 === false && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), B2 = true), t4 = t4.texture), M2(t4, e4);
    };
  }
  function $a(t3, e3, n2) {
    const i2 = n2.isWebGL2;
    return { convert: function(t4) {
      let n3;
      if (t4 === Ct)
        return 5121;
      if (t4 === Ut)
        return 32819;
      if (t4 === kt)
        return 32820;
      if (t4 === Gt)
        return 33635;
      if (t4 === It)
        return 5120;
      if (t4 === Ot)
        return 5122;
      if (t4 === Lt)
        return 5123;
      if (t4 === Nt)
        return 5124;
      if (t4 === Dt)
        return 5125;
      if (t4 === Ft)
        return 5126;
      if (t4 === Bt)
        return i2 ? 5131 : (n3 = e3.get("OES_texture_half_float"), n3 !== null ? n3.HALF_FLOAT_OES : null);
      if (t4 === zt)
        return 6406;
      if (t4 === jt)
        return 6407;
      if (t4 === Vt)
        return 6408;
      if (t4 === Wt)
        return 6409;
      if (t4 === Xt)
        return 6410;
      if (t4 === Yt)
        return 6402;
      if (t4 === Zt)
        return 34041;
      if (t4 === Jt)
        return 6403;
      if (t4 === $t)
        return 36244;
      if (t4 === Kt)
        return 33319;
      if (t4 === Qt)
        return 33320;
      if (t4 === te)
        return 36248;
      if (t4 === ee)
        return 36249;
      if (t4 === ne || t4 === ie || t4 === re || t4 === oe) {
        if (n3 = e3.get("WEBGL_compressed_texture_s3tc"), n3 === null)
          return null;
        if (t4 === ne)
          return n3.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (t4 === ie)
          return n3.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (t4 === re)
          return n3.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (t4 === oe)
          return n3.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      }
      if (t4 === se || t4 === ae || t4 === le || t4 === ue) {
        if (n3 = e3.get("WEBGL_compressed_texture_pvrtc"), n3 === null)
          return null;
        if (t4 === se)
          return n3.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (t4 === ae)
          return n3.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (t4 === le)
          return n3.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (t4 === ue)
          return n3.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      }
      if (t4 === he)
        return n3 = e3.get("WEBGL_compressed_texture_etc1"), n3 !== null ? n3.COMPRESSED_RGB_ETC1_WEBGL : null;
      if ((t4 === ce || t4 === de) && (n3 = e3.get("WEBGL_compressed_texture_etc"), n3 !== null)) {
        if (t4 === ce)
          return n3.COMPRESSED_RGB8_ETC2;
        if (t4 === de)
          return n3.COMPRESSED_RGBA8_ETC2_EAC;
      }
      return t4 === pe || t4 === fe || t4 === me || t4 === ge || t4 === ve || t4 === _e || t4 === ye || t4 === xe || t4 === be || t4 === Te || t4 === we || t4 === Se || t4 === Ee || t4 === Me || t4 === Re || t4 === Pe || t4 === Ce || t4 === Ie || t4 === Oe || t4 === Le || t4 === Ne || t4 === De || t4 === Fe || t4 === Be || t4 === Ue || t4 === ke || t4 === Ge || t4 === He ? (n3 = e3.get("WEBGL_compressed_texture_astc"), n3 !== null ? t4 : null) : t4 === Ae ? (n3 = e3.get("EXT_texture_compression_bptc"), n3 !== null ? t4 : null) : t4 === Ht ? i2 ? 34042 : (n3 = e3.get("WEBGL_depth_texture"), n3 !== null ? n3.UNSIGNED_INT_24_8_WEBGL : null) : void 0;
    } };
  }
  class Ka extends Lo {
    constructor(t3 = []) {
      super(), this.cameras = t3;
    }
  }
  Ka.prototype.isArrayCamera = true;
  class Qa extends mr {
    constructor() {
      super(), this.type = "Group";
    }
  }
  Qa.prototype.isGroup = true;
  const tl = { type: "move" };
  class el {
    constructor() {
      this._targetRay = null, this._grip = null, this._hand = null;
    }
    getHandSpace() {
      return this._hand === null && (this._hand = new Qa(), this._hand.matrixAutoUpdate = false, this._hand.visible = false, this._hand.joints = {}, this._hand.inputState = { pinching: false }), this._hand;
    }
    getTargetRaySpace() {
      return this._targetRay === null && (this._targetRay = new Qa(), this._targetRay.matrixAutoUpdate = false, this._targetRay.visible = false, this._targetRay.hasLinearVelocity = false, this._targetRay.linearVelocity = new pi(), this._targetRay.hasAngularVelocity = false, this._targetRay.angularVelocity = new pi()), this._targetRay;
    }
    getGripSpace() {
      return this._grip === null && (this._grip = new Qa(), this._grip.matrixAutoUpdate = false, this._grip.visible = false, this._grip.hasLinearVelocity = false, this._grip.linearVelocity = new pi(), this._grip.hasAngularVelocity = false, this._grip.angularVelocity = new pi()), this._grip;
    }
    dispatchEvent(t3) {
      return this._targetRay !== null && this._targetRay.dispatchEvent(t3), this._grip !== null && this._grip.dispatchEvent(t3), this._hand !== null && this._hand.dispatchEvent(t3), this;
    }
    disconnect(t3) {
      return this.dispatchEvent({ type: "disconnected", data: t3 }), this._targetRay !== null && (this._targetRay.visible = false), this._grip !== null && (this._grip.visible = false), this._hand !== null && (this._hand.visible = false), this;
    }
    update(t3, e3, n2) {
      let i2 = null, r3 = null, o3 = null;
      const s3 = this._targetRay, a2 = this._grip, l2 = this._hand;
      if (t3 && e3.session.visibilityState !== "visible-blurred")
        if (s3 !== null && (i2 = e3.getPose(t3.targetRaySpace, n2), i2 !== null && (s3.matrix.fromArray(i2.transform.matrix), s3.matrix.decompose(s3.position, s3.rotation, s3.scale), i2.linearVelocity ? (s3.hasLinearVelocity = true, s3.linearVelocity.copy(i2.linearVelocity)) : s3.hasLinearVelocity = false, i2.angularVelocity ? (s3.hasAngularVelocity = true, s3.angularVelocity.copy(i2.angularVelocity)) : s3.hasAngularVelocity = false, this.dispatchEvent(tl))), l2 && t3.hand) {
          o3 = true;
          for (const i4 of t3.hand.values()) {
            const t4 = e3.getJointPose(i4, n2);
            if (l2.joints[i4.jointName] === void 0) {
              const t5 = new Qa();
              t5.matrixAutoUpdate = false, t5.visible = false, l2.joints[i4.jointName] = t5, l2.add(t5);
            }
            const r5 = l2.joints[i4.jointName];
            t4 !== null && (r5.matrix.fromArray(t4.transform.matrix), r5.matrix.decompose(r5.position, r5.rotation, r5.scale), r5.jointRadius = t4.radius), r5.visible = t4 !== null;
          }
          const i3 = l2.joints["index-finger-tip"], r4 = l2.joints["thumb-tip"], s4 = i3.position.distanceTo(r4.position), a3 = 0.02, u2 = 5e-3;
          l2.inputState.pinching && s4 > a3 + u2 ? (l2.inputState.pinching = false, this.dispatchEvent({ type: "pinchend", handedness: t3.handedness, target: this })) : !l2.inputState.pinching && s4 <= a3 - u2 && (l2.inputState.pinching = true, this.dispatchEvent({ type: "pinchstart", handedness: t3.handedness, target: this }));
        } else
          a2 !== null && t3.gripSpace && (r3 = e3.getPose(t3.gripSpace, n2), r3 !== null && (a2.matrix.fromArray(r3.transform.matrix), a2.matrix.decompose(a2.position, a2.rotation, a2.scale), r3.linearVelocity ? (a2.hasLinearVelocity = true, a2.linearVelocity.copy(r3.linearVelocity)) : a2.hasLinearVelocity = false, r3.angularVelocity ? (a2.hasAngularVelocity = true, a2.angularVelocity.copy(r3.angularVelocity)) : a2.hasAngularVelocity = false));
      return s3 !== null && (s3.visible = i2 !== null), a2 !== null && (a2.visible = r3 !== null), l2 !== null && (l2.visible = o3 !== null), this;
    }
  }
  class nl extends zn {
    constructor(t3, e3) {
      super();
      const n2 = this, i2 = t3.state;
      let r3 = null, o3 = 1, s3 = null, a2 = "local-floor", l2 = null, u2 = null, h2 = null, c2 = null;
      const d2 = [], p2 = new Map(), f2 = new Lo();
      f2.layers.enable(1), f2.viewport = new li();
      const m2 = new Lo();
      m2.layers.enable(2), m2.viewport = new li();
      const g2 = [f2, m2], v2 = new Ka();
      v2.layers.enable(1), v2.layers.enable(2);
      let _2 = null, y2 = null;
      function x2(t4) {
        const e4 = p2.get(t4.inputSource);
        e4 && e4.dispatchEvent({ type: t4.type, data: t4.inputSource });
      }
      function b2() {
        p2.forEach(function(t4, e4) {
          t4.disconnect(e4);
        }), p2.clear(), _2 = null, y2 = null, i2.bindXRFramebuffer(null), t3.setRenderTarget(t3.getRenderTarget()), A2.stop(), n2.isPresenting = false, n2.dispatchEvent({ type: "sessionend" });
      }
      function T2(t4) {
        const e4 = r3.inputSources;
        for (let t5 = 0; t5 < d2.length; t5++)
          p2.set(e4[t5], d2[t5]);
        for (let e5 = 0; e5 < t4.removed.length; e5++) {
          const n3 = t4.removed[e5], i3 = p2.get(n3);
          i3 && (i3.dispatchEvent({ type: "disconnected", data: n3 }), p2.delete(n3));
        }
        for (let e5 = 0; e5 < t4.added.length; e5++) {
          const n3 = t4.added[e5], i3 = p2.get(n3);
          i3 && i3.dispatchEvent({ type: "connected", data: n3 });
        }
      }
      this.cameraAutoUpdate = true, this.enabled = false, this.isPresenting = false, this.getController = function(t4) {
        let e4 = d2[t4];
        return e4 === void 0 && (e4 = new el(), d2[t4] = e4), e4.getTargetRaySpace();
      }, this.getControllerGrip = function(t4) {
        let e4 = d2[t4];
        return e4 === void 0 && (e4 = new el(), d2[t4] = e4), e4.getGripSpace();
      }, this.getHand = function(t4) {
        let e4 = d2[t4];
        return e4 === void 0 && (e4 = new el(), d2[t4] = e4), e4.getHandSpace();
      }, this.setFramebufferScaleFactor = function(t4) {
        o3 = t4, n2.isPresenting === true && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
      }, this.setReferenceSpaceType = function(t4) {
        a2 = t4, n2.isPresenting === true && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
      }, this.getReferenceSpace = function() {
        return s3;
      }, this.getSession = function() {
        return r3;
      }, this.setSession = async function(t4) {
        if (r3 = t4, r3 !== null) {
          r3.addEventListener("select", x2), r3.addEventListener("selectstart", x2), r3.addEventListener("selectend", x2), r3.addEventListener("squeeze", x2), r3.addEventListener("squeezestart", x2), r3.addEventListener("squeezeend", x2), r3.addEventListener("end", b2), r3.addEventListener("inputsourceschange", T2);
          const t5 = e3.getContextAttributes();
          if (t5.xrCompatible !== true && await e3.makeXRCompatible(), r3.renderState.layers === void 0) {
            const n3 = { antialias: t5.antialias, alpha: t5.alpha, depth: t5.depth, stencil: t5.stencil, framebufferScaleFactor: o3 }, i3 = new XRWebGLLayer(r3, e3, n3);
            r3.updateRenderState({ baseLayer: i3 });
          } else {
            let n3 = 0;
            t5.depth && (n3 = t5.stencil ? 34041 : 6402);
            const i3 = { colorFormat: t5.alpha ? 6408 : 6407, depthFormat: n3, scaleFactor: o3 };
            u2 = new XRWebGLBinding(r3, e3), c2 = u2.createProjectionLayer(i3), h2 = e3.createFramebuffer(), r3.updateRenderState({ layers: [c2] });
          }
          s3 = await r3.requestReferenceSpace(a2), A2.setContext(r3), A2.start(), n2.isPresenting = true, n2.dispatchEvent({ type: "sessionstart" });
        }
      };
      const w2 = new pi(), S2 = new pi();
      function E2(t4, e4) {
        e4 === null ? t4.matrixWorld.copy(t4.matrix) : t4.matrixWorld.multiplyMatrices(e4.matrixWorld, t4.matrix), t4.matrixWorldInverse.copy(t4.matrixWorld).invert();
      }
      this.updateCamera = function(t4) {
        if (r3 === null)
          return;
        v2.near = m2.near = f2.near = t4.near, v2.far = m2.far = f2.far = t4.far, _2 === v2.near && y2 === v2.far || (r3.updateRenderState({ depthNear: v2.near, depthFar: v2.far }), _2 = v2.near, y2 = v2.far);
        const e4 = t4.parent, n3 = v2.cameras;
        E2(v2, e4);
        for (let t5 = 0; t5 < n3.length; t5++)
          E2(n3[t5], e4);
        v2.matrixWorld.decompose(v2.position, v2.quaternion, v2.scale), t4.position.copy(v2.position), t4.quaternion.copy(v2.quaternion), t4.scale.copy(v2.scale), t4.matrix.copy(v2.matrix), t4.matrixWorld.copy(v2.matrixWorld);
        const i3 = t4.children;
        for (let t5 = 0, e5 = i3.length; t5 < e5; t5++)
          i3[t5].updateMatrixWorld(true);
        n3.length === 2 ? function(t5, e5, n4) {
          w2.setFromMatrixPosition(e5.matrixWorld), S2.setFromMatrixPosition(n4.matrixWorld);
          const i4 = w2.distanceTo(S2), r4 = e5.projectionMatrix.elements, o4 = n4.projectionMatrix.elements, s4 = r4[14] / (r4[10] - 1), a3 = r4[14] / (r4[10] + 1), l3 = (r4[9] + 1) / r4[5], u3 = (r4[9] - 1) / r4[5], h3 = (r4[8] - 1) / r4[0], c3 = (o4[8] + 1) / o4[0], d3 = s4 * h3, p3 = s4 * c3, f3 = i4 / (-h3 + c3), m3 = f3 * -h3;
          e5.matrixWorld.decompose(t5.position, t5.quaternion, t5.scale), t5.translateX(m3), t5.translateZ(f3), t5.matrixWorld.compose(t5.position, t5.quaternion, t5.scale), t5.matrixWorldInverse.copy(t5.matrixWorld).invert();
          const g3 = s4 + f3, v3 = a3 + f3, _3 = d3 - m3, y3 = p3 + (i4 - m3), x3 = l3 * a3 / v3 * g3, b3 = u3 * a3 / v3 * g3;
          t5.projectionMatrix.makePerspective(_3, y3, x3, b3, g3, v3);
        }(v2, f2, m2) : v2.projectionMatrix.copy(f2.projectionMatrix);
      }, this.getCamera = function() {
        return v2;
      };
      let M2 = null;
      const A2 = new Vo();
      A2.setAnimationLoop(function(t4, n3) {
        if (l2 = n3.getViewerPose(s3), l2 !== null) {
          const t5 = l2.views, n4 = r3.renderState.baseLayer;
          r3.renderState.layers === void 0 && i2.bindXRFramebuffer(n4.framebuffer);
          let o5 = false;
          t5.length !== v2.cameras.length && (v2.cameras.length = 0, o5 = true);
          for (let s4 = 0; s4 < t5.length; s4++) {
            const a3 = t5[s4];
            let l3 = null;
            if (r3.renderState.layers === void 0)
              l3 = n4.getViewport(a3);
            else {
              const t6 = u2.getViewSubImage(c2, a3);
              i2.bindXRFramebuffer(h2), e3.framebufferTexture2D(36160, 36064, 3553, t6.colorTexture, 0), t6.depthStencilTexture !== void 0 && e3.framebufferTexture2D(36160, 36096, 3553, t6.depthStencilTexture, 0), l3 = t6.viewport;
            }
            const d3 = g2[s4];
            d3.matrix.fromArray(a3.transform.matrix), d3.projectionMatrix.fromArray(a3.projectionMatrix), d3.viewport.set(l3.x, l3.y, l3.width, l3.height), s4 === 0 && v2.matrix.copy(d3.matrix), o5 === true && v2.cameras.push(d3);
          }
        }
        const o4 = r3.inputSources;
        for (let t5 = 0; t5 < d2.length; t5++) {
          const e4 = d2[t5], i3 = o4[t5];
          e4.update(i3, n3, s3);
        }
        M2 && M2(t4, n3);
      }), this.setAnimationLoop = function(t4) {
        M2 = t4;
      }, this.dispose = function() {
      };
    }
  }
  function il(t3) {
    function e3(e4, n3) {
      e4.opacity.value = n3.opacity, n3.color && e4.diffuse.value.copy(n3.color), n3.emissive && e4.emissive.value.copy(n3.emissive).multiplyScalar(n3.emissiveIntensity), n3.map && (e4.map.value = n3.map), n3.alphaMap && (e4.alphaMap.value = n3.alphaMap), n3.specularMap && (e4.specularMap.value = n3.specularMap);
      const i2 = t3.get(n3).envMap;
      if (i2) {
        e4.envMap.value = i2, e4.flipEnvMap.value = i2.isCubeTexture && i2._needsFlipEnvMap ? -1 : 1, e4.reflectivity.value = n3.reflectivity, e4.refractionRatio.value = n3.refractionRatio;
        const r4 = t3.get(i2).__maxMipLevel;
        r4 !== void 0 && (e4.maxMipLevel.value = r4);
      }
      let r3, o3;
      n3.lightMap && (e4.lightMap.value = n3.lightMap, e4.lightMapIntensity.value = n3.lightMapIntensity), n3.aoMap && (e4.aoMap.value = n3.aoMap, e4.aoMapIntensity.value = n3.aoMapIntensity), n3.map ? r3 = n3.map : n3.specularMap ? r3 = n3.specularMap : n3.displacementMap ? r3 = n3.displacementMap : n3.normalMap ? r3 = n3.normalMap : n3.bumpMap ? r3 = n3.bumpMap : n3.roughnessMap ? r3 = n3.roughnessMap : n3.metalnessMap ? r3 = n3.metalnessMap : n3.alphaMap ? r3 = n3.alphaMap : n3.emissiveMap ? r3 = n3.emissiveMap : n3.clearcoatMap ? r3 = n3.clearcoatMap : n3.clearcoatNormalMap ? r3 = n3.clearcoatNormalMap : n3.clearcoatRoughnessMap && (r3 = n3.clearcoatRoughnessMap), r3 !== void 0 && (r3.isWebGLRenderTarget && (r3 = r3.texture), r3.matrixAutoUpdate === true && r3.updateMatrix(), e4.uvTransform.value.copy(r3.matrix)), n3.aoMap ? o3 = n3.aoMap : n3.lightMap && (o3 = n3.lightMap), o3 !== void 0 && (o3.isWebGLRenderTarget && (o3 = o3.texture), o3.matrixAutoUpdate === true && o3.updateMatrix(), e4.uv2Transform.value.copy(o3.matrix));
    }
    function n2(e4, n3) {
      e4.roughness.value = n3.roughness, e4.metalness.value = n3.metalness, n3.roughnessMap && (e4.roughnessMap.value = n3.roughnessMap), n3.metalnessMap && (e4.metalnessMap.value = n3.metalnessMap), n3.emissiveMap && (e4.emissiveMap.value = n3.emissiveMap), n3.bumpMap && (e4.bumpMap.value = n3.bumpMap, e4.bumpScale.value = n3.bumpScale, n3.side === b && (e4.bumpScale.value *= -1)), n3.normalMap && (e4.normalMap.value = n3.normalMap, e4.normalScale.value.copy(n3.normalScale), n3.side === b && e4.normalScale.value.negate()), n3.displacementMap && (e4.displacementMap.value = n3.displacementMap, e4.displacementScale.value = n3.displacementScale, e4.displacementBias.value = n3.displacementBias);
      t3.get(n3).envMap && (e4.envMapIntensity.value = n3.envMapIntensity);
    }
    return { refreshFogUniforms: function(t4, e4) {
      t4.fogColor.value.copy(e4.color), e4.isFog ? (t4.fogNear.value = e4.near, t4.fogFar.value = e4.far) : e4.isFogExp2 && (t4.fogDensity.value = e4.density);
    }, refreshMaterialUniforms: function(t4, i2, r3, o3, s3) {
      i2.isMeshBasicMaterial ? e3(t4, i2) : i2.isMeshLambertMaterial ? (e3(t4, i2), function(t5, e4) {
        e4.emissiveMap && (t5.emissiveMap.value = e4.emissiveMap);
      }(t4, i2)) : i2.isMeshToonMaterial ? (e3(t4, i2), function(t5, e4) {
        e4.gradientMap && (t5.gradientMap.value = e4.gradientMap);
        e4.emissiveMap && (t5.emissiveMap.value = e4.emissiveMap);
        e4.bumpMap && (t5.bumpMap.value = e4.bumpMap, t5.bumpScale.value = e4.bumpScale, e4.side === b && (t5.bumpScale.value *= -1));
        e4.normalMap && (t5.normalMap.value = e4.normalMap, t5.normalScale.value.copy(e4.normalScale), e4.side === b && t5.normalScale.value.negate());
        e4.displacementMap && (t5.displacementMap.value = e4.displacementMap, t5.displacementScale.value = e4.displacementScale, t5.displacementBias.value = e4.displacementBias);
      }(t4, i2)) : i2.isMeshPhongMaterial ? (e3(t4, i2), function(t5, e4) {
        t5.specular.value.copy(e4.specular), t5.shininess.value = Math.max(e4.shininess, 1e-4), e4.emissiveMap && (t5.emissiveMap.value = e4.emissiveMap);
        e4.bumpMap && (t5.bumpMap.value = e4.bumpMap, t5.bumpScale.value = e4.bumpScale, e4.side === b && (t5.bumpScale.value *= -1));
        e4.normalMap && (t5.normalMap.value = e4.normalMap, t5.normalScale.value.copy(e4.normalScale), e4.side === b && t5.normalScale.value.negate());
        e4.displacementMap && (t5.displacementMap.value = e4.displacementMap, t5.displacementScale.value = e4.displacementScale, t5.displacementBias.value = e4.displacementBias);
      }(t4, i2)) : i2.isMeshStandardMaterial ? (e3(t4, i2), i2.isMeshPhysicalMaterial ? function(t5, e4, i3) {
        n2(t5, e4), t5.reflectivity.value = e4.reflectivity, t5.clearcoat.value = e4.clearcoat, t5.clearcoatRoughness.value = e4.clearcoatRoughness, e4.sheen && t5.sheen.value.copy(e4.sheen);
        e4.clearcoatMap && (t5.clearcoatMap.value = e4.clearcoatMap);
        e4.clearcoatRoughnessMap && (t5.clearcoatRoughnessMap.value = e4.clearcoatRoughnessMap);
        e4.clearcoatNormalMap && (t5.clearcoatNormalScale.value.copy(e4.clearcoatNormalScale), t5.clearcoatNormalMap.value = e4.clearcoatNormalMap, e4.side === b && t5.clearcoatNormalScale.value.negate());
        t5.transmission.value = e4.transmission, e4.transmissionMap && (t5.transmissionMap.value = e4.transmissionMap);
        e4.transmission > 0 && (t5.transmissionSamplerMap.value = i3.texture, t5.transmissionSamplerSize.value.set(i3.width, i3.height));
        t5.thickness.value = e4.thickness, e4.thicknessMap && (t5.thicknessMap.value = e4.thicknessMap);
        t5.attenuationDistance.value = e4.attenuationDistance, t5.attenuationColor.value.copy(e4.attenuationColor);
      }(t4, i2, s3) : n2(t4, i2)) : i2.isMeshMatcapMaterial ? (e3(t4, i2), function(t5, e4) {
        e4.matcap && (t5.matcap.value = e4.matcap);
        e4.bumpMap && (t5.bumpMap.value = e4.bumpMap, t5.bumpScale.value = e4.bumpScale, e4.side === b && (t5.bumpScale.value *= -1));
        e4.normalMap && (t5.normalMap.value = e4.normalMap, t5.normalScale.value.copy(e4.normalScale), e4.side === b && t5.normalScale.value.negate());
        e4.displacementMap && (t5.displacementMap.value = e4.displacementMap, t5.displacementScale.value = e4.displacementScale, t5.displacementBias.value = e4.displacementBias);
      }(t4, i2)) : i2.isMeshDepthMaterial ? (e3(t4, i2), function(t5, e4) {
        e4.displacementMap && (t5.displacementMap.value = e4.displacementMap, t5.displacementScale.value = e4.displacementScale, t5.displacementBias.value = e4.displacementBias);
      }(t4, i2)) : i2.isMeshDistanceMaterial ? (e3(t4, i2), function(t5, e4) {
        e4.displacementMap && (t5.displacementMap.value = e4.displacementMap, t5.displacementScale.value = e4.displacementScale, t5.displacementBias.value = e4.displacementBias);
        t5.referencePosition.value.copy(e4.referencePosition), t5.nearDistance.value = e4.nearDistance, t5.farDistance.value = e4.farDistance;
      }(t4, i2)) : i2.isMeshNormalMaterial ? (e3(t4, i2), function(t5, e4) {
        e4.bumpMap && (t5.bumpMap.value = e4.bumpMap, t5.bumpScale.value = e4.bumpScale, e4.side === b && (t5.bumpScale.value *= -1));
        e4.normalMap && (t5.normalMap.value = e4.normalMap, t5.normalScale.value.copy(e4.normalScale), e4.side === b && t5.normalScale.value.negate());
        e4.displacementMap && (t5.displacementMap.value = e4.displacementMap, t5.displacementScale.value = e4.displacementScale, t5.displacementBias.value = e4.displacementBias);
      }(t4, i2)) : i2.isLineBasicMaterial ? (function(t5, e4) {
        t5.diffuse.value.copy(e4.color), t5.opacity.value = e4.opacity;
      }(t4, i2), i2.isLineDashedMaterial && function(t5, e4) {
        t5.dashSize.value = e4.dashSize, t5.totalSize.value = e4.dashSize + e4.gapSize, t5.scale.value = e4.scale;
      }(t4, i2)) : i2.isPointsMaterial ? function(t5, e4, n3, i3) {
        t5.diffuse.value.copy(e4.color), t5.opacity.value = e4.opacity, t5.size.value = e4.size * n3, t5.scale.value = 0.5 * i3, e4.map && (t5.map.value = e4.map);
        e4.alphaMap && (t5.alphaMap.value = e4.alphaMap);
        let r4;
        e4.map ? r4 = e4.map : e4.alphaMap && (r4 = e4.alphaMap);
        r4 !== void 0 && (r4.matrixAutoUpdate === true && r4.updateMatrix(), t5.uvTransform.value.copy(r4.matrix));
      }(t4, i2, r3, o3) : i2.isSpriteMaterial ? function(t5, e4) {
        t5.diffuse.value.copy(e4.color), t5.opacity.value = e4.opacity, t5.rotation.value = e4.rotation, e4.map && (t5.map.value = e4.map);
        e4.alphaMap && (t5.alphaMap.value = e4.alphaMap);
        let n3;
        e4.map ? n3 = e4.map : e4.alphaMap && (n3 = e4.alphaMap);
        n3 !== void 0 && (n3.matrixAutoUpdate === true && n3.updateMatrix(), t5.uvTransform.value.copy(n3.matrix));
      }(t4, i2) : i2.isShadowMaterial ? (t4.color.value.copy(i2.color), t4.opacity.value = i2.opacity) : i2.isShaderMaterial && (i2.uniformsNeedUpdate = false);
    } };
  }
  function rl(t3 = {}) {
    const e3 = t3.canvas !== void 0 ? t3.canvas : function() {
      const t4 = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
      return t4.style.display = "block", t4;
    }(), n2 = t3.context !== void 0 ? t3.context : null, i2 = t3.alpha !== void 0 && t3.alpha, r3 = t3.depth === void 0 || t3.depth, o3 = t3.stencil === void 0 || t3.stencil, s3 = t3.antialias !== void 0 && t3.antialias, a2 = t3.premultipliedAlpha === void 0 || t3.premultipliedAlpha, l2 = t3.preserveDrawingBuffer !== void 0 && t3.preserveDrawingBuffer, u2 = t3.powerPreference !== void 0 ? t3.powerPreference : "default", h2 = t3.failIfMajorPerformanceCaveat !== void 0 && t3.failIfMajorPerformanceCaveat;
    let c2 = null, d2 = null;
    const p2 = [], f2 = [];
    this.domElement = e3, this.debug = { checkShaderErrors: true }, this.autoClear = true, this.autoClearColor = true, this.autoClearDepth = true, this.autoClearStencil = true, this.sortObjects = true, this.clippingPlanes = [], this.localClippingEnabled = false, this.gammaFactor = 2, this.outputEncoding = nn, this.physicallyCorrectLights = false, this.toneMapping = rt, this.toneMappingExposure = 1;
    const m2 = this;
    let g2 = false, v2 = 0, _2 = 0, y2 = null, w2 = -1, S2 = null;
    const E2 = new li(), M2 = new li();
    let A2 = null, R2 = e3.width, P2 = e3.height, C2 = 1, I2 = null, O2 = null;
    const L2 = new li(0, 0, R2, P2), N2 = new li(0, 0, R2, P2);
    let D2 = false;
    const F2 = [], B2 = new jo();
    let U2 = false, k2 = false, G2 = null;
    const H2 = new Vi(), z2 = new pi(), j2 = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };
    function V2() {
      return y2 === null ? C2 : 1;
    }
    let W2, X2, q2, Y2, Z2, J2, $2, K2, Q2, tt2, et2, nt2, it2, ot2, st2, at2, lt2, ut2, ht2, ct2, dt2, pt2, ft2 = n2;
    function mt2(t4, n3) {
      for (let i3 = 0; i3 < t4.length; i3++) {
        const r4 = t4[i3], o4 = e3.getContext(r4, n3);
        if (o4 !== null)
          return o4;
      }
      return null;
    }
    try {
      const t4 = { alpha: i2, depth: r3, stencil: o3, antialias: s3, premultipliedAlpha: a2, preserveDrawingBuffer: l2, powerPreference: u2, failIfMajorPerformanceCaveat: h2 };
      if (e3.addEventListener("webglcontextlost", yt2, false), e3.addEventListener("webglcontextrestored", bt2, false), ft2 === null) {
        const e4 = ["webgl2", "webgl", "experimental-webgl"];
        if (m2.isWebGL1Renderer === true && e4.shift(), ft2 = mt2(e4, t4), ft2 === null)
          throw mt2(e4) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
      }
      ft2.getShaderPrecisionFormat === void 0 && (ft2.getShaderPrecisionFormat = function() {
        return { rangeMin: 1, rangeMax: 1, precision: 1 };
      });
    } catch (t4) {
      throw console.error("THREE.WebGLRenderer: " + t4.message), t4;
    }
    function gt2() {
      W2 = new ns(ft2), X2 = new Qo(ft2, W2, t3), W2.init(X2), dt2 = new $a(ft2, W2, X2), q2 = new Za(ft2, W2, X2), F2[0] = 1029, Y2 = new os(ft2), Z2 = new Da(), J2 = new Ja(ft2, W2, q2, Z2, X2, dt2, Y2), $2 = new es(m2), K2 = new Wo(ft2, X2), pt2 = new $o(ft2, W2, K2, X2), Q2 = new is(ft2, K2, Y2, pt2), tt2 = new us(ft2, Q2, K2, Y2), ut2 = new ls(ft2), st2 = new ts(Z2), et2 = new Na(m2, $2, W2, X2, pt2, st2), nt2 = new il(Z2), it2 = new ka(Z2), ot2 = new Wa(W2, X2), lt2 = new Jo(m2, $2, q2, tt2, a2), at2 = new Ya(m2, tt2, X2), ht2 = new Ko(ft2, W2, Y2, X2), ct2 = new rs(ft2, W2, Y2, X2), Y2.programs = et2.programs, m2.capabilities = X2, m2.extensions = W2, m2.properties = Z2, m2.renderLists = it2, m2.shadowMap = at2, m2.state = q2, m2.info = Y2;
    }
    gt2();
    const vt2 = new nl(m2, ft2);
    function yt2(t4) {
      t4.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), g2 = true;
    }
    function bt2() {
      console.log("THREE.WebGLRenderer: Context Restored."), g2 = false;
      const t4 = Y2.autoReset, e4 = at2.enabled, n3 = at2.autoUpdate, i3 = at2.needsUpdate, r4 = at2.type;
      gt2(), Y2.autoReset = t4, at2.enabled = e4, at2.autoUpdate = n3, at2.needsUpdate = i3, at2.type = r4;
    }
    function Tt2(t4) {
      const e4 = t4.target;
      e4.removeEventListener("dispose", Tt2), function(t5) {
        (function(t6) {
          const e5 = Z2.get(t6).programs;
          e5 !== void 0 && e5.forEach(function(t7) {
            et2.releaseProgram(t7);
          });
        })(t5), Z2.remove(t5);
      }(e4);
    }
    this.xr = vt2, this.getContext = function() {
      return ft2;
    }, this.getContextAttributes = function() {
      return ft2.getContextAttributes();
    }, this.forceContextLoss = function() {
      const t4 = W2.get("WEBGL_lose_context");
      t4 && t4.loseContext();
    }, this.forceContextRestore = function() {
      const t4 = W2.get("WEBGL_lose_context");
      t4 && t4.restoreContext();
    }, this.getPixelRatio = function() {
      return C2;
    }, this.setPixelRatio = function(t4) {
      t4 !== void 0 && (C2 = t4, this.setSize(R2, P2, false));
    }, this.getSize = function(t4) {
      return t4.set(R2, P2);
    }, this.setSize = function(t4, n3, i3) {
      vt2.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (R2 = t4, P2 = n3, e3.width = Math.floor(t4 * C2), e3.height = Math.floor(n3 * C2), i3 !== false && (e3.style.width = t4 + "px", e3.style.height = n3 + "px"), this.setViewport(0, 0, t4, n3));
    }, this.getDrawingBufferSize = function(t4) {
      return t4.set(R2 * C2, P2 * C2).floor();
    }, this.setDrawingBufferSize = function(t4, n3, i3) {
      R2 = t4, P2 = n3, C2 = i3, e3.width = Math.floor(t4 * i3), e3.height = Math.floor(n3 * i3), this.setViewport(0, 0, t4, n3);
    }, this.getCurrentViewport = function(t4) {
      return t4.copy(E2);
    }, this.getViewport = function(t4) {
      return t4.copy(L2);
    }, this.setViewport = function(t4, e4, n3, i3) {
      t4.isVector4 ? L2.set(t4.x, t4.y, t4.z, t4.w) : L2.set(t4, e4, n3, i3), q2.viewport(E2.copy(L2).multiplyScalar(C2).floor());
    }, this.getScissor = function(t4) {
      return t4.copy(N2);
    }, this.setScissor = function(t4, e4, n3, i3) {
      t4.isVector4 ? N2.set(t4.x, t4.y, t4.z, t4.w) : N2.set(t4, e4, n3, i3), q2.scissor(M2.copy(N2).multiplyScalar(C2).floor());
    }, this.getScissorTest = function() {
      return D2;
    }, this.setScissorTest = function(t4) {
      q2.setScissorTest(D2 = t4);
    }, this.setOpaqueSort = function(t4) {
      I2 = t4;
    }, this.setTransparentSort = function(t4) {
      O2 = t4;
    }, this.getClearColor = function(t4) {
      return t4.copy(lt2.getClearColor());
    }, this.setClearColor = function() {
      lt2.setClearColor.apply(lt2, arguments);
    }, this.getClearAlpha = function() {
      return lt2.getClearAlpha();
    }, this.setClearAlpha = function() {
      lt2.setClearAlpha.apply(lt2, arguments);
    }, this.clear = function(t4, e4, n3) {
      let i3 = 0;
      (t4 === void 0 || t4) && (i3 |= 16384), (e4 === void 0 || e4) && (i3 |= 256), (n3 === void 0 || n3) && (i3 |= 1024), ft2.clear(i3);
    }, this.clearColor = function() {
      this.clear(true, false, false);
    }, this.clearDepth = function() {
      this.clear(false, true, false);
    }, this.clearStencil = function() {
      this.clear(false, false, true);
    }, this.dispose = function() {
      e3.removeEventListener("webglcontextlost", yt2, false), e3.removeEventListener("webglcontextrestored", bt2, false), it2.dispose(), ot2.dispose(), Z2.dispose(), $2.dispose(), tt2.dispose(), pt2.dispose(), vt2.dispose(), vt2.removeEventListener("sessionstart", St2), vt2.removeEventListener("sessionend", Et2), G2 && (G2.dispose(), G2 = null), Mt2.stop();
    }, this.renderBufferImmediate = function(t4, e4) {
      pt2.initAttributes();
      const n3 = Z2.get(t4);
      t4.hasPositions && !n3.position && (n3.position = ft2.createBuffer()), t4.hasNormals && !n3.normal && (n3.normal = ft2.createBuffer()), t4.hasUvs && !n3.uv && (n3.uv = ft2.createBuffer()), t4.hasColors && !n3.color && (n3.color = ft2.createBuffer());
      const i3 = e4.getAttributes();
      t4.hasPositions && (ft2.bindBuffer(34962, n3.position), ft2.bufferData(34962, t4.positionArray, 35048), pt2.enableAttribute(i3.position), ft2.vertexAttribPointer(i3.position, 3, 5126, false, 0, 0)), t4.hasNormals && (ft2.bindBuffer(34962, n3.normal), ft2.bufferData(34962, t4.normalArray, 35048), pt2.enableAttribute(i3.normal), ft2.vertexAttribPointer(i3.normal, 3, 5126, false, 0, 0)), t4.hasUvs && (ft2.bindBuffer(34962, n3.uv), ft2.bufferData(34962, t4.uvArray, 35048), pt2.enableAttribute(i3.uv), ft2.vertexAttribPointer(i3.uv, 2, 5126, false, 0, 0)), t4.hasColors && (ft2.bindBuffer(34962, n3.color), ft2.bufferData(34962, t4.colorArray, 35048), pt2.enableAttribute(i3.color), ft2.vertexAttribPointer(i3.color, 3, 5126, false, 0, 0)), pt2.disableUnusedAttributes(), ft2.drawArrays(4, 0, t4.count), t4.count = 0;
    }, this.renderBufferDirect = function(t4, e4, n3, i3, r4, o4) {
      e4 === null && (e4 = j2);
      const s4 = r4.isMesh && r4.matrixWorld.determinant() < 0, a3 = Lt2(t4, e4, i3, r4);
      q2.setMaterial(i3, s4);
      let l3 = n3.index;
      const u3 = n3.attributes.position;
      if (l3 === null) {
        if (u3 === void 0 || u3.count === 0)
          return;
      } else if (l3.count === 0)
        return;
      let h3, c3 = 1;
      i3.wireframe === true && (l3 = Q2.getWireframeAttribute(n3), c3 = 2), (i3.morphTargets || i3.morphNormals) && ut2.update(r4, n3, i3, a3), pt2.setup(r4, i3, a3, n3, l3);
      let d3 = ht2;
      l3 !== null && (h3 = K2.get(l3), d3 = ct2, d3.setIndex(h3));
      const p3 = l3 !== null ? l3.count : u3.count, f3 = n3.drawRange.start * c3, m3 = n3.drawRange.count * c3, g3 = o4 !== null ? o4.start * c3 : 0, v3 = o4 !== null ? o4.count * c3 : 1 / 0, _3 = Math.max(f3, g3), y3 = Math.min(p3, f3 + m3, g3 + v3) - 1, x2 = Math.max(0, y3 - _3 + 1);
      if (x2 !== 0) {
        if (r4.isMesh)
          i3.wireframe === true ? (q2.setLineWidth(i3.wireframeLinewidth * V2()), d3.setMode(1)) : d3.setMode(4);
        else if (r4.isLine) {
          let t5 = i3.linewidth;
          t5 === void 0 && (t5 = 1), q2.setLineWidth(t5 * V2()), r4.isLineSegments ? d3.setMode(1) : r4.isLineLoop ? d3.setMode(2) : d3.setMode(3);
        } else
          r4.isPoints ? d3.setMode(0) : r4.isSprite && d3.setMode(4);
        if (r4.isInstancedMesh)
          d3.renderInstances(_3, x2, r4.count);
        else if (n3.isInstancedBufferGeometry) {
          const t5 = Math.min(n3.instanceCount, n3._maxInstanceCount);
          d3.renderInstances(_3, x2, t5);
        } else
          d3.render(_3, x2);
      }
    }, this.compile = function(t4, e4) {
      d2 = ot2.get(t4), d2.init(), t4.traverseVisible(function(t5) {
        t5.isLight && t5.layers.test(e4.layers) && (d2.pushLight(t5), t5.castShadow && d2.pushShadow(t5));
      }), d2.setupLights(), t4.traverse(function(e5) {
        const n3 = e5.material;
        if (n3)
          if (Array.isArray(n3))
            for (let i3 = 0; i3 < n3.length; i3++) {
              It2(n3[i3], t4, e5);
            }
          else
            It2(n3, t4, e5);
      });
    };
    let wt2 = null;
    function St2() {
      Mt2.stop();
    }
    function Et2() {
      Mt2.start();
    }
    const Mt2 = new Vo();
    function At2(t4, e4, n3) {
      const i3 = e4.isScene === true ? e4.overrideMaterial : null;
      for (let r4 = 0, o4 = t4.length; r4 < o4; r4++) {
        const o5 = t4[r4], s4 = o5.object, a3 = o5.geometry, l3 = i3 === null ? o5.material : i3, u3 = o5.group;
        if (n3.isArrayCamera) {
          const t5 = n3.cameras;
          for (let n4 = 0, i4 = t5.length; n4 < i4; n4++) {
            const i5 = t5[n4];
            s4.layers.test(i5.layers) && (q2.viewport(E2.copy(i5.viewport)), d2.setupLightsView(i5), Pt2(s4, e4, i5, a3, l3, u3));
          }
        } else
          Pt2(s4, e4, n3, a3, l3, u3);
      }
    }
    function Pt2(t4, e4, n3, i3, r4, o4) {
      if (t4.onBeforeRender(m2, e4, n3, i3, r4, o4), t4.modelViewMatrix.multiplyMatrices(n3.matrixWorldInverse, t4.matrixWorld), t4.normalMatrix.getNormalMatrix(t4.modelViewMatrix), t4.isImmediateRenderObject) {
        const i4 = Lt2(n3, e4, r4, t4);
        q2.setMaterial(r4), pt2.reset(), function(t5, e5) {
          t5.render(function(t6) {
            m2.renderBufferImmediate(t6, e5);
          });
        }(t4, i4);
      } else
        r4.transparent === true && r4.side === T ? (r4.side = b, r4.needsUpdate = true, m2.renderBufferDirect(n3, e4, i3, r4, t4, o4), r4.side = x, r4.needsUpdate = true, m2.renderBufferDirect(n3, e4, i3, r4, t4, o4), r4.side = T) : m2.renderBufferDirect(n3, e4, i3, r4, t4, o4);
      t4.onAfterRender(m2, e4, n3, i3, r4, o4);
    }
    function It2(t4, e4, n3) {
      e4.isScene !== true && (e4 = j2);
      const i3 = Z2.get(t4), r4 = d2.state.lights, o4 = d2.state.shadowsArray, s4 = r4.state.version, a3 = et2.getParameters(t4, r4.state, o4, e4, n3), l3 = et2.getProgramCacheKey(a3);
      let u3 = i3.programs;
      i3.environment = t4.isMeshStandardMaterial ? e4.environment : null, i3.fog = e4.fog, i3.envMap = $2.get(t4.envMap || i3.environment), u3 === void 0 && (t4.addEventListener("dispose", Tt2), u3 = new Map(), i3.programs = u3);
      let h3 = u3.get(l3);
      if (h3 !== void 0) {
        if (i3.currentProgram === h3 && i3.lightsStateVersion === s4)
          return Ot2(t4, a3), h3;
      } else
        a3.uniforms = et2.getUniforms(t4), t4.onBuild(a3, m2), t4.onBeforeCompile(a3, m2), h3 = et2.acquireProgram(a3, l3), u3.set(l3, h3), i3.uniforms = a3.uniforms;
      const c3 = i3.uniforms;
      (t4.isShaderMaterial || t4.isRawShaderMaterial) && t4.clipping !== true || (c3.clippingPlanes = st2.uniform), Ot2(t4, a3), i3.needsLights = function(t5) {
        return t5.isMeshLambertMaterial || t5.isMeshToonMaterial || t5.isMeshPhongMaterial || t5.isMeshStandardMaterial || t5.isShadowMaterial || t5.isShaderMaterial && t5.lights === true;
      }(t4), i3.lightsStateVersion = s4, i3.needsLights && (c3.ambientLightColor.value = r4.state.ambient, c3.lightProbe.value = r4.state.probe, c3.directionalLights.value = r4.state.directional, c3.directionalLightShadows.value = r4.state.directionalShadow, c3.spotLights.value = r4.state.spot, c3.spotLightShadows.value = r4.state.spotShadow, c3.rectAreaLights.value = r4.state.rectArea, c3.ltc_1.value = r4.state.rectAreaLTC1, c3.ltc_2.value = r4.state.rectAreaLTC2, c3.pointLights.value = r4.state.point, c3.pointLightShadows.value = r4.state.pointShadow, c3.hemisphereLights.value = r4.state.hemi, c3.directionalShadowMap.value = r4.state.directionalShadowMap, c3.directionalShadowMatrix.value = r4.state.directionalShadowMatrix, c3.spotShadowMap.value = r4.state.spotShadowMap, c3.spotShadowMatrix.value = r4.state.spotShadowMatrix, c3.pointShadowMap.value = r4.state.pointShadowMap, c3.pointShadowMatrix.value = r4.state.pointShadowMatrix);
      const p3 = h3.getUniforms(), f3 = pa.seqWithValue(p3.seq, c3);
      return i3.currentProgram = h3, i3.uniformsList = f3, h3;
    }
    function Ot2(t4, e4) {
      const n3 = Z2.get(t4);
      n3.outputEncoding = e4.outputEncoding, n3.instancing = e4.instancing, n3.skinning = e4.skinning, n3.numClippingPlanes = e4.numClippingPlanes, n3.numIntersection = e4.numClipIntersection, n3.vertexAlphas = e4.vertexAlphas;
    }
    function Lt2(t4, e4, n3, i3) {
      e4.isScene !== true && (e4 = j2), J2.resetTextureUnits();
      const r4 = e4.fog, o4 = n3.isMeshStandardMaterial ? e4.environment : null, s4 = y2 === null ? m2.outputEncoding : y2.texture.encoding, a3 = $2.get(n3.envMap || o4), l3 = n3.vertexColors === true && i3.geometry && i3.geometry.attributes.color && i3.geometry.attributes.color.itemSize === 4, u3 = Z2.get(n3), h3 = d2.state.lights;
      if (U2 === true && (k2 === true || t4 !== S2)) {
        const e5 = t4 === S2 && n3.id === w2;
        st2.setState(n3, t4, e5);
      }
      let c3 = false;
      n3.version === u3.__version ? u3.needsLights && u3.lightsStateVersion !== h3.state.version || u3.outputEncoding !== s4 || i3.isInstancedMesh && u3.instancing === false ? c3 = true : i3.isInstancedMesh || u3.instancing !== true ? i3.isSkinnedMesh && u3.skinning === false ? c3 = true : i3.isSkinnedMesh || u3.skinning !== true ? u3.envMap !== a3 || n3.fog && u3.fog !== r4 ? c3 = true : u3.numClippingPlanes === void 0 || u3.numClippingPlanes === st2.numPlanes && u3.numIntersection === st2.numIntersection ? u3.vertexAlphas !== l3 && (c3 = true) : c3 = true : c3 = true : c3 = true : (c3 = true, u3.__version = n3.version);
      let p3 = u3.currentProgram;
      c3 === true && (p3 = It2(n3, e4, i3));
      let f3 = false, g3 = false, v3 = false;
      const _3 = p3.getUniforms(), x2 = u3.uniforms;
      if (q2.useProgram(p3.program) && (f3 = true, g3 = true, v3 = true), n3.id !== w2 && (w2 = n3.id, g3 = true), f3 || S2 !== t4) {
        if (_3.setValue(ft2, "projectionMatrix", t4.projectionMatrix), X2.logarithmicDepthBuffer && _3.setValue(ft2, "logDepthBufFC", 2 / (Math.log(t4.far + 1) / Math.LN2)), S2 !== t4 && (S2 = t4, g3 = true, v3 = true), n3.isShaderMaterial || n3.isMeshPhongMaterial || n3.isMeshToonMaterial || n3.isMeshStandardMaterial || n3.envMap) {
          const e5 = _3.map.cameraPosition;
          e5 !== void 0 && e5.setValue(ft2, z2.setFromMatrixPosition(t4.matrixWorld));
        }
        (n3.isMeshPhongMaterial || n3.isMeshToonMaterial || n3.isMeshLambertMaterial || n3.isMeshBasicMaterial || n3.isMeshStandardMaterial || n3.isShaderMaterial) && _3.setValue(ft2, "isOrthographic", t4.isOrthographicCamera === true), (n3.isMeshPhongMaterial || n3.isMeshToonMaterial || n3.isMeshLambertMaterial || n3.isMeshBasicMaterial || n3.isMeshStandardMaterial || n3.isShaderMaterial || n3.isShadowMaterial || i3.isSkinnedMesh) && _3.setValue(ft2, "viewMatrix", t4.matrixWorldInverse);
      }
      if (i3.isSkinnedMesh) {
        _3.setOptional(ft2, i3, "bindMatrix"), _3.setOptional(ft2, i3, "bindMatrixInverse");
        const t5 = i3.skeleton;
        t5 && (X2.floatVertexTextures ? (t5.boneTexture === null && t5.computeBoneTexture(), _3.setValue(ft2, "boneTexture", t5.boneTexture, J2), _3.setValue(ft2, "boneTextureSize", t5.boneTextureSize)) : _3.setOptional(ft2, t5, "boneMatrices"));
      }
      var b2, T2;
      return (g3 || u3.receiveShadow !== i3.receiveShadow) && (u3.receiveShadow = i3.receiveShadow, _3.setValue(ft2, "receiveShadow", i3.receiveShadow)), g3 && (_3.setValue(ft2, "toneMappingExposure", m2.toneMappingExposure), u3.needsLights && (T2 = v3, (b2 = x2).ambientLightColor.needsUpdate = T2, b2.lightProbe.needsUpdate = T2, b2.directionalLights.needsUpdate = T2, b2.directionalLightShadows.needsUpdate = T2, b2.pointLights.needsUpdate = T2, b2.pointLightShadows.needsUpdate = T2, b2.spotLights.needsUpdate = T2, b2.spotLightShadows.needsUpdate = T2, b2.rectAreaLights.needsUpdate = T2, b2.hemisphereLights.needsUpdate = T2), r4 && n3.fog && nt2.refreshFogUniforms(x2, r4), nt2.refreshMaterialUniforms(x2, n3, C2, P2, G2), pa.upload(ft2, u3.uniformsList, x2, J2)), n3.isShaderMaterial && n3.uniformsNeedUpdate === true && (pa.upload(ft2, u3.uniformsList, x2, J2), n3.uniformsNeedUpdate = false), n3.isSpriteMaterial && _3.setValue(ft2, "center", i3.center), _3.setValue(ft2, "modelViewMatrix", i3.modelViewMatrix), _3.setValue(ft2, "normalMatrix", i3.normalMatrix), _3.setValue(ft2, "modelMatrix", i3.matrixWorld), p3;
    }
    Mt2.setAnimationLoop(function(t4) {
      wt2 && wt2(t4);
    }), typeof window != "undefined" && Mt2.setContext(window), this.setAnimationLoop = function(t4) {
      wt2 = t4, vt2.setAnimationLoop(t4), t4 === null ? Mt2.stop() : Mt2.start();
    }, vt2.addEventListener("sessionstart", St2), vt2.addEventListener("sessionend", Et2), this.render = function(t4, e4) {
      if (e4 !== void 0 && e4.isCamera !== true)
        return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
      if (g2 === true)
        return;
      t4.autoUpdate === true && t4.updateMatrixWorld(), e4.parent === null && e4.updateMatrixWorld(), vt2.enabled === true && vt2.isPresenting === true && (vt2.cameraAutoUpdate === true && vt2.updateCamera(e4), e4 = vt2.getCamera()), t4.isScene === true && t4.onBeforeRender(m2, t4, e4, y2), d2 = ot2.get(t4, f2.length), d2.init(), f2.push(d2), H2.multiplyMatrices(e4.projectionMatrix, e4.matrixWorldInverse), B2.setFromProjectionMatrix(H2), k2 = this.localClippingEnabled, U2 = st2.init(this.clippingPlanes, k2, e4), c2 = it2.get(t4, p2.length), c2.init(), p2.push(c2), function t5(e5, n4, i4, r5) {
        if (e5.visible === false)
          return;
        if (e5.layers.test(n4.layers)) {
          if (e5.isGroup)
            i4 = e5.renderOrder;
          else if (e5.isLOD)
            e5.autoUpdate === true && e5.update(n4);
          else if (e5.isLight)
            d2.pushLight(e5), e5.castShadow && d2.pushShadow(e5);
          else if (e5.isSprite) {
            if (!e5.frustumCulled || B2.intersectsSprite(e5)) {
              r5 && z2.setFromMatrixPosition(e5.matrixWorld).applyMatrix4(H2);
              const t6 = tt2.update(e5), n5 = e5.material;
              n5.visible && c2.push(e5, t6, n5, i4, z2.z, null);
            }
          } else if (e5.isImmediateRenderObject)
            r5 && z2.setFromMatrixPosition(e5.matrixWorld).applyMatrix4(H2), c2.push(e5, null, e5.material, i4, z2.z, null);
          else if ((e5.isMesh || e5.isLine || e5.isPoints) && (e5.isSkinnedMesh && e5.skeleton.frame !== Y2.render.frame && (e5.skeleton.update(), e5.skeleton.frame = Y2.render.frame), !e5.frustumCulled || B2.intersectsObject(e5))) {
            r5 && z2.setFromMatrixPosition(e5.matrixWorld).applyMatrix4(H2);
            const t6 = tt2.update(e5), n5 = e5.material;
            if (Array.isArray(n5)) {
              const r6 = t6.groups;
              for (let o6 = 0, s4 = r6.length; o6 < s4; o6++) {
                const s5 = r6[o6], a3 = n5[s5.materialIndex];
                a3 && a3.visible && c2.push(e5, t6, a3, i4, z2.z, s5);
              }
            } else
              n5.visible && c2.push(e5, t6, n5, i4, z2.z, null);
          }
        }
        const o5 = e5.children;
        for (let e6 = 0, s4 = o5.length; e6 < s4; e6++)
          t5(o5[e6], n4, i4, r5);
      }(t4, e4, 0, m2.sortObjects), c2.finish(), m2.sortObjects === true && c2.sort(I2, O2), U2 === true && st2.beginShadows();
      const n3 = d2.state.shadowsArray;
      at2.render(n3, t4, e4), d2.setupLights(), d2.setupLightsView(e4), U2 === true && st2.endShadows(), this.info.autoReset === true && this.info.reset(), lt2.render(c2, t4);
      const i3 = c2.opaque, r4 = c2.transmissive, o4 = c2.transparent;
      i3.length > 0 && At2(i3, t4, e4), r4.length > 0 && function(t5, e5, n4, i4) {
        if (G2 === null) {
          const t6 = s3 === true && X2.isWebGL2 === true;
          G2 = new (t6 ? ci : ui)(1024, 1024, { generateMipmaps: true, type: dt2.convert(Bt) !== null ? Bt : Ct, minFilter: Rt, magFilter: xt, wrapS: _t, wrapT: _t });
        }
        const r5 = m2.getRenderTarget();
        m2.setRenderTarget(G2), m2.clear();
        const o5 = m2.toneMapping;
        m2.toneMapping = rt, At2(t5, n4, i4), m2.toneMapping = o5, J2.updateMultisampleRenderTarget(G2), J2.updateRenderTargetMipmap(G2), m2.setRenderTarget(r5), At2(e5, n4, i4);
      }(i3, r4, t4, e4), o4.length > 0 && At2(o4, t4, e4), y2 !== null && (J2.updateMultisampleRenderTarget(y2), J2.updateRenderTargetMipmap(y2)), t4.isScene === true && t4.onAfterRender(m2, t4, e4), q2.buffers.depth.setTest(true), q2.buffers.depth.setMask(true), q2.buffers.color.setMask(true), q2.setPolygonOffset(false), pt2.resetDefaultState(), w2 = -1, S2 = null, f2.pop(), d2 = f2.length > 0 ? f2[f2.length - 1] : null, p2.pop(), c2 = p2.length > 0 ? p2[p2.length - 1] : null;
    }, this.getActiveCubeFace = function() {
      return v2;
    }, this.getActiveMipmapLevel = function() {
      return _2;
    }, this.getRenderTarget = function() {
      return y2;
    }, this.setRenderTarget = function(t4, e4 = 0, n3 = 0) {
      y2 = t4, v2 = e4, _2 = n3, t4 && Z2.get(t4).__webglFramebuffer === void 0 && J2.setupRenderTarget(t4);
      let i3 = null, r4 = false, o4 = false;
      if (t4) {
        const n4 = t4.texture;
        (n4.isDataTexture3D || n4.isDataTexture2DArray) && (o4 = true);
        const s4 = Z2.get(t4).__webglFramebuffer;
        t4.isWebGLCubeRenderTarget ? (i3 = s4[e4], r4 = true) : i3 = t4.isWebGLMultisampleRenderTarget ? Z2.get(t4).__webglMultisampledFramebuffer : s4, E2.copy(t4.viewport), M2.copy(t4.scissor), A2 = t4.scissorTest;
      } else
        E2.copy(L2).multiplyScalar(C2).floor(), M2.copy(N2).multiplyScalar(C2).floor(), A2 = D2;
      if (q2.bindFramebuffer(36160, i3) && X2.drawBuffers) {
        let e5 = false;
        if (t4)
          if (t4.isWebGLMultipleRenderTargets) {
            const n4 = t4.texture;
            if (F2.length !== n4.length || F2[0] !== 36064) {
              for (let t5 = 0, e6 = n4.length; t5 < e6; t5++)
                F2[t5] = 36064 + t5;
              F2.length = n4.length, e5 = true;
            }
          } else
            F2.length === 1 && F2[0] === 36064 || (F2[0] = 36064, F2.length = 1, e5 = true);
        else
          F2.length === 1 && F2[0] === 1029 || (F2[0] = 1029, F2.length = 1, e5 = true);
        e5 && (X2.isWebGL2 ? ft2.drawBuffers(F2) : W2.get("WEBGL_draw_buffers").drawBuffersWEBGL(F2));
      }
      if (q2.viewport(E2), q2.scissor(M2), q2.setScissorTest(A2), r4) {
        const i4 = Z2.get(t4.texture);
        ft2.framebufferTexture2D(36160, 36064, 34069 + e4, i4.__webglTexture, n3);
      } else if (o4) {
        const i4 = Z2.get(t4.texture), r5 = e4 || 0;
        ft2.framebufferTextureLayer(36160, 36064, i4.__webglTexture, n3 || 0, r5);
      }
    }, this.readRenderTargetPixels = function(t4, e4, n3, i3, r4, o4, s4) {
      if (!t4 || !t4.isWebGLRenderTarget)
        return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      let a3 = Z2.get(t4).__webglFramebuffer;
      if (t4.isWebGLCubeRenderTarget && s4 !== void 0 && (a3 = a3[s4]), a3) {
        q2.bindFramebuffer(36160, a3);
        try {
          const s5 = t4.texture, a4 = s5.format, l3 = s5.type;
          if (a4 !== Vt && dt2.convert(a4) !== ft2.getParameter(35739))
            return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
          const u3 = l3 === Bt && (W2.has("EXT_color_buffer_half_float") || X2.isWebGL2 && W2.has("EXT_color_buffer_float"));
          if (!(l3 === Ct || dt2.convert(l3) === ft2.getParameter(35738) || l3 === Ft && (X2.isWebGL2 || W2.has("OES_texture_float") || W2.has("WEBGL_color_buffer_float")) || u3))
            return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
          ft2.checkFramebufferStatus(36160) === 36053 ? e4 >= 0 && e4 <= t4.width - i3 && n3 >= 0 && n3 <= t4.height - r4 && ft2.readPixels(e4, n3, i3, r4, dt2.convert(a4), dt2.convert(l3), o4) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
        } finally {
          const t5 = y2 !== null ? Z2.get(y2).__webglFramebuffer : null;
          q2.bindFramebuffer(36160, t5);
        }
      }
    }, this.copyFramebufferToTexture = function(t4, e4, n3 = 0) {
      const i3 = Math.pow(2, -n3), r4 = Math.floor(e4.image.width * i3), o4 = Math.floor(e4.image.height * i3);
      let s4 = dt2.convert(e4.format);
      X2.isWebGL2 && (s4 === 6407 && (s4 = 32849), s4 === 6408 && (s4 = 32856)), J2.setTexture2D(e4, 0), ft2.copyTexImage2D(3553, n3, s4, t4.x, t4.y, r4, o4, 0), q2.unbindTexture();
    }, this.copyTextureToTexture = function(t4, e4, n3, i3 = 0) {
      const r4 = e4.image.width, o4 = e4.image.height, s4 = dt2.convert(n3.format), a3 = dt2.convert(n3.type);
      J2.setTexture2D(n3, 0), ft2.pixelStorei(37440, n3.flipY), ft2.pixelStorei(37441, n3.premultiplyAlpha), ft2.pixelStorei(3317, n3.unpackAlignment), e4.isDataTexture ? ft2.texSubImage2D(3553, i3, t4.x, t4.y, r4, o4, s4, a3, e4.image.data) : e4.isCompressedTexture ? ft2.compressedTexSubImage2D(3553, i3, t4.x, t4.y, e4.mipmaps[0].width, e4.mipmaps[0].height, s4, e4.mipmaps[0].data) : ft2.texSubImage2D(3553, i3, t4.x, t4.y, s4, a3, e4.image), i3 === 0 && n3.generateMipmaps && ft2.generateMipmap(3553), q2.unbindTexture();
    }, this.copyTextureToTexture3D = function(t4, e4, n3, i3, r4 = 0) {
      if (m2.isWebGL1Renderer)
        return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
      const o4 = t4.max.x - t4.min.x + 1, s4 = t4.max.y - t4.min.y + 1, a3 = t4.max.z - t4.min.z + 1, l3 = dt2.convert(i3.format), u3 = dt2.convert(i3.type);
      let h3;
      if (i3.isDataTexture3D)
        J2.setTexture3D(i3, 0), h3 = 32879;
      else {
        if (!i3.isDataTexture2DArray)
          return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
        J2.setTexture2DArray(i3, 0), h3 = 35866;
      }
      ft2.pixelStorei(37440, i3.flipY), ft2.pixelStorei(37441, i3.premultiplyAlpha), ft2.pixelStorei(3317, i3.unpackAlignment);
      const c3 = ft2.getParameter(3314), d3 = ft2.getParameter(32878), p3 = ft2.getParameter(3316), f3 = ft2.getParameter(3315), g3 = ft2.getParameter(32877), v3 = n3.isCompressedTexture ? n3.mipmaps[0] : n3.image;
      ft2.pixelStorei(3314, v3.width), ft2.pixelStorei(32878, v3.height), ft2.pixelStorei(3316, t4.min.x), ft2.pixelStorei(3315, t4.min.y), ft2.pixelStorei(32877, t4.min.z), n3.isDataTexture || n3.isDataTexture3D ? ft2.texSubImage3D(h3, r4, e4.x, e4.y, e4.z, o4, s4, a3, l3, u3, v3.data) : n3.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), ft2.compressedTexSubImage3D(h3, r4, e4.x, e4.y, e4.z, o4, s4, a3, l3, v3.data)) : ft2.texSubImage3D(h3, r4, e4.x, e4.y, e4.z, o4, s4, a3, l3, u3, v3), ft2.pixelStorei(3314, c3), ft2.pixelStorei(32878, d3), ft2.pixelStorei(3316, p3), ft2.pixelStorei(3315, f3), ft2.pixelStorei(32877, g3), r4 === 0 && i3.generateMipmaps && ft2.generateMipmap(h3), q2.unbindTexture();
    }, this.initTexture = function(t4) {
      J2.setTexture2D(t4, 0), q2.unbindTexture();
    }, this.resetState = function() {
      v2 = 0, _2 = 0, y2 = null, q2.reset(), pt2.reset();
    }, typeof __THREE_DEVTOOLS__ != "undefined" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  class ol extends rl {
  }
  ol.prototype.isWebGL1Renderer = true;
  class sl {
    constructor(t3, e3 = 25e-5) {
      this.name = "", this.color = new Dr(t3), this.density = e3;
    }
    clone() {
      return new sl(this.color, this.density);
    }
    toJSON() {
      return { type: "FogExp2", color: this.color.getHex(), density: this.density };
    }
  }
  sl.prototype.isFogExp2 = true;
  class al {
    constructor(t3, e3 = 1, n2 = 1e3) {
      this.name = "", this.color = new Dr(t3), this.near = e3, this.far = n2;
    }
    clone() {
      return new al(this.color, this.near, this.far);
    }
    toJSON() {
      return { type: "Fog", color: this.color.getHex(), near: this.near, far: this.far };
    }
  }
  al.prototype.isFog = true;
  class ll extends mr {
    constructor() {
      super(), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = true, typeof __THREE_DEVTOOLS__ != "undefined" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
    }
    copy(t3, e3) {
      return super.copy(t3, e3), t3.background !== null && (this.background = t3.background.clone()), t3.environment !== null && (this.environment = t3.environment.clone()), t3.fog !== null && (this.fog = t3.fog.clone()), t3.overrideMaterial !== null && (this.overrideMaterial = t3.overrideMaterial.clone()), this.autoUpdate = t3.autoUpdate, this.matrixAutoUpdate = t3.matrixAutoUpdate, this;
    }
    toJSON(t3) {
      const e3 = super.toJSON(t3);
      return this.fog !== null && (e3.object.fog = this.fog.toJSON()), e3;
    }
  }
  ll.prototype.isScene = true;
  class ul {
    constructor(t3, e3) {
      this.array = t3, this.stride = e3, this.count = t3 !== void 0 ? t3.length / e3 : 0, this.usage = In, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = qn();
    }
    onUploadCallback() {
    }
    set needsUpdate(t3) {
      t3 === true && this.version++;
    }
    setUsage(t3) {
      return this.usage = t3, this;
    }
    copy(t3) {
      return this.array = new t3.array.constructor(t3.array), this.count = t3.count, this.stride = t3.stride, this.usage = t3.usage, this;
    }
    copyAt(t3, e3, n2) {
      t3 *= this.stride, n2 *= e3.stride;
      for (let i2 = 0, r3 = this.stride; i2 < r3; i2++)
        this.array[t3 + i2] = e3.array[n2 + i2];
      return this;
    }
    set(t3, e3 = 0) {
      return this.array.set(t3, e3), this;
    }
    clone(t3) {
      t3.arrayBuffers === void 0 && (t3.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = qn()), t3.arrayBuffers[this.array.buffer._uuid] === void 0 && (t3.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
      const e3 = new this.array.constructor(t3.arrayBuffers[this.array.buffer._uuid]), n2 = new this.constructor(e3, this.stride);
      return n2.setUsage(this.usage), n2;
    }
    onUpload(t3) {
      return this.onUploadCallback = t3, this;
    }
    toJSON(t3) {
      return t3.arrayBuffers === void 0 && (t3.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = qn()), t3.arrayBuffers[this.array.buffer._uuid] === void 0 && (t3.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride };
    }
  }
  ul.prototype.isInterleavedBuffer = true;
  const hl = new pi();
  class cl {
    constructor(t3, e3, n2, i2 = false) {
      this.name = "", this.data = t3, this.itemSize = e3, this.offset = n2, this.normalized = i2 === true;
    }
    get count() {
      return this.data.count;
    }
    get array() {
      return this.data.array;
    }
    set needsUpdate(t3) {
      this.data.needsUpdate = t3;
    }
    applyMatrix4(t3) {
      for (let e3 = 0, n2 = this.data.count; e3 < n2; e3++)
        hl.x = this.getX(e3), hl.y = this.getY(e3), hl.z = this.getZ(e3), hl.applyMatrix4(t3), this.setXYZ(e3, hl.x, hl.y, hl.z);
      return this;
    }
    applyNormalMatrix(t3) {
      for (let e3 = 0, n2 = this.count; e3 < n2; e3++)
        hl.x = this.getX(e3), hl.y = this.getY(e3), hl.z = this.getZ(e3), hl.applyNormalMatrix(t3), this.setXYZ(e3, hl.x, hl.y, hl.z);
      return this;
    }
    transformDirection(t3) {
      for (let e3 = 0, n2 = this.count; e3 < n2; e3++)
        hl.x = this.getX(e3), hl.y = this.getY(e3), hl.z = this.getZ(e3), hl.transformDirection(t3), this.setXYZ(e3, hl.x, hl.y, hl.z);
      return this;
    }
    setX(t3, e3) {
      return this.data.array[t3 * this.data.stride + this.offset] = e3, this;
    }
    setY(t3, e3) {
      return this.data.array[t3 * this.data.stride + this.offset + 1] = e3, this;
    }
    setZ(t3, e3) {
      return this.data.array[t3 * this.data.stride + this.offset + 2] = e3, this;
    }
    setW(t3, e3) {
      return this.data.array[t3 * this.data.stride + this.offset + 3] = e3, this;
    }
    getX(t3) {
      return this.data.array[t3 * this.data.stride + this.offset];
    }
    getY(t3) {
      return this.data.array[t3 * this.data.stride + this.offset + 1];
    }
    getZ(t3) {
      return this.data.array[t3 * this.data.stride + this.offset + 2];
    }
    getW(t3) {
      return this.data.array[t3 * this.data.stride + this.offset + 3];
    }
    setXY(t3, e3, n2) {
      return t3 = t3 * this.data.stride + this.offset, this.data.array[t3 + 0] = e3, this.data.array[t3 + 1] = n2, this;
    }
    setXYZ(t3, e3, n2, i2) {
      return t3 = t3 * this.data.stride + this.offset, this.data.array[t3 + 0] = e3, this.data.array[t3 + 1] = n2, this.data.array[t3 + 2] = i2, this;
    }
    setXYZW(t3, e3, n2, i2, r3) {
      return t3 = t3 * this.data.stride + this.offset, this.data.array[t3 + 0] = e3, this.data.array[t3 + 1] = n2, this.data.array[t3 + 2] = i2, this.data.array[t3 + 3] = r3, this;
    }
    clone(t3) {
      if (t3 === void 0) {
        console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
        const t4 = [];
        for (let e3 = 0; e3 < this.count; e3++) {
          const n2 = e3 * this.data.stride + this.offset;
          for (let e4 = 0; e4 < this.itemSize; e4++)
            t4.push(this.data.array[n2 + e4]);
        }
        return new kr(new this.array.constructor(t4), this.itemSize, this.normalized);
      }
      return t3.interleavedBuffers === void 0 && (t3.interleavedBuffers = {}), t3.interleavedBuffers[this.data.uuid] === void 0 && (t3.interleavedBuffers[this.data.uuid] = this.data.clone(t3)), new cl(t3.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
    }
    toJSON(t3) {
      if (t3 === void 0) {
        console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
        const t4 = [];
        for (let e3 = 0; e3 < this.count; e3++) {
          const n2 = e3 * this.data.stride + this.offset;
          for (let e4 = 0; e4 < this.itemSize; e4++)
            t4.push(this.data.array[n2 + e4]);
        }
        return { itemSize: this.itemSize, type: this.array.constructor.name, array: t4, normalized: this.normalized };
      }
      return t3.interleavedBuffers === void 0 && (t3.interleavedBuffers = {}), t3.interleavedBuffers[this.data.uuid] === void 0 && (t3.interleavedBuffers[this.data.uuid] = this.data.toJSON(t3)), { isInterleavedBufferAttribute: true, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized };
    }
  }
  cl.prototype.isInterleavedBufferAttribute = true;
  class dl extends Rr {
    constructor(t3) {
      super(), this.type = "SpriteMaterial", this.color = new Dr(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = true, this.transparent = true, this.setValues(t3);
    }
    copy(t3) {
      return super.copy(t3), this.color.copy(t3.color), this.map = t3.map, this.alphaMap = t3.alphaMap, this.rotation = t3.rotation, this.sizeAttenuation = t3.sizeAttenuation, this;
    }
  }
  let pl;
  dl.prototype.isSpriteMaterial = true;
  const fl = new pi(), ml = new pi(), gl = new pi(), vl = new ei(), _l = new ei(), yl = new Vi(), xl = new pi(), bl = new pi(), Tl = new pi(), wl = new ei(), Sl = new ei(), El = new ei();
  class Ml extends mr {
    constructor(t3) {
      if (super(), this.type = "Sprite", pl === void 0) {
        pl = new so();
        const t4 = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]), e3 = new ul(t4, 5);
        pl.setIndex([0, 1, 2, 0, 2, 3]), pl.setAttribute("position", new cl(e3, 3, 0, false)), pl.setAttribute("uv", new cl(e3, 2, 3, false));
      }
      this.geometry = pl, this.material = t3 !== void 0 ? t3 : new dl(), this.center = new ei(0.5, 0.5);
    }
    raycast(t3, e3) {
      t3.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), ml.setFromMatrixScale(this.matrixWorld), yl.copy(t3.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t3.camera.matrixWorldInverse, this.matrixWorld), gl.setFromMatrixPosition(this.modelViewMatrix), t3.camera.isPerspectiveCamera && this.material.sizeAttenuation === false && ml.multiplyScalar(-gl.z);
      const n2 = this.material.rotation;
      let i2, r3;
      n2 !== 0 && (r3 = Math.cos(n2), i2 = Math.sin(n2));
      const o3 = this.center;
      Al(xl.set(-0.5, -0.5, 0), gl, o3, ml, i2, r3), Al(bl.set(0.5, -0.5, 0), gl, o3, ml, i2, r3), Al(Tl.set(0.5, 0.5, 0), gl, o3, ml, i2, r3), wl.set(0, 0), Sl.set(1, 0), El.set(1, 1);
      let s3 = t3.ray.intersectTriangle(xl, bl, Tl, false, fl);
      if (s3 === null && (Al(bl.set(-0.5, 0.5, 0), gl, o3, ml, i2, r3), Sl.set(0, 1), s3 = t3.ray.intersectTriangle(xl, Tl, bl, false, fl), s3 === null))
        return;
      const a2 = t3.ray.origin.distanceTo(fl);
      a2 < t3.near || a2 > t3.far || e3.push({ distance: a2, point: fl.clone(), uv: Mr.getUV(fl, xl, bl, Tl, wl, Sl, El, new ei()), face: null, object: this });
    }
    copy(t3) {
      return super.copy(t3), t3.center !== void 0 && this.center.copy(t3.center), this.material = t3.material, this;
    }
  }
  function Al(t3, e3, n2, i2, r3, o3) {
    vl.subVectors(t3, n2).addScalar(0.5).multiply(i2), r3 !== void 0 ? (_l.x = o3 * vl.x - r3 * vl.y, _l.y = r3 * vl.x + o3 * vl.y) : _l.copy(vl), t3.copy(e3), t3.x += _l.x, t3.y += _l.y, t3.applyMatrix4(yl);
  }
  Ml.prototype.isSprite = true;
  const Rl = new pi(), Pl = new pi();
  class Cl extends mr {
    constructor() {
      super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, { levels: { enumerable: true, value: [] }, isLOD: { value: true } }), this.autoUpdate = true;
    }
    copy(t3) {
      super.copy(t3, false);
      const e3 = t3.levels;
      for (let t4 = 0, n2 = e3.length; t4 < n2; t4++) {
        const n3 = e3[t4];
        this.addLevel(n3.object.clone(), n3.distance);
      }
      return this.autoUpdate = t3.autoUpdate, this;
    }
    addLevel(t3, e3 = 0) {
      e3 = Math.abs(e3);
      const n2 = this.levels;
      let i2;
      for (i2 = 0; i2 < n2.length && !(e3 < n2[i2].distance); i2++)
        ;
      return n2.splice(i2, 0, { distance: e3, object: t3 }), this.add(t3), this;
    }
    getCurrentLevel() {
      return this._currentLevel;
    }
    getObjectForDistance(t3) {
      const e3 = this.levels;
      if (e3.length > 0) {
        let n2, i2;
        for (n2 = 1, i2 = e3.length; n2 < i2 && !(t3 < e3[n2].distance); n2++)
          ;
        return e3[n2 - 1].object;
      }
      return null;
    }
    raycast(t3, e3) {
      if (this.levels.length > 0) {
        Rl.setFromMatrixPosition(this.matrixWorld);
        const n2 = t3.ray.origin.distanceTo(Rl);
        this.getObjectForDistance(n2).raycast(t3, e3);
      }
    }
    update(t3) {
      const e3 = this.levels;
      if (e3.length > 1) {
        Rl.setFromMatrixPosition(t3.matrixWorld), Pl.setFromMatrixPosition(this.matrixWorld);
        const n2 = Rl.distanceTo(Pl) / t3.zoom;
        let i2, r3;
        for (e3[0].object.visible = true, i2 = 1, r3 = e3.length; i2 < r3 && n2 >= e3[i2].distance; i2++)
          e3[i2 - 1].object.visible = false, e3[i2].object.visible = true;
        for (this._currentLevel = i2 - 1; i2 < r3; i2++)
          e3[i2].object.visible = false;
      }
    }
    toJSON(t3) {
      const e3 = super.toJSON(t3);
      this.autoUpdate === false && (e3.object.autoUpdate = false), e3.object.levels = [];
      const n2 = this.levels;
      for (let t4 = 0, i2 = n2.length; t4 < i2; t4++) {
        const i3 = n2[t4];
        e3.object.levels.push({ object: i3.object.uuid, distance: i3.distance });
      }
      return e3;
    }
  }
  const Il = new pi(), Ol = new li(), Ll = new li(), Nl = new pi(), Dl = new Vi();
  class Fl extends Eo {
    constructor(t3, e3) {
      super(t3, e3), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Vi(), this.bindMatrixInverse = new Vi();
    }
    copy(t3) {
      return super.copy(t3), this.bindMode = t3.bindMode, this.bindMatrix.copy(t3.bindMatrix), this.bindMatrixInverse.copy(t3.bindMatrixInverse), this.skeleton = t3.skeleton, this;
    }
    bind(t3, e3) {
      this.skeleton = t3, e3 === void 0 && (this.updateMatrixWorld(true), this.skeleton.calculateInverses(), e3 = this.matrixWorld), this.bindMatrix.copy(e3), this.bindMatrixInverse.copy(e3).invert();
    }
    pose() {
      this.skeleton.pose();
    }
    normalizeSkinWeights() {
      const t3 = new li(), e3 = this.geometry.attributes.skinWeight;
      for (let n2 = 0, i2 = e3.count; n2 < i2; n2++) {
        t3.x = e3.getX(n2), t3.y = e3.getY(n2), t3.z = e3.getZ(n2), t3.w = e3.getW(n2);
        const i3 = 1 / t3.manhattanLength();
        i3 !== 1 / 0 ? t3.multiplyScalar(i3) : t3.set(1, 0, 0, 0), e3.setXYZW(n2, t3.x, t3.y, t3.z, t3.w);
      }
    }
    updateMatrixWorld(t3) {
      super.updateMatrixWorld(t3), this.bindMode === "attached" ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === "detached" ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
    }
    boneTransform(t3, e3) {
      const n2 = this.skeleton, i2 = this.geometry;
      Ol.fromBufferAttribute(i2.attributes.skinIndex, t3), Ll.fromBufferAttribute(i2.attributes.skinWeight, t3), Il.fromBufferAttribute(i2.attributes.position, t3).applyMatrix4(this.bindMatrix), e3.set(0, 0, 0);
      for (let t4 = 0; t4 < 4; t4++) {
        const i3 = Ll.getComponent(t4);
        if (i3 !== 0) {
          const r3 = Ol.getComponent(t4);
          Dl.multiplyMatrices(n2.bones[r3].matrixWorld, n2.boneInverses[r3]), e3.addScaledVector(Nl.copy(Il).applyMatrix4(Dl), i3);
        }
      }
      return e3.applyMatrix4(this.bindMatrixInverse);
    }
  }
  Fl.prototype.isSkinnedMesh = true;
  class Bl extends mr {
    constructor() {
      super(), this.type = "Bone";
    }
  }
  Bl.prototype.isBone = true;
  class Ul extends si {
    constructor(t3 = null, e3 = 1, n2 = 1, i2, r3, o3, s3, a2, l2 = xt, u2 = xt, h2, c2) {
      super(null, o3, s3, a2, l2, u2, i2, r3, h2, c2), this.image = { data: t3, width: e3, height: n2 }, this.magFilter = l2, this.minFilter = u2, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1, this.needsUpdate = true;
    }
  }
  Ul.prototype.isDataTexture = true;
  const kl = new Vi(), Gl = new Vi();
  class Hl {
    constructor(t3 = [], e3 = []) {
      this.uuid = qn(), this.bones = t3.slice(0), this.boneInverses = e3, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init();
    }
    init() {
      const t3 = this.bones, e3 = this.boneInverses;
      if (this.boneMatrices = new Float32Array(16 * t3.length), e3.length === 0)
        this.calculateInverses();
      else if (t3.length !== e3.length) {
        console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
        for (let t4 = 0, e4 = this.bones.length; t4 < e4; t4++)
          this.boneInverses.push(new Vi());
      }
    }
    calculateInverses() {
      this.boneInverses.length = 0;
      for (let t3 = 0, e3 = this.bones.length; t3 < e3; t3++) {
        const e4 = new Vi();
        this.bones[t3] && e4.copy(this.bones[t3].matrixWorld).invert(), this.boneInverses.push(e4);
      }
    }
    pose() {
      for (let t3 = 0, e3 = this.bones.length; t3 < e3; t3++) {
        const e4 = this.bones[t3];
        e4 && e4.matrixWorld.copy(this.boneInverses[t3]).invert();
      }
      for (let t3 = 0, e3 = this.bones.length; t3 < e3; t3++) {
        const e4 = this.bones[t3];
        e4 && (e4.parent && e4.parent.isBone ? (e4.matrix.copy(e4.parent.matrixWorld).invert(), e4.matrix.multiply(e4.matrixWorld)) : e4.matrix.copy(e4.matrixWorld), e4.matrix.decompose(e4.position, e4.quaternion, e4.scale));
      }
    }
    update() {
      const t3 = this.bones, e3 = this.boneInverses, n2 = this.boneMatrices, i2 = this.boneTexture;
      for (let i3 = 0, r3 = t3.length; i3 < r3; i3++) {
        const r4 = t3[i3] ? t3[i3].matrixWorld : Gl;
        kl.multiplyMatrices(r4, e3[i3]), kl.toArray(n2, 16 * i3);
      }
      i2 !== null && (i2.needsUpdate = true);
    }
    clone() {
      return new Hl(this.bones, this.boneInverses);
    }
    computeBoneTexture() {
      let t3 = Math.sqrt(4 * this.bones.length);
      t3 = Kn(t3), t3 = Math.max(t3, 4);
      const e3 = new Float32Array(t3 * t3 * 4);
      e3.set(this.boneMatrices);
      const n2 = new Ul(e3, t3, t3, Vt, Ft);
      return this.boneMatrices = e3, this.boneTexture = n2, this.boneTextureSize = t3, this;
    }
    getBoneByName(t3) {
      for (let e3 = 0, n2 = this.bones.length; e3 < n2; e3++) {
        const n3 = this.bones[e3];
        if (n3.name === t3)
          return n3;
      }
    }
    dispose() {
      this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null);
    }
    fromJSON(t3, e3) {
      this.uuid = t3.uuid;
      for (let n2 = 0, i2 = t3.bones.length; n2 < i2; n2++) {
        const i3 = t3.bones[n2];
        let r3 = e3[i3];
        r3 === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", i3), r3 = new Bl()), this.bones.push(r3), this.boneInverses.push(new Vi().fromArray(t3.boneInverses[n2]));
      }
      return this.init(), this;
    }
    toJSON() {
      const t3 = { metadata: { version: 4.5, type: "Skeleton", generator: "Skeleton.toJSON" }, bones: [], boneInverses: [] };
      t3.uuid = this.uuid;
      const e3 = this.bones, n2 = this.boneInverses;
      for (let i2 = 0, r3 = e3.length; i2 < r3; i2++) {
        const r4 = e3[i2];
        t3.bones.push(r4.uuid);
        const o3 = n2[i2];
        t3.boneInverses.push(o3.toArray());
      }
      return t3;
    }
  }
  const zl = new Vi(), jl = new Vi(), Vl = [], Wl = new Eo();
  class Xl extends Eo {
    constructor(t3, e3, n2) {
      super(t3, e3), this.instanceMatrix = new kr(new Float32Array(16 * n2), 16), this.instanceColor = null, this.count = n2, this.frustumCulled = false;
    }
    copy(t3) {
      return super.copy(t3), this.instanceMatrix.copy(t3.instanceMatrix), t3.instanceColor !== null && (this.instanceColor = t3.instanceColor.clone()), this.count = t3.count, this;
    }
    getColorAt(t3, e3) {
      e3.fromArray(this.instanceColor.array, 3 * t3);
    }
    getMatrixAt(t3, e3) {
      e3.fromArray(this.instanceMatrix.array, 16 * t3);
    }
    raycast(t3, e3) {
      const n2 = this.matrixWorld, i2 = this.count;
      if (Wl.geometry = this.geometry, Wl.material = this.material, Wl.material !== void 0)
        for (let r3 = 0; r3 < i2; r3++) {
          this.getMatrixAt(r3, zl), jl.multiplyMatrices(n2, zl), Wl.matrixWorld = jl, Wl.raycast(t3, Vl);
          for (let t4 = 0, n3 = Vl.length; t4 < n3; t4++) {
            const n4 = Vl[t4];
            n4.instanceId = r3, n4.object = this, e3.push(n4);
          }
          Vl.length = 0;
        }
    }
    setColorAt(t3, e3) {
      this.instanceColor === null && (this.instanceColor = new kr(new Float32Array(3 * this.count), 3)), e3.toArray(this.instanceColor.array, 3 * t3);
    }
    setMatrixAt(t3, e3) {
      e3.toArray(this.instanceMatrix.array, 16 * t3);
    }
    updateMorphTargets() {
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  }
  Xl.prototype.isInstancedMesh = true;
  class ql extends Rr {
    constructor(t3) {
      super(), this.type = "LineBasicMaterial", this.color = new Dr(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.morphTargets = false, this.setValues(t3);
    }
    copy(t3) {
      return super.copy(t3), this.color.copy(t3.color), this.linewidth = t3.linewidth, this.linecap = t3.linecap, this.linejoin = t3.linejoin, this.morphTargets = t3.morphTargets, this;
    }
  }
  ql.prototype.isLineBasicMaterial = true;
  const Yl = new pi(), Zl = new pi(), Jl = new Vi(), $l = new ji(), Kl = new Di();
  class Ql extends mr {
    constructor(t3 = new so(), e3 = new ql()) {
      super(), this.type = "Line", this.geometry = t3, this.material = e3, this.updateMorphTargets();
    }
    copy(t3) {
      return super.copy(t3), this.material = t3.material, this.geometry = t3.geometry, this;
    }
    computeLineDistances() {
      const t3 = this.geometry;
      if (t3.isBufferGeometry)
        if (t3.index === null) {
          const e3 = t3.attributes.position, n2 = [0];
          for (let t4 = 1, i2 = e3.count; t4 < i2; t4++)
            Yl.fromBufferAttribute(e3, t4 - 1), Zl.fromBufferAttribute(e3, t4), n2[t4] = n2[t4 - 1], n2[t4] += Yl.distanceTo(Zl);
          t3.setAttribute("lineDistance", new Yr(n2, 1));
        } else
          console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      else
        t3.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      return this;
    }
    raycast(t3, e3) {
      const n2 = this.geometry, i2 = this.matrixWorld, r3 = t3.params.Line.threshold, o3 = n2.drawRange;
      if (n2.boundingSphere === null && n2.computeBoundingSphere(), Kl.copy(n2.boundingSphere), Kl.applyMatrix4(i2), Kl.radius += r3, t3.ray.intersectsSphere(Kl) === false)
        return;
      Jl.copy(i2).invert(), $l.copy(t3.ray).applyMatrix4(Jl);
      const s3 = r3 / ((this.scale.x + this.scale.y + this.scale.z) / 3), a2 = s3 * s3, l2 = new pi(), u2 = new pi(), h2 = new pi(), c2 = new pi(), d2 = this.isLineSegments ? 2 : 1;
      if (n2.isBufferGeometry) {
        const i3 = n2.index, r4 = n2.attributes.position;
        if (i3 !== null) {
          for (let n3 = Math.max(0, o3.start), s4 = Math.min(i3.count, o3.start + o3.count) - 1; n3 < s4; n3 += d2) {
            const o4 = i3.getX(n3), s5 = i3.getX(n3 + 1);
            l2.fromBufferAttribute(r4, o4), u2.fromBufferAttribute(r4, s5);
            if ($l.distanceSqToSegment(l2, u2, c2, h2) > a2)
              continue;
            c2.applyMatrix4(this.matrixWorld);
            const d3 = t3.ray.origin.distanceTo(c2);
            d3 < t3.near || d3 > t3.far || e3.push({ distance: d3, point: h2.clone().applyMatrix4(this.matrixWorld), index: n3, face: null, faceIndex: null, object: this });
          }
        } else {
          for (let n3 = Math.max(0, o3.start), i4 = Math.min(r4.count, o3.start + o3.count) - 1; n3 < i4; n3 += d2) {
            l2.fromBufferAttribute(r4, n3), u2.fromBufferAttribute(r4, n3 + 1);
            if ($l.distanceSqToSegment(l2, u2, c2, h2) > a2)
              continue;
            c2.applyMatrix4(this.matrixWorld);
            const i5 = t3.ray.origin.distanceTo(c2);
            i5 < t3.near || i5 > t3.far || e3.push({ distance: i5, point: h2.clone().applyMatrix4(this.matrixWorld), index: n3, face: null, faceIndex: null, object: this });
          }
        }
      } else
        n2.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
    updateMorphTargets() {
      const t3 = this.geometry;
      if (t3.isBufferGeometry) {
        const e3 = t3.morphAttributes, n2 = Object.keys(e3);
        if (n2.length > 0) {
          const t4 = e3[n2[0]];
          if (t4 !== void 0) {
            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
            for (let e4 = 0, n3 = t4.length; e4 < n3; e4++) {
              const n4 = t4[e4].name || String(e4);
              this.morphTargetInfluences.push(0), this.morphTargetDictionary[n4] = e4;
            }
          }
        }
      } else {
        const e3 = t3.morphTargets;
        e3 !== void 0 && e3.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  }
  Ql.prototype.isLine = true;
  const tu = new pi(), eu = new pi();
  class nu extends Ql {
    constructor(t3, e3) {
      super(t3, e3), this.type = "LineSegments";
    }
    computeLineDistances() {
      const t3 = this.geometry;
      if (t3.isBufferGeometry)
        if (t3.index === null) {
          const e3 = t3.attributes.position, n2 = [];
          for (let t4 = 0, i2 = e3.count; t4 < i2; t4 += 2)
            tu.fromBufferAttribute(e3, t4), eu.fromBufferAttribute(e3, t4 + 1), n2[t4] = t4 === 0 ? 0 : n2[t4 - 1], n2[t4 + 1] = n2[t4] + tu.distanceTo(eu);
          t3.setAttribute("lineDistance", new Yr(n2, 1));
        } else
          console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      else
        t3.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      return this;
    }
  }
  nu.prototype.isLineSegments = true;
  class iu extends Ql {
    constructor(t3, e3) {
      super(t3, e3), this.type = "LineLoop";
    }
  }
  iu.prototype.isLineLoop = true;
  class ru extends Rr {
    constructor(t3) {
      super(), this.type = "PointsMaterial", this.color = new Dr(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = true, this.morphTargets = false, this.setValues(t3);
    }
    copy(t3) {
      return super.copy(t3), this.color.copy(t3.color), this.map = t3.map, this.alphaMap = t3.alphaMap, this.size = t3.size, this.sizeAttenuation = t3.sizeAttenuation, this.morphTargets = t3.morphTargets, this;
    }
  }
  ru.prototype.isPointsMaterial = true;
  const ou = new Vi(), su = new ji(), au = new Di(), lu = new pi();
  class uu extends mr {
    constructor(t3 = new so(), e3 = new ru()) {
      super(), this.type = "Points", this.geometry = t3, this.material = e3, this.updateMorphTargets();
    }
    copy(t3) {
      return super.copy(t3), this.material = t3.material, this.geometry = t3.geometry, this;
    }
    raycast(t3, e3) {
      const n2 = this.geometry, i2 = this.matrixWorld, r3 = t3.params.Points.threshold, o3 = n2.drawRange;
      if (n2.boundingSphere === null && n2.computeBoundingSphere(), au.copy(n2.boundingSphere), au.applyMatrix4(i2), au.radius += r3, t3.ray.intersectsSphere(au) === false)
        return;
      ou.copy(i2).invert(), su.copy(t3.ray).applyMatrix4(ou);
      const s3 = r3 / ((this.scale.x + this.scale.y + this.scale.z) / 3), a2 = s3 * s3;
      if (n2.isBufferGeometry) {
        const r4 = n2.index, s4 = n2.attributes.position;
        if (r4 !== null) {
          for (let n3 = Math.max(0, o3.start), l2 = Math.min(r4.count, o3.start + o3.count); n3 < l2; n3++) {
            const o4 = r4.getX(n3);
            lu.fromBufferAttribute(s4, o4), hu(lu, o4, a2, i2, t3, e3, this);
          }
        } else {
          for (let n3 = Math.max(0, o3.start), r5 = Math.min(s4.count, o3.start + o3.count); n3 < r5; n3++)
            lu.fromBufferAttribute(s4, n3), hu(lu, n3, a2, i2, t3, e3, this);
        }
      } else
        console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
    updateMorphTargets() {
      const t3 = this.geometry;
      if (t3.isBufferGeometry) {
        const e3 = t3.morphAttributes, n2 = Object.keys(e3);
        if (n2.length > 0) {
          const t4 = e3[n2[0]];
          if (t4 !== void 0) {
            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
            for (let e4 = 0, n3 = t4.length; e4 < n3; e4++) {
              const n4 = t4[e4].name || String(e4);
              this.morphTargetInfluences.push(0), this.morphTargetDictionary[n4] = e4;
            }
          }
        }
      } else {
        const e3 = t3.morphTargets;
        e3 !== void 0 && e3.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  }
  function hu(t3, e3, n2, i2, r3, o3, s3) {
    const a2 = su.distanceSqToPoint(t3);
    if (a2 < n2) {
      const n3 = new pi();
      su.closestPointToPoint(t3, n3), n3.applyMatrix4(i2);
      const l2 = r3.ray.origin.distanceTo(n3);
      if (l2 < r3.near || l2 > r3.far)
        return;
      o3.push({ distance: l2, distanceToRay: Math.sqrt(a2), point: n3, index: e3, face: null, object: s3 });
    }
  }
  uu.prototype.isPoints = true;
  class cu extends si {
    constructor(t3, e3, n2, i2, r3, o3, s3, a2, l2) {
      super(t3, e3, n2, i2, r3, o3, s3, a2, l2), this.format = s3 !== void 0 ? s3 : jt, this.minFilter = o3 !== void 0 ? o3 : Et, this.magFilter = r3 !== void 0 ? r3 : Et, this.generateMipmaps = false;
      const u2 = this;
      "requestVideoFrameCallback" in t3 && t3.requestVideoFrameCallback(function e4() {
        u2.needsUpdate = true, t3.requestVideoFrameCallback(e4);
      });
    }
    clone() {
      return new this.constructor(this.image).copy(this);
    }
    update() {
      const t3 = this.image;
      "requestVideoFrameCallback" in t3 === false && t3.readyState >= t3.HAVE_CURRENT_DATA && (this.needsUpdate = true);
    }
  }
  cu.prototype.isVideoTexture = true;
  class du extends si {
    constructor(t3, e3, n2, i2, r3, o3, s3, a2, l2, u2, h2, c2) {
      super(null, o3, s3, a2, l2, u2, i2, r3, h2, c2), this.image = { width: e3, height: n2 }, this.mipmaps = t3, this.flipY = false, this.generateMipmaps = false;
    }
  }
  du.prototype.isCompressedTexture = true;
  class pu extends si {
    constructor(t3, e3, n2, i2, r3, o3, s3, a2, l2) {
      super(t3, e3, n2, i2, r3, o3, s3, a2, l2), this.needsUpdate = true;
    }
  }
  pu.prototype.isCanvasTexture = true;
  class fu extends si {
    constructor(t3, e3, n2, i2, r3, o3, s3, a2, l2, u2) {
      if ((u2 = u2 !== void 0 ? u2 : Yt) !== Yt && u2 !== Zt)
        throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
      n2 === void 0 && u2 === Yt && (n2 = Lt), n2 === void 0 && u2 === Zt && (n2 = Ht), super(null, i2, r3, o3, s3, a2, u2, n2, l2), this.image = { width: t3, height: e3 }, this.magFilter = s3 !== void 0 ? s3 : xt, this.minFilter = a2 !== void 0 ? a2 : xt, this.flipY = false, this.generateMipmaps = false;
    }
  }
  fu.prototype.isDepthTexture = true;
  class mu extends so {
    constructor(t3 = 1, e3 = 8, n2 = 0, i2 = 2 * Math.PI) {
      super(), this.type = "CircleGeometry", this.parameters = { radius: t3, segments: e3, thetaStart: n2, thetaLength: i2 }, e3 = Math.max(3, e3);
      const r3 = [], o3 = [], s3 = [], a2 = [], l2 = new pi(), u2 = new ei();
      o3.push(0, 0, 0), s3.push(0, 0, 1), a2.push(0.5, 0.5);
      for (let r4 = 0, h2 = 3; r4 <= e3; r4++, h2 += 3) {
        const c2 = n2 + r4 / e3 * i2;
        l2.x = t3 * Math.cos(c2), l2.y = t3 * Math.sin(c2), o3.push(l2.x, l2.y, l2.z), s3.push(0, 0, 1), u2.x = (o3[h2] / t3 + 1) / 2, u2.y = (o3[h2 + 1] / t3 + 1) / 2, a2.push(u2.x, u2.y);
      }
      for (let t4 = 1; t4 <= e3; t4++)
        r3.push(t4, t4 + 1, 0);
      this.setIndex(r3), this.setAttribute("position", new Yr(o3, 3)), this.setAttribute("normal", new Yr(s3, 3)), this.setAttribute("uv", new Yr(a2, 2));
    }
    static fromJSON(t3) {
      return new mu(t3.radius, t3.segments, t3.thetaStart, t3.thetaLength);
    }
  }
  class gu extends so {
    constructor(t3 = 1, e3 = 1, n2 = 1, i2 = 8, r3 = 1, o3 = false, s3 = 0, a2 = 2 * Math.PI) {
      super(), this.type = "CylinderGeometry", this.parameters = { radiusTop: t3, radiusBottom: e3, height: n2, radialSegments: i2, heightSegments: r3, openEnded: o3, thetaStart: s3, thetaLength: a2 };
      const l2 = this;
      i2 = Math.floor(i2), r3 = Math.floor(r3);
      const u2 = [], h2 = [], c2 = [], d2 = [];
      let p2 = 0;
      const f2 = [], m2 = n2 / 2;
      let g2 = 0;
      function v2(n3) {
        const r4 = p2, o4 = new ei(), f3 = new pi();
        let v3 = 0;
        const _2 = n3 === true ? t3 : e3, y2 = n3 === true ? 1 : -1;
        for (let t4 = 1; t4 <= i2; t4++)
          h2.push(0, m2 * y2, 0), c2.push(0, y2, 0), d2.push(0.5, 0.5), p2++;
        const x2 = p2;
        for (let t4 = 0; t4 <= i2; t4++) {
          const e4 = t4 / i2 * a2 + s3, n4 = Math.cos(e4), r5 = Math.sin(e4);
          f3.x = _2 * r5, f3.y = m2 * y2, f3.z = _2 * n4, h2.push(f3.x, f3.y, f3.z), c2.push(0, y2, 0), o4.x = 0.5 * n4 + 0.5, o4.y = 0.5 * r5 * y2 + 0.5, d2.push(o4.x, o4.y), p2++;
        }
        for (let t4 = 0; t4 < i2; t4++) {
          const e4 = r4 + t4, i3 = x2 + t4;
          n3 === true ? u2.push(i3, i3 + 1, e4) : u2.push(i3 + 1, i3, e4), v3 += 3;
        }
        l2.addGroup(g2, v3, n3 === true ? 1 : 2), g2 += v3;
      }
      !function() {
        const o4 = new pi(), v3 = new pi();
        let _2 = 0;
        const y2 = (e3 - t3) / n2;
        for (let l3 = 0; l3 <= r3; l3++) {
          const u3 = [], g3 = l3 / r3, _3 = g3 * (e3 - t3) + t3;
          for (let t4 = 0; t4 <= i2; t4++) {
            const e4 = t4 / i2, r4 = e4 * a2 + s3, l4 = Math.sin(r4), f3 = Math.cos(r4);
            v3.x = _3 * l4, v3.y = -g3 * n2 + m2, v3.z = _3 * f3, h2.push(v3.x, v3.y, v3.z), o4.set(l4, y2, f3).normalize(), c2.push(o4.x, o4.y, o4.z), d2.push(e4, 1 - g3), u3.push(p2++);
          }
          f2.push(u3);
        }
        for (let t4 = 0; t4 < i2; t4++)
          for (let e4 = 0; e4 < r3; e4++) {
            const n3 = f2[e4][t4], i3 = f2[e4 + 1][t4], r4 = f2[e4 + 1][t4 + 1], o5 = f2[e4][t4 + 1];
            u2.push(n3, i3, o5), u2.push(i3, r4, o5), _2 += 6;
          }
        l2.addGroup(g2, _2, 0), g2 += _2;
      }(), o3 === false && (t3 > 0 && v2(true), e3 > 0 && v2(false)), this.setIndex(u2), this.setAttribute("position", new Yr(h2, 3)), this.setAttribute("normal", new Yr(c2, 3)), this.setAttribute("uv", new Yr(d2, 2));
    }
    static fromJSON(t3) {
      return new gu(t3.radiusTop, t3.radiusBottom, t3.height, t3.radialSegments, t3.heightSegments, t3.openEnded, t3.thetaStart, t3.thetaLength);
    }
  }
  class vu extends gu {
    constructor(t3 = 1, e3 = 1, n2 = 8, i2 = 1, r3 = false, o3 = 0, s3 = 2 * Math.PI) {
      super(0, t3, e3, n2, i2, r3, o3, s3), this.type = "ConeGeometry", this.parameters = { radius: t3, height: e3, radialSegments: n2, heightSegments: i2, openEnded: r3, thetaStart: o3, thetaLength: s3 };
    }
    static fromJSON(t3) {
      return new vu(t3.radius, t3.height, t3.radialSegments, t3.heightSegments, t3.openEnded, t3.thetaStart, t3.thetaLength);
    }
  }
  class _u extends so {
    constructor(t3, e3, n2 = 1, i2 = 0) {
      super(), this.type = "PolyhedronGeometry", this.parameters = { vertices: t3, indices: e3, radius: n2, detail: i2 };
      const r3 = [], o3 = [];
      function s3(t4, e4, n3, i3) {
        const r4 = i3 + 1, o4 = [];
        for (let i4 = 0; i4 <= r4; i4++) {
          o4[i4] = [];
          const s4 = t4.clone().lerp(n3, i4 / r4), a3 = e4.clone().lerp(n3, i4 / r4), l3 = r4 - i4;
          for (let t5 = 0; t5 <= l3; t5++)
            o4[i4][t5] = t5 === 0 && i4 === r4 ? s4 : s4.clone().lerp(a3, t5 / l3);
        }
        for (let t5 = 0; t5 < r4; t5++)
          for (let e5 = 0; e5 < 2 * (r4 - t5) - 1; e5++) {
            const n4 = Math.floor(e5 / 2);
            e5 % 2 == 0 ? (a2(o4[t5][n4 + 1]), a2(o4[t5 + 1][n4]), a2(o4[t5][n4])) : (a2(o4[t5][n4 + 1]), a2(o4[t5 + 1][n4 + 1]), a2(o4[t5 + 1][n4]));
          }
      }
      function a2(t4) {
        r3.push(t4.x, t4.y, t4.z);
      }
      function l2(e4, n3) {
        const i3 = 3 * e4;
        n3.x = t3[i3 + 0], n3.y = t3[i3 + 1], n3.z = t3[i3 + 2];
      }
      function u2(t4, e4, n3, i3) {
        i3 < 0 && t4.x === 1 && (o3[e4] = t4.x - 1), n3.x === 0 && n3.z === 0 && (o3[e4] = i3 / 2 / Math.PI + 0.5);
      }
      function h2(t4) {
        return Math.atan2(t4.z, -t4.x);
      }
      !function(t4) {
        const n3 = new pi(), i3 = new pi(), r4 = new pi();
        for (let o4 = 0; o4 < e3.length; o4 += 3)
          l2(e3[o4 + 0], n3), l2(e3[o4 + 1], i3), l2(e3[o4 + 2], r4), s3(n3, i3, r4, t4);
      }(i2), function(t4) {
        const e4 = new pi();
        for (let n3 = 0; n3 < r3.length; n3 += 3)
          e4.x = r3[n3 + 0], e4.y = r3[n3 + 1], e4.z = r3[n3 + 2], e4.normalize().multiplyScalar(t4), r3[n3 + 0] = e4.x, r3[n3 + 1] = e4.y, r3[n3 + 2] = e4.z;
      }(n2), function() {
        const t4 = new pi();
        for (let n3 = 0; n3 < r3.length; n3 += 3) {
          t4.x = r3[n3 + 0], t4.y = r3[n3 + 1], t4.z = r3[n3 + 2];
          const i3 = h2(t4) / 2 / Math.PI + 0.5, s4 = (e4 = t4, Math.atan2(-e4.y, Math.sqrt(e4.x * e4.x + e4.z * e4.z)) / Math.PI + 0.5);
          o3.push(i3, 1 - s4);
        }
        var e4;
        (function() {
          const t5 = new pi(), e5 = new pi(), n3 = new pi(), i3 = new pi(), s4 = new ei(), a3 = new ei(), l3 = new ei();
          for (let c2 = 0, d2 = 0; c2 < r3.length; c2 += 9, d2 += 6) {
            t5.set(r3[c2 + 0], r3[c2 + 1], r3[c2 + 2]), e5.set(r3[c2 + 3], r3[c2 + 4], r3[c2 + 5]), n3.set(r3[c2 + 6], r3[c2 + 7], r3[c2 + 8]), s4.set(o3[d2 + 0], o3[d2 + 1]), a3.set(o3[d2 + 2], o3[d2 + 3]), l3.set(o3[d2 + 4], o3[d2 + 5]), i3.copy(t5).add(e5).add(n3).divideScalar(3);
            const p2 = h2(i3);
            u2(s4, d2 + 0, t5, p2), u2(a3, d2 + 2, e5, p2), u2(l3, d2 + 4, n3, p2);
          }
        })(), function() {
          for (let t5 = 0; t5 < o3.length; t5 += 6) {
            const e5 = o3[t5 + 0], n3 = o3[t5 + 2], i3 = o3[t5 + 4], r4 = Math.max(e5, n3, i3), s4 = Math.min(e5, n3, i3);
            r4 > 0.9 && s4 < 0.1 && (e5 < 0.2 && (o3[t5 + 0] += 1), n3 < 0.2 && (o3[t5 + 2] += 1), i3 < 0.2 && (o3[t5 + 4] += 1));
          }
        }();
      }(), this.setAttribute("position", new Yr(r3, 3)), this.setAttribute("normal", new Yr(r3.slice(), 3)), this.setAttribute("uv", new Yr(o3, 2)), i2 === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    }
    static fromJSON(t3) {
      return new _u(t3.vertices, t3.indices, t3.radius, t3.details);
    }
  }
  class yu extends _u {
    constructor(t3 = 1, e3 = 0) {
      const n2 = (1 + Math.sqrt(5)) / 2, i2 = 1 / n2;
      super([-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -i2, -n2, 0, -i2, n2, 0, i2, -n2, 0, i2, n2, -i2, -n2, 0, -i2, n2, 0, i2, -n2, 0, i2, n2, 0, -n2, 0, -i2, n2, 0, -i2, -n2, 0, i2, n2, 0, i2], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], t3, e3), this.type = "DodecahedronGeometry", this.parameters = { radius: t3, detail: e3 };
    }
    static fromJSON(t3) {
      return new yu(t3.radius, t3.detail);
    }
  }
  const xu = new pi(), bu = new pi(), Tu = new pi(), wu = new Mr();
  class Su extends so {
    constructor(t3, e3) {
      if (super(), this.type = "EdgesGeometry", this.parameters = { thresholdAngle: e3 }, e3 = e3 !== void 0 ? e3 : 1, t3.isGeometry === true)
        return void console.error("THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      const n2 = Math.pow(10, 4), i2 = Math.cos(Wn * e3), r3 = t3.getIndex(), o3 = t3.getAttribute("position"), s3 = r3 ? r3.count : o3.count, a2 = [0, 0, 0], l2 = ["a", "b", "c"], u2 = new Array(3), h2 = {}, c2 = [];
      for (let t4 = 0; t4 < s3; t4 += 3) {
        r3 ? (a2[0] = r3.getX(t4), a2[1] = r3.getX(t4 + 1), a2[2] = r3.getX(t4 + 2)) : (a2[0] = t4, a2[1] = t4 + 1, a2[2] = t4 + 2);
        const { a: e4, b: s4, c: d2 } = wu;
        if (e4.fromBufferAttribute(o3, a2[0]), s4.fromBufferAttribute(o3, a2[1]), d2.fromBufferAttribute(o3, a2[2]), wu.getNormal(Tu), u2[0] = `${Math.round(e4.x * n2)},${Math.round(e4.y * n2)},${Math.round(e4.z * n2)}`, u2[1] = `${Math.round(s4.x * n2)},${Math.round(s4.y * n2)},${Math.round(s4.z * n2)}`, u2[2] = `${Math.round(d2.x * n2)},${Math.round(d2.y * n2)},${Math.round(d2.z * n2)}`, u2[0] !== u2[1] && u2[1] !== u2[2] && u2[2] !== u2[0])
          for (let t5 = 0; t5 < 3; t5++) {
            const e5 = (t5 + 1) % 3, n3 = u2[t5], r4 = u2[e5], o4 = wu[l2[t5]], s5 = wu[l2[e5]], d3 = `${n3}_${r4}`, p2 = `${r4}_${n3}`;
            p2 in h2 && h2[p2] ? (Tu.dot(h2[p2].normal) <= i2 && (c2.push(o4.x, o4.y, o4.z), c2.push(s5.x, s5.y, s5.z)), h2[p2] = null) : d3 in h2 || (h2[d3] = { index0: a2[t5], index1: a2[e5], normal: Tu.clone() });
          }
      }
      for (const t4 in h2)
        if (h2[t4]) {
          const { index0: e4, index1: n3 } = h2[t4];
          xu.fromBufferAttribute(o3, e4), bu.fromBufferAttribute(o3, n3), c2.push(xu.x, xu.y, xu.z), c2.push(bu.x, bu.y, bu.z);
        }
      this.setAttribute("position", new Yr(c2, 3));
    }
  }
  class Eu {
    constructor() {
      this.type = "Curve", this.arcLengthDivisions = 200;
    }
    getPoint() {
      return console.warn("THREE.Curve: .getPoint() not implemented."), null;
    }
    getPointAt(t3, e3) {
      const n2 = this.getUtoTmapping(t3);
      return this.getPoint(n2, e3);
    }
    getPoints(t3 = 5) {
      const e3 = [];
      for (let n2 = 0; n2 <= t3; n2++)
        e3.push(this.getPoint(n2 / t3));
      return e3;
    }
    getSpacedPoints(t3 = 5) {
      const e3 = [];
      for (let n2 = 0; n2 <= t3; n2++)
        e3.push(this.getPointAt(n2 / t3));
      return e3;
    }
    getLength() {
      const t3 = this.getLengths();
      return t3[t3.length - 1];
    }
    getLengths(t3 = this.arcLengthDivisions) {
      if (this.cacheArcLengths && this.cacheArcLengths.length === t3 + 1 && !this.needsUpdate)
        return this.cacheArcLengths;
      this.needsUpdate = false;
      const e3 = [];
      let n2, i2 = this.getPoint(0), r3 = 0;
      e3.push(0);
      for (let o3 = 1; o3 <= t3; o3++)
        n2 = this.getPoint(o3 / t3), r3 += n2.distanceTo(i2), e3.push(r3), i2 = n2;
      return this.cacheArcLengths = e3, e3;
    }
    updateArcLengths() {
      this.needsUpdate = true, this.getLengths();
    }
    getUtoTmapping(t3, e3) {
      const n2 = this.getLengths();
      let i2 = 0;
      const r3 = n2.length;
      let o3;
      o3 = e3 || t3 * n2[r3 - 1];
      let s3, a2 = 0, l2 = r3 - 1;
      for (; a2 <= l2; )
        if (i2 = Math.floor(a2 + (l2 - a2) / 2), s3 = n2[i2] - o3, s3 < 0)
          a2 = i2 + 1;
        else {
          if (!(s3 > 0)) {
            l2 = i2;
            break;
          }
          l2 = i2 - 1;
        }
      if (i2 = l2, n2[i2] === o3)
        return i2 / (r3 - 1);
      const u2 = n2[i2];
      return (i2 + (o3 - u2) / (n2[i2 + 1] - u2)) / (r3 - 1);
    }
    getTangent(t3, e3) {
      let n2 = t3 - 1e-4, i2 = t3 + 1e-4;
      n2 < 0 && (n2 = 0), i2 > 1 && (i2 = 1);
      const r3 = this.getPoint(n2), o3 = this.getPoint(i2), s3 = e3 || (r3.isVector2 ? new ei() : new pi());
      return s3.copy(o3).sub(r3).normalize(), s3;
    }
    getTangentAt(t3, e3) {
      const n2 = this.getUtoTmapping(t3);
      return this.getTangent(n2, e3);
    }
    computeFrenetFrames(t3, e3) {
      const n2 = new pi(), i2 = [], r3 = [], o3 = [], s3 = new pi(), a2 = new Vi();
      for (let e4 = 0; e4 <= t3; e4++) {
        const n3 = e4 / t3;
        i2[e4] = this.getTangentAt(n3, new pi()), i2[e4].normalize();
      }
      r3[0] = new pi(), o3[0] = new pi();
      let l2 = Number.MAX_VALUE;
      const u2 = Math.abs(i2[0].x), h2 = Math.abs(i2[0].y), c2 = Math.abs(i2[0].z);
      u2 <= l2 && (l2 = u2, n2.set(1, 0, 0)), h2 <= l2 && (l2 = h2, n2.set(0, 1, 0)), c2 <= l2 && n2.set(0, 0, 1), s3.crossVectors(i2[0], n2).normalize(), r3[0].crossVectors(i2[0], s3), o3[0].crossVectors(i2[0], r3[0]);
      for (let e4 = 1; e4 <= t3; e4++) {
        if (r3[e4] = r3[e4 - 1].clone(), o3[e4] = o3[e4 - 1].clone(), s3.crossVectors(i2[e4 - 1], i2[e4]), s3.length() > Number.EPSILON) {
          s3.normalize();
          const t4 = Math.acos(Yn(i2[e4 - 1].dot(i2[e4]), -1, 1));
          r3[e4].applyMatrix4(a2.makeRotationAxis(s3, t4));
        }
        o3[e4].crossVectors(i2[e4], r3[e4]);
      }
      if (e3 === true) {
        let e4 = Math.acos(Yn(r3[0].dot(r3[t3]), -1, 1));
        e4 /= t3, i2[0].dot(s3.crossVectors(r3[0], r3[t3])) > 0 && (e4 = -e4);
        for (let n3 = 1; n3 <= t3; n3++)
          r3[n3].applyMatrix4(a2.makeRotationAxis(i2[n3], e4 * n3)), o3[n3].crossVectors(i2[n3], r3[n3]);
      }
      return { tangents: i2, normals: r3, binormals: o3 };
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t3) {
      return this.arcLengthDivisions = t3.arcLengthDivisions, this;
    }
    toJSON() {
      const t3 = { metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" } };
      return t3.arcLengthDivisions = this.arcLengthDivisions, t3.type = this.type, t3;
    }
    fromJSON(t3) {
      return this.arcLengthDivisions = t3.arcLengthDivisions, this;
    }
  }
  class Mu extends Eu {
    constructor(t3 = 0, e3 = 0, n2 = 1, i2 = 1, r3 = 0, o3 = 2 * Math.PI, s3 = false, a2 = 0) {
      super(), this.type = "EllipseCurve", this.aX = t3, this.aY = e3, this.xRadius = n2, this.yRadius = i2, this.aStartAngle = r3, this.aEndAngle = o3, this.aClockwise = s3, this.aRotation = a2;
    }
    getPoint(t3, e3) {
      const n2 = e3 || new ei(), i2 = 2 * Math.PI;
      let r3 = this.aEndAngle - this.aStartAngle;
      const o3 = Math.abs(r3) < Number.EPSILON;
      for (; r3 < 0; )
        r3 += i2;
      for (; r3 > i2; )
        r3 -= i2;
      r3 < Number.EPSILON && (r3 = o3 ? 0 : i2), this.aClockwise !== true || o3 || (r3 === i2 ? r3 = -i2 : r3 -= i2);
      const s3 = this.aStartAngle + t3 * r3;
      let a2 = this.aX + this.xRadius * Math.cos(s3), l2 = this.aY + this.yRadius * Math.sin(s3);
      if (this.aRotation !== 0) {
        const t4 = Math.cos(this.aRotation), e4 = Math.sin(this.aRotation), n3 = a2 - this.aX, i3 = l2 - this.aY;
        a2 = n3 * t4 - i3 * e4 + this.aX, l2 = n3 * e4 + i3 * t4 + this.aY;
      }
      return n2.set(a2, l2);
    }
    copy(t3) {
      return super.copy(t3), this.aX = t3.aX, this.aY = t3.aY, this.xRadius = t3.xRadius, this.yRadius = t3.yRadius, this.aStartAngle = t3.aStartAngle, this.aEndAngle = t3.aEndAngle, this.aClockwise = t3.aClockwise, this.aRotation = t3.aRotation, this;
    }
    toJSON() {
      const t3 = super.toJSON();
      return t3.aX = this.aX, t3.aY = this.aY, t3.xRadius = this.xRadius, t3.yRadius = this.yRadius, t3.aStartAngle = this.aStartAngle, t3.aEndAngle = this.aEndAngle, t3.aClockwise = this.aClockwise, t3.aRotation = this.aRotation, t3;
    }
    fromJSON(t3) {
      return super.fromJSON(t3), this.aX = t3.aX, this.aY = t3.aY, this.xRadius = t3.xRadius, this.yRadius = t3.yRadius, this.aStartAngle = t3.aStartAngle, this.aEndAngle = t3.aEndAngle, this.aClockwise = t3.aClockwise, this.aRotation = t3.aRotation, this;
    }
  }
  Mu.prototype.isEllipseCurve = true;
  class Au extends Mu {
    constructor(t3, e3, n2, i2, r3, o3) {
      super(t3, e3, n2, n2, i2, r3, o3), this.type = "ArcCurve";
    }
  }
  function Ru() {
    let t3 = 0, e3 = 0, n2 = 0, i2 = 0;
    function r3(r4, o3, s3, a2) {
      t3 = r4, e3 = s3, n2 = -3 * r4 + 3 * o3 - 2 * s3 - a2, i2 = 2 * r4 - 2 * o3 + s3 + a2;
    }
    return { initCatmullRom: function(t4, e4, n3, i3, o3) {
      r3(e4, n3, o3 * (n3 - t4), o3 * (i3 - e4));
    }, initNonuniformCatmullRom: function(t4, e4, n3, i3, o3, s3, a2) {
      let l2 = (e4 - t4) / o3 - (n3 - t4) / (o3 + s3) + (n3 - e4) / s3, u2 = (n3 - e4) / s3 - (i3 - e4) / (s3 + a2) + (i3 - n3) / a2;
      l2 *= s3, u2 *= s3, r3(e4, n3, l2, u2);
    }, calc: function(r4) {
      const o3 = r4 * r4;
      return t3 + e3 * r4 + n2 * o3 + i2 * (o3 * r4);
    } };
  }
  Au.prototype.isArcCurve = true;
  const Pu = new pi(), Cu = new Ru(), Iu = new Ru(), Ou = new Ru();
  class Lu extends Eu {
    constructor(t3 = [], e3 = false, n2 = "centripetal", i2 = 0.5) {
      super(), this.type = "CatmullRomCurve3", this.points = t3, this.closed = e3, this.curveType = n2, this.tension = i2;
    }
    getPoint(t3, e3 = new pi()) {
      const n2 = e3, i2 = this.points, r3 = i2.length, o3 = (r3 - (this.closed ? 0 : 1)) * t3;
      let s3, a2, l2 = Math.floor(o3), u2 = o3 - l2;
      this.closed ? l2 += l2 > 0 ? 0 : (Math.floor(Math.abs(l2) / r3) + 1) * r3 : u2 === 0 && l2 === r3 - 1 && (l2 = r3 - 2, u2 = 1), this.closed || l2 > 0 ? s3 = i2[(l2 - 1) % r3] : (Pu.subVectors(i2[0], i2[1]).add(i2[0]), s3 = Pu);
      const h2 = i2[l2 % r3], c2 = i2[(l2 + 1) % r3];
      if (this.closed || l2 + 2 < r3 ? a2 = i2[(l2 + 2) % r3] : (Pu.subVectors(i2[r3 - 1], i2[r3 - 2]).add(i2[r3 - 1]), a2 = Pu), this.curveType === "centripetal" || this.curveType === "chordal") {
        const t4 = this.curveType === "chordal" ? 0.5 : 0.25;
        let e4 = Math.pow(s3.distanceToSquared(h2), t4), n3 = Math.pow(h2.distanceToSquared(c2), t4), i3 = Math.pow(c2.distanceToSquared(a2), t4);
        n3 < 1e-4 && (n3 = 1), e4 < 1e-4 && (e4 = n3), i3 < 1e-4 && (i3 = n3), Cu.initNonuniformCatmullRom(s3.x, h2.x, c2.x, a2.x, e4, n3, i3), Iu.initNonuniformCatmullRom(s3.y, h2.y, c2.y, a2.y, e4, n3, i3), Ou.initNonuniformCatmullRom(s3.z, h2.z, c2.z, a2.z, e4, n3, i3);
      } else
        this.curveType === "catmullrom" && (Cu.initCatmullRom(s3.x, h2.x, c2.x, a2.x, this.tension), Iu.initCatmullRom(s3.y, h2.y, c2.y, a2.y, this.tension), Ou.initCatmullRom(s3.z, h2.z, c2.z, a2.z, this.tension));
      return n2.set(Cu.calc(u2), Iu.calc(u2), Ou.calc(u2)), n2;
    }
    copy(t3) {
      super.copy(t3), this.points = [];
      for (let e3 = 0, n2 = t3.points.length; e3 < n2; e3++) {
        const n3 = t3.points[e3];
        this.points.push(n3.clone());
      }
      return this.closed = t3.closed, this.curveType = t3.curveType, this.tension = t3.tension, this;
    }
    toJSON() {
      const t3 = super.toJSON();
      t3.points = [];
      for (let e3 = 0, n2 = this.points.length; e3 < n2; e3++) {
        const n3 = this.points[e3];
        t3.points.push(n3.toArray());
      }
      return t3.closed = this.closed, t3.curveType = this.curveType, t3.tension = this.tension, t3;
    }
    fromJSON(t3) {
      super.fromJSON(t3), this.points = [];
      for (let e3 = 0, n2 = t3.points.length; e3 < n2; e3++) {
        const n3 = t3.points[e3];
        this.points.push(new pi().fromArray(n3));
      }
      return this.closed = t3.closed, this.curveType = t3.curveType, this.tension = t3.tension, this;
    }
  }
  function Nu(t3, e3, n2, i2, r3) {
    const o3 = 0.5 * (i2 - e3), s3 = 0.5 * (r3 - n2), a2 = t3 * t3;
    return (2 * n2 - 2 * i2 + o3 + s3) * (t3 * a2) + (-3 * n2 + 3 * i2 - 2 * o3 - s3) * a2 + o3 * t3 + n2;
  }
  function Du(t3, e3, n2, i2) {
    return function(t4, e4) {
      const n3 = 1 - t4;
      return n3 * n3 * e4;
    }(t3, e3) + function(t4, e4) {
      return 2 * (1 - t4) * t4 * e4;
    }(t3, n2) + function(t4, e4) {
      return t4 * t4 * e4;
    }(t3, i2);
  }
  function Fu(t3, e3, n2, i2, r3) {
    return function(t4, e4) {
      const n3 = 1 - t4;
      return n3 * n3 * n3 * e4;
    }(t3, e3) + function(t4, e4) {
      const n3 = 1 - t4;
      return 3 * n3 * n3 * t4 * e4;
    }(t3, n2) + function(t4, e4) {
      return 3 * (1 - t4) * t4 * t4 * e4;
    }(t3, i2) + function(t4, e4) {
      return t4 * t4 * t4 * e4;
    }(t3, r3);
  }
  Lu.prototype.isCatmullRomCurve3 = true;
  class Bu extends Eu {
    constructor(t3 = new ei(), e3 = new ei(), n2 = new ei(), i2 = new ei()) {
      super(), this.type = "CubicBezierCurve", this.v0 = t3, this.v1 = e3, this.v2 = n2, this.v3 = i2;
    }
    getPoint(t3, e3 = new ei()) {
      const n2 = e3, i2 = this.v0, r3 = this.v1, o3 = this.v2, s3 = this.v3;
      return n2.set(Fu(t3, i2.x, r3.x, o3.x, s3.x), Fu(t3, i2.y, r3.y, o3.y, s3.y)), n2;
    }
    copy(t3) {
      return super.copy(t3), this.v0.copy(t3.v0), this.v1.copy(t3.v1), this.v2.copy(t3.v2), this.v3.copy(t3.v3), this;
    }
    toJSON() {
      const t3 = super.toJSON();
      return t3.v0 = this.v0.toArray(), t3.v1 = this.v1.toArray(), t3.v2 = this.v2.toArray(), t3.v3 = this.v3.toArray(), t3;
    }
    fromJSON(t3) {
      return super.fromJSON(t3), this.v0.fromArray(t3.v0), this.v1.fromArray(t3.v1), this.v2.fromArray(t3.v2), this.v3.fromArray(t3.v3), this;
    }
  }
  Bu.prototype.isCubicBezierCurve = true;
  class Uu extends Eu {
    constructor(t3 = new pi(), e3 = new pi(), n2 = new pi(), i2 = new pi()) {
      super(), this.type = "CubicBezierCurve3", this.v0 = t3, this.v1 = e3, this.v2 = n2, this.v3 = i2;
    }
    getPoint(t3, e3 = new pi()) {
      const n2 = e3, i2 = this.v0, r3 = this.v1, o3 = this.v2, s3 = this.v3;
      return n2.set(Fu(t3, i2.x, r3.x, o3.x, s3.x), Fu(t3, i2.y, r3.y, o3.y, s3.y), Fu(t3, i2.z, r3.z, o3.z, s3.z)), n2;
    }
    copy(t3) {
      return super.copy(t3), this.v0.copy(t3.v0), this.v1.copy(t3.v1), this.v2.copy(t3.v2), this.v3.copy(t3.v3), this;
    }
    toJSON() {
      const t3 = super.toJSON();
      return t3.v0 = this.v0.toArray(), t3.v1 = this.v1.toArray(), t3.v2 = this.v2.toArray(), t3.v3 = this.v3.toArray(), t3;
    }
    fromJSON(t3) {
      return super.fromJSON(t3), this.v0.fromArray(t3.v0), this.v1.fromArray(t3.v1), this.v2.fromArray(t3.v2), this.v3.fromArray(t3.v3), this;
    }
  }
  Uu.prototype.isCubicBezierCurve3 = true;
  class ku extends Eu {
    constructor(t3 = new ei(), e3 = new ei()) {
      super(), this.type = "LineCurve", this.v1 = t3, this.v2 = e3;
    }
    getPoint(t3, e3 = new ei()) {
      const n2 = e3;
      return t3 === 1 ? n2.copy(this.v2) : (n2.copy(this.v2).sub(this.v1), n2.multiplyScalar(t3).add(this.v1)), n2;
    }
    getPointAt(t3, e3) {
      return this.getPoint(t3, e3);
    }
    getTangent(t3, e3) {
      const n2 = e3 || new ei();
      return n2.copy(this.v2).sub(this.v1).normalize(), n2;
    }
    copy(t3) {
      return super.copy(t3), this.v1.copy(t3.v1), this.v2.copy(t3.v2), this;
    }
    toJSON() {
      const t3 = super.toJSON();
      return t3.v1 = this.v1.toArray(), t3.v2 = this.v2.toArray(), t3;
    }
    fromJSON(t3) {
      return super.fromJSON(t3), this.v1.fromArray(t3.v1), this.v2.fromArray(t3.v2), this;
    }
  }
  ku.prototype.isLineCurve = true;
  class Gu extends Eu {
    constructor(t3 = new pi(), e3 = new pi()) {
      super(), this.type = "LineCurve3", this.isLineCurve3 = true, this.v1 = t3, this.v2 = e3;
    }
    getPoint(t3, e3 = new pi()) {
      const n2 = e3;
      return t3 === 1 ? n2.copy(this.v2) : (n2.copy(this.v2).sub(this.v1), n2.multiplyScalar(t3).add(this.v1)), n2;
    }
    getPointAt(t3, e3) {
      return this.getPoint(t3, e3);
    }
    copy(t3) {
      return super.copy(t3), this.v1.copy(t3.v1), this.v2.copy(t3.v2), this;
    }
    toJSON() {
      const t3 = super.toJSON();
      return t3.v1 = this.v1.toArray(), t3.v2 = this.v2.toArray(), t3;
    }
    fromJSON(t3) {
      return super.fromJSON(t3), this.v1.fromArray(t3.v1), this.v2.fromArray(t3.v2), this;
    }
  }
  class Hu extends Eu {
    constructor(t3 = new ei(), e3 = new ei(), n2 = new ei()) {
      super(), this.type = "QuadraticBezierCurve", this.v0 = t3, this.v1 = e3, this.v2 = n2;
    }
    getPoint(t3, e3 = new ei()) {
      const n2 = e3, i2 = this.v0, r3 = this.v1, o3 = this.v2;
      return n2.set(Du(t3, i2.x, r3.x, o3.x), Du(t3, i2.y, r3.y, o3.y)), n2;
    }
    copy(t3) {
      return super.copy(t3), this.v0.copy(t3.v0), this.v1.copy(t3.v1), this.v2.copy(t3.v2), this;
    }
    toJSON() {
      const t3 = super.toJSON();
      return t3.v0 = this.v0.toArray(), t3.v1 = this.v1.toArray(), t3.v2 = this.v2.toArray(), t3;
    }
    fromJSON(t3) {
      return super.fromJSON(t3), this.v0.fromArray(t3.v0), this.v1.fromArray(t3.v1), this.v2.fromArray(t3.v2), this;
    }
  }
  Hu.prototype.isQuadraticBezierCurve = true;
  class zu extends Eu {
    constructor(t3 = new pi(), e3 = new pi(), n2 = new pi()) {
      super(), this.type = "QuadraticBezierCurve3", this.v0 = t3, this.v1 = e3, this.v2 = n2;
    }
    getPoint(t3, e3 = new pi()) {
      const n2 = e3, i2 = this.v0, r3 = this.v1, o3 = this.v2;
      return n2.set(Du(t3, i2.x, r3.x, o3.x), Du(t3, i2.y, r3.y, o3.y), Du(t3, i2.z, r3.z, o3.z)), n2;
    }
    copy(t3) {
      return super.copy(t3), this.v0.copy(t3.v0), this.v1.copy(t3.v1), this.v2.copy(t3.v2), this;
    }
    toJSON() {
      const t3 = super.toJSON();
      return t3.v0 = this.v0.toArray(), t3.v1 = this.v1.toArray(), t3.v2 = this.v2.toArray(), t3;
    }
    fromJSON(t3) {
      return super.fromJSON(t3), this.v0.fromArray(t3.v0), this.v1.fromArray(t3.v1), this.v2.fromArray(t3.v2), this;
    }
  }
  zu.prototype.isQuadraticBezierCurve3 = true;
  class ju extends Eu {
    constructor(t3 = []) {
      super(), this.type = "SplineCurve", this.points = t3;
    }
    getPoint(t3, e3 = new ei()) {
      const n2 = e3, i2 = this.points, r3 = (i2.length - 1) * t3, o3 = Math.floor(r3), s3 = r3 - o3, a2 = i2[o3 === 0 ? o3 : o3 - 1], l2 = i2[o3], u2 = i2[o3 > i2.length - 2 ? i2.length - 1 : o3 + 1], h2 = i2[o3 > i2.length - 3 ? i2.length - 1 : o3 + 2];
      return n2.set(Nu(s3, a2.x, l2.x, u2.x, h2.x), Nu(s3, a2.y, l2.y, u2.y, h2.y)), n2;
    }
    copy(t3) {
      super.copy(t3), this.points = [];
      for (let e3 = 0, n2 = t3.points.length; e3 < n2; e3++) {
        const n3 = t3.points[e3];
        this.points.push(n3.clone());
      }
      return this;
    }
    toJSON() {
      const t3 = super.toJSON();
      t3.points = [];
      for (let e3 = 0, n2 = this.points.length; e3 < n2; e3++) {
        const n3 = this.points[e3];
        t3.points.push(n3.toArray());
      }
      return t3;
    }
    fromJSON(t3) {
      super.fromJSON(t3), this.points = [];
      for (let e3 = 0, n2 = t3.points.length; e3 < n2; e3++) {
        const n3 = t3.points[e3];
        this.points.push(new ei().fromArray(n3));
      }
      return this;
    }
  }
  ju.prototype.isSplineCurve = true;
  var Vu = Object.freeze({ __proto__: null, ArcCurve: Au, CatmullRomCurve3: Lu, CubicBezierCurve: Bu, CubicBezierCurve3: Uu, EllipseCurve: Mu, LineCurve: ku, LineCurve3: Gu, QuadraticBezierCurve: Hu, QuadraticBezierCurve3: zu, SplineCurve: ju });
  const Wu = function(t3, e3, n2 = 2) {
    const i2 = e3 && e3.length, r3 = i2 ? e3[0] * n2 : t3.length;
    let o3 = Xu(t3, 0, r3, n2, true);
    const s3 = [];
    if (!o3 || o3.next === o3.prev)
      return s3;
    let a2, l2, u2, h2, c2, d2, p2;
    if (i2 && (o3 = function(t4, e4, n3, i3) {
      const r4 = [];
      let o4, s4, a3, l3, u3;
      for (o4 = 0, s4 = e4.length; o4 < s4; o4++)
        a3 = e4[o4] * i3, l3 = o4 < s4 - 1 ? e4[o4 + 1] * i3 : t4.length, u3 = Xu(t4, a3, l3, i3, false), u3 === u3.next && (u3.steiner = true), r4.push(ih(u3));
      for (r4.sort(Qu), o4 = 0; o4 < r4.length; o4++)
        th(r4[o4], n3), n3 = qu(n3, n3.next);
      return n3;
    }(t3, e3, o3, n2)), t3.length > 80 * n2) {
      a2 = u2 = t3[0], l2 = h2 = t3[1];
      for (let e4 = n2; e4 < r3; e4 += n2)
        c2 = t3[e4], d2 = t3[e4 + 1], c2 < a2 && (a2 = c2), d2 < l2 && (l2 = d2), c2 > u2 && (u2 = c2), d2 > h2 && (h2 = d2);
      p2 = Math.max(u2 - a2, h2 - l2), p2 = p2 !== 0 ? 1 / p2 : 0;
    }
    return Yu(o3, s3, n2, a2, l2, p2), s3;
  };
  function Xu(t3, e3, n2, i2, r3) {
    let o3, s3;
    if (r3 === function(t4, e4, n3, i3) {
      let r4 = 0;
      for (let o4 = e4, s4 = n3 - i3; o4 < n3; o4 += i3)
        r4 += (t4[s4] - t4[o4]) * (t4[o4 + 1] + t4[s4 + 1]), s4 = o4;
      return r4;
    }(t3, e3, n2, i2) > 0)
      for (o3 = e3; o3 < n2; o3 += i2)
        s3 = ph(o3, t3[o3], t3[o3 + 1], s3);
    else
      for (o3 = n2 - i2; o3 >= e3; o3 -= i2)
        s3 = ph(o3, t3[o3], t3[o3 + 1], s3);
    return s3 && ah(s3, s3.next) && (fh(s3), s3 = s3.next), s3;
  }
  function qu(t3, e3) {
    if (!t3)
      return t3;
    e3 || (e3 = t3);
    let n2, i2 = t3;
    do {
      if (n2 = false, i2.steiner || !ah(i2, i2.next) && sh(i2.prev, i2, i2.next) !== 0)
        i2 = i2.next;
      else {
        if (fh(i2), i2 = e3 = i2.prev, i2 === i2.next)
          break;
        n2 = true;
      }
    } while (n2 || i2 !== e3);
    return e3;
  }
  function Yu(t3, e3, n2, i2, r3, o3, s3) {
    if (!t3)
      return;
    !s3 && o3 && function(t4, e4, n3, i3) {
      let r4 = t4;
      do {
        r4.z === null && (r4.z = nh(r4.x, r4.y, e4, n3, i3)), r4.prevZ = r4.prev, r4.nextZ = r4.next, r4 = r4.next;
      } while (r4 !== t4);
      r4.prevZ.nextZ = null, r4.prevZ = null, function(t5) {
        let e5, n4, i4, r5, o4, s4, a3, l3, u3 = 1;
        do {
          for (n4 = t5, t5 = null, o4 = null, s4 = 0; n4; ) {
            for (s4++, i4 = n4, a3 = 0, e5 = 0; e5 < u3 && (a3++, i4 = i4.nextZ, i4); e5++)
              ;
            for (l3 = u3; a3 > 0 || l3 > 0 && i4; )
              a3 !== 0 && (l3 === 0 || !i4 || n4.z <= i4.z) ? (r5 = n4, n4 = n4.nextZ, a3--) : (r5 = i4, i4 = i4.nextZ, l3--), o4 ? o4.nextZ = r5 : t5 = r5, r5.prevZ = o4, o4 = r5;
            n4 = i4;
          }
          o4.nextZ = null, u3 *= 2;
        } while (s4 > 1);
      }(r4);
    }(t3, i2, r3, o3);
    let a2, l2, u2 = t3;
    for (; t3.prev !== t3.next; )
      if (a2 = t3.prev, l2 = t3.next, o3 ? Ju(t3, i2, r3, o3) : Zu(t3))
        e3.push(a2.i / n2), e3.push(t3.i / n2), e3.push(l2.i / n2), fh(t3), t3 = l2.next, u2 = l2.next;
      else if ((t3 = l2) === u2) {
        s3 ? s3 === 1 ? Yu(t3 = $u(qu(t3), e3, n2), e3, n2, i2, r3, o3, 2) : s3 === 2 && Ku(t3, e3, n2, i2, r3, o3) : Yu(qu(t3), e3, n2, i2, r3, o3, 1);
        break;
      }
  }
  function Zu(t3) {
    const e3 = t3.prev, n2 = t3, i2 = t3.next;
    if (sh(e3, n2, i2) >= 0)
      return false;
    let r3 = t3.next.next;
    for (; r3 !== t3.prev; ) {
      if (rh(e3.x, e3.y, n2.x, n2.y, i2.x, i2.y, r3.x, r3.y) && sh(r3.prev, r3, r3.next) >= 0)
        return false;
      r3 = r3.next;
    }
    return true;
  }
  function Ju(t3, e3, n2, i2) {
    const r3 = t3.prev, o3 = t3, s3 = t3.next;
    if (sh(r3, o3, s3) >= 0)
      return false;
    const a2 = r3.x < o3.x ? r3.x < s3.x ? r3.x : s3.x : o3.x < s3.x ? o3.x : s3.x, l2 = r3.y < o3.y ? r3.y < s3.y ? r3.y : s3.y : o3.y < s3.y ? o3.y : s3.y, u2 = r3.x > o3.x ? r3.x > s3.x ? r3.x : s3.x : o3.x > s3.x ? o3.x : s3.x, h2 = r3.y > o3.y ? r3.y > s3.y ? r3.y : s3.y : o3.y > s3.y ? o3.y : s3.y, c2 = nh(a2, l2, e3, n2, i2), d2 = nh(u2, h2, e3, n2, i2);
    let p2 = t3.prevZ, f2 = t3.nextZ;
    for (; p2 && p2.z >= c2 && f2 && f2.z <= d2; ) {
      if (p2 !== t3.prev && p2 !== t3.next && rh(r3.x, r3.y, o3.x, o3.y, s3.x, s3.y, p2.x, p2.y) && sh(p2.prev, p2, p2.next) >= 0)
        return false;
      if (p2 = p2.prevZ, f2 !== t3.prev && f2 !== t3.next && rh(r3.x, r3.y, o3.x, o3.y, s3.x, s3.y, f2.x, f2.y) && sh(f2.prev, f2, f2.next) >= 0)
        return false;
      f2 = f2.nextZ;
    }
    for (; p2 && p2.z >= c2; ) {
      if (p2 !== t3.prev && p2 !== t3.next && rh(r3.x, r3.y, o3.x, o3.y, s3.x, s3.y, p2.x, p2.y) && sh(p2.prev, p2, p2.next) >= 0)
        return false;
      p2 = p2.prevZ;
    }
    for (; f2 && f2.z <= d2; ) {
      if (f2 !== t3.prev && f2 !== t3.next && rh(r3.x, r3.y, o3.x, o3.y, s3.x, s3.y, f2.x, f2.y) && sh(f2.prev, f2, f2.next) >= 0)
        return false;
      f2 = f2.nextZ;
    }
    return true;
  }
  function $u(t3, e3, n2) {
    let i2 = t3;
    do {
      const r3 = i2.prev, o3 = i2.next.next;
      !ah(r3, o3) && lh(r3, i2, i2.next, o3) && ch(r3, o3) && ch(o3, r3) && (e3.push(r3.i / n2), e3.push(i2.i / n2), e3.push(o3.i / n2), fh(i2), fh(i2.next), i2 = t3 = o3), i2 = i2.next;
    } while (i2 !== t3);
    return qu(i2);
  }
  function Ku(t3, e3, n2, i2, r3, o3) {
    let s3 = t3;
    do {
      let t4 = s3.next.next;
      for (; t4 !== s3.prev; ) {
        if (s3.i !== t4.i && oh(s3, t4)) {
          let a2 = dh(s3, t4);
          return s3 = qu(s3, s3.next), a2 = qu(a2, a2.next), Yu(s3, e3, n2, i2, r3, o3), void Yu(a2, e3, n2, i2, r3, o3);
        }
        t4 = t4.next;
      }
      s3 = s3.next;
    } while (s3 !== t3);
  }
  function Qu(t3, e3) {
    return t3.x - e3.x;
  }
  function th(t3, e3) {
    if (e3 = function(t4, e4) {
      let n2 = e4;
      const i2 = t4.x, r3 = t4.y;
      let o3, s3 = -1 / 0;
      do {
        if (r3 <= n2.y && r3 >= n2.next.y && n2.next.y !== n2.y) {
          const t5 = n2.x + (r3 - n2.y) * (n2.next.x - n2.x) / (n2.next.y - n2.y);
          if (t5 <= i2 && t5 > s3) {
            if (s3 = t5, t5 === i2) {
              if (r3 === n2.y)
                return n2;
              if (r3 === n2.next.y)
                return n2.next;
            }
            o3 = n2.x < n2.next.x ? n2 : n2.next;
          }
        }
        n2 = n2.next;
      } while (n2 !== e4);
      if (!o3)
        return null;
      if (i2 === s3)
        return o3;
      const a2 = o3, l2 = o3.x, u2 = o3.y;
      let h2, c2 = 1 / 0;
      n2 = o3;
      do {
        i2 >= n2.x && n2.x >= l2 && i2 !== n2.x && rh(r3 < u2 ? i2 : s3, r3, l2, u2, r3 < u2 ? s3 : i2, r3, n2.x, n2.y) && (h2 = Math.abs(r3 - n2.y) / (i2 - n2.x), ch(n2, t4) && (h2 < c2 || h2 === c2 && (n2.x > o3.x || n2.x === o3.x && eh(o3, n2))) && (o3 = n2, c2 = h2)), n2 = n2.next;
      } while (n2 !== a2);
      return o3;
    }(t3, e3)) {
      const n2 = dh(e3, t3);
      qu(e3, e3.next), qu(n2, n2.next);
    }
  }
  function eh(t3, e3) {
    return sh(t3.prev, t3, e3.prev) < 0 && sh(e3.next, t3, t3.next) < 0;
  }
  function nh(t3, e3, n2, i2, r3) {
    return (t3 = 1431655765 & ((t3 = 858993459 & ((t3 = 252645135 & ((t3 = 16711935 & ((t3 = 32767 * (t3 - n2) * r3) | t3 << 8)) | t3 << 4)) | t3 << 2)) | t3 << 1)) | (e3 = 1431655765 & ((e3 = 858993459 & ((e3 = 252645135 & ((e3 = 16711935 & ((e3 = 32767 * (e3 - i2) * r3) | e3 << 8)) | e3 << 4)) | e3 << 2)) | e3 << 1)) << 1;
  }
  function ih(t3) {
    let e3 = t3, n2 = t3;
    do {
      (e3.x < n2.x || e3.x === n2.x && e3.y < n2.y) && (n2 = e3), e3 = e3.next;
    } while (e3 !== t3);
    return n2;
  }
  function rh(t3, e3, n2, i2, r3, o3, s3, a2) {
    return (r3 - s3) * (e3 - a2) - (t3 - s3) * (o3 - a2) >= 0 && (t3 - s3) * (i2 - a2) - (n2 - s3) * (e3 - a2) >= 0 && (n2 - s3) * (o3 - a2) - (r3 - s3) * (i2 - a2) >= 0;
  }
  function oh(t3, e3) {
    return t3.next.i !== e3.i && t3.prev.i !== e3.i && !function(t4, e4) {
      let n2 = t4;
      do {
        if (n2.i !== t4.i && n2.next.i !== t4.i && n2.i !== e4.i && n2.next.i !== e4.i && lh(n2, n2.next, t4, e4))
          return true;
        n2 = n2.next;
      } while (n2 !== t4);
      return false;
    }(t3, e3) && (ch(t3, e3) && ch(e3, t3) && function(t4, e4) {
      let n2 = t4, i2 = false;
      const r3 = (t4.x + e4.x) / 2, o3 = (t4.y + e4.y) / 2;
      do {
        n2.y > o3 != n2.next.y > o3 && n2.next.y !== n2.y && r3 < (n2.next.x - n2.x) * (o3 - n2.y) / (n2.next.y - n2.y) + n2.x && (i2 = !i2), n2 = n2.next;
      } while (n2 !== t4);
      return i2;
    }(t3, e3) && (sh(t3.prev, t3, e3.prev) || sh(t3, e3.prev, e3)) || ah(t3, e3) && sh(t3.prev, t3, t3.next) > 0 && sh(e3.prev, e3, e3.next) > 0);
  }
  function sh(t3, e3, n2) {
    return (e3.y - t3.y) * (n2.x - e3.x) - (e3.x - t3.x) * (n2.y - e3.y);
  }
  function ah(t3, e3) {
    return t3.x === e3.x && t3.y === e3.y;
  }
  function lh(t3, e3, n2, i2) {
    const r3 = hh(sh(t3, e3, n2)), o3 = hh(sh(t3, e3, i2)), s3 = hh(sh(n2, i2, t3)), a2 = hh(sh(n2, i2, e3));
    return r3 !== o3 && s3 !== a2 || (!(r3 !== 0 || !uh(t3, n2, e3)) || (!(o3 !== 0 || !uh(t3, i2, e3)) || (!(s3 !== 0 || !uh(n2, t3, i2)) || !(a2 !== 0 || !uh(n2, e3, i2)))));
  }
  function uh(t3, e3, n2) {
    return e3.x <= Math.max(t3.x, n2.x) && e3.x >= Math.min(t3.x, n2.x) && e3.y <= Math.max(t3.y, n2.y) && e3.y >= Math.min(t3.y, n2.y);
  }
  function hh(t3) {
    return t3 > 0 ? 1 : t3 < 0 ? -1 : 0;
  }
  function ch(t3, e3) {
    return sh(t3.prev, t3, t3.next) < 0 ? sh(t3, e3, t3.next) >= 0 && sh(t3, t3.prev, e3) >= 0 : sh(t3, e3, t3.prev) < 0 || sh(t3, t3.next, e3) < 0;
  }
  function dh(t3, e3) {
    const n2 = new mh(t3.i, t3.x, t3.y), i2 = new mh(e3.i, e3.x, e3.y), r3 = t3.next, o3 = e3.prev;
    return t3.next = e3, e3.prev = t3, n2.next = r3, r3.prev = n2, i2.next = n2, n2.prev = i2, o3.next = i2, i2.prev = o3, i2;
  }
  function ph(t3, e3, n2, i2) {
    const r3 = new mh(t3, e3, n2);
    return i2 ? (r3.next = i2.next, r3.prev = i2, i2.next.prev = r3, i2.next = r3) : (r3.prev = r3, r3.next = r3), r3;
  }
  function fh(t3) {
    t3.next.prev = t3.prev, t3.prev.next = t3.next, t3.prevZ && (t3.prevZ.nextZ = t3.nextZ), t3.nextZ && (t3.nextZ.prevZ = t3.prevZ);
  }
  function mh(t3, e3, n2) {
    this.i = t3, this.x = e3, this.y = n2, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = false;
  }
  class gh {
    static area(t3) {
      const e3 = t3.length;
      let n2 = 0;
      for (let i2 = e3 - 1, r3 = 0; r3 < e3; i2 = r3++)
        n2 += t3[i2].x * t3[r3].y - t3[r3].x * t3[i2].y;
      return 0.5 * n2;
    }
    static isClockWise(t3) {
      return gh.area(t3) < 0;
    }
    static triangulateShape(t3, e3) {
      const n2 = [], i2 = [], r3 = [];
      vh(t3), _h(n2, t3);
      let o3 = t3.length;
      e3.forEach(vh);
      for (let t4 = 0; t4 < e3.length; t4++)
        i2.push(o3), o3 += e3[t4].length, _h(n2, e3[t4]);
      const s3 = Wu(n2, i2);
      for (let t4 = 0; t4 < s3.length; t4 += 3)
        r3.push(s3.slice(t4, t4 + 3));
      return r3;
    }
  }
  function vh(t3) {
    const e3 = t3.length;
    e3 > 2 && t3[e3 - 1].equals(t3[0]) && t3.pop();
  }
  function _h(t3, e3) {
    for (let n2 = 0; n2 < e3.length; n2++)
      t3.push(e3[n2].x), t3.push(e3[n2].y);
  }
  class yh extends so {
    constructor(t3, e3) {
      super(), this.type = "ExtrudeGeometry", this.parameters = { shapes: t3, options: e3 }, t3 = Array.isArray(t3) ? t3 : [t3];
      const n2 = this, i2 = [], r3 = [];
      for (let e4 = 0, n3 = t3.length; e4 < n3; e4++) {
        o3(t3[e4]);
      }
      function o3(t4) {
        const o4 = [], s3 = e3.curveSegments !== void 0 ? e3.curveSegments : 12, a2 = e3.steps !== void 0 ? e3.steps : 1;
        let l2 = e3.depth !== void 0 ? e3.depth : 100, u2 = e3.bevelEnabled === void 0 || e3.bevelEnabled, h2 = e3.bevelThickness !== void 0 ? e3.bevelThickness : 6, c2 = e3.bevelSize !== void 0 ? e3.bevelSize : h2 - 2, d2 = e3.bevelOffset !== void 0 ? e3.bevelOffset : 0, p2 = e3.bevelSegments !== void 0 ? e3.bevelSegments : 3;
        const f2 = e3.extrudePath, m2 = e3.UVGenerator !== void 0 ? e3.UVGenerator : xh;
        e3.amount !== void 0 && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), l2 = e3.amount);
        let g2, v2, _2, y2, x2, b2 = false;
        f2 && (g2 = f2.getSpacedPoints(a2), b2 = true, u2 = false, v2 = f2.computeFrenetFrames(a2, false), _2 = new pi(), y2 = new pi(), x2 = new pi()), u2 || (p2 = 0, h2 = 0, c2 = 0, d2 = 0);
        const T2 = t4.extractPoints(s3);
        let w2 = T2.shape;
        const S2 = T2.holes;
        if (!gh.isClockWise(w2)) {
          w2 = w2.reverse();
          for (let t5 = 0, e4 = S2.length; t5 < e4; t5++) {
            const e5 = S2[t5];
            gh.isClockWise(e5) && (S2[t5] = e5.reverse());
          }
        }
        const E2 = gh.triangulateShape(w2, S2), M2 = w2;
        for (let t5 = 0, e4 = S2.length; t5 < e4; t5++) {
          const e5 = S2[t5];
          w2 = w2.concat(e5);
        }
        function A2(t5, e4, n3) {
          return e4 || console.error("THREE.ExtrudeGeometry: vec does not exist"), e4.clone().multiplyScalar(n3).add(t5);
        }
        const R2 = w2.length, P2 = E2.length;
        function C2(t5, e4, n3) {
          let i3, r4, o5;
          const s4 = t5.x - e4.x, a3 = t5.y - e4.y, l3 = n3.x - t5.x, u3 = n3.y - t5.y, h3 = s4 * s4 + a3 * a3, c3 = s4 * u3 - a3 * l3;
          if (Math.abs(c3) > Number.EPSILON) {
            const c4 = Math.sqrt(h3), d3 = Math.sqrt(l3 * l3 + u3 * u3), p3 = e4.x - a3 / c4, f3 = e4.y + s4 / c4, m3 = ((n3.x - u3 / d3 - p3) * u3 - (n3.y + l3 / d3 - f3) * l3) / (s4 * u3 - a3 * l3);
            i3 = p3 + s4 * m3 - t5.x, r4 = f3 + a3 * m3 - t5.y;
            const g3 = i3 * i3 + r4 * r4;
            if (g3 <= 2)
              return new ei(i3, r4);
            o5 = Math.sqrt(g3 / 2);
          } else {
            let t6 = false;
            s4 > Number.EPSILON ? l3 > Number.EPSILON && (t6 = true) : s4 < -Number.EPSILON ? l3 < -Number.EPSILON && (t6 = true) : Math.sign(a3) === Math.sign(u3) && (t6 = true), t6 ? (i3 = -a3, r4 = s4, o5 = Math.sqrt(h3)) : (i3 = s4, r4 = a3, o5 = Math.sqrt(h3 / 2));
          }
          return new ei(i3 / o5, r4 / o5);
        }
        const I2 = [];
        for (let t5 = 0, e4 = M2.length, n3 = e4 - 1, i3 = t5 + 1; t5 < e4; t5++, n3++, i3++)
          n3 === e4 && (n3 = 0), i3 === e4 && (i3 = 0), I2[t5] = C2(M2[t5], M2[n3], M2[i3]);
        const O2 = [];
        let L2, N2 = I2.concat();
        for (let t5 = 0, e4 = S2.length; t5 < e4; t5++) {
          const e5 = S2[t5];
          L2 = [];
          for (let t6 = 0, n3 = e5.length, i3 = n3 - 1, r4 = t6 + 1; t6 < n3; t6++, i3++, r4++)
            i3 === n3 && (i3 = 0), r4 === n3 && (r4 = 0), L2[t6] = C2(e5[t6], e5[i3], e5[r4]);
          O2.push(L2), N2 = N2.concat(L2);
        }
        for (let t5 = 0; t5 < p2; t5++) {
          const e4 = t5 / p2, n3 = h2 * Math.cos(e4 * Math.PI / 2), i3 = c2 * Math.sin(e4 * Math.PI / 2) + d2;
          for (let t6 = 0, e5 = M2.length; t6 < e5; t6++) {
            const e6 = A2(M2[t6], I2[t6], i3);
            B2(e6.x, e6.y, -n3);
          }
          for (let t6 = 0, e5 = S2.length; t6 < e5; t6++) {
            const e6 = S2[t6];
            L2 = O2[t6];
            for (let t7 = 0, r4 = e6.length; t7 < r4; t7++) {
              const r5 = A2(e6[t7], L2[t7], i3);
              B2(r5.x, r5.y, -n3);
            }
          }
        }
        const D2 = c2 + d2;
        for (let t5 = 0; t5 < R2; t5++) {
          const e4 = u2 ? A2(w2[t5], N2[t5], D2) : w2[t5];
          b2 ? (y2.copy(v2.normals[0]).multiplyScalar(e4.x), _2.copy(v2.binormals[0]).multiplyScalar(e4.y), x2.copy(g2[0]).add(y2).add(_2), B2(x2.x, x2.y, x2.z)) : B2(e4.x, e4.y, 0);
        }
        for (let t5 = 1; t5 <= a2; t5++)
          for (let e4 = 0; e4 < R2; e4++) {
            const n3 = u2 ? A2(w2[e4], N2[e4], D2) : w2[e4];
            b2 ? (y2.copy(v2.normals[t5]).multiplyScalar(n3.x), _2.copy(v2.binormals[t5]).multiplyScalar(n3.y), x2.copy(g2[t5]).add(y2).add(_2), B2(x2.x, x2.y, x2.z)) : B2(n3.x, n3.y, l2 / a2 * t5);
          }
        for (let t5 = p2 - 1; t5 >= 0; t5--) {
          const e4 = t5 / p2, n3 = h2 * Math.cos(e4 * Math.PI / 2), i3 = c2 * Math.sin(e4 * Math.PI / 2) + d2;
          for (let t6 = 0, e5 = M2.length; t6 < e5; t6++) {
            const e6 = A2(M2[t6], I2[t6], i3);
            B2(e6.x, e6.y, l2 + n3);
          }
          for (let t6 = 0, e5 = S2.length; t6 < e5; t6++) {
            const e6 = S2[t6];
            L2 = O2[t6];
            for (let t7 = 0, r4 = e6.length; t7 < r4; t7++) {
              const r5 = A2(e6[t7], L2[t7], i3);
              b2 ? B2(r5.x, r5.y + g2[a2 - 1].y, g2[a2 - 1].x + n3) : B2(r5.x, r5.y, l2 + n3);
            }
          }
        }
        function F2(t5, e4) {
          let n3 = t5.length;
          for (; --n3 >= 0; ) {
            const i3 = n3;
            let r4 = n3 - 1;
            r4 < 0 && (r4 = t5.length - 1);
            for (let t6 = 0, n4 = a2 + 2 * p2; t6 < n4; t6++) {
              const n5 = R2 * t6, o5 = R2 * (t6 + 1);
              k2(e4 + i3 + n5, e4 + r4 + n5, e4 + r4 + o5, e4 + i3 + o5);
            }
          }
        }
        function B2(t5, e4, n3) {
          o4.push(t5), o4.push(e4), o4.push(n3);
        }
        function U2(t5, e4, r4) {
          G2(t5), G2(e4), G2(r4);
          const o5 = i2.length / 3, s4 = m2.generateTopUV(n2, i2, o5 - 3, o5 - 2, o5 - 1);
          H2(s4[0]), H2(s4[1]), H2(s4[2]);
        }
        function k2(t5, e4, r4, o5) {
          G2(t5), G2(e4), G2(o5), G2(e4), G2(r4), G2(o5);
          const s4 = i2.length / 3, a3 = m2.generateSideWallUV(n2, i2, s4 - 6, s4 - 3, s4 - 2, s4 - 1);
          H2(a3[0]), H2(a3[1]), H2(a3[3]), H2(a3[1]), H2(a3[2]), H2(a3[3]);
        }
        function G2(t5) {
          i2.push(o4[3 * t5 + 0]), i2.push(o4[3 * t5 + 1]), i2.push(o4[3 * t5 + 2]);
        }
        function H2(t5) {
          r3.push(t5.x), r3.push(t5.y);
        }
        !function() {
          const t5 = i2.length / 3;
          if (u2) {
            let t6 = 0, e4 = R2 * t6;
            for (let t7 = 0; t7 < P2; t7++) {
              const n3 = E2[t7];
              U2(n3[2] + e4, n3[1] + e4, n3[0] + e4);
            }
            t6 = a2 + 2 * p2, e4 = R2 * t6;
            for (let t7 = 0; t7 < P2; t7++) {
              const n3 = E2[t7];
              U2(n3[0] + e4, n3[1] + e4, n3[2] + e4);
            }
          } else {
            for (let t6 = 0; t6 < P2; t6++) {
              const e4 = E2[t6];
              U2(e4[2], e4[1], e4[0]);
            }
            for (let t6 = 0; t6 < P2; t6++) {
              const e4 = E2[t6];
              U2(e4[0] + R2 * a2, e4[1] + R2 * a2, e4[2] + R2 * a2);
            }
          }
          n2.addGroup(t5, i2.length / 3 - t5, 0);
        }(), function() {
          const t5 = i2.length / 3;
          let e4 = 0;
          F2(M2, e4), e4 += M2.length;
          for (let t6 = 0, n3 = S2.length; t6 < n3; t6++) {
            const n4 = S2[t6];
            F2(n4, e4), e4 += n4.length;
          }
          n2.addGroup(t5, i2.length / 3 - t5, 1);
        }();
      }
      this.setAttribute("position", new Yr(i2, 3)), this.setAttribute("uv", new Yr(r3, 2)), this.computeVertexNormals();
    }
    toJSON() {
      const t3 = super.toJSON();
      return function(t4, e3, n2) {
        if (n2.shapes = [], Array.isArray(t4))
          for (let e4 = 0, i2 = t4.length; e4 < i2; e4++) {
            const i3 = t4[e4];
            n2.shapes.push(i3.uuid);
          }
        else
          n2.shapes.push(t4.uuid);
        e3.extrudePath !== void 0 && (n2.options.extrudePath = e3.extrudePath.toJSON());
        return n2;
      }(this.parameters.shapes, this.parameters.options, t3);
    }
    static fromJSON(t3, e3) {
      const n2 = [];
      for (let i3 = 0, r3 = t3.shapes.length; i3 < r3; i3++) {
        const r4 = e3[t3.shapes[i3]];
        n2.push(r4);
      }
      const i2 = t3.options.extrudePath;
      return i2 !== void 0 && (t3.options.extrudePath = new Vu[i2.type]().fromJSON(i2)), new yh(n2, t3.options);
    }
  }
  const xh = { generateTopUV: function(t3, e3, n2, i2, r3) {
    const o3 = e3[3 * n2], s3 = e3[3 * n2 + 1], a2 = e3[3 * i2], l2 = e3[3 * i2 + 1], u2 = e3[3 * r3], h2 = e3[3 * r3 + 1];
    return [new ei(o3, s3), new ei(a2, l2), new ei(u2, h2)];
  }, generateSideWallUV: function(t3, e3, n2, i2, r3, o3) {
    const s3 = e3[3 * n2], a2 = e3[3 * n2 + 1], l2 = e3[3 * n2 + 2], u2 = e3[3 * i2], h2 = e3[3 * i2 + 1], c2 = e3[3 * i2 + 2], d2 = e3[3 * r3], p2 = e3[3 * r3 + 1], f2 = e3[3 * r3 + 2], m2 = e3[3 * o3], g2 = e3[3 * o3 + 1], v2 = e3[3 * o3 + 2];
    return Math.abs(a2 - h2) < Math.abs(s3 - u2) ? [new ei(s3, 1 - l2), new ei(u2, 1 - c2), new ei(d2, 1 - f2), new ei(m2, 1 - v2)] : [new ei(a2, 1 - l2), new ei(h2, 1 - c2), new ei(p2, 1 - f2), new ei(g2, 1 - v2)];
  } };
  class bh extends _u {
    constructor(t3 = 1, e3 = 0) {
      const n2 = (1 + Math.sqrt(5)) / 2;
      super([-1, n2, 0, 1, n2, 0, -1, -n2, 0, 1, -n2, 0, 0, -1, n2, 0, 1, n2, 0, -1, -n2, 0, 1, -n2, n2, 0, -1, n2, 0, 1, -n2, 0, -1, -n2, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t3, e3), this.type = "IcosahedronGeometry", this.parameters = { radius: t3, detail: e3 };
    }
    static fromJSON(t3) {
      return new bh(t3.radius, t3.detail);
    }
  }
  class Th extends so {
    constructor(t3, e3 = 12, n2 = 0, i2 = 2 * Math.PI) {
      super(), this.type = "LatheGeometry", this.parameters = { points: t3, segments: e3, phiStart: n2, phiLength: i2 }, e3 = Math.floor(e3), i2 = Yn(i2, 0, 2 * Math.PI);
      const r3 = [], o3 = [], s3 = [], a2 = 1 / e3, l2 = new pi(), u2 = new ei();
      for (let r4 = 0; r4 <= e3; r4++) {
        const h2 = n2 + r4 * a2 * i2, c2 = Math.sin(h2), d2 = Math.cos(h2);
        for (let n3 = 0; n3 <= t3.length - 1; n3++)
          l2.x = t3[n3].x * c2, l2.y = t3[n3].y, l2.z = t3[n3].x * d2, o3.push(l2.x, l2.y, l2.z), u2.x = r4 / e3, u2.y = n3 / (t3.length - 1), s3.push(u2.x, u2.y);
      }
      for (let n3 = 0; n3 < e3; n3++)
        for (let e4 = 0; e4 < t3.length - 1; e4++) {
          const i3 = e4 + n3 * t3.length, o4 = i3, s4 = i3 + t3.length, a3 = i3 + t3.length + 1, l3 = i3 + 1;
          r3.push(o4, s4, l3), r3.push(s4, a3, l3);
        }
      if (this.setIndex(r3), this.setAttribute("position", new Yr(o3, 3)), this.setAttribute("uv", new Yr(s3, 2)), this.computeVertexNormals(), i2 === 2 * Math.PI) {
        const n3 = this.attributes.normal.array, i3 = new pi(), r4 = new pi(), o4 = new pi(), s4 = e3 * t3.length * 3;
        for (let e4 = 0, a3 = 0; e4 < t3.length; e4++, a3 += 3)
          i3.x = n3[a3 + 0], i3.y = n3[a3 + 1], i3.z = n3[a3 + 2], r4.x = n3[s4 + a3 + 0], r4.y = n3[s4 + a3 + 1], r4.z = n3[s4 + a3 + 2], o4.addVectors(i3, r4).normalize(), n3[a3 + 0] = n3[s4 + a3 + 0] = o4.x, n3[a3 + 1] = n3[s4 + a3 + 1] = o4.y, n3[a3 + 2] = n3[s4 + a3 + 2] = o4.z;
      }
    }
    static fromJSON(t3) {
      return new Th(t3.points, t3.segments, t3.phiStart, t3.phiLength);
    }
  }
  class wh extends _u {
    constructor(t3 = 1, e3 = 0) {
      super([1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t3, e3), this.type = "OctahedronGeometry", this.parameters = { radius: t3, detail: e3 };
    }
    static fromJSON(t3) {
      return new wh(t3.radius, t3.detail);
    }
  }
  class Sh extends so {
    constructor(t3, e3, n2) {
      super(), this.type = "ParametricGeometry", this.parameters = { func: t3, slices: e3, stacks: n2 };
      const i2 = [], r3 = [], o3 = [], s3 = [], a2 = 1e-5, l2 = new pi(), u2 = new pi(), h2 = new pi(), c2 = new pi(), d2 = new pi();
      t3.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
      const p2 = e3 + 1;
      for (let i3 = 0; i3 <= n2; i3++) {
        const p3 = i3 / n2;
        for (let n3 = 0; n3 <= e3; n3++) {
          const i4 = n3 / e3;
          t3(i4, p3, u2), r3.push(u2.x, u2.y, u2.z), i4 - a2 >= 0 ? (t3(i4 - a2, p3, h2), c2.subVectors(u2, h2)) : (t3(i4 + a2, p3, h2), c2.subVectors(h2, u2)), p3 - a2 >= 0 ? (t3(i4, p3 - a2, h2), d2.subVectors(u2, h2)) : (t3(i4, p3 + a2, h2), d2.subVectors(h2, u2)), l2.crossVectors(c2, d2).normalize(), o3.push(l2.x, l2.y, l2.z), s3.push(i4, p3);
        }
      }
      for (let t4 = 0; t4 < n2; t4++)
        for (let n3 = 0; n3 < e3; n3++) {
          const e4 = t4 * p2 + n3, r4 = t4 * p2 + n3 + 1, o4 = (t4 + 1) * p2 + n3 + 1, s4 = (t4 + 1) * p2 + n3;
          i2.push(e4, r4, s4), i2.push(r4, o4, s4);
        }
      this.setIndex(i2), this.setAttribute("position", new Yr(r3, 3)), this.setAttribute("normal", new Yr(o3, 3)), this.setAttribute("uv", new Yr(s3, 2));
    }
  }
  class Eh extends so {
    constructor(t3 = 0.5, e3 = 1, n2 = 8, i2 = 1, r3 = 0, o3 = 2 * Math.PI) {
      super(), this.type = "RingGeometry", this.parameters = { innerRadius: t3, outerRadius: e3, thetaSegments: n2, phiSegments: i2, thetaStart: r3, thetaLength: o3 }, n2 = Math.max(3, n2);
      const s3 = [], a2 = [], l2 = [], u2 = [];
      let h2 = t3;
      const c2 = (e3 - t3) / (i2 = Math.max(1, i2)), d2 = new pi(), p2 = new ei();
      for (let t4 = 0; t4 <= i2; t4++) {
        for (let t5 = 0; t5 <= n2; t5++) {
          const i3 = r3 + t5 / n2 * o3;
          d2.x = h2 * Math.cos(i3), d2.y = h2 * Math.sin(i3), a2.push(d2.x, d2.y, d2.z), l2.push(0, 0, 1), p2.x = (d2.x / e3 + 1) / 2, p2.y = (d2.y / e3 + 1) / 2, u2.push(p2.x, p2.y);
        }
        h2 += c2;
      }
      for (let t4 = 0; t4 < i2; t4++) {
        const e4 = t4 * (n2 + 1);
        for (let t5 = 0; t5 < n2; t5++) {
          const i3 = t5 + e4, r4 = i3, o4 = i3 + n2 + 1, a3 = i3 + n2 + 2, l3 = i3 + 1;
          s3.push(r4, o4, l3), s3.push(o4, a3, l3);
        }
      }
      this.setIndex(s3), this.setAttribute("position", new Yr(a2, 3)), this.setAttribute("normal", new Yr(l2, 3)), this.setAttribute("uv", new Yr(u2, 2));
    }
    static fromJSON(t3) {
      return new Eh(t3.innerRadius, t3.outerRadius, t3.thetaSegments, t3.phiSegments, t3.thetaStart, t3.thetaLength);
    }
  }
  class Mh extends so {
    constructor(t3, e3 = 12) {
      super(), this.type = "ShapeGeometry", this.parameters = { shapes: t3, curveSegments: e3 };
      const n2 = [], i2 = [], r3 = [], o3 = [];
      let s3 = 0, a2 = 0;
      if (Array.isArray(t3) === false)
        l2(t3);
      else
        for (let e4 = 0; e4 < t3.length; e4++)
          l2(t3[e4]), this.addGroup(s3, a2, e4), s3 += a2, a2 = 0;
      function l2(t4) {
        const s4 = i2.length / 3, l3 = t4.extractPoints(e3);
        let u2 = l3.shape;
        const h2 = l3.holes;
        gh.isClockWise(u2) === false && (u2 = u2.reverse());
        for (let t5 = 0, e4 = h2.length; t5 < e4; t5++) {
          const e5 = h2[t5];
          gh.isClockWise(e5) === true && (h2[t5] = e5.reverse());
        }
        const c2 = gh.triangulateShape(u2, h2);
        for (let t5 = 0, e4 = h2.length; t5 < e4; t5++) {
          const e5 = h2[t5];
          u2 = u2.concat(e5);
        }
        for (let t5 = 0, e4 = u2.length; t5 < e4; t5++) {
          const e5 = u2[t5];
          i2.push(e5.x, e5.y, 0), r3.push(0, 0, 1), o3.push(e5.x, e5.y);
        }
        for (let t5 = 0, e4 = c2.length; t5 < e4; t5++) {
          const e5 = c2[t5], i3 = e5[0] + s4, r4 = e5[1] + s4, o4 = e5[2] + s4;
          n2.push(i3, r4, o4), a2 += 3;
        }
      }
      this.setIndex(n2), this.setAttribute("position", new Yr(i2, 3)), this.setAttribute("normal", new Yr(r3, 3)), this.setAttribute("uv", new Yr(o3, 2));
    }
    toJSON() {
      const t3 = super.toJSON();
      return function(t4, e3) {
        if (e3.shapes = [], Array.isArray(t4))
          for (let n2 = 0, i2 = t4.length; n2 < i2; n2++) {
            const i3 = t4[n2];
            e3.shapes.push(i3.uuid);
          }
        else
          e3.shapes.push(t4.uuid);
        return e3;
      }(this.parameters.shapes, t3);
    }
    static fromJSON(t3, e3) {
      const n2 = [];
      for (let i2 = 0, r3 = t3.shapes.length; i2 < r3; i2++) {
        const r4 = e3[t3.shapes[i2]];
        n2.push(r4);
      }
      return new Mh(n2, t3.curveSegments);
    }
  }
  class Ah extends so {
    constructor(t3 = 1, e3 = 8, n2 = 6, i2 = 0, r3 = 2 * Math.PI, o3 = 0, s3 = Math.PI) {
      super(), this.type = "SphereGeometry", this.parameters = { radius: t3, widthSegments: e3, heightSegments: n2, phiStart: i2, phiLength: r3, thetaStart: o3, thetaLength: s3 }, e3 = Math.max(3, Math.floor(e3)), n2 = Math.max(2, Math.floor(n2));
      const a2 = Math.min(o3 + s3, Math.PI);
      let l2 = 0;
      const u2 = [], h2 = new pi(), c2 = new pi(), d2 = [], p2 = [], f2 = [], m2 = [];
      for (let d3 = 0; d3 <= n2; d3++) {
        const g2 = [], v2 = d3 / n2;
        let _2 = 0;
        d3 == 0 && o3 == 0 ? _2 = 0.5 / e3 : d3 == n2 && a2 == Math.PI && (_2 = -0.5 / e3);
        for (let n3 = 0; n3 <= e3; n3++) {
          const a3 = n3 / e3;
          h2.x = -t3 * Math.cos(i2 + a3 * r3) * Math.sin(o3 + v2 * s3), h2.y = t3 * Math.cos(o3 + v2 * s3), h2.z = t3 * Math.sin(i2 + a3 * r3) * Math.sin(o3 + v2 * s3), p2.push(h2.x, h2.y, h2.z), c2.copy(h2).normalize(), f2.push(c2.x, c2.y, c2.z), m2.push(a3 + _2, 1 - v2), g2.push(l2++);
        }
        u2.push(g2);
      }
      for (let t4 = 0; t4 < n2; t4++)
        for (let i3 = 0; i3 < e3; i3++) {
          const e4 = u2[t4][i3 + 1], r4 = u2[t4][i3], s4 = u2[t4 + 1][i3], l3 = u2[t4 + 1][i3 + 1];
          (t4 !== 0 || o3 > 0) && d2.push(e4, r4, l3), (t4 !== n2 - 1 || a2 < Math.PI) && d2.push(r4, s4, l3);
        }
      this.setIndex(d2), this.setAttribute("position", new Yr(p2, 3)), this.setAttribute("normal", new Yr(f2, 3)), this.setAttribute("uv", new Yr(m2, 2));
    }
    static fromJSON(t3) {
      return new Ah(t3.radius, t3.widthSegments, t3.heightSegments, t3.phiStart, t3.phiLength, t3.thetaStart, t3.thetaLength);
    }
  }
  class Rh extends _u {
    constructor(t3 = 1, e3 = 0) {
      super([1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t3, e3), this.type = "TetrahedronGeometry", this.parameters = { radius: t3, detail: e3 };
    }
    static fromJSON(t3) {
      return new Rh(t3.radius, t3.detail);
    }
  }
  class Ph extends yh {
    constructor(t3, e3 = {}) {
      const n2 = e3.font;
      if (!n2 || !n2.isFont)
        return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new so();
      const i2 = n2.generateShapes(t3, e3.size);
      e3.depth = e3.height !== void 0 ? e3.height : 50, e3.bevelThickness === void 0 && (e3.bevelThickness = 10), e3.bevelSize === void 0 && (e3.bevelSize = 8), e3.bevelEnabled === void 0 && (e3.bevelEnabled = false), super(i2, e3), this.type = "TextGeometry";
    }
  }
  class Ch extends so {
    constructor(t3 = 1, e3 = 0.4, n2 = 8, i2 = 6, r3 = 2 * Math.PI) {
      super(), this.type = "TorusGeometry", this.parameters = { radius: t3, tube: e3, radialSegments: n2, tubularSegments: i2, arc: r3 }, n2 = Math.floor(n2), i2 = Math.floor(i2);
      const o3 = [], s3 = [], a2 = [], l2 = [], u2 = new pi(), h2 = new pi(), c2 = new pi();
      for (let o4 = 0; o4 <= n2; o4++)
        for (let d2 = 0; d2 <= i2; d2++) {
          const p2 = d2 / i2 * r3, f2 = o4 / n2 * Math.PI * 2;
          h2.x = (t3 + e3 * Math.cos(f2)) * Math.cos(p2), h2.y = (t3 + e3 * Math.cos(f2)) * Math.sin(p2), h2.z = e3 * Math.sin(f2), s3.push(h2.x, h2.y, h2.z), u2.x = t3 * Math.cos(p2), u2.y = t3 * Math.sin(p2), c2.subVectors(h2, u2).normalize(), a2.push(c2.x, c2.y, c2.z), l2.push(d2 / i2), l2.push(o4 / n2);
        }
      for (let t4 = 1; t4 <= n2; t4++)
        for (let e4 = 1; e4 <= i2; e4++) {
          const n3 = (i2 + 1) * t4 + e4 - 1, r4 = (i2 + 1) * (t4 - 1) + e4 - 1, s4 = (i2 + 1) * (t4 - 1) + e4, a3 = (i2 + 1) * t4 + e4;
          o3.push(n3, r4, a3), o3.push(r4, s4, a3);
        }
      this.setIndex(o3), this.setAttribute("position", new Yr(s3, 3)), this.setAttribute("normal", new Yr(a2, 3)), this.setAttribute("uv", new Yr(l2, 2));
    }
    static fromJSON(t3) {
      return new Ch(t3.radius, t3.tube, t3.radialSegments, t3.tubularSegments, t3.arc);
    }
  }
  class Ih extends so {
    constructor(t3 = 1, e3 = 0.4, n2 = 64, i2 = 8, r3 = 2, o3 = 3) {
      super(), this.type = "TorusKnotGeometry", this.parameters = { radius: t3, tube: e3, tubularSegments: n2, radialSegments: i2, p: r3, q: o3 }, n2 = Math.floor(n2), i2 = Math.floor(i2);
      const s3 = [], a2 = [], l2 = [], u2 = [], h2 = new pi(), c2 = new pi(), d2 = new pi(), p2 = new pi(), f2 = new pi(), m2 = new pi(), g2 = new pi();
      for (let s4 = 0; s4 <= n2; ++s4) {
        const _2 = s4 / n2 * r3 * Math.PI * 2;
        v2(_2, r3, o3, t3, d2), v2(_2 + 0.01, r3, o3, t3, p2), m2.subVectors(p2, d2), g2.addVectors(p2, d2), f2.crossVectors(m2, g2), g2.crossVectors(f2, m2), f2.normalize(), g2.normalize();
        for (let t4 = 0; t4 <= i2; ++t4) {
          const r4 = t4 / i2 * Math.PI * 2, o4 = -e3 * Math.cos(r4), p3 = e3 * Math.sin(r4);
          h2.x = d2.x + (o4 * g2.x + p3 * f2.x), h2.y = d2.y + (o4 * g2.y + p3 * f2.y), h2.z = d2.z + (o4 * g2.z + p3 * f2.z), a2.push(h2.x, h2.y, h2.z), c2.subVectors(h2, d2).normalize(), l2.push(c2.x, c2.y, c2.z), u2.push(s4 / n2), u2.push(t4 / i2);
        }
      }
      for (let t4 = 1; t4 <= n2; t4++)
        for (let e4 = 1; e4 <= i2; e4++) {
          const n3 = (i2 + 1) * (t4 - 1) + (e4 - 1), r4 = (i2 + 1) * t4 + (e4 - 1), o4 = (i2 + 1) * t4 + e4, a3 = (i2 + 1) * (t4 - 1) + e4;
          s3.push(n3, r4, a3), s3.push(r4, o4, a3);
        }
      function v2(t4, e4, n3, i3, r4) {
        const o4 = Math.cos(t4), s4 = Math.sin(t4), a3 = n3 / e4 * t4, l3 = Math.cos(a3);
        r4.x = i3 * (2 + l3) * 0.5 * o4, r4.y = i3 * (2 + l3) * s4 * 0.5, r4.z = i3 * Math.sin(a3) * 0.5;
      }
      this.setIndex(s3), this.setAttribute("position", new Yr(a2, 3)), this.setAttribute("normal", new Yr(l2, 3)), this.setAttribute("uv", new Yr(u2, 2));
    }
    static fromJSON(t3) {
      return new Ih(t3.radius, t3.tube, t3.tubularSegments, t3.radialSegments, t3.p, t3.q);
    }
  }
  class Oh extends so {
    constructor(t3, e3 = 64, n2 = 1, i2 = 8, r3 = false) {
      super(), this.type = "TubeGeometry", this.parameters = { path: t3, tubularSegments: e3, radius: n2, radialSegments: i2, closed: r3 };
      const o3 = t3.computeFrenetFrames(e3, r3);
      this.tangents = o3.tangents, this.normals = o3.normals, this.binormals = o3.binormals;
      const s3 = new pi(), a2 = new pi(), l2 = new ei();
      let u2 = new pi();
      const h2 = [], c2 = [], d2 = [], p2 = [];
      function f2(r4) {
        u2 = t3.getPointAt(r4 / e3, u2);
        const l3 = o3.normals[r4], d3 = o3.binormals[r4];
        for (let t4 = 0; t4 <= i2; t4++) {
          const e4 = t4 / i2 * Math.PI * 2, r5 = Math.sin(e4), o4 = -Math.cos(e4);
          a2.x = o4 * l3.x + r5 * d3.x, a2.y = o4 * l3.y + r5 * d3.y, a2.z = o4 * l3.z + r5 * d3.z, a2.normalize(), c2.push(a2.x, a2.y, a2.z), s3.x = u2.x + n2 * a2.x, s3.y = u2.y + n2 * a2.y, s3.z = u2.z + n2 * a2.z, h2.push(s3.x, s3.y, s3.z);
        }
      }
      !function() {
        for (let t4 = 0; t4 < e3; t4++)
          f2(t4);
        f2(r3 === false ? e3 : 0), function() {
          for (let t4 = 0; t4 <= e3; t4++)
            for (let n3 = 0; n3 <= i2; n3++)
              l2.x = t4 / e3, l2.y = n3 / i2, d2.push(l2.x, l2.y);
        }(), function() {
          for (let t4 = 1; t4 <= e3; t4++)
            for (let e4 = 1; e4 <= i2; e4++) {
              const n3 = (i2 + 1) * (t4 - 1) + (e4 - 1), r4 = (i2 + 1) * t4 + (e4 - 1), o4 = (i2 + 1) * t4 + e4, s4 = (i2 + 1) * (t4 - 1) + e4;
              p2.push(n3, r4, s4), p2.push(r4, o4, s4);
            }
        }();
      }(), this.setIndex(p2), this.setAttribute("position", new Yr(h2, 3)), this.setAttribute("normal", new Yr(c2, 3)), this.setAttribute("uv", new Yr(d2, 2));
    }
    toJSON() {
      const t3 = super.toJSON();
      return t3.path = this.parameters.path.toJSON(), t3;
    }
    static fromJSON(t3) {
      return new Oh(new Vu[t3.path.type]().fromJSON(t3.path), t3.tubularSegments, t3.radius, t3.radialSegments, t3.closed);
    }
  }
  class Lh extends so {
    constructor(t3) {
      if (super(), this.type = "WireframeGeometry", t3.isGeometry === true)
        return void console.error("THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      const e3 = [], n2 = [0, 0], i2 = {}, r3 = new pi();
      if (t3.index !== null) {
        const o3 = t3.attributes.position, s3 = t3.index;
        let a2 = t3.groups;
        a2.length === 0 && (a2 = [{ start: 0, count: s3.count, materialIndex: 0 }]);
        for (let t4 = 0, e4 = a2.length; t4 < e4; ++t4) {
          const e5 = a2[t4], r4 = e5.start;
          for (let t5 = r4, o4 = r4 + e5.count; t5 < o4; t5 += 3)
            for (let e6 = 0; e6 < 3; e6++) {
              const r5 = s3.getX(t5 + e6), o5 = s3.getX(t5 + (e6 + 1) % 3);
              n2[0] = Math.min(r5, o5), n2[1] = Math.max(r5, o5);
              const a3 = n2[0] + "," + n2[1];
              i2[a3] === void 0 && (i2[a3] = { index1: n2[0], index2: n2[1] });
            }
        }
        for (const t4 in i2) {
          const n3 = i2[t4];
          r3.fromBufferAttribute(o3, n3.index1), e3.push(r3.x, r3.y, r3.z), r3.fromBufferAttribute(o3, n3.index2), e3.push(r3.x, r3.y, r3.z);
        }
      } else {
        const n3 = t3.attributes.position;
        for (let t4 = 0, i3 = n3.count / 3; t4 < i3; t4++)
          for (let i4 = 0; i4 < 3; i4++) {
            const o3 = 3 * t4 + i4;
            r3.fromBufferAttribute(n3, o3), e3.push(r3.x, r3.y, r3.z);
            const s3 = 3 * t4 + (i4 + 1) % 3;
            r3.fromBufferAttribute(n3, s3), e3.push(r3.x, r3.y, r3.z);
          }
      }
      this.setAttribute("position", new Yr(e3, 3));
    }
  }
  var Nh = Object.freeze({ __proto__: null, BoxGeometry: Ao, BoxBufferGeometry: Ao, CircleGeometry: mu, CircleBufferGeometry: mu, ConeGeometry: vu, ConeBufferGeometry: vu, CylinderGeometry: gu, CylinderBufferGeometry: gu, DodecahedronGeometry: yu, DodecahedronBufferGeometry: yu, EdgesGeometry: Su, ExtrudeGeometry: yh, ExtrudeBufferGeometry: yh, IcosahedronGeometry: bh, IcosahedronBufferGeometry: bh, LatheGeometry: Th, LatheBufferGeometry: Th, OctahedronGeometry: wh, OctahedronBufferGeometry: wh, ParametricGeometry: Sh, ParametricBufferGeometry: Sh, PlaneGeometry: Xo, PlaneBufferGeometry: Xo, PolyhedronGeometry: _u, PolyhedronBufferGeometry: _u, RingGeometry: Eh, RingBufferGeometry: Eh, ShapeGeometry: Mh, ShapeBufferGeometry: Mh, SphereGeometry: Ah, SphereBufferGeometry: Ah, TetrahedronGeometry: Rh, TetrahedronBufferGeometry: Rh, TextGeometry: Ph, TextBufferGeometry: Ph, TorusGeometry: Ch, TorusBufferGeometry: Ch, TorusKnotGeometry: Ih, TorusKnotBufferGeometry: Ih, TubeGeometry: Oh, TubeBufferGeometry: Oh, WireframeGeometry: Lh });
  class Dh extends Rr {
    constructor(t3) {
      super(), this.type = "ShadowMaterial", this.color = new Dr(0), this.transparent = true, this.setValues(t3);
    }
    copy(t3) {
      return super.copy(t3), this.color.copy(t3.color), this;
    }
  }
  Dh.prototype.isShadowMaterial = true;
  class Fh extends Io {
    constructor(t3) {
      super(t3), this.type = "RawShaderMaterial";
    }
  }
  Fh.prototype.isRawShaderMaterial = true;
  class Bh extends Rr {
    constructor(t3) {
      super(), this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new Dr(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Dr(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = pn, this.normalScale = new ei(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.morphTargets = false, this.morphNormals = false, this.flatShading = false, this.vertexTangents = false, this.setValues(t3);
    }
    copy(t3) {
      return super.copy(t3), this.defines = { STANDARD: "" }, this.color.copy(t3.color), this.roughness = t3.roughness, this.metalness = t3.metalness, this.map = t3.map, this.lightMap = t3.lightMap, this.lightMapIntensity = t3.lightMapIntensity, this.aoMap = t3.aoMap, this.aoMapIntensity = t3.aoMapIntensity, this.emissive.copy(t3.emissive), this.emissiveMap = t3.emissiveMap, this.emissiveIntensity = t3.emissiveIntensity, this.bumpMap = t3.bumpMap, this.bumpScale = t3.bumpScale, this.normalMap = t3.normalMap, this.normalMapType = t3.normalMapType, this.normalScale.copy(t3.normalScale), this.displacementMap = t3.displacementMap, this.displacementScale = t3.displacementScale, this.displacementBias = t3.displacementBias, this.roughnessMap = t3.roughnessMap, this.metalnessMap = t3.metalnessMap, this.alphaMap = t3.alphaMap, this.envMap = t3.envMap, this.envMapIntensity = t3.envMapIntensity, this.refractionRatio = t3.refractionRatio, this.wireframe = t3.wireframe, this.wireframeLinewidth = t3.wireframeLinewidth, this.wireframeLinecap = t3.wireframeLinecap, this.wireframeLinejoin = t3.wireframeLinejoin, this.morphTargets = t3.morphTargets, this.morphNormals = t3.morphNormals, this.flatShading = t3.flatShading, this.vertexTangents = t3.vertexTangents, this;
    }
  }
  Bh.prototype.isMeshStandardMaterial = true;
  class Uh extends Bh {
    constructor(t3) {
      super(), this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.clearcoat = 0, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new ei(1, 1), this.clearcoatNormalMap = null, this.reflectivity = 0.5, Object.defineProperty(this, "ior", { get: function() {
        return (1 + 0.4 * this.reflectivity) / (1 - 0.4 * this.reflectivity);
      }, set: function(t4) {
        this.reflectivity = Yn(2.5 * (t4 - 1) / (t4 + 1), 0, 1);
      } }), this.sheen = null, this.transmission = 0, this.transmissionMap = null, this.thickness = 0.01, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationColor = new Dr(1, 1, 1), this.setValues(t3);
    }
    copy(t3) {
      return super.copy(t3), this.defines = { STANDARD: "", PHYSICAL: "" }, this.clearcoat = t3.clearcoat, this.clearcoatMap = t3.clearcoatMap, this.clearcoatRoughness = t3.clearcoatRoughness, this.clearcoatRoughnessMap = t3.clearcoatRoughnessMap, this.clearcoatNormalMap = t3.clearcoatNormalMap, this.clearcoatNormalScale.copy(t3.clearcoatNormalScale), this.reflectivity = t3.reflectivity, t3.sheen ? this.sheen = (this.sheen || new Dr()).copy(t3.sheen) : this.sheen = null, this.transmission = t3.transmission, this.transmissionMap = t3.transmissionMap, this.thickness = t3.thickness, this.thicknessMap = t3.thicknessMap, this.attenuationDistance = t3.attenuationDistance, this.attenuationColor.copy(t3.attenuationColor), this;
    }
  }
  Uh.prototype.isMeshPhysicalMaterial = true;
  class kh extends Rr {
    constructor(t3) {
      super(), this.type = "MeshPhongMaterial", this.color = new Dr(16777215), this.specular = new Dr(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Dr(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = pn, this.normalScale = new ei(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = et, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.morphTargets = false, this.morphNormals = false, this.flatShading = false, this.setValues(t3);
    }
    copy(t3) {
      return super.copy(t3), this.color.copy(t3.color), this.specular.copy(t3.specular), this.shininess = t3.shininess, this.map = t3.map, this.lightMap = t3.lightMap, this.lightMapIntensity = t3.lightMapIntensity, this.aoMap = t3.aoMap, this.aoMapIntensity = t3.aoMapIntensity, this.emissive.copy(t3.emissive), this.emissiveMap = t3.emissiveMap, this.emissiveIntensity = t3.emissiveIntensity, this.bumpMap = t3.bumpMap, this.bumpScale = t3.bumpScale, this.normalMap = t3.normalMap, this.normalMapType = t3.normalMapType, this.normalScale.copy(t3.normalScale), this.displacementMap = t3.displacementMap, this.displacementScale = t3.displacementScale, this.displacementBias = t3.displacementBias, this.specularMap = t3.specularMap, this.alphaMap = t3.alphaMap, this.envMap = t3.envMap, this.combine = t3.combine, this.reflectivity = t3.reflectivity, this.refractionRatio = t3.refractionRatio, this.wireframe = t3.wireframe, this.wireframeLinewidth = t3.wireframeLinewidth, this.wireframeLinecap = t3.wireframeLinecap, this.wireframeLinejoin = t3.wireframeLinejoin, this.morphTargets = t3.morphTargets, this.morphNormals = t3.morphNormals, this.flatShading = t3.flatShading, this;
    }
  }
  kh.prototype.isMeshPhongMaterial = true;
  class Gh extends Rr {
    constructor(t3) {
      super(), this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new Dr(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Dr(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = pn, this.normalScale = new ei(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.morphTargets = false, this.morphNormals = false, this.setValues(t3);
    }
    copy(t3) {
      return super.copy(t3), this.color.copy(t3.color), this.map = t3.map, this.gradientMap = t3.gradientMap, this.lightMap = t3.lightMap, this.lightMapIntensity = t3.lightMapIntensity, this.aoMap = t3.aoMap, this.aoMapIntensity = t3.aoMapIntensity, this.emissive.copy(t3.emissive), this.emissiveMap = t3.emissiveMap, this.emissiveIntensity = t3.emissiveIntensity, this.bumpMap = t3.bumpMap, this.bumpScale = t3.bumpScale, this.normalMap = t3.normalMap, this.normalMapType = t3.normalMapType, this.normalScale.copy(t3.normalScale), this.displacementMap = t3.displacementMap, this.displacementScale = t3.displacementScale, this.displacementBias = t3.displacementBias, this.alphaMap = t3.alphaMap, this.wireframe = t3.wireframe, this.wireframeLinewidth = t3.wireframeLinewidth, this.wireframeLinecap = t3.wireframeLinecap, this.wireframeLinejoin = t3.wireframeLinejoin, this.morphTargets = t3.morphTargets, this.morphNormals = t3.morphNormals, this;
    }
  }
  Gh.prototype.isMeshToonMaterial = true;
  class Hh extends Rr {
    constructor(t3) {
      super(), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = pn, this.normalScale = new ei(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.morphTargets = false, this.morphNormals = false, this.flatShading = false, this.setValues(t3);
    }
    copy(t3) {
      return super.copy(t3), this.bumpMap = t3.bumpMap, this.bumpScale = t3.bumpScale, this.normalMap = t3.normalMap, this.normalMapType = t3.normalMapType, this.normalScale.copy(t3.normalScale), this.displacementMap = t3.displacementMap, this.displacementScale = t3.displacementScale, this.displacementBias = t3.displacementBias, this.wireframe = t3.wireframe, this.wireframeLinewidth = t3.wireframeLinewidth, this.morphTargets = t3.morphTargets, this.morphNormals = t3.morphNormals, this.flatShading = t3.flatShading, this;
    }
  }
  Hh.prototype.isMeshNormalMaterial = true;
  class zh extends Rr {
    constructor(t3) {
      super(), this.type = "MeshLambertMaterial", this.color = new Dr(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Dr(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = et, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.morphTargets = false, this.morphNormals = false, this.setValues(t3);
    }
    copy(t3) {
      return super.copy(t3), this.color.copy(t3.color), this.map = t3.map, this.lightMap = t3.lightMap, this.lightMapIntensity = t3.lightMapIntensity, this.aoMap = t3.aoMap, this.aoMapIntensity = t3.aoMapIntensity, this.emissive.copy(t3.emissive), this.emissiveMap = t3.emissiveMap, this.emissiveIntensity = t3.emissiveIntensity, this.specularMap = t3.specularMap, this.alphaMap = t3.alphaMap, this.envMap = t3.envMap, this.combine = t3.combine, this.reflectivity = t3.reflectivity, this.refractionRatio = t3.refractionRatio, this.wireframe = t3.wireframe, this.wireframeLinewidth = t3.wireframeLinewidth, this.wireframeLinecap = t3.wireframeLinecap, this.wireframeLinejoin = t3.wireframeLinejoin, this.morphTargets = t3.morphTargets, this.morphNormals = t3.morphNormals, this;
    }
  }
  zh.prototype.isMeshLambertMaterial = true;
  class jh extends Rr {
    constructor(t3) {
      super(), this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new Dr(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = pn, this.normalScale = new ei(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.morphTargets = false, this.morphNormals = false, this.flatShading = false, this.setValues(t3);
    }
    copy(t3) {
      return super.copy(t3), this.defines = { MATCAP: "" }, this.color.copy(t3.color), this.matcap = t3.matcap, this.map = t3.map, this.bumpMap = t3.bumpMap, this.bumpScale = t3.bumpScale, this.normalMap = t3.normalMap, this.normalMapType = t3.normalMapType, this.normalScale.copy(t3.normalScale), this.displacementMap = t3.displacementMap, this.displacementScale = t3.displacementScale, this.displacementBias = t3.displacementBias, this.alphaMap = t3.alphaMap, this.morphTargets = t3.morphTargets, this.morphNormals = t3.morphNormals, this.flatShading = t3.flatShading, this;
    }
  }
  jh.prototype.isMeshMatcapMaterial = true;
  class Vh extends ql {
    constructor(t3) {
      super(), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t3);
    }
    copy(t3) {
      return super.copy(t3), this.scale = t3.scale, this.dashSize = t3.dashSize, this.gapSize = t3.gapSize, this;
    }
  }
  Vh.prototype.isLineDashedMaterial = true;
  var Wh = Object.freeze({ __proto__: null, ShadowMaterial: Dh, SpriteMaterial: dl, RawShaderMaterial: Fh, ShaderMaterial: Io, PointsMaterial: ru, MeshPhysicalMaterial: Uh, MeshStandardMaterial: Bh, MeshPhongMaterial: kh, MeshToonMaterial: Gh, MeshNormalMaterial: Hh, MeshLambertMaterial: zh, MeshDepthMaterial: Xa, MeshDistanceMaterial: qa, MeshBasicMaterial: Fr, MeshMatcapMaterial: jh, LineDashedMaterial: Vh, LineBasicMaterial: ql, Material: Rr });
  const Xh = { arraySlice: function(t3, e3, n2) {
    return Xh.isTypedArray(t3) ? new t3.constructor(t3.subarray(e3, n2 !== void 0 ? n2 : t3.length)) : t3.slice(e3, n2);
  }, convertArray: function(t3, e3, n2) {
    return !t3 || !n2 && t3.constructor === e3 ? t3 : typeof e3.BYTES_PER_ELEMENT == "number" ? new e3(t3) : Array.prototype.slice.call(t3);
  }, isTypedArray: function(t3) {
    return ArrayBuffer.isView(t3) && !(t3 instanceof DataView);
  }, getKeyframeOrder: function(t3) {
    const e3 = t3.length, n2 = new Array(e3);
    for (let t4 = 0; t4 !== e3; ++t4)
      n2[t4] = t4;
    return n2.sort(function(e4, n3) {
      return t3[e4] - t3[n3];
    }), n2;
  }, sortedArray: function(t3, e3, n2) {
    const i2 = t3.length, r3 = new t3.constructor(i2);
    for (let o3 = 0, s3 = 0; s3 !== i2; ++o3) {
      const i3 = n2[o3] * e3;
      for (let n3 = 0; n3 !== e3; ++n3)
        r3[s3++] = t3[i3 + n3];
    }
    return r3;
  }, flattenJSON: function(t3, e3, n2, i2) {
    let r3 = 1, o3 = t3[0];
    for (; o3 !== void 0 && o3[i2] === void 0; )
      o3 = t3[r3++];
    if (o3 === void 0)
      return;
    let s3 = o3[i2];
    if (s3 !== void 0)
      if (Array.isArray(s3))
        do {
          s3 = o3[i2], s3 !== void 0 && (e3.push(o3.time), n2.push.apply(n2, s3)), o3 = t3[r3++];
        } while (o3 !== void 0);
      else if (s3.toArray !== void 0)
        do {
          s3 = o3[i2], s3 !== void 0 && (e3.push(o3.time), s3.toArray(n2, n2.length)), o3 = t3[r3++];
        } while (o3 !== void 0);
      else
        do {
          s3 = o3[i2], s3 !== void 0 && (e3.push(o3.time), n2.push(s3)), o3 = t3[r3++];
        } while (o3 !== void 0);
  }, subclip: function(t3, e3, n2, i2, r3 = 30) {
    const o3 = t3.clone();
    o3.name = e3;
    const s3 = [];
    for (let t4 = 0; t4 < o3.tracks.length; ++t4) {
      const e4 = o3.tracks[t4], a3 = e4.getValueSize(), l2 = [], u2 = [];
      for (let t5 = 0; t5 < e4.times.length; ++t5) {
        const o4 = e4.times[t5] * r3;
        if (!(o4 < n2 || o4 >= i2)) {
          l2.push(e4.times[t5]);
          for (let n3 = 0; n3 < a3; ++n3)
            u2.push(e4.values[t5 * a3 + n3]);
        }
      }
      l2.length !== 0 && (e4.times = Xh.convertArray(l2, e4.times.constructor), e4.values = Xh.convertArray(u2, e4.values.constructor), s3.push(e4));
    }
    o3.tracks = s3;
    let a2 = 1 / 0;
    for (let t4 = 0; t4 < o3.tracks.length; ++t4)
      a2 > o3.tracks[t4].times[0] && (a2 = o3.tracks[t4].times[0]);
    for (let t4 = 0; t4 < o3.tracks.length; ++t4)
      o3.tracks[t4].shift(-1 * a2);
    return o3.resetDuration(), o3;
  }, makeClipAdditive: function(t3, e3 = 0, n2 = t3, i2 = 30) {
    i2 <= 0 && (i2 = 30);
    const r3 = n2.tracks.length, o3 = e3 / i2;
    for (let e4 = 0; e4 < r3; ++e4) {
      const i3 = n2.tracks[e4], r4 = i3.ValueTypeName;
      if (r4 === "bool" || r4 === "string")
        continue;
      const s3 = t3.tracks.find(function(t4) {
        return t4.name === i3.name && t4.ValueTypeName === r4;
      });
      if (s3 === void 0)
        continue;
      let a2 = 0;
      const l2 = i3.getValueSize();
      i3.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (a2 = l2 / 3);
      let u2 = 0;
      const h2 = s3.getValueSize();
      s3.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (u2 = h2 / 3);
      const c2 = i3.times.length - 1;
      let d2;
      if (o3 <= i3.times[0]) {
        const t4 = a2, e5 = l2 - a2;
        d2 = Xh.arraySlice(i3.values, t4, e5);
      } else if (o3 >= i3.times[c2]) {
        const t4 = c2 * l2 + a2, e5 = t4 + l2 - a2;
        d2 = Xh.arraySlice(i3.values, t4, e5);
      } else {
        const t4 = i3.createInterpolant(), e5 = a2, n3 = l2 - a2;
        t4.evaluate(o3), d2 = Xh.arraySlice(t4.resultBuffer, e5, n3);
      }
      if (r4 === "quaternion") {
        new di().fromArray(d2).normalize().conjugate().toArray(d2);
      }
      const p2 = s3.times.length;
      for (let t4 = 0; t4 < p2; ++t4) {
        const e5 = t4 * h2 + u2;
        if (r4 === "quaternion")
          di.multiplyQuaternionsFlat(s3.values, e5, d2, 0, s3.values, e5);
        else {
          const t5 = h2 - 2 * u2;
          for (let n3 = 0; n3 < t5; ++n3)
            s3.values[e5 + n3] -= d2[n3];
        }
      }
    }
    return t3.blendMode = Ke, t3;
  } };
  class qh {
    constructor(t3, e3, n2, i2) {
      this.parameterPositions = t3, this._cachedIndex = 0, this.resultBuffer = i2 !== void 0 ? i2 : new e3.constructor(n2), this.sampleValues = e3, this.valueSize = n2, this.settings = null, this.DefaultSettings_ = {};
    }
    evaluate(t3) {
      const e3 = this.parameterPositions;
      let n2 = this._cachedIndex, i2 = e3[n2], r3 = e3[n2 - 1];
      t: {
        e: {
          let o3;
          n: {
            i:
              if (!(t3 < i2)) {
                for (let o4 = n2 + 2; ; ) {
                  if (i2 === void 0) {
                    if (t3 < r3)
                      break i;
                    return n2 = e3.length, this._cachedIndex = n2, this.afterEnd_(n2 - 1, t3, r3);
                  }
                  if (n2 === o4)
                    break;
                  if (r3 = i2, i2 = e3[++n2], t3 < i2)
                    break e;
                }
                o3 = e3.length;
                break n;
              }
            if (t3 >= r3)
              break t;
            {
              const s3 = e3[1];
              t3 < s3 && (n2 = 2, r3 = s3);
              for (let o4 = n2 - 2; ; ) {
                if (r3 === void 0)
                  return this._cachedIndex = 0, this.beforeStart_(0, t3, i2);
                if (n2 === o4)
                  break;
                if (i2 = r3, r3 = e3[--n2 - 1], t3 >= r3)
                  break e;
              }
              o3 = n2, n2 = 0;
            }
          }
          for (; n2 < o3; ) {
            const i3 = n2 + o3 >>> 1;
            t3 < e3[i3] ? o3 = i3 : n2 = i3 + 1;
          }
          if (i2 = e3[n2], r3 = e3[n2 - 1], r3 === void 0)
            return this._cachedIndex = 0, this.beforeStart_(0, t3, i2);
          if (i2 === void 0)
            return n2 = e3.length, this._cachedIndex = n2, this.afterEnd_(n2 - 1, r3, t3);
        }
        this._cachedIndex = n2, this.intervalChanged_(n2, r3, i2);
      }
      return this.interpolate_(n2, r3, t3, i2);
    }
    getSettings_() {
      return this.settings || this.DefaultSettings_;
    }
    copySampleValue_(t3) {
      const e3 = this.resultBuffer, n2 = this.sampleValues, i2 = this.valueSize, r3 = t3 * i2;
      for (let t4 = 0; t4 !== i2; ++t4)
        e3[t4] = n2[r3 + t4];
      return e3;
    }
    interpolate_() {
      throw new Error("call to abstract method");
    }
    intervalChanged_() {
    }
  }
  qh.prototype.beforeStart_ = qh.prototype.copySampleValue_, qh.prototype.afterEnd_ = qh.prototype.copySampleValue_;
  class Yh extends qh {
    constructor(t3, e3, n2, i2) {
      super(t3, e3, n2, i2), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = { endingStart: Ye, endingEnd: Ye };
    }
    intervalChanged_(t3, e3, n2) {
      const i2 = this.parameterPositions;
      let r3 = t3 - 2, o3 = t3 + 1, s3 = i2[r3], a2 = i2[o3];
      if (s3 === void 0)
        switch (this.getSettings_().endingStart) {
          case Ze:
            r3 = t3, s3 = 2 * e3 - n2;
            break;
          case Je:
            r3 = i2.length - 2, s3 = e3 + i2[r3] - i2[r3 + 1];
            break;
          default:
            r3 = t3, s3 = n2;
        }
      if (a2 === void 0)
        switch (this.getSettings_().endingEnd) {
          case Ze:
            o3 = t3, a2 = 2 * n2 - e3;
            break;
          case Je:
            o3 = 1, a2 = n2 + i2[1] - i2[0];
            break;
          default:
            o3 = t3 - 1, a2 = e3;
        }
      const l2 = 0.5 * (n2 - e3), u2 = this.valueSize;
      this._weightPrev = l2 / (e3 - s3), this._weightNext = l2 / (a2 - n2), this._offsetPrev = r3 * u2, this._offsetNext = o3 * u2;
    }
    interpolate_(t3, e3, n2, i2) {
      const r3 = this.resultBuffer, o3 = this.sampleValues, s3 = this.valueSize, a2 = t3 * s3, l2 = a2 - s3, u2 = this._offsetPrev, h2 = this._offsetNext, c2 = this._weightPrev, d2 = this._weightNext, p2 = (n2 - e3) / (i2 - e3), f2 = p2 * p2, m2 = f2 * p2, g2 = -c2 * m2 + 2 * c2 * f2 - c2 * p2, v2 = (1 + c2) * m2 + (-1.5 - 2 * c2) * f2 + (-0.5 + c2) * p2 + 1, _2 = (-1 - d2) * m2 + (1.5 + d2) * f2 + 0.5 * p2, y2 = d2 * m2 - d2 * f2;
      for (let t4 = 0; t4 !== s3; ++t4)
        r3[t4] = g2 * o3[u2 + t4] + v2 * o3[l2 + t4] + _2 * o3[a2 + t4] + y2 * o3[h2 + t4];
      return r3;
    }
  }
  class Zh extends qh {
    constructor(t3, e3, n2, i2) {
      super(t3, e3, n2, i2);
    }
    interpolate_(t3, e3, n2, i2) {
      const r3 = this.resultBuffer, o3 = this.sampleValues, s3 = this.valueSize, a2 = t3 * s3, l2 = a2 - s3, u2 = (n2 - e3) / (i2 - e3), h2 = 1 - u2;
      for (let t4 = 0; t4 !== s3; ++t4)
        r3[t4] = o3[l2 + t4] * h2 + o3[a2 + t4] * u2;
      return r3;
    }
  }
  class Jh extends qh {
    constructor(t3, e3, n2, i2) {
      super(t3, e3, n2, i2);
    }
    interpolate_(t3) {
      return this.copySampleValue_(t3 - 1);
    }
  }
  class $h {
    constructor(t3, e3, n2, i2) {
      if (t3 === void 0)
        throw new Error("THREE.KeyframeTrack: track name is undefined");
      if (e3 === void 0 || e3.length === 0)
        throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t3);
      this.name = t3, this.times = Xh.convertArray(e3, this.TimeBufferType), this.values = Xh.convertArray(n2, this.ValueBufferType), this.setInterpolation(i2 || this.DefaultInterpolation);
    }
    static toJSON(t3) {
      const e3 = t3.constructor;
      let n2;
      if (e3.toJSON !== this.toJSON)
        n2 = e3.toJSON(t3);
      else {
        n2 = { name: t3.name, times: Xh.convertArray(t3.times, Array), values: Xh.convertArray(t3.values, Array) };
        const e4 = t3.getInterpolation();
        e4 !== t3.DefaultInterpolation && (n2.interpolation = e4);
      }
      return n2.type = t3.ValueTypeName, n2;
    }
    InterpolantFactoryMethodDiscrete(t3) {
      return new Jh(this.times, this.values, this.getValueSize(), t3);
    }
    InterpolantFactoryMethodLinear(t3) {
      return new Zh(this.times, this.values, this.getValueSize(), t3);
    }
    InterpolantFactoryMethodSmooth(t3) {
      return new Yh(this.times, this.values, this.getValueSize(), t3);
    }
    setInterpolation(t3) {
      let e3;
      switch (t3) {
        case We:
          e3 = this.InterpolantFactoryMethodDiscrete;
          break;
        case Xe:
          e3 = this.InterpolantFactoryMethodLinear;
          break;
        case qe:
          e3 = this.InterpolantFactoryMethodSmooth;
      }
      if (e3 === void 0) {
        const e4 = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
        if (this.createInterpolant === void 0) {
          if (t3 === this.DefaultInterpolation)
            throw new Error(e4);
          this.setInterpolation(this.DefaultInterpolation);
        }
        return console.warn("THREE.KeyframeTrack:", e4), this;
      }
      return this.createInterpolant = e3, this;
    }
    getInterpolation() {
      switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
          return We;
        case this.InterpolantFactoryMethodLinear:
          return Xe;
        case this.InterpolantFactoryMethodSmooth:
          return qe;
      }
    }
    getValueSize() {
      return this.values.length / this.times.length;
    }
    shift(t3) {
      if (t3 !== 0) {
        const e3 = this.times;
        for (let n2 = 0, i2 = e3.length; n2 !== i2; ++n2)
          e3[n2] += t3;
      }
      return this;
    }
    scale(t3) {
      if (t3 !== 1) {
        const e3 = this.times;
        for (let n2 = 0, i2 = e3.length; n2 !== i2; ++n2)
          e3[n2] *= t3;
      }
      return this;
    }
    trim(t3, e3) {
      const n2 = this.times, i2 = n2.length;
      let r3 = 0, o3 = i2 - 1;
      for (; r3 !== i2 && n2[r3] < t3; )
        ++r3;
      for (; o3 !== -1 && n2[o3] > e3; )
        --o3;
      if (++o3, r3 !== 0 || o3 !== i2) {
        r3 >= o3 && (o3 = Math.max(o3, 1), r3 = o3 - 1);
        const t4 = this.getValueSize();
        this.times = Xh.arraySlice(n2, r3, o3), this.values = Xh.arraySlice(this.values, r3 * t4, o3 * t4);
      }
      return this;
    }
    validate() {
      let t3 = true;
      const e3 = this.getValueSize();
      e3 - Math.floor(e3) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t3 = false);
      const n2 = this.times, i2 = this.values, r3 = n2.length;
      r3 === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), t3 = false);
      let o3 = null;
      for (let e4 = 0; e4 !== r3; e4++) {
        const i3 = n2[e4];
        if (typeof i3 == "number" && isNaN(i3)) {
          console.error("THREE.KeyframeTrack: Time is not a valid number.", this, e4, i3), t3 = false;
          break;
        }
        if (o3 !== null && o3 > i3) {
          console.error("THREE.KeyframeTrack: Out of order keys.", this, e4, i3, o3), t3 = false;
          break;
        }
        o3 = i3;
      }
      if (i2 !== void 0 && Xh.isTypedArray(i2))
        for (let e4 = 0, n3 = i2.length; e4 !== n3; ++e4) {
          const n4 = i2[e4];
          if (isNaN(n4)) {
            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, e4, n4), t3 = false;
            break;
          }
        }
      return t3;
    }
    optimize() {
      const t3 = Xh.arraySlice(this.times), e3 = Xh.arraySlice(this.values), n2 = this.getValueSize(), i2 = this.getInterpolation() === qe, r3 = t3.length - 1;
      let o3 = 1;
      for (let s3 = 1; s3 < r3; ++s3) {
        let r4 = false;
        const a2 = t3[s3];
        if (a2 !== t3[s3 + 1] && (s3 !== 1 || a2 !== t3[0]))
          if (i2)
            r4 = true;
          else {
            const t4 = s3 * n2, i3 = t4 - n2, o4 = t4 + n2;
            for (let s4 = 0; s4 !== n2; ++s4) {
              const n3 = e3[t4 + s4];
              if (n3 !== e3[i3 + s4] || n3 !== e3[o4 + s4]) {
                r4 = true;
                break;
              }
            }
          }
        if (r4) {
          if (s3 !== o3) {
            t3[o3] = t3[s3];
            const i3 = s3 * n2, r5 = o3 * n2;
            for (let t4 = 0; t4 !== n2; ++t4)
              e3[r5 + t4] = e3[i3 + t4];
          }
          ++o3;
        }
      }
      if (r3 > 0) {
        t3[o3] = t3[r3];
        for (let t4 = r3 * n2, i3 = o3 * n2, s3 = 0; s3 !== n2; ++s3)
          e3[i3 + s3] = e3[t4 + s3];
        ++o3;
      }
      return o3 !== t3.length ? (this.times = Xh.arraySlice(t3, 0, o3), this.values = Xh.arraySlice(e3, 0, o3 * n2)) : (this.times = t3, this.values = e3), this;
    }
    clone() {
      const t3 = Xh.arraySlice(this.times, 0), e3 = Xh.arraySlice(this.values, 0), n2 = new this.constructor(this.name, t3, e3);
      return n2.createInterpolant = this.createInterpolant, n2;
    }
  }
  $h.prototype.TimeBufferType = Float32Array, $h.prototype.ValueBufferType = Float32Array, $h.prototype.DefaultInterpolation = Xe;
  class Kh extends $h {
  }
  Kh.prototype.ValueTypeName = "bool", Kh.prototype.ValueBufferType = Array, Kh.prototype.DefaultInterpolation = We, Kh.prototype.InterpolantFactoryMethodLinear = void 0, Kh.prototype.InterpolantFactoryMethodSmooth = void 0;
  class Qh extends $h {
  }
  Qh.prototype.ValueTypeName = "color";
  class tc extends $h {
  }
  tc.prototype.ValueTypeName = "number";
  class ec extends qh {
    constructor(t3, e3, n2, i2) {
      super(t3, e3, n2, i2);
    }
    interpolate_(t3, e3, n2, i2) {
      const r3 = this.resultBuffer, o3 = this.sampleValues, s3 = this.valueSize, a2 = (n2 - e3) / (i2 - e3);
      let l2 = t3 * s3;
      for (let t4 = l2 + s3; l2 !== t4; l2 += 4)
        di.slerpFlat(r3, 0, o3, l2 - s3, o3, l2, a2);
      return r3;
    }
  }
  class nc extends $h {
    InterpolantFactoryMethodLinear(t3) {
      return new ec(this.times, this.values, this.getValueSize(), t3);
    }
  }
  nc.prototype.ValueTypeName = "quaternion", nc.prototype.DefaultInterpolation = Xe, nc.prototype.InterpolantFactoryMethodSmooth = void 0;
  class ic extends $h {
  }
  ic.prototype.ValueTypeName = "string", ic.prototype.ValueBufferType = Array, ic.prototype.DefaultInterpolation = We, ic.prototype.InterpolantFactoryMethodLinear = void 0, ic.prototype.InterpolantFactoryMethodSmooth = void 0;
  class rc extends $h {
  }
  rc.prototype.ValueTypeName = "vector";
  class oc {
    constructor(t3, e3 = -1, n2, i2 = $e) {
      this.name = t3, this.tracks = n2, this.duration = e3, this.blendMode = i2, this.uuid = qn(), this.duration < 0 && this.resetDuration();
    }
    static parse(t3) {
      const e3 = [], n2 = t3.tracks, i2 = 1 / (t3.fps || 1);
      for (let t4 = 0, r4 = n2.length; t4 !== r4; ++t4)
        e3.push(sc(n2[t4]).scale(i2));
      const r3 = new this(t3.name, t3.duration, e3, t3.blendMode);
      return r3.uuid = t3.uuid, r3;
    }
    static toJSON(t3) {
      const e3 = [], n2 = t3.tracks, i2 = { name: t3.name, duration: t3.duration, tracks: e3, uuid: t3.uuid, blendMode: t3.blendMode };
      for (let t4 = 0, i3 = n2.length; t4 !== i3; ++t4)
        e3.push($h.toJSON(n2[t4]));
      return i2;
    }
    static CreateFromMorphTargetSequence(t3, e3, n2, i2) {
      const r3 = e3.length, o3 = [];
      for (let t4 = 0; t4 < r3; t4++) {
        let s3 = [], a2 = [];
        s3.push((t4 + r3 - 1) % r3, t4, (t4 + 1) % r3), a2.push(0, 1, 0);
        const l2 = Xh.getKeyframeOrder(s3);
        s3 = Xh.sortedArray(s3, 1, l2), a2 = Xh.sortedArray(a2, 1, l2), i2 || s3[0] !== 0 || (s3.push(r3), a2.push(a2[0])), o3.push(new tc(".morphTargetInfluences[" + e3[t4].name + "]", s3, a2).scale(1 / n2));
      }
      return new this(t3, -1, o3);
    }
    static findByName(t3, e3) {
      let n2 = t3;
      if (!Array.isArray(t3)) {
        const e4 = t3;
        n2 = e4.geometry && e4.geometry.animations || e4.animations;
      }
      for (let t4 = 0; t4 < n2.length; t4++)
        if (n2[t4].name === e3)
          return n2[t4];
      return null;
    }
    static CreateClipsFromMorphTargetSequences(t3, e3, n2) {
      const i2 = {}, r3 = /^([\w-]*?)([\d]+)$/;
      for (let e4 = 0, n3 = t3.length; e4 < n3; e4++) {
        const n4 = t3[e4], o4 = n4.name.match(r3);
        if (o4 && o4.length > 1) {
          const t4 = o4[1];
          let e5 = i2[t4];
          e5 || (i2[t4] = e5 = []), e5.push(n4);
        }
      }
      const o3 = [];
      for (const t4 in i2)
        o3.push(this.CreateFromMorphTargetSequence(t4, i2[t4], e3, n2));
      return o3;
    }
    static parseAnimation(t3, e3) {
      if (!t3)
        return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
      const n2 = function(t4, e4, n3, i3, r4) {
        if (n3.length !== 0) {
          const o4 = [], s4 = [];
          Xh.flattenJSON(n3, o4, s4, i3), o4.length !== 0 && r4.push(new t4(e4, o4, s4));
        }
      }, i2 = [], r3 = t3.name || "default", o3 = t3.fps || 30, s3 = t3.blendMode;
      let a2 = t3.length || -1;
      const l2 = t3.hierarchy || [];
      for (let t4 = 0; t4 < l2.length; t4++) {
        const r4 = l2[t4].keys;
        if (r4 && r4.length !== 0)
          if (r4[0].morphTargets) {
            const t5 = {};
            let e4;
            for (e4 = 0; e4 < r4.length; e4++)
              if (r4[e4].morphTargets)
                for (let n3 = 0; n3 < r4[e4].morphTargets.length; n3++)
                  t5[r4[e4].morphTargets[n3]] = -1;
            for (const n3 in t5) {
              const t6 = [], o4 = [];
              for (let i3 = 0; i3 !== r4[e4].morphTargets.length; ++i3) {
                const i4 = r4[e4];
                t6.push(i4.time), o4.push(i4.morphTarget === n3 ? 1 : 0);
              }
              i2.push(new tc(".morphTargetInfluence[" + n3 + "]", t6, o4));
            }
            a2 = t5.length * (o3 || 1);
          } else {
            const o4 = ".bones[" + e3[t4].name + "]";
            n2(rc, o4 + ".position", r4, "pos", i2), n2(nc, o4 + ".quaternion", r4, "rot", i2), n2(rc, o4 + ".scale", r4, "scl", i2);
          }
      }
      if (i2.length === 0)
        return null;
      return new this(r3, a2, i2, s3);
    }
    resetDuration() {
      let t3 = 0;
      for (let e3 = 0, n2 = this.tracks.length; e3 !== n2; ++e3) {
        const n3 = this.tracks[e3];
        t3 = Math.max(t3, n3.times[n3.times.length - 1]);
      }
      return this.duration = t3, this;
    }
    trim() {
      for (let t3 = 0; t3 < this.tracks.length; t3++)
        this.tracks[t3].trim(0, this.duration);
      return this;
    }
    validate() {
      let t3 = true;
      for (let e3 = 0; e3 < this.tracks.length; e3++)
        t3 = t3 && this.tracks[e3].validate();
      return t3;
    }
    optimize() {
      for (let t3 = 0; t3 < this.tracks.length; t3++)
        this.tracks[t3].optimize();
      return this;
    }
    clone() {
      const t3 = [];
      for (let e3 = 0; e3 < this.tracks.length; e3++)
        t3.push(this.tracks[e3].clone());
      return new this.constructor(this.name, this.duration, t3, this.blendMode);
    }
    toJSON() {
      return this.constructor.toJSON(this);
    }
  }
  function sc(t3) {
    if (t3.type === void 0)
      throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    const e3 = function(t4) {
      switch (t4.toLowerCase()) {
        case "scalar":
        case "double":
        case "float":
        case "number":
        case "integer":
          return tc;
        case "vector":
        case "vector2":
        case "vector3":
        case "vector4":
          return rc;
        case "color":
          return Qh;
        case "quaternion":
          return nc;
        case "bool":
        case "boolean":
          return Kh;
        case "string":
          return ic;
      }
      throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t4);
    }(t3.type);
    if (t3.times === void 0) {
      const e4 = [], n2 = [];
      Xh.flattenJSON(t3.keys, e4, n2, "value"), t3.times = e4, t3.values = n2;
    }
    return e3.parse !== void 0 ? e3.parse(t3) : new e3(t3.name, t3.times, t3.values, t3.interpolation);
  }
  const ac = { enabled: false, files: {}, add: function(t3, e3) {
    this.enabled !== false && (this.files[t3] = e3);
  }, get: function(t3) {
    if (this.enabled !== false)
      return this.files[t3];
  }, remove: function(t3) {
    delete this.files[t3];
  }, clear: function() {
    this.files = {};
  } };
  class lc {
    constructor(t3, e3, n2) {
      const i2 = this;
      let r3 = false, o3 = 0, s3 = 0, a2 = void 0;
      const l2 = [];
      this.onStart = void 0, this.onLoad = t3, this.onProgress = e3, this.onError = n2, this.itemStart = function(t4) {
        s3++, r3 === false && i2.onStart !== void 0 && i2.onStart(t4, o3, s3), r3 = true;
      }, this.itemEnd = function(t4) {
        o3++, i2.onProgress !== void 0 && i2.onProgress(t4, o3, s3), o3 === s3 && (r3 = false, i2.onLoad !== void 0 && i2.onLoad());
      }, this.itemError = function(t4) {
        i2.onError !== void 0 && i2.onError(t4);
      }, this.resolveURL = function(t4) {
        return a2 ? a2(t4) : t4;
      }, this.setURLModifier = function(t4) {
        return a2 = t4, this;
      }, this.addHandler = function(t4, e4) {
        return l2.push(t4, e4), this;
      }, this.removeHandler = function(t4) {
        const e4 = l2.indexOf(t4);
        return e4 !== -1 && l2.splice(e4, 2), this;
      }, this.getHandler = function(t4) {
        for (let e4 = 0, n3 = l2.length; e4 < n3; e4 += 2) {
          const n4 = l2[e4], i3 = l2[e4 + 1];
          if (n4.global && (n4.lastIndex = 0), n4.test(t4))
            return i3;
        }
        return null;
      };
    }
  }
  const uc = new lc();
  class hc {
    constructor(t3) {
      this.manager = t3 !== void 0 ? t3 : uc, this.crossOrigin = "anonymous", this.withCredentials = false, this.path = "", this.resourcePath = "", this.requestHeader = {};
    }
    load() {
    }
    loadAsync(t3, e3) {
      const n2 = this;
      return new Promise(function(i2, r3) {
        n2.load(t3, i2, e3, r3);
      });
    }
    parse() {
    }
    setCrossOrigin(t3) {
      return this.crossOrigin = t3, this;
    }
    setWithCredentials(t3) {
      return this.withCredentials = t3, this;
    }
    setPath(t3) {
      return this.path = t3, this;
    }
    setResourcePath(t3) {
      return this.resourcePath = t3, this;
    }
    setRequestHeader(t3) {
      return this.requestHeader = t3, this;
    }
  }
  const cc = {};
  class dc extends hc {
    constructor(t3) {
      super(t3);
    }
    load(t3, e3, n2, i2) {
      t3 === void 0 && (t3 = ""), this.path !== void 0 && (t3 = this.path + t3), t3 = this.manager.resolveURL(t3);
      const r3 = this, o3 = ac.get(t3);
      if (o3 !== void 0)
        return r3.manager.itemStart(t3), setTimeout(function() {
          e3 && e3(o3), r3.manager.itemEnd(t3);
        }, 0), o3;
      if (cc[t3] !== void 0)
        return void cc[t3].push({ onLoad: e3, onProgress: n2, onError: i2 });
      const s3 = t3.match(/^data:(.*?)(;base64)?,(.*)$/);
      let a2;
      if (s3) {
        const n3 = s3[1], o4 = !!s3[2];
        let a3 = s3[3];
        a3 = decodeURIComponent(a3), o4 && (a3 = atob(a3));
        try {
          let i3;
          const o5 = (this.responseType || "").toLowerCase();
          switch (o5) {
            case "arraybuffer":
            case "blob":
              const t4 = new Uint8Array(a3.length);
              for (let e5 = 0; e5 < a3.length; e5++)
                t4[e5] = a3.charCodeAt(e5);
              i3 = o5 === "blob" ? new Blob([t4.buffer], { type: n3 }) : t4.buffer;
              break;
            case "document":
              const e4 = new DOMParser();
              i3 = e4.parseFromString(a3, n3);
              break;
            case "json":
              i3 = JSON.parse(a3);
              break;
            default:
              i3 = a3;
          }
          setTimeout(function() {
            e3 && e3(i3), r3.manager.itemEnd(t3);
          }, 0);
        } catch (e4) {
          setTimeout(function() {
            i2 && i2(e4), r3.manager.itemError(t3), r3.manager.itemEnd(t3);
          }, 0);
        }
      } else {
        cc[t3] = [], cc[t3].push({ onLoad: e3, onProgress: n2, onError: i2 }), a2 = new XMLHttpRequest(), a2.open("GET", t3, true), a2.addEventListener("load", function(e4) {
          const n3 = this.response, i3 = cc[t3];
          if (delete cc[t3], this.status === 200 || this.status === 0) {
            this.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), ac.add(t3, n3);
            for (let t4 = 0, e5 = i3.length; t4 < e5; t4++) {
              const e6 = i3[t4];
              e6.onLoad && e6.onLoad(n3);
            }
            r3.manager.itemEnd(t3);
          } else {
            for (let t4 = 0, n4 = i3.length; t4 < n4; t4++) {
              const n5 = i3[t4];
              n5.onError && n5.onError(e4);
            }
            r3.manager.itemError(t3), r3.manager.itemEnd(t3);
          }
        }, false), a2.addEventListener("progress", function(e4) {
          const n3 = cc[t3];
          for (let t4 = 0, i3 = n3.length; t4 < i3; t4++) {
            const i4 = n3[t4];
            i4.onProgress && i4.onProgress(e4);
          }
        }, false), a2.addEventListener("error", function(e4) {
          const n3 = cc[t3];
          delete cc[t3];
          for (let t4 = 0, i3 = n3.length; t4 < i3; t4++) {
            const i4 = n3[t4];
            i4.onError && i4.onError(e4);
          }
          r3.manager.itemError(t3), r3.manager.itemEnd(t3);
        }, false), a2.addEventListener("abort", function(e4) {
          const n3 = cc[t3];
          delete cc[t3];
          for (let t4 = 0, i3 = n3.length; t4 < i3; t4++) {
            const i4 = n3[t4];
            i4.onError && i4.onError(e4);
          }
          r3.manager.itemError(t3), r3.manager.itemEnd(t3);
        }, false), this.responseType !== void 0 && (a2.responseType = this.responseType), this.withCredentials !== void 0 && (a2.withCredentials = this.withCredentials), a2.overrideMimeType && a2.overrideMimeType(this.mimeType !== void 0 ? this.mimeType : "text/plain");
        for (const t4 in this.requestHeader)
          a2.setRequestHeader(t4, this.requestHeader[t4]);
        a2.send(null);
      }
      return r3.manager.itemStart(t3), a2;
    }
    setResponseType(t3) {
      return this.responseType = t3, this;
    }
    setMimeType(t3) {
      return this.mimeType = t3, this;
    }
  }
  class pc extends hc {
    constructor(t3) {
      super(t3);
    }
    load(t3, e3, n2, i2) {
      const r3 = this, o3 = new dc(this.manager);
      o3.setPath(this.path), o3.setRequestHeader(this.requestHeader), o3.setWithCredentials(this.withCredentials), o3.load(t3, function(n3) {
        try {
          e3(r3.parse(JSON.parse(n3)));
        } catch (e4) {
          i2 ? i2(e4) : console.error(e4), r3.manager.itemError(t3);
        }
      }, n2, i2);
    }
    parse(t3) {
      const e3 = [];
      for (let n2 = 0; n2 < t3.length; n2++) {
        const i2 = oc.parse(t3[n2]);
        e3.push(i2);
      }
      return e3;
    }
  }
  class fc extends hc {
    constructor(t3) {
      super(t3);
    }
    load(t3, e3, n2, i2) {
      const r3 = this, o3 = [], s3 = new du(), a2 = new dc(this.manager);
      a2.setPath(this.path), a2.setResponseType("arraybuffer"), a2.setRequestHeader(this.requestHeader), a2.setWithCredentials(r3.withCredentials);
      let l2 = 0;
      function u2(u3) {
        a2.load(t3[u3], function(t4) {
          const n3 = r3.parse(t4, true);
          o3[u3] = { width: n3.width, height: n3.height, format: n3.format, mipmaps: n3.mipmaps }, l2 += 1, l2 === 6 && (n3.mipmapCount === 1 && (s3.minFilter = Et), s3.image = o3, s3.format = n3.format, s3.needsUpdate = true, e3 && e3(s3));
        }, n2, i2);
      }
      if (Array.isArray(t3))
        for (let e4 = 0, n3 = t3.length; e4 < n3; ++e4)
          u2(e4);
      else
        a2.load(t3, function(t4) {
          const n3 = r3.parse(t4, true);
          if (n3.isCubemap) {
            const t5 = n3.mipmaps.length / n3.mipmapCount;
            for (let e4 = 0; e4 < t5; e4++) {
              o3[e4] = { mipmaps: [] };
              for (let t6 = 0; t6 < n3.mipmapCount; t6++)
                o3[e4].mipmaps.push(n3.mipmaps[e4 * n3.mipmapCount + t6]), o3[e4].format = n3.format, o3[e4].width = n3.width, o3[e4].height = n3.height;
            }
            s3.image = o3;
          } else
            s3.image.width = n3.width, s3.image.height = n3.height, s3.mipmaps = n3.mipmaps;
          n3.mipmapCount === 1 && (s3.minFilter = Et), s3.format = n3.format, s3.needsUpdate = true, e3 && e3(s3);
        }, n2, i2);
      return s3;
    }
  }
  class mc extends hc {
    constructor(t3) {
      super(t3);
    }
    load(t3, e3, n2, i2) {
      this.path !== void 0 && (t3 = this.path + t3), t3 = this.manager.resolveURL(t3);
      const r3 = this, o3 = ac.get(t3);
      if (o3 !== void 0)
        return r3.manager.itemStart(t3), setTimeout(function() {
          e3 && e3(o3), r3.manager.itemEnd(t3);
        }, 0), o3;
      const s3 = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
      function a2() {
        s3.removeEventListener("load", a2, false), s3.removeEventListener("error", l2, false), ac.add(t3, this), e3 && e3(this), r3.manager.itemEnd(t3);
      }
      function l2(e4) {
        s3.removeEventListener("load", a2, false), s3.removeEventListener("error", l2, false), i2 && i2(e4), r3.manager.itemError(t3), r3.manager.itemEnd(t3);
      }
      return s3.addEventListener("load", a2, false), s3.addEventListener("error", l2, false), t3.substr(0, 5) !== "data:" && this.crossOrigin !== void 0 && (s3.crossOrigin = this.crossOrigin), r3.manager.itemStart(t3), s3.src = t3, s3;
    }
  }
  class gc extends hc {
    constructor(t3) {
      super(t3);
    }
    load(t3, e3, n2, i2) {
      const r3 = new Do(), o3 = new mc(this.manager);
      o3.setCrossOrigin(this.crossOrigin), o3.setPath(this.path);
      let s3 = 0;
      function a2(n3) {
        o3.load(t3[n3], function(t4) {
          r3.images[n3] = t4, s3++, s3 === 6 && (r3.needsUpdate = true, e3 && e3(r3));
        }, void 0, i2);
      }
      for (let e4 = 0; e4 < t3.length; ++e4)
        a2(e4);
      return r3;
    }
  }
  class vc extends hc {
    constructor(t3) {
      super(t3);
    }
    load(t3, e3, n2, i2) {
      const r3 = this, o3 = new Ul(), s3 = new dc(this.manager);
      return s3.setResponseType("arraybuffer"), s3.setRequestHeader(this.requestHeader), s3.setPath(this.path), s3.setWithCredentials(r3.withCredentials), s3.load(t3, function(t4) {
        const n3 = r3.parse(t4);
        n3 && (n3.image !== void 0 ? o3.image = n3.image : n3.data !== void 0 && (o3.image.width = n3.width, o3.image.height = n3.height, o3.image.data = n3.data), o3.wrapS = n3.wrapS !== void 0 ? n3.wrapS : _t, o3.wrapT = n3.wrapT !== void 0 ? n3.wrapT : _t, o3.magFilter = n3.magFilter !== void 0 ? n3.magFilter : Et, o3.minFilter = n3.minFilter !== void 0 ? n3.minFilter : Et, o3.anisotropy = n3.anisotropy !== void 0 ? n3.anisotropy : 1, n3.encoding !== void 0 && (o3.encoding = n3.encoding), n3.flipY !== void 0 && (o3.flipY = n3.flipY), n3.format !== void 0 && (o3.format = n3.format), n3.type !== void 0 && (o3.type = n3.type), n3.mipmaps !== void 0 && (o3.mipmaps = n3.mipmaps, o3.minFilter = Rt), n3.mipmapCount === 1 && (o3.minFilter = Et), n3.generateMipmaps !== void 0 && (o3.generateMipmaps = n3.generateMipmaps), o3.needsUpdate = true, e3 && e3(o3, n3));
      }, n2, i2), o3;
    }
  }
  class _c extends hc {
    constructor(t3) {
      super(t3);
    }
    load(t3, e3, n2, i2) {
      const r3 = new si(), o3 = new mc(this.manager);
      return o3.setCrossOrigin(this.crossOrigin), o3.setPath(this.path), o3.load(t3, function(n3) {
        r3.image = n3;
        const i3 = t3.search(/\.jpe?g($|\?)/i) > 0 || t3.search(/^data\:image\/jpeg/) === 0;
        r3.format = i3 ? jt : Vt, r3.needsUpdate = true, e3 !== void 0 && e3(r3);
      }, n2, i2), r3;
    }
  }
  class yc extends Eu {
    constructor() {
      super(), this.type = "CurvePath", this.curves = [], this.autoClose = false;
    }
    add(t3) {
      this.curves.push(t3);
    }
    closePath() {
      const t3 = this.curves[0].getPoint(0), e3 = this.curves[this.curves.length - 1].getPoint(1);
      t3.equals(e3) || this.curves.push(new ku(e3, t3));
    }
    getPoint(t3) {
      const e3 = t3 * this.getLength(), n2 = this.getCurveLengths();
      let i2 = 0;
      for (; i2 < n2.length; ) {
        if (n2[i2] >= e3) {
          const t4 = n2[i2] - e3, r3 = this.curves[i2], o3 = r3.getLength(), s3 = o3 === 0 ? 0 : 1 - t4 / o3;
          return r3.getPointAt(s3);
        }
        i2++;
      }
      return null;
    }
    getLength() {
      const t3 = this.getCurveLengths();
      return t3[t3.length - 1];
    }
    updateArcLengths() {
      this.needsUpdate = true, this.cacheLengths = null, this.getCurveLengths();
    }
    getCurveLengths() {
      if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
        return this.cacheLengths;
      const t3 = [];
      let e3 = 0;
      for (let n2 = 0, i2 = this.curves.length; n2 < i2; n2++)
        e3 += this.curves[n2].getLength(), t3.push(e3);
      return this.cacheLengths = t3, t3;
    }
    getSpacedPoints(t3 = 40) {
      const e3 = [];
      for (let n2 = 0; n2 <= t3; n2++)
        e3.push(this.getPoint(n2 / t3));
      return this.autoClose && e3.push(e3[0]), e3;
    }
    getPoints(t3 = 12) {
      const e3 = [];
      let n2;
      for (let i2 = 0, r3 = this.curves; i2 < r3.length; i2++) {
        const o3 = r3[i2], s3 = o3 && o3.isEllipseCurve ? 2 * t3 : o3 && (o3.isLineCurve || o3.isLineCurve3) ? 1 : o3 && o3.isSplineCurve ? t3 * o3.points.length : t3, a2 = o3.getPoints(s3);
        for (let t4 = 0; t4 < a2.length; t4++) {
          const i3 = a2[t4];
          n2 && n2.equals(i3) || (e3.push(i3), n2 = i3);
        }
      }
      return this.autoClose && e3.length > 1 && !e3[e3.length - 1].equals(e3[0]) && e3.push(e3[0]), e3;
    }
    copy(t3) {
      super.copy(t3), this.curves = [];
      for (let e3 = 0, n2 = t3.curves.length; e3 < n2; e3++) {
        const n3 = t3.curves[e3];
        this.curves.push(n3.clone());
      }
      return this.autoClose = t3.autoClose, this;
    }
    toJSON() {
      const t3 = super.toJSON();
      t3.autoClose = this.autoClose, t3.curves = [];
      for (let e3 = 0, n2 = this.curves.length; e3 < n2; e3++) {
        const n3 = this.curves[e3];
        t3.curves.push(n3.toJSON());
      }
      return t3;
    }
    fromJSON(t3) {
      super.fromJSON(t3), this.autoClose = t3.autoClose, this.curves = [];
      for (let e3 = 0, n2 = t3.curves.length; e3 < n2; e3++) {
        const n3 = t3.curves[e3];
        this.curves.push(new Vu[n3.type]().fromJSON(n3));
      }
      return this;
    }
  }
  class xc extends yc {
    constructor(t3) {
      super(), this.type = "Path", this.currentPoint = new ei(), t3 && this.setFromPoints(t3);
    }
    setFromPoints(t3) {
      this.moveTo(t3[0].x, t3[0].y);
      for (let e3 = 1, n2 = t3.length; e3 < n2; e3++)
        this.lineTo(t3[e3].x, t3[e3].y);
      return this;
    }
    moveTo(t3, e3) {
      return this.currentPoint.set(t3, e3), this;
    }
    lineTo(t3, e3) {
      const n2 = new ku(this.currentPoint.clone(), new ei(t3, e3));
      return this.curves.push(n2), this.currentPoint.set(t3, e3), this;
    }
    quadraticCurveTo(t3, e3, n2, i2) {
      const r3 = new Hu(this.currentPoint.clone(), new ei(t3, e3), new ei(n2, i2));
      return this.curves.push(r3), this.currentPoint.set(n2, i2), this;
    }
    bezierCurveTo(t3, e3, n2, i2, r3, o3) {
      const s3 = new Bu(this.currentPoint.clone(), new ei(t3, e3), new ei(n2, i2), new ei(r3, o3));
      return this.curves.push(s3), this.currentPoint.set(r3, o3), this;
    }
    splineThru(t3) {
      const e3 = [this.currentPoint.clone()].concat(t3), n2 = new ju(e3);
      return this.curves.push(n2), this.currentPoint.copy(t3[t3.length - 1]), this;
    }
    arc(t3, e3, n2, i2, r3, o3) {
      const s3 = this.currentPoint.x, a2 = this.currentPoint.y;
      return this.absarc(t3 + s3, e3 + a2, n2, i2, r3, o3), this;
    }
    absarc(t3, e3, n2, i2, r3, o3) {
      return this.absellipse(t3, e3, n2, n2, i2, r3, o3), this;
    }
    ellipse(t3, e3, n2, i2, r3, o3, s3, a2) {
      const l2 = this.currentPoint.x, u2 = this.currentPoint.y;
      return this.absellipse(t3 + l2, e3 + u2, n2, i2, r3, o3, s3, a2), this;
    }
    absellipse(t3, e3, n2, i2, r3, o3, s3, a2) {
      const l2 = new Mu(t3, e3, n2, i2, r3, o3, s3, a2);
      if (this.curves.length > 0) {
        const t4 = l2.getPoint(0);
        t4.equals(this.currentPoint) || this.lineTo(t4.x, t4.y);
      }
      this.curves.push(l2);
      const u2 = l2.getPoint(1);
      return this.currentPoint.copy(u2), this;
    }
    copy(t3) {
      return super.copy(t3), this.currentPoint.copy(t3.currentPoint), this;
    }
    toJSON() {
      const t3 = super.toJSON();
      return t3.currentPoint = this.currentPoint.toArray(), t3;
    }
    fromJSON(t3) {
      return super.fromJSON(t3), this.currentPoint.fromArray(t3.currentPoint), this;
    }
  }
  class bc extends xc {
    constructor(t3) {
      super(t3), this.uuid = qn(), this.type = "Shape", this.holes = [];
    }
    getPointsHoles(t3) {
      const e3 = [];
      for (let n2 = 0, i2 = this.holes.length; n2 < i2; n2++)
        e3[n2] = this.holes[n2].getPoints(t3);
      return e3;
    }
    extractPoints(t3) {
      return { shape: this.getPoints(t3), holes: this.getPointsHoles(t3) };
    }
    copy(t3) {
      super.copy(t3), this.holes = [];
      for (let e3 = 0, n2 = t3.holes.length; e3 < n2; e3++) {
        const n3 = t3.holes[e3];
        this.holes.push(n3.clone());
      }
      return this;
    }
    toJSON() {
      const t3 = super.toJSON();
      t3.uuid = this.uuid, t3.holes = [];
      for (let e3 = 0, n2 = this.holes.length; e3 < n2; e3++) {
        const n3 = this.holes[e3];
        t3.holes.push(n3.toJSON());
      }
      return t3;
    }
    fromJSON(t3) {
      super.fromJSON(t3), this.uuid = t3.uuid, this.holes = [];
      for (let e3 = 0, n2 = t3.holes.length; e3 < n2; e3++) {
        const n3 = t3.holes[e3];
        this.holes.push(new xc().fromJSON(n3));
      }
      return this;
    }
  }
  class Tc extends mr {
    constructor(t3, e3 = 1) {
      super(), this.type = "Light", this.color = new Dr(t3), this.intensity = e3;
    }
    dispose() {
    }
    copy(t3) {
      return super.copy(t3), this.color.copy(t3.color), this.intensity = t3.intensity, this;
    }
    toJSON(t3) {
      const e3 = super.toJSON(t3);
      return e3.object.color = this.color.getHex(), e3.object.intensity = this.intensity, this.groundColor !== void 0 && (e3.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (e3.object.distance = this.distance), this.angle !== void 0 && (e3.object.angle = this.angle), this.decay !== void 0 && (e3.object.decay = this.decay), this.penumbra !== void 0 && (e3.object.penumbra = this.penumbra), this.shadow !== void 0 && (e3.object.shadow = this.shadow.toJSON()), e3;
    }
  }
  Tc.prototype.isLight = true;
  class wc extends Tc {
    constructor(t3, e3, n2) {
      super(t3, n2), this.type = "HemisphereLight", this.position.copy(mr.DefaultUp), this.updateMatrix(), this.groundColor = new Dr(e3);
    }
    copy(t3) {
      return Tc.prototype.copy.call(this, t3), this.groundColor.copy(t3.groundColor), this;
    }
  }
  wc.prototype.isHemisphereLight = true;
  const Sc = new Vi(), Ec = new pi(), Mc = new pi();
  class Ac {
    constructor(t3) {
      this.camera = t3, this.bias = 0, this.normalBias = 0, this.radius = 1, this.mapSize = new ei(512, 512), this.map = null, this.mapPass = null, this.matrix = new Vi(), this.autoUpdate = true, this.needsUpdate = false, this._frustum = new jo(), this._frameExtents = new ei(1, 1), this._viewportCount = 1, this._viewports = [new li(0, 0, 1, 1)];
    }
    getViewportCount() {
      return this._viewportCount;
    }
    getFrustum() {
      return this._frustum;
    }
    updateMatrices(t3) {
      const e3 = this.camera, n2 = this.matrix;
      Ec.setFromMatrixPosition(t3.matrixWorld), e3.position.copy(Ec), Mc.setFromMatrixPosition(t3.target.matrixWorld), e3.lookAt(Mc), e3.updateMatrixWorld(), Sc.multiplyMatrices(e3.projectionMatrix, e3.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Sc), n2.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), n2.multiply(e3.projectionMatrix), n2.multiply(e3.matrixWorldInverse);
    }
    getViewport(t3) {
      return this._viewports[t3];
    }
    getFrameExtents() {
      return this._frameExtents;
    }
    dispose() {
      this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
    }
    copy(t3) {
      return this.camera = t3.camera.clone(), this.bias = t3.bias, this.radius = t3.radius, this.mapSize.copy(t3.mapSize), this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    toJSON() {
      const t3 = {};
      return this.bias !== 0 && (t3.bias = this.bias), this.normalBias !== 0 && (t3.normalBias = this.normalBias), this.radius !== 1 && (t3.radius = this.radius), this.mapSize.x === 512 && this.mapSize.y === 512 || (t3.mapSize = this.mapSize.toArray()), t3.camera = this.camera.toJSON(false).object, delete t3.camera.matrix, t3;
    }
  }
  class Rc extends Ac {
    constructor() {
      super(new Lo(50, 1, 0.5, 500)), this.focus = 1;
    }
    updateMatrices(t3) {
      const e3 = this.camera, n2 = 2 * Xn * t3.angle * this.focus, i2 = this.mapSize.width / this.mapSize.height, r3 = t3.distance || e3.far;
      n2 === e3.fov && i2 === e3.aspect && r3 === e3.far || (e3.fov = n2, e3.aspect = i2, e3.far = r3, e3.updateProjectionMatrix()), super.updateMatrices(t3);
    }
    copy(t3) {
      return super.copy(t3), this.focus = t3.focus, this;
    }
  }
  Rc.prototype.isSpotLightShadow = true;
  class Pc extends Tc {
    constructor(t3, e3, n2 = 0, i2 = Math.PI / 3, r3 = 0, o3 = 1) {
      super(t3, e3), this.type = "SpotLight", this.position.copy(mr.DefaultUp), this.updateMatrix(), this.target = new mr(), this.distance = n2, this.angle = i2, this.penumbra = r3, this.decay = o3, this.shadow = new Rc();
    }
    get power() {
      return this.intensity * Math.PI;
    }
    set power(t3) {
      this.intensity = t3 / Math.PI;
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(t3) {
      return super.copy(t3), this.distance = t3.distance, this.angle = t3.angle, this.penumbra = t3.penumbra, this.decay = t3.decay, this.target = t3.target.clone(), this.shadow = t3.shadow.clone(), this;
    }
  }
  Pc.prototype.isSpotLight = true;
  const Cc = new Vi(), Ic = new pi(), Oc = new pi();
  class Lc extends Ac {
    constructor() {
      super(new Lo(90, 1, 0.5, 500)), this._frameExtents = new ei(4, 2), this._viewportCount = 6, this._viewports = [new li(2, 1, 1, 1), new li(0, 1, 1, 1), new li(3, 1, 1, 1), new li(1, 1, 1, 1), new li(3, 0, 1, 1), new li(1, 0, 1, 1)], this._cubeDirections = [new pi(1, 0, 0), new pi(-1, 0, 0), new pi(0, 0, 1), new pi(0, 0, -1), new pi(0, 1, 0), new pi(0, -1, 0)], this._cubeUps = [new pi(0, 1, 0), new pi(0, 1, 0), new pi(0, 1, 0), new pi(0, 1, 0), new pi(0, 0, 1), new pi(0, 0, -1)];
    }
    updateMatrices(t3, e3 = 0) {
      const n2 = this.camera, i2 = this.matrix, r3 = t3.distance || n2.far;
      r3 !== n2.far && (n2.far = r3, n2.updateProjectionMatrix()), Ic.setFromMatrixPosition(t3.matrixWorld), n2.position.copy(Ic), Oc.copy(n2.position), Oc.add(this._cubeDirections[e3]), n2.up.copy(this._cubeUps[e3]), n2.lookAt(Oc), n2.updateMatrixWorld(), i2.makeTranslation(-Ic.x, -Ic.y, -Ic.z), Cc.multiplyMatrices(n2.projectionMatrix, n2.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Cc);
    }
  }
  Lc.prototype.isPointLightShadow = true;
  class Nc extends Tc {
    constructor(t3, e3, n2 = 0, i2 = 1) {
      super(t3, e3), this.type = "PointLight", this.distance = n2, this.decay = i2, this.shadow = new Lc();
    }
    get power() {
      return 4 * this.intensity * Math.PI;
    }
    set power(t3) {
      this.intensity = t3 / (4 * Math.PI);
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(t3) {
      return super.copy(t3), this.distance = t3.distance, this.decay = t3.decay, this.shadow = t3.shadow.clone(), this;
    }
  }
  Nc.prototype.isPointLight = true;
  class Dc extends Oo {
    constructor(t3 = -1, e3 = 1, n2 = 1, i2 = -1, r3 = 0.1, o3 = 2e3) {
      super(), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t3, this.right = e3, this.top = n2, this.bottom = i2, this.near = r3, this.far = o3, this.updateProjectionMatrix();
    }
    copy(t3, e3) {
      return super.copy(t3, e3), this.left = t3.left, this.right = t3.right, this.top = t3.top, this.bottom = t3.bottom, this.near = t3.near, this.far = t3.far, this.zoom = t3.zoom, this.view = t3.view === null ? null : Object.assign({}, t3.view), this;
    }
    setViewOffset(t3, e3, n2, i2, r3, o3) {
      this.view === null && (this.view = { enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = true, this.view.fullWidth = t3, this.view.fullHeight = e3, this.view.offsetX = n2, this.view.offsetY = i2, this.view.width = r3, this.view.height = o3, this.updateProjectionMatrix();
    }
    clearViewOffset() {
      this.view !== null && (this.view.enabled = false), this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
      const t3 = (this.right - this.left) / (2 * this.zoom), e3 = (this.top - this.bottom) / (2 * this.zoom), n2 = (this.right + this.left) / 2, i2 = (this.top + this.bottom) / 2;
      let r3 = n2 - t3, o3 = n2 + t3, s3 = i2 + e3, a2 = i2 - e3;
      if (this.view !== null && this.view.enabled) {
        const t4 = (this.right - this.left) / this.view.fullWidth / this.zoom, e4 = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
        r3 += t4 * this.view.offsetX, o3 = r3 + t4 * this.view.width, s3 -= e4 * this.view.offsetY, a2 = s3 - e4 * this.view.height;
      }
      this.projectionMatrix.makeOrthographic(r3, o3, s3, a2, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(t3) {
      const e3 = super.toJSON(t3);
      return e3.object.zoom = this.zoom, e3.object.left = this.left, e3.object.right = this.right, e3.object.top = this.top, e3.object.bottom = this.bottom, e3.object.near = this.near, e3.object.far = this.far, this.view !== null && (e3.object.view = Object.assign({}, this.view)), e3;
    }
  }
  Dc.prototype.isOrthographicCamera = true;
  class Fc extends Ac {
    constructor() {
      super(new Dc(-5, 5, 5, -5, 0.5, 500));
    }
  }
  Fc.prototype.isDirectionalLightShadow = true;
  class Bc extends Tc {
    constructor(t3, e3) {
      super(t3, e3), this.type = "DirectionalLight", this.position.copy(mr.DefaultUp), this.updateMatrix(), this.target = new mr(), this.shadow = new Fc();
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(t3) {
      return super.copy(t3), this.target = t3.target.clone(), this.shadow = t3.shadow.clone(), this;
    }
  }
  Bc.prototype.isDirectionalLight = true;
  class Uc extends Tc {
    constructor(t3, e3) {
      super(t3, e3), this.type = "AmbientLight";
    }
  }
  Uc.prototype.isAmbientLight = true;
  class kc extends Tc {
    constructor(t3, e3, n2 = 10, i2 = 10) {
      super(t3, e3), this.type = "RectAreaLight", this.width = n2, this.height = i2;
    }
    copy(t3) {
      return super.copy(t3), this.width = t3.width, this.height = t3.height, this;
    }
    toJSON(t3) {
      const e3 = super.toJSON(t3);
      return e3.object.width = this.width, e3.object.height = this.height, e3;
    }
  }
  kc.prototype.isRectAreaLight = true;
  class Gc {
    constructor() {
      this.coefficients = [];
      for (let t3 = 0; t3 < 9; t3++)
        this.coefficients.push(new pi());
    }
    set(t3) {
      for (let e3 = 0; e3 < 9; e3++)
        this.coefficients[e3].copy(t3[e3]);
      return this;
    }
    zero() {
      for (let t3 = 0; t3 < 9; t3++)
        this.coefficients[t3].set(0, 0, 0);
      return this;
    }
    getAt(t3, e3) {
      const n2 = t3.x, i2 = t3.y, r3 = t3.z, o3 = this.coefficients;
      return e3.copy(o3[0]).multiplyScalar(0.282095), e3.addScaledVector(o3[1], 0.488603 * i2), e3.addScaledVector(o3[2], 0.488603 * r3), e3.addScaledVector(o3[3], 0.488603 * n2), e3.addScaledVector(o3[4], n2 * i2 * 1.092548), e3.addScaledVector(o3[5], i2 * r3 * 1.092548), e3.addScaledVector(o3[6], 0.315392 * (3 * r3 * r3 - 1)), e3.addScaledVector(o3[7], n2 * r3 * 1.092548), e3.addScaledVector(o3[8], 0.546274 * (n2 * n2 - i2 * i2)), e3;
    }
    getIrradianceAt(t3, e3) {
      const n2 = t3.x, i2 = t3.y, r3 = t3.z, o3 = this.coefficients;
      return e3.copy(o3[0]).multiplyScalar(0.886227), e3.addScaledVector(o3[1], 1.023328 * i2), e3.addScaledVector(o3[2], 1.023328 * r3), e3.addScaledVector(o3[3], 1.023328 * n2), e3.addScaledVector(o3[4], 0.858086 * n2 * i2), e3.addScaledVector(o3[5], 0.858086 * i2 * r3), e3.addScaledVector(o3[6], 0.743125 * r3 * r3 - 0.247708), e3.addScaledVector(o3[7], 0.858086 * n2 * r3), e3.addScaledVector(o3[8], 0.429043 * (n2 * n2 - i2 * i2)), e3;
    }
    add(t3) {
      for (let e3 = 0; e3 < 9; e3++)
        this.coefficients[e3].add(t3.coefficients[e3]);
      return this;
    }
    addScaledSH(t3, e3) {
      for (let n2 = 0; n2 < 9; n2++)
        this.coefficients[n2].addScaledVector(t3.coefficients[n2], e3);
      return this;
    }
    scale(t3) {
      for (let e3 = 0; e3 < 9; e3++)
        this.coefficients[e3].multiplyScalar(t3);
      return this;
    }
    lerp(t3, e3) {
      for (let n2 = 0; n2 < 9; n2++)
        this.coefficients[n2].lerp(t3.coefficients[n2], e3);
      return this;
    }
    equals(t3) {
      for (let e3 = 0; e3 < 9; e3++)
        if (!this.coefficients[e3].equals(t3.coefficients[e3]))
          return false;
      return true;
    }
    copy(t3) {
      return this.set(t3.coefficients);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    fromArray(t3, e3 = 0) {
      const n2 = this.coefficients;
      for (let i2 = 0; i2 < 9; i2++)
        n2[i2].fromArray(t3, e3 + 3 * i2);
      return this;
    }
    toArray(t3 = [], e3 = 0) {
      const n2 = this.coefficients;
      for (let i2 = 0; i2 < 9; i2++)
        n2[i2].toArray(t3, e3 + 3 * i2);
      return t3;
    }
    static getBasisAt(t3, e3) {
      const n2 = t3.x, i2 = t3.y, r3 = t3.z;
      e3[0] = 0.282095, e3[1] = 0.488603 * i2, e3[2] = 0.488603 * r3, e3[3] = 0.488603 * n2, e3[4] = 1.092548 * n2 * i2, e3[5] = 1.092548 * i2 * r3, e3[6] = 0.315392 * (3 * r3 * r3 - 1), e3[7] = 1.092548 * n2 * r3, e3[8] = 0.546274 * (n2 * n2 - i2 * i2);
    }
  }
  Gc.prototype.isSphericalHarmonics3 = true;
  class Hc extends Tc {
    constructor(t3 = new Gc(), e3 = 1) {
      super(void 0, e3), this.sh = t3;
    }
    copy(t3) {
      return super.copy(t3), this.sh.copy(t3.sh), this;
    }
    fromJSON(t3) {
      return this.intensity = t3.intensity, this.sh.fromArray(t3.sh), this;
    }
    toJSON(t3) {
      const e3 = super.toJSON(t3);
      return e3.object.sh = this.sh.toArray(), e3;
    }
  }
  Hc.prototype.isLightProbe = true;
  class zc extends hc {
    constructor(t3) {
      super(t3), this.textures = {};
    }
    load(t3, e3, n2, i2) {
      const r3 = this, o3 = new dc(r3.manager);
      o3.setPath(r3.path), o3.setRequestHeader(r3.requestHeader), o3.setWithCredentials(r3.withCredentials), o3.load(t3, function(n3) {
        try {
          e3(r3.parse(JSON.parse(n3)));
        } catch (e4) {
          i2 ? i2(e4) : console.error(e4), r3.manager.itemError(t3);
        }
      }, n2, i2);
    }
    parse(t3) {
      const e3 = this.textures;
      function n2(t4) {
        return e3[t4] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", t4), e3[t4];
      }
      const i2 = new Wh[t3.type]();
      if (t3.uuid !== void 0 && (i2.uuid = t3.uuid), t3.name !== void 0 && (i2.name = t3.name), t3.color !== void 0 && i2.color !== void 0 && i2.color.setHex(t3.color), t3.roughness !== void 0 && (i2.roughness = t3.roughness), t3.metalness !== void 0 && (i2.metalness = t3.metalness), t3.sheen !== void 0 && (i2.sheen = new Dr().setHex(t3.sheen)), t3.emissive !== void 0 && i2.emissive !== void 0 && i2.emissive.setHex(t3.emissive), t3.specular !== void 0 && i2.specular !== void 0 && i2.specular.setHex(t3.specular), t3.shininess !== void 0 && (i2.shininess = t3.shininess), t3.clearcoat !== void 0 && (i2.clearcoat = t3.clearcoat), t3.clearcoatRoughness !== void 0 && (i2.clearcoatRoughness = t3.clearcoatRoughness), t3.transmission !== void 0 && (i2.transmission = t3.transmission), t3.thickness !== void 0 && (i2.thickness = t3.thickness), t3.attenuationDistance !== void 0 && (i2.attenuationDistance = t3.attenuationDistance), t3.attenuationColor !== void 0 && i2.attenuationColor !== void 0 && i2.attenuationColor.setHex(t3.attenuationColor), t3.fog !== void 0 && (i2.fog = t3.fog), t3.flatShading !== void 0 && (i2.flatShading = t3.flatShading), t3.blending !== void 0 && (i2.blending = t3.blending), t3.combine !== void 0 && (i2.combine = t3.combine), t3.side !== void 0 && (i2.side = t3.side), t3.shadowSide !== void 0 && (i2.shadowSide = t3.shadowSide), t3.opacity !== void 0 && (i2.opacity = t3.opacity), t3.transparent !== void 0 && (i2.transparent = t3.transparent), t3.alphaTest !== void 0 && (i2.alphaTest = t3.alphaTest), t3.depthTest !== void 0 && (i2.depthTest = t3.depthTest), t3.depthWrite !== void 0 && (i2.depthWrite = t3.depthWrite), t3.colorWrite !== void 0 && (i2.colorWrite = t3.colorWrite), t3.stencilWrite !== void 0 && (i2.stencilWrite = t3.stencilWrite), t3.stencilWriteMask !== void 0 && (i2.stencilWriteMask = t3.stencilWriteMask), t3.stencilFunc !== void 0 && (i2.stencilFunc = t3.stencilFunc), t3.stencilRef !== void 0 && (i2.stencilRef = t3.stencilRef), t3.stencilFuncMask !== void 0 && (i2.stencilFuncMask = t3.stencilFuncMask), t3.stencilFail !== void 0 && (i2.stencilFail = t3.stencilFail), t3.stencilZFail !== void 0 && (i2.stencilZFail = t3.stencilZFail), t3.stencilZPass !== void 0 && (i2.stencilZPass = t3.stencilZPass), t3.wireframe !== void 0 && (i2.wireframe = t3.wireframe), t3.wireframeLinewidth !== void 0 && (i2.wireframeLinewidth = t3.wireframeLinewidth), t3.wireframeLinecap !== void 0 && (i2.wireframeLinecap = t3.wireframeLinecap), t3.wireframeLinejoin !== void 0 && (i2.wireframeLinejoin = t3.wireframeLinejoin), t3.rotation !== void 0 && (i2.rotation = t3.rotation), t3.linewidth !== 1 && (i2.linewidth = t3.linewidth), t3.dashSize !== void 0 && (i2.dashSize = t3.dashSize), t3.gapSize !== void 0 && (i2.gapSize = t3.gapSize), t3.scale !== void 0 && (i2.scale = t3.scale), t3.polygonOffset !== void 0 && (i2.polygonOffset = t3.polygonOffset), t3.polygonOffsetFactor !== void 0 && (i2.polygonOffsetFactor = t3.polygonOffsetFactor), t3.polygonOffsetUnits !== void 0 && (i2.polygonOffsetUnits = t3.polygonOffsetUnits), t3.morphTargets !== void 0 && (i2.morphTargets = t3.morphTargets), t3.morphNormals !== void 0 && (i2.morphNormals = t3.morphNormals), t3.dithering !== void 0 && (i2.dithering = t3.dithering), t3.alphaToCoverage !== void 0 && (i2.alphaToCoverage = t3.alphaToCoverage), t3.premultipliedAlpha !== void 0 && (i2.premultipliedAlpha = t3.premultipliedAlpha), t3.vertexTangents !== void 0 && (i2.vertexTangents = t3.vertexTangents), t3.visible !== void 0 && (i2.visible = t3.visible), t3.toneMapped !== void 0 && (i2.toneMapped = t3.toneMapped), t3.userData !== void 0 && (i2.userData = t3.userData), t3.vertexColors !== void 0 && (typeof t3.vertexColors == "number" ? i2.vertexColors = t3.vertexColors > 0 : i2.vertexColors = t3.vertexColors), t3.uniforms !== void 0)
        for (const e4 in t3.uniforms) {
          const r3 = t3.uniforms[e4];
          switch (i2.uniforms[e4] = {}, r3.type) {
            case "t":
              i2.uniforms[e4].value = n2(r3.value);
              break;
            case "c":
              i2.uniforms[e4].value = new Dr().setHex(r3.value);
              break;
            case "v2":
              i2.uniforms[e4].value = new ei().fromArray(r3.value);
              break;
            case "v3":
              i2.uniforms[e4].value = new pi().fromArray(r3.value);
              break;
            case "v4":
              i2.uniforms[e4].value = new li().fromArray(r3.value);
              break;
            case "m3":
              i2.uniforms[e4].value = new ni().fromArray(r3.value);
              break;
            case "m4":
              i2.uniforms[e4].value = new Vi().fromArray(r3.value);
              break;
            default:
              i2.uniforms[e4].value = r3.value;
          }
        }
      if (t3.defines !== void 0 && (i2.defines = t3.defines), t3.vertexShader !== void 0 && (i2.vertexShader = t3.vertexShader), t3.fragmentShader !== void 0 && (i2.fragmentShader = t3.fragmentShader), t3.extensions !== void 0)
        for (const e4 in t3.extensions)
          i2.extensions[e4] = t3.extensions[e4];
      if (t3.shading !== void 0 && (i2.flatShading = t3.shading === 1), t3.size !== void 0 && (i2.size = t3.size), t3.sizeAttenuation !== void 0 && (i2.sizeAttenuation = t3.sizeAttenuation), t3.map !== void 0 && (i2.map = n2(t3.map)), t3.matcap !== void 0 && (i2.matcap = n2(t3.matcap)), t3.alphaMap !== void 0 && (i2.alphaMap = n2(t3.alphaMap)), t3.bumpMap !== void 0 && (i2.bumpMap = n2(t3.bumpMap)), t3.bumpScale !== void 0 && (i2.bumpScale = t3.bumpScale), t3.normalMap !== void 0 && (i2.normalMap = n2(t3.normalMap)), t3.normalMapType !== void 0 && (i2.normalMapType = t3.normalMapType), t3.normalScale !== void 0) {
        let e4 = t3.normalScale;
        Array.isArray(e4) === false && (e4 = [e4, e4]), i2.normalScale = new ei().fromArray(e4);
      }
      return t3.displacementMap !== void 0 && (i2.displacementMap = n2(t3.displacementMap)), t3.displacementScale !== void 0 && (i2.displacementScale = t3.displacementScale), t3.displacementBias !== void 0 && (i2.displacementBias = t3.displacementBias), t3.roughnessMap !== void 0 && (i2.roughnessMap = n2(t3.roughnessMap)), t3.metalnessMap !== void 0 && (i2.metalnessMap = n2(t3.metalnessMap)), t3.emissiveMap !== void 0 && (i2.emissiveMap = n2(t3.emissiveMap)), t3.emissiveIntensity !== void 0 && (i2.emissiveIntensity = t3.emissiveIntensity), t3.specularMap !== void 0 && (i2.specularMap = n2(t3.specularMap)), t3.envMap !== void 0 && (i2.envMap = n2(t3.envMap)), t3.envMapIntensity !== void 0 && (i2.envMapIntensity = t3.envMapIntensity), t3.reflectivity !== void 0 && (i2.reflectivity = t3.reflectivity), t3.refractionRatio !== void 0 && (i2.refractionRatio = t3.refractionRatio), t3.lightMap !== void 0 && (i2.lightMap = n2(t3.lightMap)), t3.lightMapIntensity !== void 0 && (i2.lightMapIntensity = t3.lightMapIntensity), t3.aoMap !== void 0 && (i2.aoMap = n2(t3.aoMap)), t3.aoMapIntensity !== void 0 && (i2.aoMapIntensity = t3.aoMapIntensity), t3.gradientMap !== void 0 && (i2.gradientMap = n2(t3.gradientMap)), t3.clearcoatMap !== void 0 && (i2.clearcoatMap = n2(t3.clearcoatMap)), t3.clearcoatRoughnessMap !== void 0 && (i2.clearcoatRoughnessMap = n2(t3.clearcoatRoughnessMap)), t3.clearcoatNormalMap !== void 0 && (i2.clearcoatNormalMap = n2(t3.clearcoatNormalMap)), t3.clearcoatNormalScale !== void 0 && (i2.clearcoatNormalScale = new ei().fromArray(t3.clearcoatNormalScale)), t3.transmissionMap !== void 0 && (i2.transmissionMap = n2(t3.transmissionMap)), t3.thicknessMap !== void 0 && (i2.thicknessMap = n2(t3.thicknessMap)), i2;
    }
    setTextures(t3) {
      return this.textures = t3, this;
    }
  }
  class jc {
    static decodeText(t3) {
      if (typeof TextDecoder != "undefined")
        return new TextDecoder().decode(t3);
      let e3 = "";
      for (let n2 = 0, i2 = t3.length; n2 < i2; n2++)
        e3 += String.fromCharCode(t3[n2]);
      try {
        return decodeURIComponent(escape(e3));
      } catch (t4) {
        return e3;
      }
    }
    static extractUrlBase(t3) {
      const e3 = t3.lastIndexOf("/");
      return e3 === -1 ? "./" : t3.substr(0, e3 + 1);
    }
  }
  class Vc extends so {
    constructor() {
      super(), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
    }
    copy(t3) {
      return super.copy(t3), this.instanceCount = t3.instanceCount, this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    toJSON() {
      const t3 = super.toJSON(this);
      return t3.instanceCount = this.instanceCount, t3.isInstancedBufferGeometry = true, t3;
    }
  }
  Vc.prototype.isInstancedBufferGeometry = true;
  class Wc extends kr {
    constructor(t3, e3, n2, i2 = 1) {
      typeof n2 == "number" && (i2 = n2, n2 = false, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), super(t3, e3, n2), this.meshPerAttribute = i2;
    }
    copy(t3) {
      return super.copy(t3), this.meshPerAttribute = t3.meshPerAttribute, this;
    }
    toJSON() {
      const t3 = super.toJSON();
      return t3.meshPerAttribute = this.meshPerAttribute, t3.isInstancedBufferAttribute = true, t3;
    }
  }
  Wc.prototype.isInstancedBufferAttribute = true;
  class Xc extends hc {
    constructor(t3) {
      super(t3);
    }
    load(t3, e3, n2, i2) {
      const r3 = this, o3 = new dc(r3.manager);
      o3.setPath(r3.path), o3.setRequestHeader(r3.requestHeader), o3.setWithCredentials(r3.withCredentials), o3.load(t3, function(n3) {
        try {
          e3(r3.parse(JSON.parse(n3)));
        } catch (e4) {
          i2 ? i2(e4) : console.error(e4), r3.manager.itemError(t3);
        }
      }, n2, i2);
    }
    parse(t3) {
      const e3 = {}, n2 = {};
      function i2(t4, i3) {
        if (e3[i3] !== void 0)
          return e3[i3];
        const r4 = t4.interleavedBuffers[i3], o4 = function(t5, e4) {
          if (n2[e4] !== void 0)
            return n2[e4];
          const i4 = t5.arrayBuffers[e4], r5 = new Uint32Array(i4).buffer;
          return n2[e4] = r5, r5;
        }(t4, r4.buffer), s4 = Kr(r4.type, o4), a3 = new ul(s4, r4.stride);
        return a3.uuid = r4.uuid, e3[i3] = a3, a3;
      }
      const r3 = t3.isInstancedBufferGeometry ? new Vc() : new so(), o3 = t3.data.index;
      if (o3 !== void 0) {
        const t4 = Kr(o3.type, o3.array);
        r3.setIndex(new kr(t4, 1));
      }
      const s3 = t3.data.attributes;
      for (const e4 in s3) {
        const n3 = s3[e4];
        let o4;
        if (n3.isInterleavedBufferAttribute) {
          const e5 = i2(t3.data, n3.data);
          o4 = new cl(e5, n3.itemSize, n3.offset, n3.normalized);
        } else {
          const t4 = Kr(n3.type, n3.array);
          o4 = new (n3.isInstancedBufferAttribute ? Wc : kr)(t4, n3.itemSize, n3.normalized);
        }
        n3.name !== void 0 && (o4.name = n3.name), n3.usage !== void 0 && o4.setUsage(n3.usage), n3.updateRange !== void 0 && (o4.updateRange.offset = n3.updateRange.offset, o4.updateRange.count = n3.updateRange.count), r3.setAttribute(e4, o4);
      }
      const a2 = t3.data.morphAttributes;
      if (a2)
        for (const e4 in a2) {
          const n3 = a2[e4], o4 = [];
          for (let e5 = 0, r4 = n3.length; e5 < r4; e5++) {
            const r5 = n3[e5];
            let s4;
            if (r5.isInterleavedBufferAttribute) {
              const e6 = i2(t3.data, r5.data);
              s4 = new cl(e6, r5.itemSize, r5.offset, r5.normalized);
            } else {
              const t4 = Kr(r5.type, r5.array);
              s4 = new kr(t4, r5.itemSize, r5.normalized);
            }
            r5.name !== void 0 && (s4.name = r5.name), o4.push(s4);
          }
          r3.morphAttributes[e4] = o4;
        }
      t3.data.morphTargetsRelative && (r3.morphTargetsRelative = true);
      const l2 = t3.data.groups || t3.data.drawcalls || t3.data.offsets;
      if (l2 !== void 0)
        for (let t4 = 0, e4 = l2.length; t4 !== e4; ++t4) {
          const e5 = l2[t4];
          r3.addGroup(e5.start, e5.count, e5.materialIndex);
        }
      const u2 = t3.data.boundingSphere;
      if (u2 !== void 0) {
        const t4 = new pi();
        u2.center !== void 0 && t4.fromArray(u2.center), r3.boundingSphere = new Di(t4, u2.radius);
      }
      return t3.name && (r3.name = t3.name), t3.userData && (r3.userData = t3.userData), r3;
    }
  }
  class qc extends hc {
    constructor(t3) {
      super(t3);
    }
    load(t3, e3, n2, i2) {
      const r3 = this, o3 = this.path === "" ? jc.extractUrlBase(t3) : this.path;
      this.resourcePath = this.resourcePath || o3;
      const s3 = new dc(this.manager);
      s3.setPath(this.path), s3.setRequestHeader(this.requestHeader), s3.setWithCredentials(this.withCredentials), s3.load(t3, function(n3) {
        let o4 = null;
        try {
          o4 = JSON.parse(n3);
        } catch (e4) {
          return i2 !== void 0 && i2(e4), void console.error("THREE:ObjectLoader: Can't parse " + t3 + ".", e4.message);
        }
        const s4 = o4.metadata;
        s4 !== void 0 && s4.type !== void 0 && s4.type.toLowerCase() !== "geometry" ? r3.parse(o4, e3) : console.error("THREE.ObjectLoader: Can't load " + t3);
      }, n2, i2);
    }
    async loadAsync(t3, e3) {
      const n2 = this.path === "" ? jc.extractUrlBase(t3) : this.path;
      this.resourcePath = this.resourcePath || n2;
      const i2 = new dc(this.manager);
      i2.setPath(this.path), i2.setRequestHeader(this.requestHeader), i2.setWithCredentials(this.withCredentials);
      const r3 = await i2.loadAsync(t3, e3), o3 = JSON.parse(r3), s3 = o3.metadata;
      if (s3 === void 0 || s3.type === void 0 || s3.type.toLowerCase() === "geometry")
        throw new Error("THREE.ObjectLoader: Can't load " + t3);
      return await this.parseAsync(o3);
    }
    parse(t3, e3) {
      const n2 = this.parseAnimations(t3.animations), i2 = this.parseShapes(t3.shapes), r3 = this.parseGeometries(t3.geometries, i2), o3 = this.parseImages(t3.images, function() {
        e3 !== void 0 && e3(l2);
      }), s3 = this.parseTextures(t3.textures, o3), a2 = this.parseMaterials(t3.materials, s3), l2 = this.parseObject(t3.object, r3, a2, s3, n2), u2 = this.parseSkeletons(t3.skeletons, l2);
      if (this.bindSkeletons(l2, u2), e3 !== void 0) {
        let t4 = false;
        for (const e4 in o3)
          if (o3[e4] instanceof HTMLImageElement) {
            t4 = true;
            break;
          }
        t4 === false && e3(l2);
      }
      return l2;
    }
    async parseAsync(t3) {
      const e3 = this.parseAnimations(t3.animations), n2 = this.parseShapes(t3.shapes), i2 = this.parseGeometries(t3.geometries, n2), r3 = await this.parseImagesAsync(t3.images), o3 = this.parseTextures(t3.textures, r3), s3 = this.parseMaterials(t3.materials, o3), a2 = this.parseObject(t3.object, i2, s3, o3, e3), l2 = this.parseSkeletons(t3.skeletons, a2);
      return this.bindSkeletons(a2, l2), a2;
    }
    parseShapes(t3) {
      const e3 = {};
      if (t3 !== void 0)
        for (let n2 = 0, i2 = t3.length; n2 < i2; n2++) {
          const i3 = new bc().fromJSON(t3[n2]);
          e3[i3.uuid] = i3;
        }
      return e3;
    }
    parseSkeletons(t3, e3) {
      const n2 = {}, i2 = {};
      if (e3.traverse(function(t4) {
        t4.isBone && (i2[t4.uuid] = t4);
      }), t3 !== void 0)
        for (let e4 = 0, r3 = t3.length; e4 < r3; e4++) {
          const r4 = new Hl().fromJSON(t3[e4], i2);
          n2[r4.uuid] = r4;
        }
      return n2;
    }
    parseGeometries(t3, e3) {
      const n2 = {};
      if (t3 !== void 0) {
        const i2 = new Xc();
        for (let r3 = 0, o3 = t3.length; r3 < o3; r3++) {
          let o4;
          const s3 = t3[r3];
          switch (s3.type) {
            case "BufferGeometry":
            case "InstancedBufferGeometry":
              o4 = i2.parse(s3);
              break;
            case "Geometry":
              console.error("THREE.ObjectLoader: The legacy Geometry type is no longer supported.");
              break;
            default:
              s3.type in Nh ? o4 = Nh[s3.type].fromJSON(s3, e3) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${s3.type}"`);
          }
          o4.uuid = s3.uuid, s3.name !== void 0 && (o4.name = s3.name), o4.isBufferGeometry === true && s3.userData !== void 0 && (o4.userData = s3.userData), n2[s3.uuid] = o4;
        }
      }
      return n2;
    }
    parseMaterials(t3, e3) {
      const n2 = {}, i2 = {};
      if (t3 !== void 0) {
        const r3 = new zc();
        r3.setTextures(e3);
        for (let e4 = 0, o3 = t3.length; e4 < o3; e4++) {
          const o4 = t3[e4];
          if (o4.type === "MultiMaterial") {
            const t4 = [];
            for (let e5 = 0; e5 < o4.materials.length; e5++) {
              const i3 = o4.materials[e5];
              n2[i3.uuid] === void 0 && (n2[i3.uuid] = r3.parse(i3)), t4.push(n2[i3.uuid]);
            }
            i2[o4.uuid] = t4;
          } else
            n2[o4.uuid] === void 0 && (n2[o4.uuid] = r3.parse(o4)), i2[o4.uuid] = n2[o4.uuid];
        }
      }
      return i2;
    }
    parseAnimations(t3) {
      const e3 = {};
      if (t3 !== void 0)
        for (let n2 = 0; n2 < t3.length; n2++) {
          const i2 = t3[n2], r3 = oc.parse(i2);
          e3[r3.uuid] = r3;
        }
      return e3;
    }
    parseImages(t3, e3) {
      const n2 = this, i2 = {};
      let r3;
      function o3(t4) {
        if (typeof t4 == "string") {
          const e4 = t4;
          return function(t5) {
            return n2.manager.itemStart(t5), r3.load(t5, function() {
              n2.manager.itemEnd(t5);
            }, void 0, function() {
              n2.manager.itemError(t5), n2.manager.itemEnd(t5);
            });
          }(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(e4) ? e4 : n2.resourcePath + e4);
        }
        return t4.data ? { data: Kr(t4.type, t4.data), width: t4.width, height: t4.height } : null;
      }
      if (t3 !== void 0 && t3.length > 0) {
        const n3 = new lc(e3);
        r3 = new mc(n3), r3.setCrossOrigin(this.crossOrigin);
        for (let e4 = 0, n4 = t3.length; e4 < n4; e4++) {
          const n5 = t3[e4], r4 = n5.url;
          if (Array.isArray(r4)) {
            i2[n5.uuid] = [];
            for (let t4 = 0, e5 = r4.length; t4 < e5; t4++) {
              const e6 = o3(r4[t4]);
              e6 !== null && (e6 instanceof HTMLImageElement ? i2[n5.uuid].push(e6) : i2[n5.uuid].push(new Ul(e6.data, e6.width, e6.height)));
            }
          } else {
            const t4 = o3(n5.url);
            t4 !== null && (i2[n5.uuid] = t4);
          }
        }
      }
      return i2;
    }
    async parseImagesAsync(t3) {
      const e3 = this, n2 = {};
      let i2;
      async function r3(t4) {
        if (typeof t4 == "string") {
          const n3 = t4, r4 = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(n3) ? n3 : e3.resourcePath + n3;
          return await i2.loadAsync(r4);
        }
        return t4.data ? { data: Kr(t4.type, t4.data), width: t4.width, height: t4.height } : null;
      }
      if (t3 !== void 0 && t3.length > 0) {
        i2 = new mc(this.manager), i2.setCrossOrigin(this.crossOrigin);
        for (let e4 = 0, i3 = t3.length; e4 < i3; e4++) {
          const i4 = t3[e4], o3 = i4.url;
          if (Array.isArray(o3)) {
            n2[i4.uuid] = [];
            for (let t4 = 0, e5 = o3.length; t4 < e5; t4++) {
              const e6 = o3[t4], s3 = await r3(e6);
              s3 !== null && (s3 instanceof HTMLImageElement ? n2[i4.uuid].push(s3) : n2[i4.uuid].push(new Ul(s3.data, s3.width, s3.height)));
            }
          } else {
            const t4 = await r3(i4.url);
            t4 !== null && (n2[i4.uuid] = t4);
          }
        }
      }
      return n2;
    }
    parseTextures(t3, e3) {
      function n2(t4, e4) {
        return typeof t4 == "number" ? t4 : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", t4), e4[t4]);
      }
      const i2 = {};
      if (t3 !== void 0)
        for (let r3 = 0, o3 = t3.length; r3 < o3; r3++) {
          const o4 = t3[r3];
          let s3;
          o4.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', o4.uuid), e3[o4.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", o4.image);
          const a2 = e3[o4.image];
          Array.isArray(a2) ? (s3 = new Do(a2), a2.length === 6 && (s3.needsUpdate = true)) : (s3 = a2 && a2.data ? new Ul(a2.data, a2.width, a2.height) : new si(a2), a2 && (s3.needsUpdate = true)), s3.uuid = o4.uuid, o4.name !== void 0 && (s3.name = o4.name), o4.mapping !== void 0 && (s3.mapping = n2(o4.mapping, Yc)), o4.offset !== void 0 && s3.offset.fromArray(o4.offset), o4.repeat !== void 0 && s3.repeat.fromArray(o4.repeat), o4.center !== void 0 && s3.center.fromArray(o4.center), o4.rotation !== void 0 && (s3.rotation = o4.rotation), o4.wrap !== void 0 && (s3.wrapS = n2(o4.wrap[0], Zc), s3.wrapT = n2(o4.wrap[1], Zc)), o4.format !== void 0 && (s3.format = o4.format), o4.type !== void 0 && (s3.type = o4.type), o4.encoding !== void 0 && (s3.encoding = o4.encoding), o4.minFilter !== void 0 && (s3.minFilter = n2(o4.minFilter, Jc)), o4.magFilter !== void 0 && (s3.magFilter = n2(o4.magFilter, Jc)), o4.anisotropy !== void 0 && (s3.anisotropy = o4.anisotropy), o4.flipY !== void 0 && (s3.flipY = o4.flipY), o4.premultiplyAlpha !== void 0 && (s3.premultiplyAlpha = o4.premultiplyAlpha), o4.unpackAlignment !== void 0 && (s3.unpackAlignment = o4.unpackAlignment), i2[o4.uuid] = s3;
        }
      return i2;
    }
    parseObject(t3, e3, n2, i2, r3) {
      let o3, s3, a2;
      function l2(t4) {
        return e3[t4] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", t4), e3[t4];
      }
      function u2(t4) {
        if (t4 !== void 0) {
          if (Array.isArray(t4)) {
            const e4 = [];
            for (let i3 = 0, r4 = t4.length; i3 < r4; i3++) {
              const r5 = t4[i3];
              n2[r5] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", r5), e4.push(n2[r5]);
            }
            return e4;
          }
          return n2[t4] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", t4), n2[t4];
        }
      }
      function h2(t4) {
        return i2[t4] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", t4), i2[t4];
      }
      switch (t3.type) {
        case "Scene":
          o3 = new ll(), t3.background !== void 0 && (Number.isInteger(t3.background) ? o3.background = new Dr(t3.background) : o3.background = h2(t3.background)), t3.environment !== void 0 && (o3.environment = h2(t3.environment)), t3.fog !== void 0 && (t3.fog.type === "Fog" ? o3.fog = new al(t3.fog.color, t3.fog.near, t3.fog.far) : t3.fog.type === "FogExp2" && (o3.fog = new sl(t3.fog.color, t3.fog.density)));
          break;
        case "PerspectiveCamera":
          o3 = new Lo(t3.fov, t3.aspect, t3.near, t3.far), t3.focus !== void 0 && (o3.focus = t3.focus), t3.zoom !== void 0 && (o3.zoom = t3.zoom), t3.filmGauge !== void 0 && (o3.filmGauge = t3.filmGauge), t3.filmOffset !== void 0 && (o3.filmOffset = t3.filmOffset), t3.view !== void 0 && (o3.view = Object.assign({}, t3.view));
          break;
        case "OrthographicCamera":
          o3 = new Dc(t3.left, t3.right, t3.top, t3.bottom, t3.near, t3.far), t3.zoom !== void 0 && (o3.zoom = t3.zoom), t3.view !== void 0 && (o3.view = Object.assign({}, t3.view));
          break;
        case "AmbientLight":
          o3 = new Uc(t3.color, t3.intensity);
          break;
        case "DirectionalLight":
          o3 = new Bc(t3.color, t3.intensity);
          break;
        case "PointLight":
          o3 = new Nc(t3.color, t3.intensity, t3.distance, t3.decay);
          break;
        case "RectAreaLight":
          o3 = new kc(t3.color, t3.intensity, t3.width, t3.height);
          break;
        case "SpotLight":
          o3 = new Pc(t3.color, t3.intensity, t3.distance, t3.angle, t3.penumbra, t3.decay);
          break;
        case "HemisphereLight":
          o3 = new wc(t3.color, t3.groundColor, t3.intensity);
          break;
        case "LightProbe":
          o3 = new Hc().fromJSON(t3);
          break;
        case "SkinnedMesh":
          s3 = l2(t3.geometry), a2 = u2(t3.material), o3 = new Fl(s3, a2), t3.bindMode !== void 0 && (o3.bindMode = t3.bindMode), t3.bindMatrix !== void 0 && o3.bindMatrix.fromArray(t3.bindMatrix), t3.skeleton !== void 0 && (o3.skeleton = t3.skeleton);
          break;
        case "Mesh":
          s3 = l2(t3.geometry), a2 = u2(t3.material), o3 = new Eo(s3, a2);
          break;
        case "InstancedMesh":
          s3 = l2(t3.geometry), a2 = u2(t3.material);
          const e4 = t3.count, n3 = t3.instanceMatrix, i3 = t3.instanceColor;
          o3 = new Xl(s3, a2, e4), o3.instanceMatrix = new kr(new Float32Array(n3.array), 16), i3 !== void 0 && (o3.instanceColor = new kr(new Float32Array(i3.array), i3.itemSize));
          break;
        case "LOD":
          o3 = new Cl();
          break;
        case "Line":
          o3 = new Ql(l2(t3.geometry), u2(t3.material));
          break;
        case "LineLoop":
          o3 = new iu(l2(t3.geometry), u2(t3.material));
          break;
        case "LineSegments":
          o3 = new nu(l2(t3.geometry), u2(t3.material));
          break;
        case "PointCloud":
        case "Points":
          o3 = new uu(l2(t3.geometry), u2(t3.material));
          break;
        case "Sprite":
          o3 = new Ml(u2(t3.material));
          break;
        case "Group":
          o3 = new Qa();
          break;
        case "Bone":
          o3 = new Bl();
          break;
        default:
          o3 = new mr();
      }
      if (o3.uuid = t3.uuid, t3.name !== void 0 && (o3.name = t3.name), t3.matrix !== void 0 ? (o3.matrix.fromArray(t3.matrix), t3.matrixAutoUpdate !== void 0 && (o3.matrixAutoUpdate = t3.matrixAutoUpdate), o3.matrixAutoUpdate && o3.matrix.decompose(o3.position, o3.quaternion, o3.scale)) : (t3.position !== void 0 && o3.position.fromArray(t3.position), t3.rotation !== void 0 && o3.rotation.fromArray(t3.rotation), t3.quaternion !== void 0 && o3.quaternion.fromArray(t3.quaternion), t3.scale !== void 0 && o3.scale.fromArray(t3.scale)), t3.castShadow !== void 0 && (o3.castShadow = t3.castShadow), t3.receiveShadow !== void 0 && (o3.receiveShadow = t3.receiveShadow), t3.shadow && (t3.shadow.bias !== void 0 && (o3.shadow.bias = t3.shadow.bias), t3.shadow.normalBias !== void 0 && (o3.shadow.normalBias = t3.shadow.normalBias), t3.shadow.radius !== void 0 && (o3.shadow.radius = t3.shadow.radius), t3.shadow.mapSize !== void 0 && o3.shadow.mapSize.fromArray(t3.shadow.mapSize), t3.shadow.camera !== void 0 && (o3.shadow.camera = this.parseObject(t3.shadow.camera))), t3.visible !== void 0 && (o3.visible = t3.visible), t3.frustumCulled !== void 0 && (o3.frustumCulled = t3.frustumCulled), t3.renderOrder !== void 0 && (o3.renderOrder = t3.renderOrder), t3.userData !== void 0 && (o3.userData = t3.userData), t3.layers !== void 0 && (o3.layers.mask = t3.layers), t3.children !== void 0) {
        const s4 = t3.children;
        for (let t4 = 0; t4 < s4.length; t4++)
          o3.add(this.parseObject(s4[t4], e3, n2, i2, r3));
      }
      if (t3.animations !== void 0) {
        const e4 = t3.animations;
        for (let t4 = 0; t4 < e4.length; t4++) {
          const n3 = e4[t4];
          o3.animations.push(r3[n3]);
        }
      }
      if (t3.type === "LOD") {
        t3.autoUpdate !== void 0 && (o3.autoUpdate = t3.autoUpdate);
        const e4 = t3.levels;
        for (let t4 = 0; t4 < e4.length; t4++) {
          const n3 = e4[t4], i3 = o3.getObjectByProperty("uuid", n3.object);
          i3 !== void 0 && o3.addLevel(i3, n3.distance);
        }
      }
      return o3;
    }
    bindSkeletons(t3, e3) {
      Object.keys(e3).length !== 0 && t3.traverse(function(t4) {
        if (t4.isSkinnedMesh === true && t4.skeleton !== void 0) {
          const n2 = e3[t4.skeleton];
          n2 === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", t4.skeleton) : t4.bind(n2, t4.bindMatrix);
        }
      });
    }
    setTexturePath(t3) {
      return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(t3);
    }
  }
  const Yc = { UVMapping: ht, CubeReflectionMapping: ct, CubeRefractionMapping: dt, EquirectangularReflectionMapping: pt, EquirectangularRefractionMapping: ft, CubeUVReflectionMapping: mt, CubeUVRefractionMapping: gt }, Zc = { RepeatWrapping: vt, ClampToEdgeWrapping: _t, MirroredRepeatWrapping: yt }, Jc = { NearestFilter: xt, NearestMipmapNearestFilter: bt, NearestMipmapLinearFilter: wt, LinearFilter: Et, LinearMipmapNearestFilter: Mt, LinearMipmapLinearFilter: Rt };
  class $c extends hc {
    constructor(t3) {
      super(t3), typeof createImageBitmap == "undefined" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch == "undefined" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" };
    }
    setOptions(t3) {
      return this.options = t3, this;
    }
    load(t3, e3, n2, i2) {
      t3 === void 0 && (t3 = ""), this.path !== void 0 && (t3 = this.path + t3), t3 = this.manager.resolveURL(t3);
      const r3 = this, o3 = ac.get(t3);
      if (o3 !== void 0)
        return r3.manager.itemStart(t3), setTimeout(function() {
          e3 && e3(o3), r3.manager.itemEnd(t3);
        }, 0), o3;
      const s3 = {};
      s3.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", s3.headers = this.requestHeader, fetch(t3, s3).then(function(t4) {
        return t4.blob();
      }).then(function(t4) {
        return createImageBitmap(t4, Object.assign(r3.options, { colorSpaceConversion: "none" }));
      }).then(function(n3) {
        ac.add(t3, n3), e3 && e3(n3), r3.manager.itemEnd(t3);
      }).catch(function(e4) {
        i2 && i2(e4), r3.manager.itemError(t3), r3.manager.itemEnd(t3);
      }), r3.manager.itemStart(t3);
    }
  }
  $c.prototype.isImageBitmapLoader = true;
  class Kc {
    constructor() {
      this.type = "ShapePath", this.color = new Dr(), this.subPaths = [], this.currentPath = null;
    }
    moveTo(t3, e3) {
      return this.currentPath = new xc(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(t3, e3), this;
    }
    lineTo(t3, e3) {
      return this.currentPath.lineTo(t3, e3), this;
    }
    quadraticCurveTo(t3, e3, n2, i2) {
      return this.currentPath.quadraticCurveTo(t3, e3, n2, i2), this;
    }
    bezierCurveTo(t3, e3, n2, i2, r3, o3) {
      return this.currentPath.bezierCurveTo(t3, e3, n2, i2, r3, o3), this;
    }
    splineThru(t3) {
      return this.currentPath.splineThru(t3), this;
    }
    toShapes(t3, e3) {
      function n2(t4) {
        const e4 = [];
        for (let n3 = 0, i3 = t4.length; n3 < i3; n3++) {
          const i4 = t4[n3], r4 = new bc();
          r4.curves = i4.curves, e4.push(r4);
        }
        return e4;
      }
      function i2(t4, e4) {
        const n3 = e4.length;
        let i3 = false;
        for (let r4 = n3 - 1, o4 = 0; o4 < n3; r4 = o4++) {
          let n4 = e4[r4], s4 = e4[o4], a3 = s4.x - n4.x, l3 = s4.y - n4.y;
          if (Math.abs(l3) > Number.EPSILON) {
            if (l3 < 0 && (n4 = e4[o4], a3 = -a3, s4 = e4[r4], l3 = -l3), t4.y < n4.y || t4.y > s4.y)
              continue;
            if (t4.y === n4.y) {
              if (t4.x === n4.x)
                return true;
            } else {
              const e5 = l3 * (t4.x - n4.x) - a3 * (t4.y - n4.y);
              if (e5 === 0)
                return true;
              if (e5 < 0)
                continue;
              i3 = !i3;
            }
          } else {
            if (t4.y !== n4.y)
              continue;
            if (s4.x <= t4.x && t4.x <= n4.x || n4.x <= t4.x && t4.x <= s4.x)
              return true;
          }
        }
        return i3;
      }
      const r3 = gh.isClockWise, o3 = this.subPaths;
      if (o3.length === 0)
        return [];
      if (e3 === true)
        return n2(o3);
      let s3, a2, l2;
      const u2 = [];
      if (o3.length === 1)
        return a2 = o3[0], l2 = new bc(), l2.curves = a2.curves, u2.push(l2), u2;
      let h2 = !r3(o3[0].getPoints());
      h2 = t3 ? !h2 : h2;
      const c2 = [], d2 = [];
      let p2, f2, m2 = [], g2 = 0;
      d2[g2] = void 0, m2[g2] = [];
      for (let e4 = 0, n3 = o3.length; e4 < n3; e4++)
        a2 = o3[e4], p2 = a2.getPoints(), s3 = r3(p2), s3 = t3 ? !s3 : s3, s3 ? (!h2 && d2[g2] && g2++, d2[g2] = { s: new bc(), p: p2 }, d2[g2].s.curves = a2.curves, h2 && g2++, m2[g2] = []) : m2[g2].push({ h: a2, p: p2[0] });
      if (!d2[0])
        return n2(o3);
      if (d2.length > 1) {
        let t4 = false;
        const e4 = [];
        for (let t5 = 0, e5 = d2.length; t5 < e5; t5++)
          c2[t5] = [];
        for (let n3 = 0, r4 = d2.length; n3 < r4; n3++) {
          const r5 = m2[n3];
          for (let o4 = 0; o4 < r5.length; o4++) {
            const s4 = r5[o4];
            let a3 = true;
            for (let r6 = 0; r6 < d2.length; r6++)
              i2(s4.p, d2[r6].p) && (n3 !== r6 && e4.push({ froms: n3, tos: r6, hole: o4 }), a3 ? (a3 = false, c2[r6].push(s4)) : t4 = true);
            a3 && c2[n3].push(s4);
          }
        }
        e4.length > 0 && (t4 || (m2 = c2));
      }
      for (let t4 = 0, e4 = d2.length; t4 < e4; t4++) {
        l2 = d2[t4].s, u2.push(l2), f2 = m2[t4];
        for (let t5 = 0, e5 = f2.length; t5 < e5; t5++)
          l2.holes.push(f2[t5].h);
      }
      return u2;
    }
  }
  class Qc {
    constructor(t3) {
      this.type = "Font", this.data = t3;
    }
    generateShapes(t3, e3 = 100) {
      const n2 = [], i2 = function(t4, e4, n3) {
        const i3 = Array.from(t4), r3 = e4 / n3.resolution, o3 = (n3.boundingBox.yMax - n3.boundingBox.yMin + n3.underlineThickness) * r3, s3 = [];
        let a2 = 0, l2 = 0;
        for (let t5 = 0; t5 < i3.length; t5++) {
          const e5 = i3[t5];
          if (e5 === "\n")
            a2 = 0, l2 -= o3;
          else {
            const t6 = td(e5, r3, a2, l2, n3);
            a2 += t6.offsetX, s3.push(t6.path);
          }
        }
        return s3;
      }(t3, e3, this.data);
      for (let t4 = 0, e4 = i2.length; t4 < e4; t4++)
        Array.prototype.push.apply(n2, i2[t4].toShapes());
      return n2;
    }
  }
  function td(t3, e3, n2, i2, r3) {
    const o3 = r3.glyphs[t3] || r3.glyphs["?"];
    if (!o3)
      return void console.error('THREE.Font: character "' + t3 + '" does not exists in font family ' + r3.familyName + ".");
    const s3 = new Kc();
    let a2, l2, u2, h2, c2, d2, p2, f2;
    if (o3.o) {
      const t4 = o3._cachedOutline || (o3._cachedOutline = o3.o.split(" "));
      for (let r4 = 0, o4 = t4.length; r4 < o4; ) {
        switch (t4[r4++]) {
          case "m":
            a2 = t4[r4++] * e3 + n2, l2 = t4[r4++] * e3 + i2, s3.moveTo(a2, l2);
            break;
          case "l":
            a2 = t4[r4++] * e3 + n2, l2 = t4[r4++] * e3 + i2, s3.lineTo(a2, l2);
            break;
          case "q":
            u2 = t4[r4++] * e3 + n2, h2 = t4[r4++] * e3 + i2, c2 = t4[r4++] * e3 + n2, d2 = t4[r4++] * e3 + i2, s3.quadraticCurveTo(c2, d2, u2, h2);
            break;
          case "b":
            u2 = t4[r4++] * e3 + n2, h2 = t4[r4++] * e3 + i2, c2 = t4[r4++] * e3 + n2, d2 = t4[r4++] * e3 + i2, p2 = t4[r4++] * e3 + n2, f2 = t4[r4++] * e3 + i2, s3.bezierCurveTo(c2, d2, p2, f2, u2, h2);
        }
      }
    }
    return { offsetX: o3.ha * e3, path: s3 };
  }
  Qc.prototype.isFont = true;
  class ed extends hc {
    constructor(t3) {
      super(t3);
    }
    load(t3, e3, n2, i2) {
      const r3 = this, o3 = new dc(this.manager);
      o3.setPath(this.path), o3.setRequestHeader(this.requestHeader), o3.setWithCredentials(r3.withCredentials), o3.load(t3, function(t4) {
        let n3;
        try {
          n3 = JSON.parse(t4);
        } catch (e4) {
          console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), n3 = JSON.parse(t4.substring(65, t4.length - 2));
        }
        const i3 = r3.parse(n3);
        e3 && e3(i3);
      }, n2, i2);
    }
    parse(t3) {
      return new Qc(t3);
    }
  }
  let nd;
  const id = { getContext: function() {
    return nd === void 0 && (nd = new (window.AudioContext || window.webkitAudioContext)()), nd;
  }, setContext: function(t3) {
    nd = t3;
  } };
  class rd extends hc {
    constructor(t3) {
      super(t3);
    }
    load(t3, e3, n2, i2) {
      const r3 = this, o3 = new dc(this.manager);
      o3.setResponseType("arraybuffer"), o3.setPath(this.path), o3.setRequestHeader(this.requestHeader), o3.setWithCredentials(this.withCredentials), o3.load(t3, function(n3) {
        try {
          const t4 = n3.slice(0);
          id.getContext().decodeAudioData(t4, function(t5) {
            e3(t5);
          });
        } catch (e4) {
          i2 ? i2(e4) : console.error(e4), r3.manager.itemError(t3);
        }
      }, n2, i2);
    }
  }
  class od extends Hc {
    constructor(t3, e3, n2 = 1) {
      super(void 0, n2);
      const i2 = new Dr().set(t3), r3 = new Dr().set(e3), o3 = new pi(i2.r, i2.g, i2.b), s3 = new pi(r3.r, r3.g, r3.b), a2 = Math.sqrt(Math.PI), l2 = a2 * Math.sqrt(0.75);
      this.sh.coefficients[0].copy(o3).add(s3).multiplyScalar(a2), this.sh.coefficients[1].copy(o3).sub(s3).multiplyScalar(l2);
    }
  }
  od.prototype.isHemisphereLightProbe = true;
  class sd extends Hc {
    constructor(t3, e3 = 1) {
      super(void 0, e3);
      const n2 = new Dr().set(t3);
      this.sh.coefficients[0].set(n2.r, n2.g, n2.b).multiplyScalar(2 * Math.sqrt(Math.PI));
    }
  }
  sd.prototype.isAmbientLightProbe = true;
  const ad = new Vi(), ld = new Vi();
  class ud {
    constructor() {
      this.type = "StereoCamera", this.aspect = 1, this.eyeSep = 0.064, this.cameraL = new Lo(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = false, this.cameraR = new Lo(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = false, this._cache = { focus: null, fov: null, aspect: null, near: null, far: null, zoom: null, eyeSep: null };
    }
    update(t3) {
      const e3 = this._cache;
      if (e3.focus !== t3.focus || e3.fov !== t3.fov || e3.aspect !== t3.aspect * this.aspect || e3.near !== t3.near || e3.far !== t3.far || e3.zoom !== t3.zoom || e3.eyeSep !== this.eyeSep) {
        e3.focus = t3.focus, e3.fov = t3.fov, e3.aspect = t3.aspect * this.aspect, e3.near = t3.near, e3.far = t3.far, e3.zoom = t3.zoom, e3.eyeSep = this.eyeSep;
        const n2 = t3.projectionMatrix.clone(), i2 = e3.eyeSep / 2, r3 = i2 * e3.near / e3.focus, o3 = e3.near * Math.tan(Wn * e3.fov * 0.5) / e3.zoom;
        let s3, a2;
        ld.elements[12] = -i2, ad.elements[12] = i2, s3 = -o3 * e3.aspect + r3, a2 = o3 * e3.aspect + r3, n2.elements[0] = 2 * e3.near / (a2 - s3), n2.elements[8] = (a2 + s3) / (a2 - s3), this.cameraL.projectionMatrix.copy(n2), s3 = -o3 * e3.aspect - r3, a2 = o3 * e3.aspect - r3, n2.elements[0] = 2 * e3.near / (a2 - s3), n2.elements[8] = (a2 + s3) / (a2 - s3), this.cameraR.projectionMatrix.copy(n2);
      }
      this.cameraL.matrixWorld.copy(t3.matrixWorld).multiply(ld), this.cameraR.matrixWorld.copy(t3.matrixWorld).multiply(ad);
    }
  }
  class hd {
    constructor(t3 = true) {
      this.autoStart = t3, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = false;
    }
    start() {
      this.startTime = cd(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = true;
    }
    stop() {
      this.getElapsedTime(), this.running = false, this.autoStart = false;
    }
    getElapsedTime() {
      return this.getDelta(), this.elapsedTime;
    }
    getDelta() {
      let t3 = 0;
      if (this.autoStart && !this.running)
        return this.start(), 0;
      if (this.running) {
        const e3 = cd();
        t3 = (e3 - this.oldTime) / 1e3, this.oldTime = e3, this.elapsedTime += t3;
      }
      return t3;
    }
  }
  function cd() {
    return (typeof performance == "undefined" ? Date : performance).now();
  }
  const dd = new pi(), pd = new di(), fd = new pi(), md = new pi();
  class gd extends mr {
    constructor() {
      super(), this.type = "AudioListener", this.context = id.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new hd();
    }
    getInput() {
      return this.gain;
    }
    removeFilter() {
      return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
    }
    getFilter() {
      return this.filter;
    }
    setFilter(t3) {
      return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = t3, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
    }
    getMasterVolume() {
      return this.gain.gain.value;
    }
    setMasterVolume(t3) {
      return this.gain.gain.setTargetAtTime(t3, this.context.currentTime, 0.01), this;
    }
    updateMatrixWorld(t3) {
      super.updateMatrixWorld(t3);
      const e3 = this.context.listener, n2 = this.up;
      if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(dd, pd, fd), md.set(0, 0, -1).applyQuaternion(pd), e3.positionX) {
        const t4 = this.context.currentTime + this.timeDelta;
        e3.positionX.linearRampToValueAtTime(dd.x, t4), e3.positionY.linearRampToValueAtTime(dd.y, t4), e3.positionZ.linearRampToValueAtTime(dd.z, t4), e3.forwardX.linearRampToValueAtTime(md.x, t4), e3.forwardY.linearRampToValueAtTime(md.y, t4), e3.forwardZ.linearRampToValueAtTime(md.z, t4), e3.upX.linearRampToValueAtTime(n2.x, t4), e3.upY.linearRampToValueAtTime(n2.y, t4), e3.upZ.linearRampToValueAtTime(n2.z, t4);
      } else
        e3.setPosition(dd.x, dd.y, dd.z), e3.setOrientation(md.x, md.y, md.z, n2.x, n2.y, n2.z);
    }
  }
  class vd extends mr {
    constructor(t3) {
      super(), this.type = "Audio", this.listener = t3, this.context = t3.context, this.gain = this.context.createGain(), this.gain.connect(t3.getInput()), this.autoplay = false, this.buffer = null, this.detune = 0, this.loop = false, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = false, this.hasPlaybackControl = true, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = false, this.filters = [];
    }
    getOutput() {
      return this.gain;
    }
    setNodeSource(t3) {
      return this.hasPlaybackControl = false, this.sourceType = "audioNode", this.source = t3, this.connect(), this;
    }
    setMediaElementSource(t3) {
      return this.hasPlaybackControl = false, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t3), this.connect(), this;
    }
    setMediaStreamSource(t3) {
      return this.hasPlaybackControl = false, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(t3), this.connect(), this;
    }
    setBuffer(t3) {
      return this.buffer = t3, this.sourceType = "buffer", this.autoplay && this.play(), this;
    }
    play(t3 = 0) {
      if (this.isPlaying === true)
        return void console.warn("THREE.Audio: Audio is already playing.");
      if (this.hasPlaybackControl === false)
        return void console.warn("THREE.Audio: this Audio has no playback control.");
      this._startedAt = this.context.currentTime + t3;
      const e3 = this.context.createBufferSource();
      return e3.buffer = this.buffer, e3.loop = this.loop, e3.loopStart = this.loopStart, e3.loopEnd = this.loopEnd, e3.onended = this.onEnded.bind(this), e3.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = true, this.source = e3, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
    }
    pause() {
      if (this.hasPlaybackControl !== false)
        return this.isPlaying === true && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === true && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = false), this;
      console.warn("THREE.Audio: this Audio has no playback control.");
    }
    stop() {
      if (this.hasPlaybackControl !== false)
        return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = false, this;
      console.warn("THREE.Audio: this Audio has no playback control.");
    }
    connect() {
      if (this.filters.length > 0) {
        this.source.connect(this.filters[0]);
        for (let t3 = 1, e3 = this.filters.length; t3 < e3; t3++)
          this.filters[t3 - 1].connect(this.filters[t3]);
        this.filters[this.filters.length - 1].connect(this.getOutput());
      } else
        this.source.connect(this.getOutput());
      return this._connected = true, this;
    }
    disconnect() {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (let t3 = 1, e3 = this.filters.length; t3 < e3; t3++)
          this.filters[t3 - 1].disconnect(this.filters[t3]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else
        this.source.disconnect(this.getOutput());
      return this._connected = false, this;
    }
    getFilters() {
      return this.filters;
    }
    setFilters(t3) {
      return t3 || (t3 = []), this._connected === true ? (this.disconnect(), this.filters = t3.slice(), this.connect()) : this.filters = t3.slice(), this;
    }
    setDetune(t3) {
      if (this.detune = t3, this.source.detune !== void 0)
        return this.isPlaying === true && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
    }
    getDetune() {
      return this.detune;
    }
    getFilter() {
      return this.getFilters()[0];
    }
    setFilter(t3) {
      return this.setFilters(t3 ? [t3] : []);
    }
    setPlaybackRate(t3) {
      if (this.hasPlaybackControl !== false)
        return this.playbackRate = t3, this.isPlaying === true && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
      console.warn("THREE.Audio: this Audio has no playback control.");
    }
    getPlaybackRate() {
      return this.playbackRate;
    }
    onEnded() {
      this.isPlaying = false;
    }
    getLoop() {
      return this.hasPlaybackControl === false ? (console.warn("THREE.Audio: this Audio has no playback control."), false) : this.loop;
    }
    setLoop(t3) {
      if (this.hasPlaybackControl !== false)
        return this.loop = t3, this.isPlaying === true && (this.source.loop = this.loop), this;
      console.warn("THREE.Audio: this Audio has no playback control.");
    }
    setLoopStart(t3) {
      return this.loopStart = t3, this;
    }
    setLoopEnd(t3) {
      return this.loopEnd = t3, this;
    }
    getVolume() {
      return this.gain.gain.value;
    }
    setVolume(t3) {
      return this.gain.gain.setTargetAtTime(t3, this.context.currentTime, 0.01), this;
    }
  }
  const _d = new pi(), yd = new di(), xd = new pi(), bd = new pi();
  class Td extends vd {
    constructor(t3) {
      super(t3), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain);
    }
    getOutput() {
      return this.panner;
    }
    getRefDistance() {
      return this.panner.refDistance;
    }
    setRefDistance(t3) {
      return this.panner.refDistance = t3, this;
    }
    getRolloffFactor() {
      return this.panner.rolloffFactor;
    }
    setRolloffFactor(t3) {
      return this.panner.rolloffFactor = t3, this;
    }
    getDistanceModel() {
      return this.panner.distanceModel;
    }
    setDistanceModel(t3) {
      return this.panner.distanceModel = t3, this;
    }
    getMaxDistance() {
      return this.panner.maxDistance;
    }
    setMaxDistance(t3) {
      return this.panner.maxDistance = t3, this;
    }
    setDirectionalCone(t3, e3, n2) {
      return this.panner.coneInnerAngle = t3, this.panner.coneOuterAngle = e3, this.panner.coneOuterGain = n2, this;
    }
    updateMatrixWorld(t3) {
      if (super.updateMatrixWorld(t3), this.hasPlaybackControl === true && this.isPlaying === false)
        return;
      this.matrixWorld.decompose(_d, yd, xd), bd.set(0, 0, 1).applyQuaternion(yd);
      const e3 = this.panner;
      if (e3.positionX) {
        const t4 = this.context.currentTime + this.listener.timeDelta;
        e3.positionX.linearRampToValueAtTime(_d.x, t4), e3.positionY.linearRampToValueAtTime(_d.y, t4), e3.positionZ.linearRampToValueAtTime(_d.z, t4), e3.orientationX.linearRampToValueAtTime(bd.x, t4), e3.orientationY.linearRampToValueAtTime(bd.y, t4), e3.orientationZ.linearRampToValueAtTime(bd.z, t4);
      } else
        e3.setPosition(_d.x, _d.y, _d.z), e3.setOrientation(bd.x, bd.y, bd.z);
    }
  }
  class wd {
    constructor(t3, e3 = 2048) {
      this.analyser = t3.context.createAnalyser(), this.analyser.fftSize = e3, this.data = new Uint8Array(this.analyser.frequencyBinCount), t3.getOutput().connect(this.analyser);
    }
    getFrequencyData() {
      return this.analyser.getByteFrequencyData(this.data), this.data;
    }
    getAverageFrequency() {
      let t3 = 0;
      const e3 = this.getFrequencyData();
      for (let n2 = 0; n2 < e3.length; n2++)
        t3 += e3[n2];
      return t3 / e3.length;
    }
  }
  class Sd {
    constructor(t3, e3, n2) {
      let i2, r3, o3;
      switch (this.binding = t3, this.valueSize = n2, e3) {
        case "quaternion":
          i2 = this._slerp, r3 = this._slerpAdditive, o3 = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n2), this._workIndex = 5;
          break;
        case "string":
        case "bool":
          i2 = this._select, r3 = this._select, o3 = this._setAdditiveIdentityOther, this.buffer = new Array(5 * n2);
          break;
        default:
          i2 = this._lerp, r3 = this._lerpAdditive, o3 = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n2);
      }
      this._mixBufferRegion = i2, this._mixBufferRegionAdditive = r3, this._setIdentity = o3, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
    }
    accumulate(t3, e3) {
      const n2 = this.buffer, i2 = this.valueSize, r3 = t3 * i2 + i2;
      let o3 = this.cumulativeWeight;
      if (o3 === 0) {
        for (let t4 = 0; t4 !== i2; ++t4)
          n2[r3 + t4] = n2[t4];
        o3 = e3;
      } else {
        o3 += e3;
        const t4 = e3 / o3;
        this._mixBufferRegion(n2, r3, 0, t4, i2);
      }
      this.cumulativeWeight = o3;
    }
    accumulateAdditive(t3) {
      const e3 = this.buffer, n2 = this.valueSize, i2 = n2 * this._addIndex;
      this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(e3, i2, 0, t3, n2), this.cumulativeWeightAdditive += t3;
    }
    apply(t3) {
      const e3 = this.valueSize, n2 = this.buffer, i2 = t3 * e3 + e3, r3 = this.cumulativeWeight, o3 = this.cumulativeWeightAdditive, s3 = this.binding;
      if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r3 < 1) {
        const t4 = e3 * this._origIndex;
        this._mixBufferRegion(n2, i2, t4, 1 - r3, e3);
      }
      o3 > 0 && this._mixBufferRegionAdditive(n2, i2, this._addIndex * e3, 1, e3);
      for (let t4 = e3, r4 = e3 + e3; t4 !== r4; ++t4)
        if (n2[t4] !== n2[t4 + e3]) {
          s3.setValue(n2, i2);
          break;
        }
    }
    saveOriginalState() {
      const t3 = this.binding, e3 = this.buffer, n2 = this.valueSize, i2 = n2 * this._origIndex;
      t3.getValue(e3, i2);
      for (let t4 = n2, r3 = i2; t4 !== r3; ++t4)
        e3[t4] = e3[i2 + t4 % n2];
      this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
    }
    restoreOriginalState() {
      const t3 = 3 * this.valueSize;
      this.binding.setValue(this.buffer, t3);
    }
    _setAdditiveIdentityNumeric() {
      const t3 = this._addIndex * this.valueSize, e3 = t3 + this.valueSize;
      for (let n2 = t3; n2 < e3; n2++)
        this.buffer[n2] = 0;
    }
    _setAdditiveIdentityQuaternion() {
      this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
    }
    _setAdditiveIdentityOther() {
      const t3 = this._origIndex * this.valueSize, e3 = this._addIndex * this.valueSize;
      for (let n2 = 0; n2 < this.valueSize; n2++)
        this.buffer[e3 + n2] = this.buffer[t3 + n2];
    }
    _select(t3, e3, n2, i2, r3) {
      if (i2 >= 0.5)
        for (let i3 = 0; i3 !== r3; ++i3)
          t3[e3 + i3] = t3[n2 + i3];
    }
    _slerp(t3, e3, n2, i2) {
      di.slerpFlat(t3, e3, t3, e3, t3, n2, i2);
    }
    _slerpAdditive(t3, e3, n2, i2, r3) {
      const o3 = this._workIndex * r3;
      di.multiplyQuaternionsFlat(t3, o3, t3, e3, t3, n2), di.slerpFlat(t3, e3, t3, e3, t3, o3, i2);
    }
    _lerp(t3, e3, n2, i2, r3) {
      const o3 = 1 - i2;
      for (let s3 = 0; s3 !== r3; ++s3) {
        const r4 = e3 + s3;
        t3[r4] = t3[r4] * o3 + t3[n2 + s3] * i2;
      }
    }
    _lerpAdditive(t3, e3, n2, i2, r3) {
      for (let o3 = 0; o3 !== r3; ++o3) {
        const r4 = e3 + o3;
        t3[r4] = t3[r4] + t3[n2 + o3] * i2;
      }
    }
  }
  const Ed = new RegExp("[\\[\\]\\.:\\/]", "g"), Md = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]", Ad = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]"), Rd = /(WCOD+)?/.source.replace("WCOD", Md), Pd = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"), Cd = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"), Id = new RegExp("^" + Ad + Rd + Pd + Cd + "$"), Od = ["material", "materials", "bones"];
  class Ld {
    constructor(t3, e3, n2) {
      this.path = e3, this.parsedPath = n2 || Ld.parseTrackName(e3), this.node = Ld.findNode(t3, this.parsedPath.nodeName) || t3, this.rootNode = t3, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
    }
    static create(t3, e3, n2) {
      return t3 && t3.isAnimationObjectGroup ? new Ld.Composite(t3, e3, n2) : new Ld(t3, e3, n2);
    }
    static sanitizeNodeName(t3) {
      return t3.replace(/\s/g, "_").replace(Ed, "");
    }
    static parseTrackName(t3) {
      const e3 = Id.exec(t3);
      if (!e3)
        throw new Error("PropertyBinding: Cannot parse trackName: " + t3);
      const n2 = { nodeName: e3[2], objectName: e3[3], objectIndex: e3[4], propertyName: e3[5], propertyIndex: e3[6] }, i2 = n2.nodeName && n2.nodeName.lastIndexOf(".");
      if (i2 !== void 0 && i2 !== -1) {
        const t4 = n2.nodeName.substring(i2 + 1);
        Od.indexOf(t4) !== -1 && (n2.nodeName = n2.nodeName.substring(0, i2), n2.objectName = t4);
      }
      if (n2.propertyName === null || n2.propertyName.length === 0)
        throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t3);
      return n2;
    }
    static findNode(t3, e3) {
      if (!e3 || e3 === "" || e3 === "." || e3 === -1 || e3 === t3.name || e3 === t3.uuid)
        return t3;
      if (t3.skeleton) {
        const n2 = t3.skeleton.getBoneByName(e3);
        if (n2 !== void 0)
          return n2;
      }
      if (t3.children) {
        const n2 = function(t4) {
          for (let i3 = 0; i3 < t4.length; i3++) {
            const r3 = t4[i3];
            if (r3.name === e3 || r3.uuid === e3)
              return r3;
            const o3 = n2(r3.children);
            if (o3)
              return o3;
          }
          return null;
        }, i2 = n2(t3.children);
        if (i2)
          return i2;
      }
      return null;
    }
    _getValue_unavailable() {
    }
    _setValue_unavailable() {
    }
    _getValue_direct(t3, e3) {
      t3[e3] = this.node[this.propertyName];
    }
    _getValue_array(t3, e3) {
      const n2 = this.resolvedProperty;
      for (let i2 = 0, r3 = n2.length; i2 !== r3; ++i2)
        t3[e3++] = n2[i2];
    }
    _getValue_arrayElement(t3, e3) {
      t3[e3] = this.resolvedProperty[this.propertyIndex];
    }
    _getValue_toArray(t3, e3) {
      this.resolvedProperty.toArray(t3, e3);
    }
    _setValue_direct(t3, e3) {
      this.targetObject[this.propertyName] = t3[e3];
    }
    _setValue_direct_setNeedsUpdate(t3, e3) {
      this.targetObject[this.propertyName] = t3[e3], this.targetObject.needsUpdate = true;
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(t3, e3) {
      this.targetObject[this.propertyName] = t3[e3], this.targetObject.matrixWorldNeedsUpdate = true;
    }
    _setValue_array(t3, e3) {
      const n2 = this.resolvedProperty;
      for (let i2 = 0, r3 = n2.length; i2 !== r3; ++i2)
        n2[i2] = t3[e3++];
    }
    _setValue_array_setNeedsUpdate(t3, e3) {
      const n2 = this.resolvedProperty;
      for (let i2 = 0, r3 = n2.length; i2 !== r3; ++i2)
        n2[i2] = t3[e3++];
      this.targetObject.needsUpdate = true;
    }
    _setValue_array_setMatrixWorldNeedsUpdate(t3, e3) {
      const n2 = this.resolvedProperty;
      for (let i2 = 0, r3 = n2.length; i2 !== r3; ++i2)
        n2[i2] = t3[e3++];
      this.targetObject.matrixWorldNeedsUpdate = true;
    }
    _setValue_arrayElement(t3, e3) {
      this.resolvedProperty[this.propertyIndex] = t3[e3];
    }
    _setValue_arrayElement_setNeedsUpdate(t3, e3) {
      this.resolvedProperty[this.propertyIndex] = t3[e3], this.targetObject.needsUpdate = true;
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(t3, e3) {
      this.resolvedProperty[this.propertyIndex] = t3[e3], this.targetObject.matrixWorldNeedsUpdate = true;
    }
    _setValue_fromArray(t3, e3) {
      this.resolvedProperty.fromArray(t3, e3);
    }
    _setValue_fromArray_setNeedsUpdate(t3, e3) {
      this.resolvedProperty.fromArray(t3, e3), this.targetObject.needsUpdate = true;
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(t3, e3) {
      this.resolvedProperty.fromArray(t3, e3), this.targetObject.matrixWorldNeedsUpdate = true;
    }
    _getValue_unbound(t3, e3) {
      this.bind(), this.getValue(t3, e3);
    }
    _setValue_unbound(t3, e3) {
      this.bind(), this.setValue(t3, e3);
    }
    bind() {
      let t3 = this.node;
      const e3 = this.parsedPath, n2 = e3.objectName, i2 = e3.propertyName;
      let r3 = e3.propertyIndex;
      if (t3 || (t3 = Ld.findNode(this.rootNode, e3.nodeName) || this.rootNode, this.node = t3), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t3)
        return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
      if (n2) {
        let i3 = e3.objectIndex;
        switch (n2) {
          case "materials":
            if (!t3.material)
              return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            if (!t3.material.materials)
              return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            t3 = t3.material.materials;
            break;
          case "bones":
            if (!t3.skeleton)
              return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            t3 = t3.skeleton.bones;
            for (let e4 = 0; e4 < t3.length; e4++)
              if (t3[e4].name === i3) {
                i3 = e4;
                break;
              }
            break;
          default:
            if (t3[n2] === void 0)
              return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            t3 = t3[n2];
        }
        if (i3 !== void 0) {
          if (t3[i3] === void 0)
            return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t3);
          t3 = t3[i3];
        }
      }
      const o3 = t3[i2];
      if (o3 === void 0) {
        const n3 = e3.nodeName;
        return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n3 + "." + i2 + " but it wasn't found.", t3);
      }
      let s3 = this.Versioning.None;
      this.targetObject = t3, t3.needsUpdate !== void 0 ? s3 = this.Versioning.NeedsUpdate : t3.matrixWorldNeedsUpdate !== void 0 && (s3 = this.Versioning.MatrixWorldNeedsUpdate);
      let a2 = this.BindingType.Direct;
      if (r3 !== void 0) {
        if (i2 === "morphTargetInfluences") {
          if (!t3.geometry)
            return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          if (!t3.geometry.isBufferGeometry)
            return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
          if (!t3.geometry.morphAttributes)
            return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
          t3.morphTargetDictionary[r3] !== void 0 && (r3 = t3.morphTargetDictionary[r3]);
        }
        a2 = this.BindingType.ArrayElement, this.resolvedProperty = o3, this.propertyIndex = r3;
      } else
        o3.fromArray !== void 0 && o3.toArray !== void 0 ? (a2 = this.BindingType.HasFromToArray, this.resolvedProperty = o3) : Array.isArray(o3) ? (a2 = this.BindingType.EntireArray, this.resolvedProperty = o3) : this.propertyName = i2;
      this.getValue = this.GetterByBindingType[a2], this.setValue = this.SetterByBindingTypeAndVersioning[a2][s3];
    }
    unbind() {
      this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
    }
  }
  Ld.Composite = class {
    constructor(t3, e3, n2) {
      const i2 = n2 || Ld.parseTrackName(e3);
      this._targetGroup = t3, this._bindings = t3.subscribe_(e3, i2);
    }
    getValue(t3, e3) {
      this.bind();
      const n2 = this._targetGroup.nCachedObjects_, i2 = this._bindings[n2];
      i2 !== void 0 && i2.getValue(t3, e3);
    }
    setValue(t3, e3) {
      const n2 = this._bindings;
      for (let i2 = this._targetGroup.nCachedObjects_, r3 = n2.length; i2 !== r3; ++i2)
        n2[i2].setValue(t3, e3);
    }
    bind() {
      const t3 = this._bindings;
      for (let e3 = this._targetGroup.nCachedObjects_, n2 = t3.length; e3 !== n2; ++e3)
        t3[e3].bind();
    }
    unbind() {
      const t3 = this._bindings;
      for (let e3 = this._targetGroup.nCachedObjects_, n2 = t3.length; e3 !== n2; ++e3)
        t3[e3].unbind();
    }
  }, Ld.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, Ld.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, Ld.prototype.GetterByBindingType = [Ld.prototype._getValue_direct, Ld.prototype._getValue_array, Ld.prototype._getValue_arrayElement, Ld.prototype._getValue_toArray], Ld.prototype.SetterByBindingTypeAndVersioning = [[Ld.prototype._setValue_direct, Ld.prototype._setValue_direct_setNeedsUpdate, Ld.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [Ld.prototype._setValue_array, Ld.prototype._setValue_array_setNeedsUpdate, Ld.prototype._setValue_array_setMatrixWorldNeedsUpdate], [Ld.prototype._setValue_arrayElement, Ld.prototype._setValue_arrayElement_setNeedsUpdate, Ld.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [Ld.prototype._setValue_fromArray, Ld.prototype._setValue_fromArray_setNeedsUpdate, Ld.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
  class Nd {
    constructor() {
      this.uuid = qn(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
      const t3 = {};
      this._indicesByUUID = t3;
      for (let e4 = 0, n2 = arguments.length; e4 !== n2; ++e4)
        t3[arguments[e4].uuid] = e4;
      this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
      const e3 = this;
      this.stats = { objects: { get total() {
        return e3._objects.length;
      }, get inUse() {
        return this.total - e3.nCachedObjects_;
      } }, get bindingsPerObject() {
        return e3._bindings.length;
      } };
    }
    add() {
      const t3 = this._objects, e3 = this._indicesByUUID, n2 = this._paths, i2 = this._parsedPaths, r3 = this._bindings, o3 = r3.length;
      let s3 = void 0, a2 = t3.length, l2 = this.nCachedObjects_;
      for (let u2 = 0, h2 = arguments.length; u2 !== h2; ++u2) {
        const h3 = arguments[u2], c2 = h3.uuid;
        let d2 = e3[c2];
        if (d2 === void 0) {
          d2 = a2++, e3[c2] = d2, t3.push(h3);
          for (let t4 = 0, e4 = o3; t4 !== e4; ++t4)
            r3[t4].push(new Ld(h3, n2[t4], i2[t4]));
        } else if (d2 < l2) {
          s3 = t3[d2];
          const a3 = --l2, u3 = t3[a3];
          e3[u3.uuid] = d2, t3[d2] = u3, e3[c2] = a3, t3[a3] = h3;
          for (let t4 = 0, e4 = o3; t4 !== e4; ++t4) {
            const e5 = r3[t4], o4 = e5[a3];
            let s4 = e5[d2];
            e5[d2] = o4, s4 === void 0 && (s4 = new Ld(h3, n2[t4], i2[t4])), e5[a3] = s4;
          }
        } else
          t3[d2] !== s3 && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
      }
      this.nCachedObjects_ = l2;
    }
    remove() {
      const t3 = this._objects, e3 = this._indicesByUUID, n2 = this._bindings, i2 = n2.length;
      let r3 = this.nCachedObjects_;
      for (let o3 = 0, s3 = arguments.length; o3 !== s3; ++o3) {
        const s4 = arguments[o3], a2 = s4.uuid, l2 = e3[a2];
        if (l2 !== void 0 && l2 >= r3) {
          const o4 = r3++, u2 = t3[o4];
          e3[u2.uuid] = l2, t3[l2] = u2, e3[a2] = o4, t3[o4] = s4;
          for (let t4 = 0, e4 = i2; t4 !== e4; ++t4) {
            const e5 = n2[t4], i3 = e5[o4], r4 = e5[l2];
            e5[l2] = i3, e5[o4] = r4;
          }
        }
      }
      this.nCachedObjects_ = r3;
    }
    uncache() {
      const t3 = this._objects, e3 = this._indicesByUUID, n2 = this._bindings, i2 = n2.length;
      let r3 = this.nCachedObjects_, o3 = t3.length;
      for (let s3 = 0, a2 = arguments.length; s3 !== a2; ++s3) {
        const a3 = arguments[s3].uuid, l2 = e3[a3];
        if (l2 !== void 0)
          if (delete e3[a3], l2 < r3) {
            const s4 = --r3, a4 = t3[s4], u2 = --o3, h2 = t3[u2];
            e3[a4.uuid] = l2, t3[l2] = a4, e3[h2.uuid] = s4, t3[s4] = h2, t3.pop();
            for (let t4 = 0, e4 = i2; t4 !== e4; ++t4) {
              const e5 = n2[t4], i3 = e5[s4], r4 = e5[u2];
              e5[l2] = i3, e5[s4] = r4, e5.pop();
            }
          } else {
            const r4 = --o3, s4 = t3[r4];
            r4 > 0 && (e3[s4.uuid] = l2), t3[l2] = s4, t3.pop();
            for (let t4 = 0, e4 = i2; t4 !== e4; ++t4) {
              const e5 = n2[t4];
              e5[l2] = e5[r4], e5.pop();
            }
          }
      }
      this.nCachedObjects_ = r3;
    }
    subscribe_(t3, e3) {
      const n2 = this._bindingsIndicesByPath;
      let i2 = n2[t3];
      const r3 = this._bindings;
      if (i2 !== void 0)
        return r3[i2];
      const o3 = this._paths, s3 = this._parsedPaths, a2 = this._objects, l2 = a2.length, u2 = this.nCachedObjects_, h2 = new Array(l2);
      i2 = r3.length, n2[t3] = i2, o3.push(t3), s3.push(e3), r3.push(h2);
      for (let n3 = u2, i3 = a2.length; n3 !== i3; ++n3) {
        const i4 = a2[n3];
        h2[n3] = new Ld(i4, t3, e3);
      }
      return h2;
    }
    unsubscribe_(t3) {
      const e3 = this._bindingsIndicesByPath, n2 = e3[t3];
      if (n2 !== void 0) {
        const i2 = this._paths, r3 = this._parsedPaths, o3 = this._bindings, s3 = o3.length - 1, a2 = o3[s3];
        e3[t3[s3]] = n2, o3[n2] = a2, o3.pop(), r3[n2] = r3[s3], r3.pop(), i2[n2] = i2[s3], i2.pop();
      }
    }
  }
  Nd.prototype.isAnimationObjectGroup = true;
  class Dd {
    constructor(t3, e3, n2 = null, i2 = e3.blendMode) {
      this._mixer = t3, this._clip = e3, this._localRoot = n2, this.blendMode = i2;
      const r3 = e3.tracks, o3 = r3.length, s3 = new Array(o3), a2 = { endingStart: Ye, endingEnd: Ye };
      for (let t4 = 0; t4 !== o3; ++t4) {
        const e4 = r3[t4].createInterpolant(null);
        s3[t4] = e4, e4.settings = a2;
      }
      this._interpolantSettings = a2, this._interpolants = s3, this._propertyBindings = new Array(o3), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = je, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = false, this.enabled = true, this.clampWhenFinished = false, this.zeroSlopeAtStart = true, this.zeroSlopeAtEnd = true;
    }
    play() {
      return this._mixer._activateAction(this), this;
    }
    stop() {
      return this._mixer._deactivateAction(this), this.reset();
    }
    reset() {
      return this.paused = false, this.enabled = true, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
    }
    isRunning() {
      return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
    }
    isScheduled() {
      return this._mixer._isActiveAction(this);
    }
    startAt(t3) {
      return this._startTime = t3, this;
    }
    setLoop(t3, e3) {
      return this.loop = t3, this.repetitions = e3, this;
    }
    setEffectiveWeight(t3) {
      return this.weight = t3, this._effectiveWeight = this.enabled ? t3 : 0, this.stopFading();
    }
    getEffectiveWeight() {
      return this._effectiveWeight;
    }
    fadeIn(t3) {
      return this._scheduleFading(t3, 0, 1);
    }
    fadeOut(t3) {
      return this._scheduleFading(t3, 1, 0);
    }
    crossFadeFrom(t3, e3, n2) {
      if (t3.fadeOut(e3), this.fadeIn(e3), n2) {
        const n3 = this._clip.duration, i2 = t3._clip.duration, r3 = i2 / n3, o3 = n3 / i2;
        t3.warp(1, r3, e3), this.warp(o3, 1, e3);
      }
      return this;
    }
    crossFadeTo(t3, e3, n2) {
      return t3.crossFadeFrom(this, e3, n2);
    }
    stopFading() {
      const t3 = this._weightInterpolant;
      return t3 !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t3)), this;
    }
    setEffectiveTimeScale(t3) {
      return this.timeScale = t3, this._effectiveTimeScale = this.paused ? 0 : t3, this.stopWarping();
    }
    getEffectiveTimeScale() {
      return this._effectiveTimeScale;
    }
    setDuration(t3) {
      return this.timeScale = this._clip.duration / t3, this.stopWarping();
    }
    syncWith(t3) {
      return this.time = t3.time, this.timeScale = t3.timeScale, this.stopWarping();
    }
    halt(t3) {
      return this.warp(this._effectiveTimeScale, 0, t3);
    }
    warp(t3, e3, n2) {
      const i2 = this._mixer, r3 = i2.time, o3 = this.timeScale;
      let s3 = this._timeScaleInterpolant;
      s3 === null && (s3 = i2._lendControlInterpolant(), this._timeScaleInterpolant = s3);
      const a2 = s3.parameterPositions, l2 = s3.sampleValues;
      return a2[0] = r3, a2[1] = r3 + n2, l2[0] = t3 / o3, l2[1] = e3 / o3, this;
    }
    stopWarping() {
      const t3 = this._timeScaleInterpolant;
      return t3 !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t3)), this;
    }
    getMixer() {
      return this._mixer;
    }
    getClip() {
      return this._clip;
    }
    getRoot() {
      return this._localRoot || this._mixer._root;
    }
    _update(t3, e3, n2, i2) {
      if (!this.enabled)
        return void this._updateWeight(t3);
      const r3 = this._startTime;
      if (r3 !== null) {
        const i3 = (t3 - r3) * n2;
        if (i3 < 0 || n2 === 0)
          return;
        this._startTime = null, e3 = n2 * i3;
      }
      e3 *= this._updateTimeScale(t3);
      const o3 = this._updateTime(e3), s3 = this._updateWeight(t3);
      if (s3 > 0) {
        const t4 = this._interpolants, e4 = this._propertyBindings;
        switch (this.blendMode) {
          case Ke:
            for (let n3 = 0, i3 = t4.length; n3 !== i3; ++n3)
              t4[n3].evaluate(o3), e4[n3].accumulateAdditive(s3);
            break;
          case $e:
          default:
            for (let n3 = 0, r4 = t4.length; n3 !== r4; ++n3)
              t4[n3].evaluate(o3), e4[n3].accumulate(i2, s3);
        }
      }
    }
    _updateWeight(t3) {
      let e3 = 0;
      if (this.enabled) {
        e3 = this.weight;
        const n2 = this._weightInterpolant;
        if (n2 !== null) {
          const i2 = n2.evaluate(t3)[0];
          e3 *= i2, t3 > n2.parameterPositions[1] && (this.stopFading(), i2 === 0 && (this.enabled = false));
        }
      }
      return this._effectiveWeight = e3, e3;
    }
    _updateTimeScale(t3) {
      let e3 = 0;
      if (!this.paused) {
        e3 = this.timeScale;
        const n2 = this._timeScaleInterpolant;
        if (n2 !== null) {
          e3 *= n2.evaluate(t3)[0], t3 > n2.parameterPositions[1] && (this.stopWarping(), e3 === 0 ? this.paused = true : this.timeScale = e3);
        }
      }
      return this._effectiveTimeScale = e3, e3;
    }
    _updateTime(t3) {
      const e3 = this._clip.duration, n2 = this.loop;
      let i2 = this.time + t3, r3 = this._loopCount;
      const o3 = n2 === Ve;
      if (t3 === 0)
        return r3 === -1 ? i2 : o3 && (1 & r3) == 1 ? e3 - i2 : i2;
      if (n2 === ze) {
        r3 === -1 && (this._loopCount = 0, this._setEndings(true, true, false));
        t: {
          if (i2 >= e3)
            i2 = e3;
          else {
            if (!(i2 < 0)) {
              this.time = i2;
              break t;
            }
            i2 = 0;
          }
          this.clampWhenFinished ? this.paused = true : this.enabled = false, this.time = i2, this._mixer.dispatchEvent({ type: "finished", action: this, direction: t3 < 0 ? -1 : 1 });
        }
      } else {
        if (r3 === -1 && (t3 >= 0 ? (r3 = 0, this._setEndings(true, this.repetitions === 0, o3)) : this._setEndings(this.repetitions === 0, true, o3)), i2 >= e3 || i2 < 0) {
          const n3 = Math.floor(i2 / e3);
          i2 -= e3 * n3, r3 += Math.abs(n3);
          const s3 = this.repetitions - r3;
          if (s3 <= 0)
            this.clampWhenFinished ? this.paused = true : this.enabled = false, i2 = t3 > 0 ? e3 : 0, this.time = i2, this._mixer.dispatchEvent({ type: "finished", action: this, direction: t3 > 0 ? 1 : -1 });
          else {
            if (s3 === 1) {
              const e4 = t3 < 0;
              this._setEndings(e4, !e4, o3);
            } else
              this._setEndings(false, false, o3);
            this._loopCount = r3, this.time = i2, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: n3 });
          }
        } else
          this.time = i2;
        if (o3 && (1 & r3) == 1)
          return e3 - i2;
      }
      return i2;
    }
    _setEndings(t3, e3, n2) {
      const i2 = this._interpolantSettings;
      n2 ? (i2.endingStart = Ze, i2.endingEnd = Ze) : (i2.endingStart = t3 ? this.zeroSlopeAtStart ? Ze : Ye : Je, i2.endingEnd = e3 ? this.zeroSlopeAtEnd ? Ze : Ye : Je);
    }
    _scheduleFading(t3, e3, n2) {
      const i2 = this._mixer, r3 = i2.time;
      let o3 = this._weightInterpolant;
      o3 === null && (o3 = i2._lendControlInterpolant(), this._weightInterpolant = o3);
      const s3 = o3.parameterPositions, a2 = o3.sampleValues;
      return s3[0] = r3, a2[0] = e3, s3[1] = r3 + t3, a2[1] = n2, this;
    }
  }
  class Fd extends zn {
    constructor(t3) {
      super(), this._root = t3, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
    }
    _bindAction(t3, e3) {
      const n2 = t3._localRoot || this._root, i2 = t3._clip.tracks, r3 = i2.length, o3 = t3._propertyBindings, s3 = t3._interpolants, a2 = n2.uuid, l2 = this._bindingsByRootAndName;
      let u2 = l2[a2];
      u2 === void 0 && (u2 = {}, l2[a2] = u2);
      for (let t4 = 0; t4 !== r3; ++t4) {
        const r4 = i2[t4], l3 = r4.name;
        let h2 = u2[l3];
        if (h2 !== void 0)
          o3[t4] = h2;
        else {
          if (h2 = o3[t4], h2 !== void 0) {
            h2._cacheIndex === null && (++h2.referenceCount, this._addInactiveBinding(h2, a2, l3));
            continue;
          }
          const i3 = e3 && e3._propertyBindings[t4].binding.parsedPath;
          h2 = new Sd(Ld.create(n2, l3, i3), r4.ValueTypeName, r4.getValueSize()), ++h2.referenceCount, this._addInactiveBinding(h2, a2, l3), o3[t4] = h2;
        }
        s3[t4].resultBuffer = h2.buffer;
      }
    }
    _activateAction(t3) {
      if (!this._isActiveAction(t3)) {
        if (t3._cacheIndex === null) {
          const e4 = (t3._localRoot || this._root).uuid, n2 = t3._clip.uuid, i2 = this._actionsByClip[n2];
          this._bindAction(t3, i2 && i2.knownActions[0]), this._addInactiveAction(t3, n2, e4);
        }
        const e3 = t3._propertyBindings;
        for (let t4 = 0, n2 = e3.length; t4 !== n2; ++t4) {
          const n3 = e3[t4];
          n3.useCount++ == 0 && (this._lendBinding(n3), n3.saveOriginalState());
        }
        this._lendAction(t3);
      }
    }
    _deactivateAction(t3) {
      if (this._isActiveAction(t3)) {
        const e3 = t3._propertyBindings;
        for (let t4 = 0, n2 = e3.length; t4 !== n2; ++t4) {
          const n3 = e3[t4];
          --n3.useCount == 0 && (n3.restoreOriginalState(), this._takeBackBinding(n3));
        }
        this._takeBackAction(t3);
      }
    }
    _initMemoryManager() {
      this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
      const t3 = this;
      this.stats = { actions: { get total() {
        return t3._actions.length;
      }, get inUse() {
        return t3._nActiveActions;
      } }, bindings: { get total() {
        return t3._bindings.length;
      }, get inUse() {
        return t3._nActiveBindings;
      } }, controlInterpolants: { get total() {
        return t3._controlInterpolants.length;
      }, get inUse() {
        return t3._nActiveControlInterpolants;
      } } };
    }
    _isActiveAction(t3) {
      const e3 = t3._cacheIndex;
      return e3 !== null && e3 < this._nActiveActions;
    }
    _addInactiveAction(t3, e3, n2) {
      const i2 = this._actions, r3 = this._actionsByClip;
      let o3 = r3[e3];
      if (o3 === void 0)
        o3 = { knownActions: [t3], actionByRoot: {} }, t3._byClipCacheIndex = 0, r3[e3] = o3;
      else {
        const e4 = o3.knownActions;
        t3._byClipCacheIndex = e4.length, e4.push(t3);
      }
      t3._cacheIndex = i2.length, i2.push(t3), o3.actionByRoot[n2] = t3;
    }
    _removeInactiveAction(t3) {
      const e3 = this._actions, n2 = e3[e3.length - 1], i2 = t3._cacheIndex;
      n2._cacheIndex = i2, e3[i2] = n2, e3.pop(), t3._cacheIndex = null;
      const r3 = t3._clip.uuid, o3 = this._actionsByClip, s3 = o3[r3], a2 = s3.knownActions, l2 = a2[a2.length - 1], u2 = t3._byClipCacheIndex;
      l2._byClipCacheIndex = u2, a2[u2] = l2, a2.pop(), t3._byClipCacheIndex = null;
      delete s3.actionByRoot[(t3._localRoot || this._root).uuid], a2.length === 0 && delete o3[r3], this._removeInactiveBindingsForAction(t3);
    }
    _removeInactiveBindingsForAction(t3) {
      const e3 = t3._propertyBindings;
      for (let t4 = 0, n2 = e3.length; t4 !== n2; ++t4) {
        const n3 = e3[t4];
        --n3.referenceCount == 0 && this._removeInactiveBinding(n3);
      }
    }
    _lendAction(t3) {
      const e3 = this._actions, n2 = t3._cacheIndex, i2 = this._nActiveActions++, r3 = e3[i2];
      t3._cacheIndex = i2, e3[i2] = t3, r3._cacheIndex = n2, e3[n2] = r3;
    }
    _takeBackAction(t3) {
      const e3 = this._actions, n2 = t3._cacheIndex, i2 = --this._nActiveActions, r3 = e3[i2];
      t3._cacheIndex = i2, e3[i2] = t3, r3._cacheIndex = n2, e3[n2] = r3;
    }
    _addInactiveBinding(t3, e3, n2) {
      const i2 = this._bindingsByRootAndName, r3 = this._bindings;
      let o3 = i2[e3];
      o3 === void 0 && (o3 = {}, i2[e3] = o3), o3[n2] = t3, t3._cacheIndex = r3.length, r3.push(t3);
    }
    _removeInactiveBinding(t3) {
      const e3 = this._bindings, n2 = t3.binding, i2 = n2.rootNode.uuid, r3 = n2.path, o3 = this._bindingsByRootAndName, s3 = o3[i2], a2 = e3[e3.length - 1], l2 = t3._cacheIndex;
      a2._cacheIndex = l2, e3[l2] = a2, e3.pop(), delete s3[r3], Object.keys(s3).length === 0 && delete o3[i2];
    }
    _lendBinding(t3) {
      const e3 = this._bindings, n2 = t3._cacheIndex, i2 = this._nActiveBindings++, r3 = e3[i2];
      t3._cacheIndex = i2, e3[i2] = t3, r3._cacheIndex = n2, e3[n2] = r3;
    }
    _takeBackBinding(t3) {
      const e3 = this._bindings, n2 = t3._cacheIndex, i2 = --this._nActiveBindings, r3 = e3[i2];
      t3._cacheIndex = i2, e3[i2] = t3, r3._cacheIndex = n2, e3[n2] = r3;
    }
    _lendControlInterpolant() {
      const t3 = this._controlInterpolants, e3 = this._nActiveControlInterpolants++;
      let n2 = t3[e3];
      return n2 === void 0 && (n2 = new Zh(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), n2.__cacheIndex = e3, t3[e3] = n2), n2;
    }
    _takeBackControlInterpolant(t3) {
      const e3 = this._controlInterpolants, n2 = t3.__cacheIndex, i2 = --this._nActiveControlInterpolants, r3 = e3[i2];
      t3.__cacheIndex = i2, e3[i2] = t3, r3.__cacheIndex = n2, e3[n2] = r3;
    }
    clipAction(t3, e3, n2) {
      const i2 = e3 || this._root, r3 = i2.uuid;
      let o3 = typeof t3 == "string" ? oc.findByName(i2, t3) : t3;
      const s3 = o3 !== null ? o3.uuid : t3, a2 = this._actionsByClip[s3];
      let l2 = null;
      if (n2 === void 0 && (n2 = o3 !== null ? o3.blendMode : $e), a2 !== void 0) {
        const t4 = a2.actionByRoot[r3];
        if (t4 !== void 0 && t4.blendMode === n2)
          return t4;
        l2 = a2.knownActions[0], o3 === null && (o3 = l2._clip);
      }
      if (o3 === null)
        return null;
      const u2 = new Dd(this, o3, e3, n2);
      return this._bindAction(u2, l2), this._addInactiveAction(u2, s3, r3), u2;
    }
    existingAction(t3, e3) {
      const n2 = e3 || this._root, i2 = n2.uuid, r3 = typeof t3 == "string" ? oc.findByName(n2, t3) : t3, o3 = r3 ? r3.uuid : t3, s3 = this._actionsByClip[o3];
      return s3 !== void 0 && s3.actionByRoot[i2] || null;
    }
    stopAllAction() {
      const t3 = this._actions;
      for (let e3 = this._nActiveActions - 1; e3 >= 0; --e3)
        t3[e3].stop();
      return this;
    }
    update(t3) {
      t3 *= this.timeScale;
      const e3 = this._actions, n2 = this._nActiveActions, i2 = this.time += t3, r3 = Math.sign(t3), o3 = this._accuIndex ^= 1;
      for (let s4 = 0; s4 !== n2; ++s4) {
        e3[s4]._update(i2, t3, r3, o3);
      }
      const s3 = this._bindings, a2 = this._nActiveBindings;
      for (let t4 = 0; t4 !== a2; ++t4)
        s3[t4].apply(o3);
      return this;
    }
    setTime(t3) {
      this.time = 0;
      for (let t4 = 0; t4 < this._actions.length; t4++)
        this._actions[t4].time = 0;
      return this.update(t3);
    }
    getRoot() {
      return this._root;
    }
    uncacheClip(t3) {
      const e3 = this._actions, n2 = t3.uuid, i2 = this._actionsByClip, r3 = i2[n2];
      if (r3 !== void 0) {
        const t4 = r3.knownActions;
        for (let n3 = 0, i3 = t4.length; n3 !== i3; ++n3) {
          const i4 = t4[n3];
          this._deactivateAction(i4);
          const r4 = i4._cacheIndex, o3 = e3[e3.length - 1];
          i4._cacheIndex = null, i4._byClipCacheIndex = null, o3._cacheIndex = r4, e3[r4] = o3, e3.pop(), this._removeInactiveBindingsForAction(i4);
        }
        delete i2[n2];
      }
    }
    uncacheRoot(t3) {
      const e3 = t3.uuid, n2 = this._actionsByClip;
      for (const t4 in n2) {
        const i3 = n2[t4].actionByRoot[e3];
        i3 !== void 0 && (this._deactivateAction(i3), this._removeInactiveAction(i3));
      }
      const i2 = this._bindingsByRootAndName[e3];
      if (i2 !== void 0)
        for (const t4 in i2) {
          const e4 = i2[t4];
          e4.restoreOriginalState(), this._removeInactiveBinding(e4);
        }
    }
    uncacheAction(t3, e3) {
      const n2 = this.existingAction(t3, e3);
      n2 !== null && (this._deactivateAction(n2), this._removeInactiveAction(n2));
    }
  }
  Fd.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
  class Bd {
    constructor(t3) {
      typeof t3 == "string" && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t3 = arguments[1]), this.value = t3;
    }
    clone() {
      return new Bd(this.value.clone === void 0 ? this.value : this.value.clone());
    }
  }
  class Ud extends ul {
    constructor(t3, e3, n2 = 1) {
      super(t3, e3), this.meshPerAttribute = n2;
    }
    copy(t3) {
      return super.copy(t3), this.meshPerAttribute = t3.meshPerAttribute, this;
    }
    clone(t3) {
      const e3 = super.clone(t3);
      return e3.meshPerAttribute = this.meshPerAttribute, e3;
    }
    toJSON(t3) {
      const e3 = super.toJSON(t3);
      return e3.isInstancedInterleavedBuffer = true, e3.meshPerAttribute = this.meshPerAttribute, e3;
    }
  }
  Ud.prototype.isInstancedInterleavedBuffer = true;
  class kd {
    constructor(t3, e3, n2, i2, r3) {
      this.buffer = t3, this.type = e3, this.itemSize = n2, this.elementSize = i2, this.count = r3, this.version = 0;
    }
    set needsUpdate(t3) {
      t3 === true && this.version++;
    }
    setBuffer(t3) {
      return this.buffer = t3, this;
    }
    setType(t3, e3) {
      return this.type = t3, this.elementSize = e3, this;
    }
    setItemSize(t3) {
      return this.itemSize = t3, this;
    }
    setCount(t3) {
      return this.count = t3, this;
    }
  }
  kd.prototype.isGLBufferAttribute = true;
  class Gd {
    constructor(t3, e3, n2 = 0, i2 = 1 / 0) {
      this.ray = new ji(t3, e3), this.near = n2, this.far = i2, this.camera = null, this.layers = new er(), this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} };
    }
    set(t3, e3) {
      this.ray.set(t3, e3);
    }
    setFromCamera(t3, e3) {
      e3 && e3.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e3.matrixWorld), this.ray.direction.set(t3.x, t3.y, 0.5).unproject(e3).sub(this.ray.origin).normalize(), this.camera = e3) : e3 && e3.isOrthographicCamera ? (this.ray.origin.set(t3.x, t3.y, (e3.near + e3.far) / (e3.near - e3.far)).unproject(e3), this.ray.direction.set(0, 0, -1).transformDirection(e3.matrixWorld), this.camera = e3) : console.error("THREE.Raycaster: Unsupported camera type: " + e3.type);
    }
    intersectObject(t3, e3 = false, n2 = []) {
      return zd(t3, this, n2, e3), n2.sort(Hd), n2;
    }
    intersectObjects(t3, e3 = false, n2 = []) {
      for (let i2 = 0, r3 = t3.length; i2 < r3; i2++)
        zd(t3[i2], this, n2, e3);
      return n2.sort(Hd), n2;
    }
  }
  function Hd(t3, e3) {
    return t3.distance - e3.distance;
  }
  function zd(t3, e3, n2, i2) {
    if (t3.layers.test(e3.layers) && t3.raycast(e3, n2), i2 === true) {
      const i3 = t3.children;
      for (let t4 = 0, r3 = i3.length; t4 < r3; t4++)
        zd(i3[t4], e3, n2, true);
    }
  }
  class jd {
    constructor(t3 = 1, e3 = 0, n2 = 0) {
      return this.radius = t3, this.phi = e3, this.theta = n2, this;
    }
    set(t3, e3, n2) {
      return this.radius = t3, this.phi = e3, this.theta = n2, this;
    }
    copy(t3) {
      return this.radius = t3.radius, this.phi = t3.phi, this.theta = t3.theta, this;
    }
    makeSafe() {
      return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this;
    }
    setFromVector3(t3) {
      return this.setFromCartesianCoords(t3.x, t3.y, t3.z);
    }
    setFromCartesianCoords(t3, e3, n2) {
      return this.radius = Math.sqrt(t3 * t3 + e3 * e3 + n2 * n2), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t3, n2), this.phi = Math.acos(Yn(e3 / this.radius, -1, 1))), this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  class Vd {
    constructor(t3 = 1, e3 = 0, n2 = 0) {
      return this.radius = t3, this.theta = e3, this.y = n2, this;
    }
    set(t3, e3, n2) {
      return this.radius = t3, this.theta = e3, this.y = n2, this;
    }
    copy(t3) {
      return this.radius = t3.radius, this.theta = t3.theta, this.y = t3.y, this;
    }
    setFromVector3(t3) {
      return this.setFromCartesianCoords(t3.x, t3.y, t3.z);
    }
    setFromCartesianCoords(t3, e3, n2) {
      return this.radius = Math.sqrt(t3 * t3 + n2 * n2), this.theta = Math.atan2(t3, n2), this.y = e3, this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  const Wd = new ei();
  class Xd {
    constructor(t3 = new ei(1 / 0, 1 / 0), e3 = new ei(-1 / 0, -1 / 0)) {
      this.min = t3, this.max = e3;
    }
    set(t3, e3) {
      return this.min.copy(t3), this.max.copy(e3), this;
    }
    setFromPoints(t3) {
      this.makeEmpty();
      for (let e3 = 0, n2 = t3.length; e3 < n2; e3++)
        this.expandByPoint(t3[e3]);
      return this;
    }
    setFromCenterAndSize(t3, e3) {
      const n2 = Wd.copy(e3).multiplyScalar(0.5);
      return this.min.copy(t3).sub(n2), this.max.copy(t3).add(n2), this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t3) {
      return this.min.copy(t3.min), this.max.copy(t3.max), this;
    }
    makeEmpty() {
      return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
    }
    isEmpty() {
      return this.max.x < this.min.x || this.max.y < this.min.y;
    }
    getCenter(t3) {
      return this.isEmpty() ? t3.set(0, 0) : t3.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
    getSize(t3) {
      return this.isEmpty() ? t3.set(0, 0) : t3.subVectors(this.max, this.min);
    }
    expandByPoint(t3) {
      return this.min.min(t3), this.max.max(t3), this;
    }
    expandByVector(t3) {
      return this.min.sub(t3), this.max.add(t3), this;
    }
    expandByScalar(t3) {
      return this.min.addScalar(-t3), this.max.addScalar(t3), this;
    }
    containsPoint(t3) {
      return !(t3.x < this.min.x || t3.x > this.max.x || t3.y < this.min.y || t3.y > this.max.y);
    }
    containsBox(t3) {
      return this.min.x <= t3.min.x && t3.max.x <= this.max.x && this.min.y <= t3.min.y && t3.max.y <= this.max.y;
    }
    getParameter(t3, e3) {
      return e3.set((t3.x - this.min.x) / (this.max.x - this.min.x), (t3.y - this.min.y) / (this.max.y - this.min.y));
    }
    intersectsBox(t3) {
      return !(t3.max.x < this.min.x || t3.min.x > this.max.x || t3.max.y < this.min.y || t3.min.y > this.max.y);
    }
    clampPoint(t3, e3) {
      return e3.copy(t3).clamp(this.min, this.max);
    }
    distanceToPoint(t3) {
      return Wd.copy(t3).clamp(this.min, this.max).sub(t3).length();
    }
    intersect(t3) {
      return this.min.max(t3.min), this.max.min(t3.max), this;
    }
    union(t3) {
      return this.min.min(t3.min), this.max.max(t3.max), this;
    }
    translate(t3) {
      return this.min.add(t3), this.max.add(t3), this;
    }
    equals(t3) {
      return t3.min.equals(this.min) && t3.max.equals(this.max);
    }
  }
  Xd.prototype.isBox2 = true;
  const qd = new pi(), Yd = new pi();
  class Zd {
    constructor(t3 = new pi(), e3 = new pi()) {
      this.start = t3, this.end = e3;
    }
    set(t3, e3) {
      return this.start.copy(t3), this.end.copy(e3), this;
    }
    copy(t3) {
      return this.start.copy(t3.start), this.end.copy(t3.end), this;
    }
    getCenter(t3) {
      return t3.addVectors(this.start, this.end).multiplyScalar(0.5);
    }
    delta(t3) {
      return t3.subVectors(this.end, this.start);
    }
    distanceSq() {
      return this.start.distanceToSquared(this.end);
    }
    distance() {
      return this.start.distanceTo(this.end);
    }
    at(t3, e3) {
      return this.delta(e3).multiplyScalar(t3).add(this.start);
    }
    closestPointToPointParameter(t3, e3) {
      qd.subVectors(t3, this.start), Yd.subVectors(this.end, this.start);
      const n2 = Yd.dot(Yd);
      let i2 = Yd.dot(qd) / n2;
      return e3 && (i2 = Yn(i2, 0, 1)), i2;
    }
    closestPointToPoint(t3, e3, n2) {
      const i2 = this.closestPointToPointParameter(t3, e3);
      return this.delta(n2).multiplyScalar(i2).add(this.start);
    }
    applyMatrix4(t3) {
      return this.start.applyMatrix4(t3), this.end.applyMatrix4(t3), this;
    }
    equals(t3) {
      return t3.start.equals(this.start) && t3.end.equals(this.end);
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  class Jd extends mr {
    constructor(t3) {
      super(), this.material = t3, this.render = function() {
      }, this.hasPositions = false, this.hasNormals = false, this.hasColors = false, this.hasUvs = false, this.positionArray = null, this.normalArray = null, this.colorArray = null, this.uvArray = null, this.count = 0;
    }
  }
  Jd.prototype.isImmediateRenderObject = true;
  const $d = new pi();
  class Kd extends mr {
    constructor(t3, e3) {
      super(), this.light = t3, this.light.updateMatrixWorld(), this.matrix = t3.matrixWorld, this.matrixAutoUpdate = false, this.color = e3;
      const n2 = new so(), i2 = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
      for (let t4 = 0, e4 = 1, n3 = 32; t4 < n3; t4++, e4++) {
        const r4 = t4 / n3 * Math.PI * 2, o3 = e4 / n3 * Math.PI * 2;
        i2.push(Math.cos(r4), Math.sin(r4), 1, Math.cos(o3), Math.sin(o3), 1);
      }
      n2.setAttribute("position", new Yr(i2, 3));
      const r3 = new ql({ fog: false, toneMapped: false });
      this.cone = new nu(n2, r3), this.add(this.cone), this.update();
    }
    dispose() {
      this.cone.geometry.dispose(), this.cone.material.dispose();
    }
    update() {
      this.light.updateMatrixWorld();
      const t3 = this.light.distance ? this.light.distance : 1e3, e3 = t3 * Math.tan(this.light.angle);
      this.cone.scale.set(e3, e3, t3), $d.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt($d), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
    }
  }
  const Qd = new pi(), tp = new Vi(), ep = new Vi();
  class np extends nu {
    constructor(t3) {
      const e3 = function t4(e4) {
        const n3 = [];
        e4 && e4.isBone && n3.push(e4);
        for (let i3 = 0; i3 < e4.children.length; i3++)
          n3.push.apply(n3, t4(e4.children[i3]));
        return n3;
      }(t3), n2 = new so(), i2 = [], r3 = [], o3 = new Dr(0, 0, 1), s3 = new Dr(0, 1, 0);
      for (let t4 = 0; t4 < e3.length; t4++) {
        const n3 = e3[t4];
        n3.parent && n3.parent.isBone && (i2.push(0, 0, 0), i2.push(0, 0, 0), r3.push(o3.r, o3.g, o3.b), r3.push(s3.r, s3.g, s3.b));
      }
      n2.setAttribute("position", new Yr(i2, 3)), n2.setAttribute("color", new Yr(r3, 3));
      super(n2, new ql({ vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true })), this.type = "SkeletonHelper", this.isSkeletonHelper = true, this.root = t3, this.bones = e3, this.matrix = t3.matrixWorld, this.matrixAutoUpdate = false;
    }
    updateMatrixWorld(t3) {
      const e3 = this.bones, n2 = this.geometry, i2 = n2.getAttribute("position");
      ep.copy(this.root.matrixWorld).invert();
      for (let t4 = 0, n3 = 0; t4 < e3.length; t4++) {
        const r3 = e3[t4];
        r3.parent && r3.parent.isBone && (tp.multiplyMatrices(ep, r3.matrixWorld), Qd.setFromMatrixPosition(tp), i2.setXYZ(n3, Qd.x, Qd.y, Qd.z), tp.multiplyMatrices(ep, r3.parent.matrixWorld), Qd.setFromMatrixPosition(tp), i2.setXYZ(n3 + 1, Qd.x, Qd.y, Qd.z), n3 += 2);
      }
      n2.getAttribute("position").needsUpdate = true, super.updateMatrixWorld(t3);
    }
  }
  class ip extends Eo {
    constructor(t3, e3, n2) {
      super(new Ah(e3, 4, 2), new Fr({ wireframe: true, fog: false, toneMapped: false })), this.light = t3, this.light.updateMatrixWorld(), this.color = n2, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = false, this.update();
    }
    dispose() {
      this.geometry.dispose(), this.material.dispose();
    }
    update() {
      this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
    }
  }
  const rp = new pi(), op = new Dr(), sp = new Dr();
  class ap extends mr {
    constructor(t3, e3, n2) {
      super(), this.light = t3, this.light.updateMatrixWorld(), this.matrix = t3.matrixWorld, this.matrixAutoUpdate = false, this.color = n2;
      const i2 = new wh(e3);
      i2.rotateY(0.5 * Math.PI), this.material = new Fr({ wireframe: true, fog: false, toneMapped: false }), this.color === void 0 && (this.material.vertexColors = true);
      const r3 = i2.getAttribute("position"), o3 = new Float32Array(3 * r3.count);
      i2.setAttribute("color", new kr(o3, 3)), this.add(new Eo(i2, this.material)), this.update();
    }
    dispose() {
      this.children[0].geometry.dispose(), this.children[0].material.dispose();
    }
    update() {
      const t3 = this.children[0];
      if (this.color !== void 0)
        this.material.color.set(this.color);
      else {
        const e3 = t3.geometry.getAttribute("color");
        op.copy(this.light.color), sp.copy(this.light.groundColor);
        for (let t4 = 0, n2 = e3.count; t4 < n2; t4++) {
          const i2 = t4 < n2 / 2 ? op : sp;
          e3.setXYZ(t4, i2.r, i2.g, i2.b);
        }
        e3.needsUpdate = true;
      }
      t3.lookAt(rp.setFromMatrixPosition(this.light.matrixWorld).negate());
    }
  }
  class lp extends nu {
    constructor(t3 = 10, e3 = 10, n2 = 4473924, i2 = 8947848) {
      n2 = new Dr(n2), i2 = new Dr(i2);
      const r3 = e3 / 2, o3 = t3 / e3, s3 = t3 / 2, a2 = [], l2 = [];
      for (let t4 = 0, u3 = 0, h2 = -s3; t4 <= e3; t4++, h2 += o3) {
        a2.push(-s3, 0, h2, s3, 0, h2), a2.push(h2, 0, -s3, h2, 0, s3);
        const e4 = t4 === r3 ? n2 : i2;
        e4.toArray(l2, u3), u3 += 3, e4.toArray(l2, u3), u3 += 3, e4.toArray(l2, u3), u3 += 3, e4.toArray(l2, u3), u3 += 3;
      }
      const u2 = new so();
      u2.setAttribute("position", new Yr(a2, 3)), u2.setAttribute("color", new Yr(l2, 3));
      super(u2, new ql({ vertexColors: true, toneMapped: false })), this.type = "GridHelper";
    }
  }
  class up extends nu {
    constructor(t3 = 10, e3 = 16, n2 = 8, i2 = 64, r3 = 4473924, o3 = 8947848) {
      r3 = new Dr(r3), o3 = new Dr(o3);
      const s3 = [], a2 = [];
      for (let n3 = 0; n3 <= e3; n3++) {
        const i3 = n3 / e3 * (2 * Math.PI), l3 = Math.sin(i3) * t3, u2 = Math.cos(i3) * t3;
        s3.push(0, 0, 0), s3.push(l3, 0, u2);
        const h2 = 1 & n3 ? r3 : o3;
        a2.push(h2.r, h2.g, h2.b), a2.push(h2.r, h2.g, h2.b);
      }
      for (let e4 = 0; e4 <= n2; e4++) {
        const l3 = 1 & e4 ? r3 : o3, u2 = t3 - t3 / n2 * e4;
        for (let t4 = 0; t4 < i2; t4++) {
          let e5 = t4 / i2 * (2 * Math.PI), n3 = Math.sin(e5) * u2, r4 = Math.cos(e5) * u2;
          s3.push(n3, 0, r4), a2.push(l3.r, l3.g, l3.b), e5 = (t4 + 1) / i2 * (2 * Math.PI), n3 = Math.sin(e5) * u2, r4 = Math.cos(e5) * u2, s3.push(n3, 0, r4), a2.push(l3.r, l3.g, l3.b);
        }
      }
      const l2 = new so();
      l2.setAttribute("position", new Yr(s3, 3)), l2.setAttribute("color", new Yr(a2, 3));
      super(l2, new ql({ vertexColors: true, toneMapped: false })), this.type = "PolarGridHelper";
    }
  }
  const hp = new pi(), cp = new pi(), dp = new pi();
  class pp extends mr {
    constructor(t3, e3, n2) {
      super(), this.light = t3, this.light.updateMatrixWorld(), this.matrix = t3.matrixWorld, this.matrixAutoUpdate = false, this.color = n2, e3 === void 0 && (e3 = 1);
      let i2 = new so();
      i2.setAttribute("position", new Yr([-e3, e3, 0, e3, e3, 0, e3, -e3, 0, -e3, -e3, 0, -e3, e3, 0], 3));
      const r3 = new ql({ fog: false, toneMapped: false });
      this.lightPlane = new Ql(i2, r3), this.add(this.lightPlane), i2 = new so(), i2.setAttribute("position", new Yr([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Ql(i2, r3), this.add(this.targetLine), this.update();
    }
    dispose() {
      this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
    }
    update() {
      hp.setFromMatrixPosition(this.light.matrixWorld), cp.setFromMatrixPosition(this.light.target.matrixWorld), dp.subVectors(cp, hp), this.lightPlane.lookAt(cp), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(cp), this.targetLine.scale.z = dp.length();
    }
  }
  const fp = new pi(), mp = new Oo();
  class gp extends nu {
    constructor(t3) {
      const e3 = new so(), n2 = new ql({ color: 16777215, vertexColors: true, toneMapped: false }), i2 = [], r3 = [], o3 = {}, s3 = new Dr(16755200), a2 = new Dr(16711680), l2 = new Dr(43775), u2 = new Dr(16777215), h2 = new Dr(3355443);
      function c2(t4, e4, n3) {
        d2(t4, n3), d2(e4, n3);
      }
      function d2(t4, e4) {
        i2.push(0, 0, 0), r3.push(e4.r, e4.g, e4.b), o3[t4] === void 0 && (o3[t4] = []), o3[t4].push(i2.length / 3 - 1);
      }
      c2("n1", "n2", s3), c2("n2", "n4", s3), c2("n4", "n3", s3), c2("n3", "n1", s3), c2("f1", "f2", s3), c2("f2", "f4", s3), c2("f4", "f3", s3), c2("f3", "f1", s3), c2("n1", "f1", s3), c2("n2", "f2", s3), c2("n3", "f3", s3), c2("n4", "f4", s3), c2("p", "n1", a2), c2("p", "n2", a2), c2("p", "n3", a2), c2("p", "n4", a2), c2("u1", "u2", l2), c2("u2", "u3", l2), c2("u3", "u1", l2), c2("c", "t", u2), c2("p", "c", h2), c2("cn1", "cn2", h2), c2("cn3", "cn4", h2), c2("cf1", "cf2", h2), c2("cf3", "cf4", h2), e3.setAttribute("position", new Yr(i2, 3)), e3.setAttribute("color", new Yr(r3, 3)), super(e3, n2), this.type = "CameraHelper", this.camera = t3, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t3.matrixWorld, this.matrixAutoUpdate = false, this.pointMap = o3, this.update();
    }
    update() {
      const t3 = this.geometry, e3 = this.pointMap;
      mp.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), vp("c", e3, t3, mp, 0, 0, -1), vp("t", e3, t3, mp, 0, 0, 1), vp("n1", e3, t3, mp, -1, -1, -1), vp("n2", e3, t3, mp, 1, -1, -1), vp("n3", e3, t3, mp, -1, 1, -1), vp("n4", e3, t3, mp, 1, 1, -1), vp("f1", e3, t3, mp, -1, -1, 1), vp("f2", e3, t3, mp, 1, -1, 1), vp("f3", e3, t3, mp, -1, 1, 1), vp("f4", e3, t3, mp, 1, 1, 1), vp("u1", e3, t3, mp, 0.7, 1.1, -1), vp("u2", e3, t3, mp, -0.7, 1.1, -1), vp("u3", e3, t3, mp, 0, 2, -1), vp("cf1", e3, t3, mp, -1, 0, 1), vp("cf2", e3, t3, mp, 1, 0, 1), vp("cf3", e3, t3, mp, 0, -1, 1), vp("cf4", e3, t3, mp, 0, 1, 1), vp("cn1", e3, t3, mp, -1, 0, -1), vp("cn2", e3, t3, mp, 1, 0, -1), vp("cn3", e3, t3, mp, 0, -1, -1), vp("cn4", e3, t3, mp, 0, 1, -1), t3.getAttribute("position").needsUpdate = true;
    }
    dispose() {
      this.geometry.dispose(), this.material.dispose();
    }
  }
  function vp(t3, e3, n2, i2, r3, o3, s3) {
    fp.set(r3, o3, s3).unproject(i2);
    const a2 = e3[t3];
    if (a2 !== void 0) {
      const t4 = n2.getAttribute("position");
      for (let e4 = 0, n3 = a2.length; e4 < n3; e4++)
        t4.setXYZ(a2[e4], fp.x, fp.y, fp.z);
    }
  }
  const _p = new gi();
  class yp extends nu {
    constructor(t3, e3 = 16776960) {
      const n2 = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), i2 = new Float32Array(24), r3 = new so();
      r3.setIndex(new kr(n2, 1)), r3.setAttribute("position", new kr(i2, 3)), super(r3, new ql({ color: e3, toneMapped: false })), this.object = t3, this.type = "BoxHelper", this.matrixAutoUpdate = false, this.update();
    }
    update(t3) {
      if (t3 !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && _p.setFromObject(this.object), _p.isEmpty())
        return;
      const e3 = _p.min, n2 = _p.max, i2 = this.geometry.attributes.position, r3 = i2.array;
      r3[0] = n2.x, r3[1] = n2.y, r3[2] = n2.z, r3[3] = e3.x, r3[4] = n2.y, r3[5] = n2.z, r3[6] = e3.x, r3[7] = e3.y, r3[8] = n2.z, r3[9] = n2.x, r3[10] = e3.y, r3[11] = n2.z, r3[12] = n2.x, r3[13] = n2.y, r3[14] = e3.z, r3[15] = e3.x, r3[16] = n2.y, r3[17] = e3.z, r3[18] = e3.x, r3[19] = e3.y, r3[20] = e3.z, r3[21] = n2.x, r3[22] = e3.y, r3[23] = e3.z, i2.needsUpdate = true, this.geometry.computeBoundingSphere();
    }
    setFromObject(t3) {
      return this.object = t3, this.update(), this;
    }
    copy(t3) {
      return nu.prototype.copy.call(this, t3), this.object = t3.object, this;
    }
  }
  class xp extends nu {
    constructor(t3, e3 = 16776960) {
      const n2 = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), i2 = new so();
      i2.setIndex(new kr(n2, 1)), i2.setAttribute("position", new Yr([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), super(i2, new ql({ color: e3, toneMapped: false })), this.box = t3, this.type = "Box3Helper", this.geometry.computeBoundingSphere();
    }
    updateMatrixWorld(t3) {
      const e3 = this.box;
      e3.isEmpty() || (e3.getCenter(this.position), e3.getSize(this.scale), this.scale.multiplyScalar(0.5), super.updateMatrixWorld(t3));
    }
  }
  class bp extends Ql {
    constructor(t3, e3 = 1, n2 = 16776960) {
      const i2 = n2, r3 = new so();
      r3.setAttribute("position", new Yr([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), r3.computeBoundingSphere(), super(r3, new ql({ color: i2, toneMapped: false })), this.type = "PlaneHelper", this.plane = t3, this.size = e3;
      const o3 = new so();
      o3.setAttribute("position", new Yr([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), o3.computeBoundingSphere(), this.add(new Eo(o3, new Fr({ color: i2, opacity: 0.2, transparent: true, depthWrite: false, toneMapped: false })));
    }
    updateMatrixWorld(t3) {
      let e3 = -this.plane.constant;
      Math.abs(e3) < 1e-8 && (e3 = 1e-8), this.scale.set(0.5 * this.size, 0.5 * this.size, e3), this.children[0].material.side = e3 < 0 ? b : x, this.lookAt(this.plane.normal), super.updateMatrixWorld(t3);
    }
  }
  const Tp = new pi();
  let wp, Sp;
  class Ep extends mr {
    constructor(t3 = new pi(0, 0, 1), e3 = new pi(0, 0, 0), n2 = 1, i2 = 16776960, r3 = 0.2 * n2, o3 = 0.2 * r3) {
      super(), this.type = "ArrowHelper", wp === void 0 && (wp = new so(), wp.setAttribute("position", new Yr([0, 0, 0, 0, 1, 0], 3)), Sp = new gu(0, 0.5, 1, 5, 1), Sp.translate(0, -0.5, 0)), this.position.copy(e3), this.line = new Ql(wp, new ql({ color: i2, toneMapped: false })), this.line.matrixAutoUpdate = false, this.add(this.line), this.cone = new Eo(Sp, new Fr({ color: i2, toneMapped: false })), this.cone.matrixAutoUpdate = false, this.add(this.cone), this.setDirection(t3), this.setLength(n2, r3, o3);
    }
    setDirection(t3) {
      if (t3.y > 0.99999)
        this.quaternion.set(0, 0, 0, 1);
      else if (t3.y < -0.99999)
        this.quaternion.set(1, 0, 0, 0);
      else {
        Tp.set(t3.z, 0, -t3.x).normalize();
        const e3 = Math.acos(t3.y);
        this.quaternion.setFromAxisAngle(Tp, e3);
      }
    }
    setLength(t3, e3 = 0.2 * t3, n2 = 0.2 * e3) {
      this.line.scale.set(1, Math.max(1e-4, t3 - e3), 1), this.line.updateMatrix(), this.cone.scale.set(n2, e3, n2), this.cone.position.y = t3, this.cone.updateMatrix();
    }
    setColor(t3) {
      this.line.material.color.set(t3), this.cone.material.color.set(t3);
    }
    copy(t3) {
      return super.copy(t3, false), this.line.copy(t3.line), this.cone.copy(t3.cone), this;
    }
  }
  class Mp extends nu {
    constructor(t3 = 1) {
      const e3 = [0, 0, 0, t3, 0, 0, 0, 0, 0, 0, t3, 0, 0, 0, 0, 0, 0, t3], n2 = new so();
      n2.setAttribute("position", new Yr(e3, 3)), n2.setAttribute("color", new Yr([1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1], 3));
      super(n2, new ql({ vertexColors: true, toneMapped: false })), this.type = "AxesHelper";
    }
    setColors(t3, e3, n2) {
      const i2 = new Dr(), r3 = this.geometry.attributes.color.array;
      return i2.set(t3), i2.toArray(r3, 0), i2.toArray(r3, 3), i2.set(e3), i2.toArray(r3, 6), i2.toArray(r3, 9), i2.set(n2), i2.toArray(r3, 12), i2.toArray(r3, 15), this.geometry.attributes.color.needsUpdate = true, this;
    }
    dispose() {
      this.geometry.dispose(), this.material.dispose();
    }
  }
  const Ap = new Float32Array(1), Rp = new Int32Array(Ap.buffer);
  class Pp {
    static toHalfFloat(t3) {
      Ap[0] = t3;
      const e3 = Rp[0];
      let n2 = e3 >> 16 & 32768, i2 = e3 >> 12 & 2047;
      const r3 = e3 >> 23 & 255;
      return r3 < 103 ? n2 : r3 > 142 ? (n2 |= 31744, n2 |= (r3 == 255 ? 0 : 1) && 8388607 & e3, n2) : r3 < 113 ? (i2 |= 2048, n2 |= (i2 >> 114 - r3) + (i2 >> 113 - r3 & 1), n2) : (n2 |= r3 - 112 << 10 | i2 >> 1, n2 += 1 & i2, n2);
    }
  }
  const Cp = Math.pow(2, 8), Ip = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], Op = 5 + Ip.length, Lp = { [nn]: 0, [rn]: 1, [sn]: 2, [ln]: 3, [un]: 4, [hn]: 5, [on]: 6 }, Np = new Fr({ side: b, depthWrite: false, depthTest: false }), Dp = new Eo(new Ao(), Np), Fp = new Dc(), { _lodPlanes: Bp, _sizeLods: Up, _sigmas: kp } = Yp(), Gp = new Dr();
  let Hp = null;
  const zp = (1 + Math.sqrt(5)) / 2, jp = 1 / zp, Vp = [new pi(1, 1, 1), new pi(-1, 1, 1), new pi(1, 1, -1), new pi(-1, 1, -1), new pi(0, zp, jp), new pi(0, zp, -jp), new pi(jp, 0, zp), new pi(-jp, 0, zp), new pi(zp, jp, 0), new pi(-zp, jp, 0)];
  function Wp(t3) {
    const e3 = Math.max(t3.r, t3.g, t3.b), n2 = Math.min(Math.max(Math.ceil(Math.log2(e3)), -128), 127);
    t3.multiplyScalar(Math.pow(2, -n2));
    return (n2 + 128) / 255;
  }
  class Xp {
    constructor(t3) {
      this._renderer = t3, this._pingPongRenderTarget = null, this._blurMaterial = function(t4) {
        const e3 = new Float32Array(t4), n2 = new pi(0, 1, 0);
        return new Fh({ name: "SphericalGaussianBlur", defines: { n: t4 }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: e3 }, latitudinal: { value: false }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: n2 }, inputEncoding: { value: Lp[nn] }, outputEncoding: { value: Lp[nn] } }, vertexShader: Qp(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${tf()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`, blending: E, depthTest: false, depthWrite: false });
      }(20), this._equirectShader = null, this._cubemapShader = null, this._compileMaterial(this._blurMaterial);
    }
    fromScene(t3, e3 = 0, n2 = 0.1, i2 = 100) {
      Hp = this._renderer.getRenderTarget();
      const r3 = this._allocateTargets();
      return this._sceneToCubeUV(t3, n2, i2, r3), e3 > 0 && this._blur(r3, 0, 0, e3), this._applyPMREM(r3), this._cleanup(r3), r3;
    }
    fromEquirectangular(t3) {
      return this._fromTexture(t3);
    }
    fromCubemap(t3) {
      return this._fromTexture(t3);
    }
    compileCubemapShader() {
      this._cubemapShader === null && (this._cubemapShader = Kp(), this._compileMaterial(this._cubemapShader));
    }
    compileEquirectangularShader() {
      this._equirectShader === null && (this._equirectShader = $p(), this._compileMaterial(this._equirectShader));
    }
    dispose() {
      this._blurMaterial.dispose(), this._cubemapShader !== null && this._cubemapShader.dispose(), this._equirectShader !== null && this._equirectShader.dispose();
      for (let t3 = 0; t3 < Bp.length; t3++)
        Bp[t3].dispose();
    }
    _cleanup(t3) {
      this._pingPongRenderTarget.dispose(), this._renderer.setRenderTarget(Hp), t3.scissorTest = false, Jp(t3, 0, 0, t3.width, t3.height);
    }
    _fromTexture(t3) {
      Hp = this._renderer.getRenderTarget();
      const e3 = this._allocateTargets(t3);
      return this._textureToCubeUV(t3, e3), this._applyPMREM(e3), this._cleanup(e3), e3;
    }
    _allocateTargets(t3) {
      const e3 = { magFilter: xt, minFilter: xt, generateMipmaps: false, type: Ct, format: qt, encoding: qp(t3) ? t3.encoding : sn, depthBuffer: false }, n2 = Zp(e3);
      return n2.depthBuffer = !t3, this._pingPongRenderTarget = Zp(e3), n2;
    }
    _compileMaterial(t3) {
      const e3 = new Eo(Bp[0], t3);
      this._renderer.compile(e3, Fp);
    }
    _sceneToCubeUV(t3, e3, n2, i2) {
      const r3 = new Lo(90, 1, e3, n2), o3 = [1, -1, 1, 1, 1, 1], s3 = [1, 1, 1, -1, -1, -1], a2 = this._renderer, l2 = a2.autoClear, u2 = a2.outputEncoding, h2 = a2.toneMapping;
      a2.getClearColor(Gp), a2.toneMapping = rt, a2.outputEncoding = nn, a2.autoClear = false;
      let c2 = false;
      const d2 = t3.background;
      if (d2) {
        if (d2.isColor) {
          Np.color.copy(d2).convertSRGBToLinear(), t3.background = null;
          const e4 = Wp(Np.color);
          Np.opacity = e4, c2 = true;
        }
      } else {
        Np.color.copy(Gp).convertSRGBToLinear();
        const t4 = Wp(Np.color);
        Np.opacity = t4, c2 = true;
      }
      for (let e4 = 0; e4 < 6; e4++) {
        const n3 = e4 % 3;
        n3 == 0 ? (r3.up.set(0, o3[e4], 0), r3.lookAt(s3[e4], 0, 0)) : n3 == 1 ? (r3.up.set(0, 0, o3[e4]), r3.lookAt(0, s3[e4], 0)) : (r3.up.set(0, o3[e4], 0), r3.lookAt(0, 0, s3[e4])), Jp(i2, n3 * Cp, e4 > 2 ? Cp : 0, Cp, Cp), a2.setRenderTarget(i2), c2 && a2.render(Dp, r3), a2.render(t3, r3);
      }
      a2.toneMapping = h2, a2.outputEncoding = u2, a2.autoClear = l2;
    }
    _textureToCubeUV(t3, e3) {
      const n2 = this._renderer;
      t3.isCubeTexture ? this._cubemapShader == null && (this._cubemapShader = Kp()) : this._equirectShader == null && (this._equirectShader = $p());
      const i2 = t3.isCubeTexture ? this._cubemapShader : this._equirectShader, r3 = new Eo(Bp[0], i2), o3 = i2.uniforms;
      o3.envMap.value = t3, t3.isCubeTexture || o3.texelSize.value.set(1 / t3.image.width, 1 / t3.image.height), o3.inputEncoding.value = Lp[t3.encoding], o3.outputEncoding.value = Lp[e3.texture.encoding], Jp(e3, 0, 0, 3 * Cp, 2 * Cp), n2.setRenderTarget(e3), n2.render(r3, Fp);
    }
    _applyPMREM(t3) {
      const e3 = this._renderer, n2 = e3.autoClear;
      e3.autoClear = false;
      for (let e4 = 1; e4 < Op; e4++) {
        const n3 = Math.sqrt(kp[e4] * kp[e4] - kp[e4 - 1] * kp[e4 - 1]), i2 = Vp[(e4 - 1) % Vp.length];
        this._blur(t3, e4 - 1, e4, n3, i2);
      }
      e3.autoClear = n2;
    }
    _blur(t3, e3, n2, i2, r3) {
      const o3 = this._pingPongRenderTarget;
      this._halfBlur(t3, o3, e3, n2, i2, "latitudinal", r3), this._halfBlur(o3, t3, n2, n2, i2, "longitudinal", r3);
    }
    _halfBlur(t3, e3, n2, i2, r3, o3, s3) {
      const a2 = this._renderer, l2 = this._blurMaterial;
      o3 !== "latitudinal" && o3 !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
      const u2 = new Eo(Bp[i2], l2), h2 = l2.uniforms, c2 = Up[n2] - 1, d2 = isFinite(r3) ? Math.PI / (2 * c2) : 2 * Math.PI / 39, p2 = r3 / d2, f2 = isFinite(r3) ? 1 + Math.floor(3 * p2) : 20;
      f2 > 20 && console.warn(`sigmaRadians, ${r3}, is too large and will clip, as it requested ${f2} samples when the maximum is set to 20`);
      const m2 = [];
      let g2 = 0;
      for (let t4 = 0; t4 < 20; ++t4) {
        const e4 = t4 / p2, n3 = Math.exp(-e4 * e4 / 2);
        m2.push(n3), t4 == 0 ? g2 += n3 : t4 < f2 && (g2 += 2 * n3);
      }
      for (let t4 = 0; t4 < m2.length; t4++)
        m2[t4] = m2[t4] / g2;
      h2.envMap.value = t3.texture, h2.samples.value = f2, h2.weights.value = m2, h2.latitudinal.value = o3 === "latitudinal", s3 && (h2.poleAxis.value = s3), h2.dTheta.value = d2, h2.mipInt.value = 8 - n2, h2.inputEncoding.value = Lp[t3.texture.encoding], h2.outputEncoding.value = Lp[t3.texture.encoding];
      const v2 = Up[i2];
      Jp(e3, 3 * Math.max(0, Cp - 2 * v2), (i2 === 0 ? 0 : 2 * Cp) + 2 * v2 * (i2 > 4 ? i2 - 8 + 4 : 0), 3 * v2, 2 * v2), a2.setRenderTarget(e3), a2.render(u2, Fp);
    }
  }
  function qp(t3) {
    return t3 !== void 0 && t3.type === Ct && (t3.encoding === nn || t3.encoding === rn || t3.encoding === on);
  }
  function Yp() {
    const t3 = [], e3 = [], n2 = [];
    let i2 = 8;
    for (let r3 = 0; r3 < Op; r3++) {
      const o3 = Math.pow(2, i2);
      e3.push(o3);
      let s3 = 1 / o3;
      r3 > 4 ? s3 = Ip[r3 - 8 + 4 - 1] : r3 == 0 && (s3 = 0), n2.push(s3);
      const a2 = 1 / (o3 - 1), l2 = -a2 / 2, u2 = 1 + a2 / 2, h2 = [l2, l2, u2, l2, u2, u2, l2, l2, u2, u2, l2, u2], c2 = 6, d2 = 6, p2 = 3, f2 = 2, m2 = 1, g2 = new Float32Array(p2 * d2 * c2), v2 = new Float32Array(f2 * d2 * c2), _2 = new Float32Array(m2 * d2 * c2);
      for (let t4 = 0; t4 < c2; t4++) {
        const e4 = t4 % 3 * 2 / 3 - 1, n3 = t4 > 2 ? 0 : -1, i3 = [e4, n3, 0, e4 + 2 / 3, n3, 0, e4 + 2 / 3, n3 + 1, 0, e4, n3, 0, e4 + 2 / 3, n3 + 1, 0, e4, n3 + 1, 0];
        g2.set(i3, p2 * d2 * t4), v2.set(h2, f2 * d2 * t4);
        const r4 = [t4, t4, t4, t4, t4, t4];
        _2.set(r4, m2 * d2 * t4);
      }
      const y2 = new so();
      y2.setAttribute("position", new kr(g2, p2)), y2.setAttribute("uv", new kr(v2, f2)), y2.setAttribute("faceIndex", new kr(_2, m2)), t3.push(y2), i2 > 4 && i2--;
    }
    return { _lodPlanes: t3, _sizeLods: e3, _sigmas: n2 };
  }
  function Zp(t3) {
    const e3 = new ui(3 * Cp, 3 * Cp, t3);
    return e3.texture.mapping = mt, e3.texture.name = "PMREM.cubeUv", e3.scissorTest = true, e3;
  }
  function Jp(t3, e3, n2, i2, r3) {
    t3.viewport.set(e3, n2, i2, r3), t3.scissor.set(e3, n2, i2, r3);
  }
  function $p() {
    const t3 = new ei(1, 1);
    return new Fh({ name: "EquirectangularToCubeUV", uniforms: { envMap: { value: null }, texelSize: { value: t3 }, inputEncoding: { value: Lp[nn] }, outputEncoding: { value: Lp[nn] } }, vertexShader: Qp(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${tf()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`, blending: E, depthTest: false, depthWrite: false });
  }
  function Kp() {
    return new Fh({ name: "CubemapToCubeUV", uniforms: { envMap: { value: null }, inputEncoding: { value: Lp[nn] }, outputEncoding: { value: Lp[nn] } }, vertexShader: Qp(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${tf()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`, blending: E, depthTest: false, depthWrite: false });
  }
  function Qp() {
    return "\n\n		precision mediump float;\n		precision mediump int;\n\n		attribute vec3 position;\n		attribute vec2 uv;\n		attribute float faceIndex;\n\n		varying vec3 vOutputDirection;\n\n		// RH coordinate system; PMREM face-indexing convention\n		vec3 getDirection( vec2 uv, float face ) {\n\n			uv = 2.0 * uv - 1.0;\n\n			vec3 direction = vec3( uv, 1.0 );\n\n			if ( face == 0.0 ) {\n\n				direction = direction.zyx; // ( 1, v, u ) pos x\n\n			} else if ( face == 1.0 ) {\n\n				direction = direction.xzy;\n				direction.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n			} else if ( face == 2.0 ) {\n\n				direction.x *= -1.0; // ( -u, v, 1 ) pos z\n\n			} else if ( face == 3.0 ) {\n\n				direction = direction.zyx;\n				direction.xz *= -1.0; // ( -1, v, -u ) neg x\n\n			} else if ( face == 4.0 ) {\n\n				direction = direction.xzy;\n				direction.xy *= -1.0; // ( -u, -1, v ) neg y\n\n			} else if ( face == 5.0 ) {\n\n				direction.z *= -1.0; // ( u, v, -1 ) neg z\n\n			}\n\n			return direction;\n\n		}\n\n		void main() {\n\n			vOutputDirection = getDirection( uv, faceIndex );\n			gl_Position = vec4( position, 1.0 );\n\n		}\n	";
  }
  function tf() {
    return "\n\n		uniform int inputEncoding;\n		uniform int outputEncoding;\n\n		#include <encodings_pars_fragment>\n\n		vec4 inputTexelToLinear( vec4 value ) {\n\n			if ( inputEncoding == 0 ) {\n\n				return value;\n\n			} else if ( inputEncoding == 1 ) {\n\n				return sRGBToLinear( value );\n\n			} else if ( inputEncoding == 2 ) {\n\n				return RGBEToLinear( value );\n\n			} else if ( inputEncoding == 3 ) {\n\n				return RGBMToLinear( value, 7.0 );\n\n			} else if ( inputEncoding == 4 ) {\n\n				return RGBMToLinear( value, 16.0 );\n\n			} else if ( inputEncoding == 5 ) {\n\n				return RGBDToLinear( value, 256.0 );\n\n			} else {\n\n				return GammaToLinear( value, 2.2 );\n\n			}\n\n		}\n\n		vec4 linearToOutputTexel( vec4 value ) {\n\n			if ( outputEncoding == 0 ) {\n\n				return value;\n\n			} else if ( outputEncoding == 1 ) {\n\n				return LinearTosRGB( value );\n\n			} else if ( outputEncoding == 2 ) {\n\n				return LinearToRGBE( value );\n\n			} else if ( outputEncoding == 3 ) {\n\n				return LinearToRGBM( value, 7.0 );\n\n			} else if ( outputEncoding == 4 ) {\n\n				return LinearToRGBM( value, 16.0 );\n\n			} else if ( outputEncoding == 5 ) {\n\n				return LinearToRGBD( value, 256.0 );\n\n			} else {\n\n				return LinearToGamma( value, 2.2 );\n\n			}\n\n		}\n\n		vec4 envMapTexelToLinear( vec4 color ) {\n\n			return inputTexelToLinear( color );\n\n		}\n	";
  }
  const ef = 0, nf = 1, rf = 0, of = 1, sf = 2;
  function af(t3) {
    return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), t3;
  }
  function lf(t3 = []) {
    return console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), t3.isMultiMaterial = true, t3.materials = t3, t3.clone = function() {
      return t3.slice();
    }, t3;
  }
  function uf(t3, e3) {
    return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new uu(t3, e3);
  }
  function hf(t3) {
    return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new Ml(t3);
  }
  function cf(t3, e3) {
    return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new uu(t3, e3);
  }
  function df(t3) {
    return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new ru(t3);
  }
  function pf(t3) {
    return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new ru(t3);
  }
  function ff(t3) {
    return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new ru(t3);
  }
  function mf(t3, e3, n2) {
    return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new pi(t3, e3, n2);
  }
  function gf(t3, e3) {
    return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."), new kr(t3, e3).setUsage(On);
  }
  function vf(t3, e3) {
    return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new Gr(t3, e3);
  }
  function _f(t3, e3) {
    return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new Hr(t3, e3);
  }
  function yf(t3, e3) {
    return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new zr(t3, e3);
  }
  function xf(t3, e3) {
    return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new jr(t3, e3);
  }
  function bf(t3, e3) {
    return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new Vr(t3, e3);
  }
  function Tf(t3, e3) {
    return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new Wr(t3, e3);
  }
  function wf(t3, e3) {
    return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new Xr(t3, e3);
  }
  function Sf(t3, e3) {
    return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new Yr(t3, e3);
  }
  function Ef(t3, e3) {
    return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new Zr(t3, e3);
  }
  function Mf(t3) {
    return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new Mp(t3);
  }
  function Af(t3, e3) {
    return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new yp(t3, e3);
  }
  function Rf(t3, e3) {
    return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new nu(new Su(t3.geometry), new ql({ color: e3 !== void 0 ? e3 : 16777215 }));
  }
  function Pf(t3, e3) {
    return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new nu(new Lh(t3.geometry), new ql({ color: e3 !== void 0 ? e3 : 16777215 }));
  }
  function Cf(t3) {
    return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new dc(t3);
  }
  function If(t3) {
    return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new vc(t3);
  }
  function Of(t3, e3, n2) {
    return console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."), new Fo(t3, n2);
  }
  function Lf() {
    console.error("THREE.CanvasRenderer has been removed");
  }
  function Nf() {
    console.error("THREE.JSONLoader has been removed.");
  }
  Eu.create = function(t3, e3) {
    return console.log("THREE.Curve.create() has been deprecated"), t3.prototype = Object.create(Eu.prototype), t3.prototype.constructor = t3, t3.prototype.getPoint = e3, t3;
  }, xc.prototype.fromPoints = function(t3) {
    return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t3);
  }, lp.prototype.setColors = function() {
    console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
  }, np.prototype.update = function() {
    console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
  }, hc.prototype.extractUrlBase = function(t3) {
    return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), jc.extractUrlBase(t3);
  }, hc.Handlers = { add: function() {
    console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
  }, get: function() {
    console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
  } }, Xd.prototype.center = function(t3) {
    return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t3);
  }, Xd.prototype.empty = function() {
    return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty();
  }, Xd.prototype.isIntersectionBox = function(t3) {
    return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t3);
  }, Xd.prototype.size = function(t3) {
    return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t3);
  }, gi.prototype.center = function(t3) {
    return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t3);
  }, gi.prototype.empty = function() {
    return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty();
  }, gi.prototype.isIntersectionBox = function(t3) {
    return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t3);
  }, gi.prototype.isIntersectionSphere = function(t3) {
    return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t3);
  }, gi.prototype.size = function(t3) {
    return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t3);
  }, Di.prototype.empty = function() {
    return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty();
  }, jo.prototype.setFromMatrix = function(t3) {
    return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(t3);
  }, Zd.prototype.center = function(t3) {
    return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(t3);
  }, ni.prototype.flattenToArrayOffset = function(t3, e3) {
    return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t3, e3);
  }, ni.prototype.multiplyVector3 = function(t3) {
    return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t3.applyMatrix3(this);
  }, ni.prototype.multiplyVector3Array = function() {
    console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
  }, ni.prototype.applyToBufferAttribute = function(t3) {
    return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), t3.applyMatrix3(this);
  }, ni.prototype.applyToVector3Array = function() {
    console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
  }, ni.prototype.getInverse = function(t3) {
    return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t3).invert();
  }, Vi.prototype.extractPosition = function(t3) {
    return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t3);
  }, Vi.prototype.flattenToArrayOffset = function(t3, e3) {
    return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t3, e3);
  }, Vi.prototype.getPosition = function() {
    return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), new pi().setFromMatrixColumn(this, 3);
  }, Vi.prototype.setRotationFromQuaternion = function(t3) {
    return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t3);
  }, Vi.prototype.multiplyToArray = function() {
    console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
  }, Vi.prototype.multiplyVector3 = function(t3) {
    return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t3.applyMatrix4(this);
  }, Vi.prototype.multiplyVector4 = function(t3) {
    return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t3.applyMatrix4(this);
  }, Vi.prototype.multiplyVector3Array = function() {
    console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
  }, Vi.prototype.rotateAxis = function(t3) {
    console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t3.transformDirection(this);
  }, Vi.prototype.crossVector = function(t3) {
    return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t3.applyMatrix4(this);
  }, Vi.prototype.translate = function() {
    console.error("THREE.Matrix4: .translate() has been removed.");
  }, Vi.prototype.rotateX = function() {
    console.error("THREE.Matrix4: .rotateX() has been removed.");
  }, Vi.prototype.rotateY = function() {
    console.error("THREE.Matrix4: .rotateY() has been removed.");
  }, Vi.prototype.rotateZ = function() {
    console.error("THREE.Matrix4: .rotateZ() has been removed.");
  }, Vi.prototype.rotateByAxis = function() {
    console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
  }, Vi.prototype.applyToBufferAttribute = function(t3) {
    return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), t3.applyMatrix4(this);
  }, Vi.prototype.applyToVector3Array = function() {
    console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
  }, Vi.prototype.makeFrustum = function(t3, e3, n2, i2, r3, o3) {
    return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t3, e3, i2, n2, r3, o3);
  }, Vi.prototype.getInverse = function(t3) {
    return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t3).invert();
  }, Go.prototype.isIntersectionLine = function(t3) {
    return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t3);
  }, di.prototype.multiplyVector3 = function(t3) {
    return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t3.applyQuaternion(this);
  }, di.prototype.inverse = function() {
    return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."), this.invert();
  }, ji.prototype.isIntersectionBox = function(t3) {
    return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t3);
  }, ji.prototype.isIntersectionPlane = function(t3) {
    return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t3);
  }, ji.prototype.isIntersectionSphere = function(t3) {
    return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t3);
  }, Mr.prototype.area = function() {
    return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea();
  }, Mr.prototype.barycoordFromPoint = function(t3, e3) {
    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t3, e3);
  }, Mr.prototype.midpoint = function(t3) {
    return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t3);
  }, Mr.prototypenormal = function(t3) {
    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t3);
  }, Mr.prototype.plane = function(t3) {
    return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t3);
  }, Mr.barycoordFromPoint = function(t3, e3, n2, i2, r3) {
    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), Mr.getBarycoord(t3, e3, n2, i2, r3);
  }, Mr.normal = function(t3, e3, n2, i2) {
    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), Mr.getNormal(t3, e3, n2, i2);
  }, bc.prototype.extractAllPoints = function(t3) {
    return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t3);
  }, bc.prototype.extrude = function(t3) {
    return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new yh(this, t3);
  }, bc.prototype.makeGeometry = function(t3) {
    return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new Mh(this, t3);
  }, ei.prototype.fromAttribute = function(t3, e3, n2) {
    return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t3, e3, n2);
  }, ei.prototype.distanceToManhattan = function(t3) {
    return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t3);
  }, ei.prototype.lengthManhattan = function() {
    return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
  }, pi.prototype.setEulerFromRotationMatrix = function() {
    console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
  }, pi.prototype.setEulerFromQuaternion = function() {
    console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
  }, pi.prototype.getPositionFromMatrix = function(t3) {
    return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t3);
  }, pi.prototype.getScaleFromMatrix = function(t3) {
    return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t3);
  }, pi.prototype.getColumnFromMatrix = function(t3, e3) {
    return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e3, t3);
  }, pi.prototype.applyProjection = function(t3) {
    return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t3);
  }, pi.prototype.fromAttribute = function(t3, e3, n2) {
    return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t3, e3, n2);
  }, pi.prototype.distanceToManhattan = function(t3) {
    return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t3);
  }, pi.prototype.lengthManhattan = function() {
    return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
  }, li.prototype.fromAttribute = function(t3, e3, n2) {
    return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t3, e3, n2);
  }, li.prototype.lengthManhattan = function() {
    return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
  }, mr.prototype.getChildByName = function(t3) {
    return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t3);
  }, mr.prototype.renderDepth = function() {
    console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
  }, mr.prototype.translate = function(t3, e3) {
    return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e3, t3);
  }, mr.prototype.getWorldRotation = function() {
    console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
  }, mr.prototype.applyMatrix = function(t3) {
    return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t3);
  }, Object.defineProperties(mr.prototype, { eulerOrder: { get: function() {
    return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order;
  }, set: function(t3) {
    console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t3;
  } }, useQuaternion: { get: function() {
    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
  }, set: function() {
    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
  } } }), Eo.prototype.setDrawMode = function() {
    console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
  }, Object.defineProperties(Eo.prototype, { drawMode: { get: function() {
    return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), Qe;
  }, set: function() {
    console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
  } } }), Fl.prototype.initBones = function() {
    console.error("THREE.SkinnedMesh: initBones() has been removed.");
  }, Lo.prototype.setLens = function(t3, e3) {
    console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), e3 !== void 0 && (this.filmGauge = e3), this.setFocalLength(t3);
  }, Object.defineProperties(Tc.prototype, { onlyShadow: { set: function() {
    console.warn("THREE.Light: .onlyShadow has been removed.");
  } }, shadowCameraFov: { set: function(t3) {
    console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t3;
  } }, shadowCameraLeft: { set: function(t3) {
    console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t3;
  } }, shadowCameraRight: { set: function(t3) {
    console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t3;
  } }, shadowCameraTop: { set: function(t3) {
    console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t3;
  } }, shadowCameraBottom: { set: function(t3) {
    console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t3;
  } }, shadowCameraNear: { set: function(t3) {
    console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t3;
  } }, shadowCameraFar: { set: function(t3) {
    console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t3;
  } }, shadowCameraVisible: { set: function() {
    console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
  } }, shadowBias: { set: function(t3) {
    console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t3;
  } }, shadowDarkness: { set: function() {
    console.warn("THREE.Light: .shadowDarkness has been removed.");
  } }, shadowMapWidth: { set: function(t3) {
    console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t3;
  } }, shadowMapHeight: { set: function(t3) {
    console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t3;
  } } }), Object.defineProperties(kr.prototype, { length: { get: function() {
    return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length;
  } }, dynamic: { get: function() {
    return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === On;
  }, set: function() {
    console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(On);
  } } }), kr.prototype.setDynamic = function(t3) {
    return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(t3 === true ? On : In), this;
  }, kr.prototype.copyIndicesArray = function() {
    console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
  }, kr.prototype.setArray = function() {
    console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
  }, so.prototype.addIndex = function(t3) {
    console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t3);
  }, so.prototype.addAttribute = function(t3, e3) {
    return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), e3 && e3.isBufferAttribute || e3 && e3.isInterleavedBufferAttribute ? t3 === "index" ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e3), this) : this.setAttribute(t3, e3) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(t3, new kr(arguments[1], arguments[2])));
  }, so.prototype.addDrawCall = function(t3, e3, n2) {
    n2 !== void 0 && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t3, e3);
  }, so.prototype.clearDrawCalls = function() {
    console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups();
  }, so.prototype.computeOffsets = function() {
    console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
  }, so.prototype.removeAttribute = function(t3) {
    return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(t3);
  }, so.prototype.applyMatrix = function(t3) {
    return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t3);
  }, Object.defineProperties(so.prototype, { drawcalls: { get: function() {
    return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups;
  } }, offsets: { get: function() {
    return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups;
  } } }), ul.prototype.setDynamic = function(t3) {
    return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(t3 === true ? On : In), this;
  }, ul.prototype.setArray = function() {
    console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
  }, yh.prototype.getArrays = function() {
    console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.");
  }, yh.prototype.addShapeList = function() {
    console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.");
  }, yh.prototype.addShape = function() {
    console.error("THREE.ExtrudeGeometry: .addShape() has been removed.");
  }, ll.prototype.dispose = function() {
    console.error("THREE.Scene: .dispose() has been removed.");
  }, Bd.prototype.onUpdate = function() {
    return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this;
  }, Object.defineProperties(Rr.prototype, { wrapAround: { get: function() {
    console.warn("THREE.Material: .wrapAround has been removed.");
  }, set: function() {
    console.warn("THREE.Material: .wrapAround has been removed.");
  } }, overdraw: { get: function() {
    console.warn("THREE.Material: .overdraw has been removed.");
  }, set: function() {
    console.warn("THREE.Material: .overdraw has been removed.");
  } }, wrapRGB: { get: function() {
    return console.warn("THREE.Material: .wrapRGB has been removed."), new Dr();
  } }, shading: { get: function() {
    console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
  }, set: function(t3) {
    console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = t3 === w;
  } }, stencilMask: { get: function() {
    return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask;
  }, set: function(t3) {
    console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = t3;
  } } }), Object.defineProperties(Io.prototype, { derivatives: { get: function() {
    return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives;
  }, set: function(t3) {
    console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t3;
  } } }), rl.prototype.clearTarget = function(t3, e3, n2, i2) {
    console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t3), this.clear(e3, n2, i2);
  }, rl.prototype.animate = function(t3) {
    console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t3);
  }, rl.prototype.getCurrentRenderTarget = function() {
    return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget();
  }, rl.prototype.getMaxAnisotropy = function() {
    return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy();
  }, rl.prototype.getPrecision = function() {
    return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision;
  }, rl.prototype.resetGLState = function() {
    return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset();
  }, rl.prototype.supportsFloatTextures = function() {
    return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float");
  }, rl.prototype.supportsHalfFloatTextures = function() {
    return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float");
  }, rl.prototype.supportsStandardDerivatives = function() {
    return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives");
  }, rl.prototype.supportsCompressedTextureS3TC = function() {
    return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc");
  }, rl.prototype.supportsCompressedTexturePVRTC = function() {
    return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc");
  }, rl.prototype.supportsBlendMinMax = function() {
    return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax");
  }, rl.prototype.supportsVertexTextures = function() {
    return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures;
  }, rl.prototype.supportsInstancedArrays = function() {
    return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays");
  }, rl.prototype.enableScissorTest = function(t3) {
    console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t3);
  }, rl.prototype.initMaterial = function() {
    console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
  }, rl.prototype.addPrePlugin = function() {
    console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
  }, rl.prototype.addPostPlugin = function() {
    console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
  }, rl.prototype.updateShadowMap = function() {
    console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
  }, rl.prototype.setFaceCulling = function() {
    console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
  }, rl.prototype.allocTextureUnit = function() {
    console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
  }, rl.prototype.setTexture = function() {
    console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
  }, rl.prototype.setTexture2D = function() {
    console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
  }, rl.prototype.setTextureCube = function() {
    console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
  }, rl.prototype.getActiveMipMapLevel = function() {
    return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel();
  }, Object.defineProperties(rl.prototype, { shadowMapEnabled: { get: function() {
    return this.shadowMap.enabled;
  }, set: function(t3) {
    console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t3;
  } }, shadowMapType: { get: function() {
    return this.shadowMap.type;
  }, set: function(t3) {
    console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t3;
  } }, shadowMapCullFace: { get: function() {
    console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
  }, set: function() {
    console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
  } }, context: { get: function() {
    return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext();
  } }, vr: { get: function() {
    return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr;
  } }, gammaInput: { get: function() {
    return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), false;
  }, set: function() {
    console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
  } }, gammaOutput: { get: function() {
    return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), false;
  }, set: function(t3) {
    console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = t3 === true ? rn : nn;
  } }, toneMappingWhitePoint: { get: function() {
    return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1;
  }, set: function() {
    console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
  } } }), Object.defineProperties(Ya.prototype, { cullFace: { get: function() {
    console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
  }, set: function() {
    console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
  } }, renderReverseSided: { get: function() {
    console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
  }, set: function() {
    console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
  } }, renderSingleSided: { get: function() {
    console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
  }, set: function() {
    console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
  } } }), Object.defineProperties(ui.prototype, { wrapS: { get: function() {
    return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS;
  }, set: function(t3) {
    console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t3;
  } }, wrapT: { get: function() {
    return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT;
  }, set: function(t3) {
    console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t3;
  } }, magFilter: { get: function() {
    return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter;
  }, set: function(t3) {
    console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t3;
  } }, minFilter: { get: function() {
    return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter;
  }, set: function(t3) {
    console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t3;
  } }, anisotropy: { get: function() {
    return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy;
  }, set: function(t3) {
    console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t3;
  } }, offset: { get: function() {
    return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset;
  }, set: function(t3) {
    console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t3;
  } }, repeat: { get: function() {
    return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat;
  }, set: function(t3) {
    console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t3;
  } }, format: { get: function() {
    return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format;
  }, set: function(t3) {
    console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t3;
  } }, type: { get: function() {
    return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type;
  }, set: function(t3) {
    console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t3;
  } }, generateMipmaps: { get: function() {
    return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps;
  }, set: function(t3) {
    console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t3;
  } } }), vd.prototype.load = function(t3) {
    console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
    const e3 = this;
    return new rd().load(t3, function(t4) {
      e3.setBuffer(t4);
    }), this;
  }, wd.prototype.getData = function() {
    return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData();
  }, No.prototype.updateCubeMap = function(t3, e3) {
    return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t3, e3);
  }, No.prototype.clear = function(t3, e3, n2, i2) {
    return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(t3, e3, n2, i2);
  }, ri.crossOrigin = void 0, ri.loadTexture = function(t3, e3, n2, i2) {
    console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
    const r3 = new _c();
    r3.setCrossOrigin(this.crossOrigin);
    const o3 = r3.load(t3, n2, void 0, i2);
    return e3 && (o3.mapping = e3), o3;
  }, ri.loadTextureCube = function(t3, e3, n2, i2) {
    console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
    const r3 = new gc();
    r3.setCrossOrigin(this.crossOrigin);
    const o3 = r3.load(t3, n2, void 0, i2);
    return e3 && (o3.mapping = e3), o3;
  }, ri.loadCompressedTexture = function() {
    console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
  }, ri.loadCompressedTextureCube = function() {
    console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
  };
  const Df = { createMultiMaterialObject: function() {
    console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
  }, detach: function() {
    console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
  }, attach: function() {
    console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
  } };
  function Ff() {
    console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js");
  }
  typeof __THREE_DEVTOOLS__ != "undefined" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: u } })), typeof window != "undefined" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = u);
  class Bf {
    constructor() {
      this.camera = new Dc(10, 10, 10, 10), this.camera.position.z = 100, this.camera.position.x = 0, this.camera.position.y = 0;
    }
    focus(t3, e3) {
      t3.position.z = 50;
    }
    updateAspect(t3, e3) {
      this.camera.left = -1 * t3 / 2, this.camera.right = t3 / 2, this.camera.top = e3 / 2, this.camera.bottom = -1 * e3 / 2, this.camera.updateProjectionMatrix();
    }
  }
  class Uf {
    constructor() {
      this.camera = new Bf(), this.mesh = new Eo(), this.material = null, this.geometry = null;
    }
    addObjects(t3) {
      this.mesh.position.z = 50, t3.add(this.mesh);
    }
    setTexture(t3, e3, n2, i2) {
      this.camera.updateAspect(n2, i2), this.geometry = new Xo(n2, i2, 1, 1), this.material = new Io({ fragmentShader: this.fragmentShader, vertexShader: "\nvarying vec2 vUv;\nvoid main(){\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n" }), this.material.uniforms = { width: { value: n2 }, height: { value: i2 }, texturePrev: { value: t3 }, textureNext: { value: e3 }, timePercent: { value: 0 } }, this.mesh.geometry = this.geometry, this.mesh.material = this.material;
    }
    updateAnimation(t3) {
      this.material.uniforms.timePercent.value = t3;
    }
    dispose() {
      var t3, e3;
      (t3 = this.geometry) === null || t3 === void 0 || t3.dispose(), (e3 = this.material) === null || e3 === void 0 || e3.dispose();
    }
  }
  var kf = n(11), Gf = n.n(kf), Hf = n(12), zf = n.n(Hf);
  var jf = n(13), Vf = n.n(jf);
  var Wf = n(14), Xf = n.n(Wf);
  var qf = n(15), Yf = n.n(qf);
  var Zf = n(16), Jf = n.n(Zf);
  var $f = n(17), Kf = n.n($f);
  var Qf = n(18), tm = n.n(Qf);
  var em = n(19), nm = n.n(em);
  var im = n(20), rm = n.n(im);
  var om = n(21), sm = n.n(om);
  var am = n(22), lm = n.n(am);
  var um = n(23), hm = n.n(um);
  var cm = n(24), dm = n.n(cm);
  class pm {
    constructor() {
      this.camera = new Lo(60, 1, 1, 2e3), this.camera.position.z = 1e3, this.camera.position.x = 0, this.camera.position.y = 0;
    }
    updateAspect(t3, e3) {
      this.camera.aspect = t3 / e3, this.camera.updateProjectionMatrix();
    }
    focus(t3, e3) {
      const n2 = 0.5 * e3 / Math.tan(Math.PI / 6);
      t3.position.z = 1e3 - n2;
    }
  }
  class fm {
    constructor() {
      this.geometry = new so(), this.material = null, this.camera = new pm(), this.mesh = new Eo(), this.textureWidth = 0, this.textureHeight = 0, this.prevTexture = new si(), this.nextTexture = new si();
    }
    horizontalSegments() {
      return Math.ceil(this.verticalSegments * this.textureWidth / this.textureHeight);
    }
    initMesh(t3, e3) {
      const n2 = [], i2 = [], r3 = [], o3 = this.verticalSegments, s3 = this.horizontalSegments(), a2 = t3 / 2, l2 = e3 / 2, u2 = t3 / s3, h2 = e3 / o3, c2 = this.extraAttributes(), d2 = Object.keys(c2), p2 = d2.reduce((t4, e4) => (t4[e4] = [], t4), {});
      for (let t4 = 0; t4 < o3; t4++) {
        const e4 = t4 * h2 - l2;
        for (let n3 = 0; n3 < s3; n3++) {
          const l3 = n3 * u2 - a2;
          i2.push(l3, -e4, 0), r3.push(1 * n3 / s3, 1 - 1 * t4 / o3), d2.forEach((e5) => p2[e5].push(...c2[e5].generator(t4, n3))), i2.push(l3 + u2, -e4, 0), r3.push(1 * (n3 + 1) / s3, 1 - 1 * t4 / o3), d2.forEach((e5) => p2[e5].push(...c2[e5].generator(t4, n3))), i2.push(l3, -e4 - h2, 0), r3.push(1 * n3 / s3, 1 - 1 * (t4 + 1) / o3), d2.forEach((e5) => p2[e5].push(...c2[e5].generator(t4, n3))), i2.push(l3 + u2, -e4 - h2, 0), r3.push(1 * (n3 + 1) / s3, 1 - 1 * (t4 + 1) / o3), d2.forEach((e5) => p2[e5].push(...c2[e5].generator(t4, n3)));
        }
      }
      for (let t4 = 0; t4 < o3 * s3; t4++) {
        const e4 = 4 * t4, i3 = e4 + 1, r4 = e4 + 2, o4 = e4 + 3;
        n2.push(i3, e4, o4), n2.push(e4, r4, o4);
      }
      return this.geometry.setIndex(n2), this.geometry.setAttribute("position", new Yr(i2, 3)), this.geometry.setAttribute("uv", new Yr(new Float32Array(r3), 2)), d2.forEach((t4) => {
        this.geometry.setAttribute(t4, new Yr(new Float32Array(p2[t4]), c2[t4].itemSize));
      }), { verticalSegments: o3, horizontalSegments: s3, segmentWidth: u2, segmentHeight: h2 };
    }
    initObject() {
      this.material = new Io({ fragmentShader: this.fragmentShader, vertexShader: this.vertexShader, side: T });
    }
    setTexture(t3, e3, n2, i2) {
      this.textureHeight = i2, this.textureWidth = n2, this.prevTexture = t3, this.nextTexture = e3, this.initObject();
      const { verticalSegments: r3, horizontalSegments: o3, segmentWidth: s3, segmentHeight: a2 } = this.initMesh(n2, i2);
      this.material.uniforms = { segmentWidth: { value: s3 }, segmentHeight: { value: a2 }, verticalSegments: { value: r3 }, horizontalSegments: { value: o3 }, timePercent: { value: 0 }, texturePrev: { value: t3 }, textureNext: { value: e3 } }, this.mesh.geometry = this.geometry, this.camera.updateAspect(n2, i2), this.camera.focus(this.mesh, i2), this.material.transparent = true, this.mesh.material = this.material;
    }
    addObjects(t3) {
      t3.add(this.mesh);
    }
    updateAnimation(t3) {
      this.material.uniforms.timePercent.value = t3;
    }
    dispose() {
      var t3, e3;
      (t3 = this.geometry) === null || t3 === void 0 || t3.dispose(), (e3 = this.material) === null || e3 === void 0 || e3.dispose();
    }
  }
  var mm = n(25), gm = n.n(mm), vm = n(26), _m = n.n(vm);
  var ym = n(27), xm = n.n(ym), bm = n(28), Tm = n.n(bm);
  var wm = n(29), Sm = n.n(wm), Em = n(30), Mm = n.n(Em);
  var Am = n(31), Rm = n.n(Am), Pm = n(32), Cm = n.n(Pm);
  var Im = n(33), Om = n.n(Im), Lm = n(34), Nm = n.n(Lm);
  var Dm = n(35), Fm = n.n(Dm), Bm = n(36), Um = n.n(Bm);
  class km extends fm {
    constructor() {
      super(...arguments), this.duration = 1250, this.fragmentShader = Um.a, this.vertexShader = Fm.a, this.verticalSegments = 100;
    }
    addObjects(t3) {
      t3.add(this.mesh), t3.background = this.nextTexture;
    }
    extraAttributes() {
      return {};
    }
  }
  var Gm = n(37), Hm = n.n(Gm), zm = n(38), jm = n.n(zm);
  var Vm = n(39), Wm = n.n(Vm);
  var Xm = n(40), qm = n.n(Xm);
  var Ym = n(41), Zm = n.n(Ym);
  var Jm = n(42), $m = n.n(Jm), Km = n(43), Qm = n.n(Km);
  const tg = new pi(0, -0, 0).multiplyScalar(0.1);
  class eg {
    constructor(t3, e3, n2, i2, r3) {
      this.position = new pi(), this.previous = new pi(), this.original = new pi(), this.a = new pi(0, 0, 0), this.mass = i2, this.invMass = 1 / i2, this.tmp = new pi(), this.tmp2 = new pi(), r3(t3, e3, this.position), r3(t3, e3, this.previous), r3(t3, e3, this.original);
    }
    addForce(t3) {
      this.a.add(this.tmp2.copy(t3).multiplyScalar(this.invMass));
    }
    integrate(t3, e3, n2) {
      const i2 = 0.25 * Math.PI, r3 = 0.25 * -Math.PI, o3 = new ni(), s3 = new ni();
      o3.set(Math.cos(i2), -Math.sin(i2), 0, Math.sin(i2), Math.cos(i2), 0, 0, 0, 1), s3.set(Math.cos(r3), -Math.sin(r3), 0, Math.sin(r3), Math.cos(r3), 0, 0, 0, 1);
      const a2 = this.tmp.subVectors(this.position, this.previous);
      a2.multiplyScalar(0.97).add(this.position), a2.add(this.a.multiplyScalar(t3)), this.tmp = this.previous, this.previous = this.position, this.position = a2, this.a.set(0, 0, 0);
    }
  }
  class ng {
    constructor(t3, e3, n2) {
      this.width = t3, this.height = e3;
      const i2 = [], r3 = [];
      for (let r4 = 0; r4 <= e3; r4++)
        for (let o4 = 0; o4 <= t3; o4++)
          i2.push(new eg(o4 / t3, r4 / e3, 0, 0.1, n2));
      for (let n3 = 0; n3 < e3; n3++)
        for (let e4 = 0; e4 < t3; e4++)
          r3.push([i2[o3(e4, n3)], i2[o3(e4, n3 + 1)], 25]), r3.push([i2[o3(e4, n3)], i2[o3(e4 + 1, n3)], 25]);
      for (let n3 = t3, s3 = 0; s3 < e3; s3++)
        r3.push([i2[o3(n3, s3)], i2[o3(n3, s3 + 1)], 25]);
      for (let n3 = e3, s3 = 0; s3 < t3; s3++)
        r3.push([i2[o3(s3, n3)], i2[o3(s3 + 1, n3)], 25]);
      function o3(e4, n3) {
        return e4 + n3 * (t3 + 1);
      }
      this.particles = i2, this.constraints = r3, this.index = o3;
    }
  }
  const ig = { RandomLines: class extends Uf {
    constructor() {
      super(...arguments), this.duration = 1e3, this.fragmentShader = zf.a;
    }
    genRandomLines() {
      let t3 = [1];
      for (let e4 = 20; e4--; ) {
        let e5 = t3.sort((t4, e6) => e6 - t4)[0], n2 = t3.indexOf(e5), i2 = Math.random(), r3 = e5 * i2, o3 = e5 * (1 - i2);
        t3.splice(n2, 1), t3.push(r3, o3);
      }
      let e3 = t3.length;
      for (; e3; ) {
        let n2 = Math.floor(Math.random() * e3--);
        [t3[n2], t3[e3]] = [t3[e3], t3[n2]];
      }
      return t3;
    }
    setTexture(t3, e3, n2, i2) {
      super.setTexture(t3, e3, n2, i2), this.material.uniforms.lines = { value: this.genRandomLines() }, this.material.vertexShader = Gf.a;
    }
  }, Shape: class extends Uf {
    constructor() {
      super(...arguments), this.duration = 800, this.fragmentShader = Vf.a;
    }
  }, Ripples: class extends Uf {
    constructor() {
      super(...arguments), this.duration = 1400, this.fragmentShader = Xf.a;
    }
  }, Erase: class extends Uf {
    constructor() {
      super(...arguments), this.duration = 1e3, this.fragmentShader = Yf.a;
    }
  }, Dissolve: class extends Uf {
    constructor() {
      super(...arguments), this.duration = 1200, this.fragmentShader = Jf.a, this.dissolveIndices = {};
    }
    random40() {
      return Math.ceil(40 * Math.random());
    }
    setTexture(t3, e3, n2, i2) {
      super.setTexture(t3, e3, n2, i2);
      for (let t4 = 0; t4 < 1600; t4++) {
        let t5 = this.random40(), e4 = this.random40();
        for (; this.dissolveIndices[`${t5}_${e4}`] !== void 0; )
          t5 = this.random40(), e4 = this.random40();
        this.dissolveIndices[`${t5}_${e4}`] = 0;
      }
      this.material.uniforms.dissolveTexture = { value: this.genDissolveToTexture() };
    }
    genDissolveToTexture() {
      var t3 = new Uint8Array(4800);
      for (let e3 = 0; e3 < 1600; e3++) {
        const n2 = e3 % 40 + 1, i2 = Math.floor(e3 / 40) + 1, r3 = 3 * e3;
        this.dissolveIndices[`${n2}_${i2}`] === 0 ? (t3[r3] = 0, t3[r3 + 1] = 0, t3[r3 + 2] = 0) : (t3[r3] = 255, t3[r3 + 1] = 255, t3[r3 + 2] = 255);
      }
      return new Ul(t3, 40, 40, jt);
    }
    updateAnimation(t3) {
      const e3 = 1600 * t3 - Object.keys(this.dissolveIndices).filter((t4) => this.dissolveIndices[t4] === 1).length;
      for (let t4 = 0; t4 < e3; t4++) {
        const t5 = Object.keys(this.dissolveIndices).filter((t6) => this.dissolveIndices[t6] === 0), e4 = Math.ceil(Math.random() * t5.length) - 1;
        this.dissolveIndices[t5[e4]] = 1;
      }
      this.material.uniforms.dissolveTexture.value = this.genDissolveToTexture();
    }
  }, Smooth: class extends Uf {
    constructor() {
      super(...arguments), this.duration = 2e3, this.fragmentShader = Kf.a;
    }
  }, FadeInOut: class extends Uf {
    constructor() {
      super(...arguments), this.duration = 700, this.fragmentShader = tm.a;
    }
  }, Push: class extends Uf {
    constructor() {
      super(...arguments), this.duration = 1e3, this.fragmentShader = nm.a;
    }
  }, Separation: class extends Uf {
    constructor() {
      super(...arguments), this.duration = 1500, this.fragmentShader = rm.a;
    }
  }, Display: class extends Uf {
    constructor() {
      super(...arguments), this.duration = 3400, this.fragmentShader = sm.a;
    }
  }, Uncover: class extends Uf {
    constructor() {
      super(...arguments), this.duration = 750, this.fragmentShader = lm.a;
    }
  }, Cover: class extends Uf {
    constructor() {
      super(...arguments), this.duration = 1e3, this.fragmentShader = hm.a;
    }
  }, Flash: class extends Uf {
    constructor() {
      super(...arguments), this.duration = 1e3, this.fragmentShader = dm.a;
    }
  }, Checkerboard: class extends fm {
    constructor() {
      super(...arguments), this.duration = 2500, this.fragmentShader = _m.a, this.vertexShader = gm.a, this.vIndex = "", this.delay = 0, this.verticalSegments = 5;
    }
    extraAttributes() {
      return { times: { itemSize: 1, generator: (t3, e3) => (this.vIndex !== `${t3}${e3}` && (this.delay = 0.3 * Math.random(), this.vIndex = `${t3}${e3}`), [this.delay]) }, segment: { itemSize: 2, generator: (t3, e3) => [e3, t3] } };
    }
  }, Vortex: class {
    constructor() {
      this.duration = 4e3, this.geometry = new so(), this.material = new Io({ fragmentShader: Tm.a, vertexShader: xm.a, side: T }), this.camera = new pm(), this.mesh = new Eo();
    }
    initData(t3, e3) {
      const n2 = [], i2 = [], r3 = [], o3 = [], s3 = [], a2 = [], l2 = Math.ceil(124 * t3 / e3), u2 = t3 / 2, h2 = e3 / 2, c2 = t3 / l2, d2 = e3 / 124;
      for (let t4 = 0; t4 < 124; t4++) {
        const e4 = t4 * d2 - h2;
        for (let n3 = 0; n3 < l2; n3++) {
          const h3 = n3 * c2 - u2, p2 = Math.ceil((n3 + 1) / ((l2 + 1) / 12)), f2 = 0.4 / p2, m2 = (p2 - 1) * f2 + Math.random() * f2;
          i2.push(h3, -e4, 0), o3.push(1 * n3 / l2, 1 - 1 * t4 / 124), r3.push(0, 0, 1), s3.push(n3, t4), a2.push(m2), i2.push(h3 + c2, -e4, 0), o3.push(1 * (n3 + 1) / l2, 1 - 1 * t4 / 124), r3.push(0, 0, 1), s3.push(n3, t4), a2.push(m2), i2.push(h3, -e4 - d2, 0), o3.push(1 * n3 / l2, 1 - 1 * (t4 + 1) / 124), r3.push(0, 0, 1), s3.push(n3, t4), a2.push(m2), i2.push(h3 + c2, -e4 - d2, 0), o3.push(1 * (n3 + 1) / l2, 1 - 1 * (t4 + 1) / 124), r3.push(0, 0, 1), s3.push(n3, t4), a2.push(m2);
        }
      }
      for (let t4 = 0; t4 < 124 * l2; t4++) {
        const e4 = 4 * t4, i3 = e4 + 1, r4 = e4 + 2, o4 = e4 + 3;
        n2.push(i3, e4, o4), n2.push(e4, r4, o4);
      }
      return this.geometry.setIndex(n2), this.geometry.setAttribute("position", new Yr(i2, 3)), this.geometry.setAttribute("normal", new Yr(r3, 3)), this.geometry.setAttribute("uv", new Yr(new Float32Array(o3), 2)), this.geometry.setAttribute("segment", new Yr(new Float32Array(s3), 2)), this.geometry.setAttribute("times", new Yr(new Float32Array(a2), 1)), { verticalSegments: 124, horizontalSegments: l2, segmentWidth: c2, segmentHeight: d2 };
    }
    setTexture(t3, e3) {
      const { width: n2, height: r3 } = t3.image, { verticalSegments: o3, horizontalSegments: s3, segmentWidth: a2, segmentHeight: l2 } = this.initData(n2, r3);
      this.material.uniforms = { duration: { value: this.duration }, segmentWidth: { value: a2 }, segmentHeight: { value: l2 }, verticalSegments: { value: o3 }, horizontalSegments: { value: s3 }, timePercent: { value: 0 }, texturePrev: { value: t3 }, textureNext: { value: e3 } }, this.camera.updateAspect(n2, r3), this.camera.focus(this.mesh, r3), this.mesh.geometry = this.geometry;
      new kh({ side: T, vertexColors: true }).wireframe = true, this.material.transparent = true, this.mesh.material = this.material, console.log(i);
    }
    addObjects(t3) {
      t3.add(this.mesh);
    }
    updateAnimation(t3) {
      this.material.uniforms.timePercent.value = t3;
    }
    dispose() {
      var t3, e3;
      (t3 = this.geometry) === null || t3 === void 0 || t3.dispose(), (e3 = this.material) === null || e3 === void 0 || e3.dispose();
    }
  }, WindowShades: class {
    constructor() {
      this.duration = 1600, this.geometry = new so(), this.material = new Io({ fragmentShader: Mm.a, vertexShader: Sm.a, side: T }), this.horizontalSegments = 16, this.meshToCameraDistance = 0, this.camera = new pm(), this.mesh = new Eo();
    }
    initData(t3, e3) {
      const n2 = [], i2 = [], r3 = [], o3 = [], s3 = [], a2 = [], l2 = t3 / 2, u2 = e3 / 2, h2 = t3 / this.horizontalSegments;
      for (let t4 = 0; t4 < this.horizontalSegments; t4++) {
        const e4 = Math.abs(t4 - Math.ceil(this.horizontalSegments / 2)) * (0.3 / Math.ceil(this.horizontalSegments / 2)), n3 = t4 * h2 - l2;
        i2.push(n3, u2, 0), r3.push(0), o3.push(t4 / this.horizontalSegments, 1), s3.push(t4), a2.push(e4), i2.push(n3 + h2, u2, 0), r3.push(0), o3.push((t4 + 1) / this.horizontalSegments, 1), s3.push(t4), a2.push(e4), i2.push(n3, -1 * u2, 0), r3.push(0), o3.push(t4 / this.horizontalSegments, 0), s3.push(t4), a2.push(e4), i2.push(n3 + h2, -1 * u2, 0), o3.push((t4 + 1) / this.horizontalSegments, 0), r3.push(0), s3.push(t4), a2.push(e4), i2.push(n3 + h2, u2, 0), r3.push(1), o3.push(t4 / this.horizontalSegments, 1), s3.push(t4), a2.push(e4), i2.push(n3 + h2, u2, -1 * h2), r3.push(1), o3.push((t4 + 1) / this.horizontalSegments, 1), s3.push(t4), a2.push(e4), i2.push(n3 + h2, -1 * u2, 0), r3.push(1), o3.push(t4 / this.horizontalSegments, 0), s3.push(t4), a2.push(e4), i2.push(n3 + h2, -1 * u2, -1 * h2), o3.push((t4 + 1) / this.horizontalSegments, 0), r3.push(1), s3.push(t4), a2.push(e4);
      }
      for (let t4 = 0; t4 < this.horizontalSegments; t4++) {
        const e4 = 8 * t4, i3 = e4 + 1, r4 = e4 + 2, o4 = e4 + 3, s4 = e4 + 4, a3 = e4 + 5, l3 = e4 + 6, u3 = e4 + 7;
        n2.push(i3, e4, o4), n2.push(e4, r4, o4), n2.push(a3, s4, u3), n2.push(s4, l3, u3);
      }
      this.geometry.setIndex(n2), this.geometry.setAttribute("position", new Yr(i2, 3)), this.geometry.setAttribute("uv", new Yr(new Float32Array(o3), 2)), this.geometry.setAttribute("index", new Yr(new Float32Array(s3), 1)), this.geometry.setAttribute("type", new Yr(new Float32Array(r3), 1)), this.geometry.setAttribute("delay", new Yr(new Float32Array(a2), 1));
    }
    setTexture(t3, e3, n2, i2) {
      this.initData(n2, i2), this.material.uniforms = { segments: { value: this.horizontalSegments }, segmentWidth: { value: n2 / this.horizontalSegments }, timePercent: { value: 0 }, texturePrev: { value: t3 }, textureNext: { value: e3 } }, this.meshToCameraDistance = 0.5 * i2 / Math.tan(Math.PI / 6), this.camera.updateAspect(n2, i2), this.camera.focus(this.mesh, i2), this.mesh.geometry = this.geometry, this.material.transparent = true, this.mesh.material = this.material;
    }
    addObjects(t3) {
      t3.add(this.mesh);
    }
    updateAnimation(t3) {
      this.material.uniforms.timePercent.value = t3;
    }
    dispose() {
      var t3, e3;
      (t3 = this.geometry) === null || t3 === void 0 || t3.dispose(), (e3 = this.material) === null || e3 === void 0 || e3.dispose();
    }
  }, Curtain: class extends fm {
    constructor() {
      super(...arguments), this.duration = 6e3, this.fragmentShader = Cm.a, this.vertexShader = Rm.a, this.verticalSegments = 100;
    }
    extraAttributes() {
      return { isLeft: { itemSize: 1, generator: (t3, e3) => [e3 < this.horizontalSegments() / 2 ? 1 : 0] } };
    }
    addObjects(t3) {
      super.addObjects(t3), this.mesh.position.z += 20, t3.background = this.nextTexture;
    }
  }, Fall: class extends fm {
    constructor() {
      super(...arguments), this.zCurveLimit = 100, this.duration = 2e3, this.verticalSegments = 100, this.fragmentShader = Nm.a, this.vertexShader = Om.a;
    }
    extraAttributes() {
      return {};
    }
    setTexture(t3, e3, n2, i2) {
      super.setTexture(t3, e3, n2, i2), this.material.uniforms.zCurveLimit = { value: this.zCurveLimit }, this.material.uniforms.aCoefficient = { value: this.zCurveLimit / (this.textureHeight / 2 * (this.textureHeight / 2)) };
    }
    addObjects(t3) {
      t3.add(this.mesh), t3.background = this.nextTexture;
    }
    updateAnimation(t3) {
      this.material.uniforms.timePercent.value = t3;
    }
  }, Suspension: class extends km {
    constructor() {
      super(...arguments), this.duration = 2e3, this.fragmentShader = jm.a, this.vertexShader = Hm.a;
    }
    addObjects(t3) {
      t3.add(this.mesh), t3.background = this.prevTexture;
    }
  }, Clock: class extends Uf {
    constructor() {
      super(...arguments), this.duration = 1e3, this.fragmentShader = Wm.a;
    }
  }, Combing: class extends Uf {
    constructor() {
      super(...arguments), this.duration = 1e3, this.fragmentShader = qm.a;
    }
  }, Scale: class extends Uf {
    constructor() {
      super(...arguments), this.duration = 900, this.fragmentShader = Zm.a;
    }
  }, PeelOff: km, Flip: class extends fm {
    constructor() {
      super(...arguments), this.duration = 1250, this.fragmentShader = Qm.a, this.vertexShader = $m.a, this.verticalSegments = 1;
    }
    extraAttributes() {
      return {};
    }
  }, Wind: class {
    constructor() {
      this.duration = 2e3, this.camera = new pm(), this.mesh = new Eo(), this.geometry = null, this.material = new zh({ side: T, alphaTest: 0.5 }), this.tmpForce = new pi(), this.windForce = new pi(0, 0, 0), this.cloth = null, this.nextTexture = null, this.diff = new pi(), this.xSegs = 10, this.ySegs = 10, this.width = 10, this.height = 10, this.enablePins = true, this.animate = (t3) => {
        this.simulate(t3), this.render(), requestAnimationFrame(this.animate);
      };
    }
    setTexture(t3, e3, n2, i2) {
      const r3 = n2, o3 = i2;
      this.xSegs = Math.ceil(r3 / 25), this.ySegs = Math.ceil(o3 / 25), this.width = 25 * this.xSegs, this.height = 25 * this.ySegs;
      const s3 = function(t4, e4) {
        return function(n3, i3, r4) {
          const o4 = (n3 - 0.5) * t4, s4 = (i3 + 0.5) * e4;
          r4.set(o4, s4, 0);
        };
      }(25 * this.xSegs, 25 * this.ySegs);
      this.cloth = new ng(this.xSegs, this.ySegs, s3), this.nextTexture = e3, this.camera.updateAspect(r3, o3), this.material.map = t3, this.geometry = new Sh(s3, this.cloth.width, this.cloth.height), this.mesh.geometry = this.geometry, this.material.transparent = true, this.mesh.material = this.material, this.mesh.castShadow = true, this.mesh.position.y -= o3, this.mesh.customDepthMaterial = new Xa({ depthPacking: dn, map: t3, alphaTest: 0.5 }), this.camera.focus(this.mesh, o3);
    }
    addObjects(t3) {
      t3.add(this.mesh), t3.background = this.nextTexture, t3.add(new Uc(6710886));
      const e3 = new Bc(14674943, 1);
      e3.position.set(0, 0, 100), e3.position.multiplyScalar(1.3), e3.castShadow = true, e3.shadow.mapSize.width = 1024, e3.shadow.mapSize.height = 1024;
      const n2 = 300;
      e3.shadow.camera.left = -n2, e3.shadow.camera.right = n2, e3.shadow.camera.top = n2, e3.shadow.camera.bottom = -n2, e3.shadow.camera.far = 1e3, t3.add(e3), this.animate(0);
    }
    satisfyConstraints(t3, e3, n2) {
      this.diff.subVectors(e3.position, t3.position);
      const i2 = this.diff.length();
      if (i2 === 0)
        return;
      const r3 = this.diff.multiplyScalar(1 - n2 / i2).multiplyScalar(0.5);
      t3.position.add(r3), e3.position.sub(r3);
    }
    simulate(t3) {
      const e3 = 20 * Math.abs(Math.cos(t3 / 70));
      this.windForce.set(Math.abs(Math.sin(t3 / 300)), Math.abs(Math.cos(t3 / 200)), Math.sin(t3 / 1e3)), this.windForce.normalize(), this.windForce.x *= 50 * e3, this.windForce.y *= 50 * e3, this.windForce.z *= 0.2 * e3;
      const n2 = this.cloth.particles;
      let i2;
      const r3 = new pi(), o3 = this.geometry.index, s3 = this.geometry.attributes.normal;
      for (let t4 = 0, e4 = o3.count; t4 < e4; t4 += 3)
        for (let e5 = 0; e5 < 3; e5++)
          i2 = o3.getX(t4 + e5), r3.fromBufferAttribute(s3, i2), this.tmpForce.copy(r3).normalize().multiplyScalar(r3.dot(this.windForce)), n2[i2].addForce(this.tmpForce);
      for (let t4 = 0, e4 = n2.length; t4 < e4; t4++) {
        const e5 = n2[t4];
        e5.addForce(tg), e5.integrate(144e-6, this.width, this.height);
      }
      const a2 = this.cloth.constraints, l2 = a2.length;
      for (let t4 = 0; t4 < l2; t4++) {
        const e4 = a2[t4];
        this.satisfyConstraints(e4[0], e4[1], e4[2]);
      }
      for (let t4 = 0, e4 = n2.length; t4 < e4; t4++) {
        const e5 = n2[t4].position;
        e5.y < -250 && (e5.y = -250);
      }
      if (this.enablePins) {
        let t4 = new Array(this.xSegs + 1).fill("").map((t5, e4) => e4);
        for (let e4 = 0; e4 < this.ySegs + 1; e4++)
          t4.push(e4 * (this.xSegs + 1));
        for (let e4 = 0, i3 = t4.length; e4 < i3; e4++) {
          const i4 = n2[t4[e4]];
          i4.position.copy(i4.original), i4.previous.copy(i4.original);
        }
      }
    }
    render() {
      const t3 = this.cloth.particles;
      for (let e3 = 0, n2 = t3.length; e3 < n2; e3++) {
        const n3 = t3[e3].position;
        this.geometry.attributes.position.setXYZ(e3, n3.x, n3.y, n3.z);
      }
      this.geometry.attributes.position.needsUpdate = true, this.geometry.computeVertexNormals();
    }
    updateAnimation(t3) {
      t3 > 0.5 && (this.enablePins = false), t3 > 0.9999 && (this.mesh.visible = false);
    }
    dispose() {
      var t3, e3;
      (t3 = this.geometry) === null || t3 === void 0 || t3.dispose(), (e3 = this.material) === null || e3 === void 0 || e3.dispose();
    }
  } }, rg = { linear: (t3, e3, n2, i2) => n2 * t3 / i2 + e3, easeIn: (t3, e3, n2, i2) => n2 * (t3 /= i2) * t3 + e3, strongEaseIn: (t3, e3, n2, i2) => n2 * (t3 /= i2) * t3 * t3 * t3 * t3 + e3, strongEaseOut: (t3, e3, n2, i2) => n2 * ((t3 = t3 / i2 - 1) * t3 * t3 * t3 * t3 + 1) + e3, sineaseIn: (t3, e3, n2, i2) => n2 * (t3 /= i2) * t3 * t3 + e3, sineaseOut: (t3, e3, n2, i2) => n2 * ((t3 = t3 / i2 - 1) * t3 * t3 + 1) + e3 };
  class og {
    constructor() {
      this.startTime = 0, this.lastTime = 0, this.reverse = false, this.scene = new ll(), this.delay = 0, this.easeFn = rg.linear, this.preset = null, this.onTransactionEnd = () => {
      }, this.onTransactionStart = () => {
      }, this.isTransactionStartApplied = false, this.textureLoader = new _c(), this.prevTexture = null, this.nextTexture = null, this.renderer = new rl({ alpha: true, premultipliedAlpha: true }), this.isPlaying = false, this.animate = (t3 = -1) => {
        var e3, n2, i2;
        this.renderer.clear(), t3 > this.delay && this.lastTime === 0 && (this.lastTime = t3, this.startTime = t3);
        let r3 = 0;
        this.lastTime > 0 && r3 < 1 && (r3 = this.easeFn(t3 - this.startTime, 0, 1, (n2 = (e3 = this.preset) === null || e3 === void 0 ? void 0 : e3.duration) !== null && n2 !== void 0 ? n2 : 0)), r3 > 1 && (r3 = 1), (i2 = this.preset) === null || i2 === void 0 || i2.updateAnimation(this.reverse ? 1 - r3 : r3), this.rerender(), this.isTransactionStartApplied || (this.isTransactionStartApplied = true, this.onTransactionStart()), r3 < 1 ? window.requestAnimationFrame(this.animate) : (this.dispose(), this.onTransactionEnd());
      };
    }
    play(t3) {
      var e3, n2, i2;
      t3.onTransactionEnd && (this.onTransactionEnd = t3.onTransactionEnd), t3.onTransactionStart && (this.onTransactionStart = t3.onTransactionStart), this.init(t3), this.isTransactionStartApplied = false, this.renderer.setSize(t3.stageWidth, t3.stageHeight), this.preset = new ig[t3.presetType](), t3.duration && Number.isInteger(t3.duration) && (this.preset.duration = t3.duration), this.prevTexture = this.textureLoader.load(t3.prevTextureUrl), this.nextTexture = this.textureLoader.load(t3.nextTextureUrl), this.reverse ? (e3 = this.preset) === null || e3 === void 0 || e3.setTexture(this.nextTexture, this.prevTexture, t3.textureWidth, t3.textureHeight) : (n2 = this.preset) === null || n2 === void 0 || n2.setTexture(this.prevTexture, this.nextTexture, t3.textureWidth, t3.textureHeight), (i2 = this.preset) === null || i2 === void 0 || i2.addObjects(this.scene), this.animate(), this.isPlaying = true;
    }
    init(t3) {
      this.reverse = t3.reverse, t3.delay && Number.isInteger(t3.delay) && (this.delay = t3.delay), t3.easeFn && (this.easeFn = rg[t3.easeFn]), this.startTime = 0, this.lastTime = 0, this.scene.clear(), this.renderer.shadowMap.enabled = true, this.renderer.autoClear = false, this.renderer.setClearColor(t3.clearColor || 0);
    }
    rerender() {
      var t3;
      this.renderer.clear(), ((t3 = this.preset) === null || t3 === void 0 ? void 0 : t3.camera.camera) && this.renderer.render(this.scene, this.preset.camera.camera);
    }
    skip() {
      var t3;
      (t3 = this.preset) === null || t3 === void 0 || t3.updateAnimation(this.reverse ? 0 : 1), this.rerender(), this.dispose(), this.onTransactionEnd();
    }
    dispose() {
      var t3, e3, n2;
      this.renderer.clear(), this.isPlaying = false, (t3 = this.preset) === null || t3 === void 0 || t3.dispose(), (e3 = this.prevTexture) === null || e3 === void 0 || e3.dispose(), (n2 = this.nextTexture) === null || n2 === void 0 || n2.dispose();
      for (let t4 = this.scene.children.length - 1; t4 >= 0; t4--) {
        const e4 = this.scene.children[t4];
        this.scene.remove(e4);
      }
      this.scene.background = null;
    }
    destroy() {
      this.dispose(), this.renderer.forceContextLoss(), this.renderer.dispose();
    }
  }
  var sg = n(44), ag = n(47), lg = n.n(ag);
  /*!
   * @pixi/polyfill - v6.2.0
   * Compiled Mon, 01 Nov 2021 16:52:10 UTC
   *
   * @pixi/polyfill is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   */
  self.Promise || (self.Promise = sg.a), Object.assign || (Object.assign = lg.a);
  if (Date.now && Date.prototype.getTime || (Date.now = function() {
    return new Date().getTime();
  }), !self.performance || !self.performance.now) {
    var ug = Date.now();
    self.performance || (self.performance = {}), self.performance.now = function() {
      return Date.now() - ug;
    };
  }
  for (var hg = Date.now(), cg = ["ms", "moz", "webkit", "o"], dg = 0; dg < cg.length && !self.requestAnimationFrame; ++dg) {
    var pg = cg[dg];
    self.requestAnimationFrame = self[pg + "RequestAnimationFrame"], self.cancelAnimationFrame = self[pg + "CancelAnimationFrame"] || self[pg + "CancelRequestAnimationFrame"];
  }
  self.requestAnimationFrame || (self.requestAnimationFrame = function(t3) {
    if (typeof t3 != "function")
      throw new TypeError(t3 + "is not a function");
    var e3 = Date.now(), n2 = 16 + hg - e3;
    return n2 < 0 && (n2 = 0), hg = e3, self.setTimeout(function() {
      hg = Date.now(), t3(performance.now());
    }, n2);
  }), self.cancelAnimationFrame || (self.cancelAnimationFrame = function(t3) {
    return clearTimeout(t3);
  }), Math.sign || (Math.sign = function(t3) {
    return (t3 = Number(t3)) === 0 || isNaN(t3) ? t3 : t3 > 0 ? 1 : -1;
  }), Number.isInteger || (Number.isInteger = function(t3) {
    return typeof t3 == "number" && isFinite(t3) && Math.floor(t3) === t3;
  }), self.ArrayBuffer || (self.ArrayBuffer = Array), self.Float32Array || (self.Float32Array = Array), self.Uint32Array || (self.Uint32Array = Array), self.Uint16Array || (self.Uint16Array = Array), self.Uint8Array || (self.Uint8Array = Array), self.Int32Array || (self.Int32Array = Array);
  var fg = /iPhone/i, mg = /iPod/i, gg = /iPad/i, vg = /\biOS-universal(?:.+)Mac\b/i, _g = /\bAndroid(?:.+)Mobile\b/i, yg = /Android/i, xg = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i, bg = /Silk/i, Tg = /Windows Phone/i, wg = /\bWindows(?:.+)ARM\b/i, Sg = /BlackBerry/i, Eg = /BB10/i, Mg = /Opera Mini/i, Ag = /\b(CriOS|Chrome)(?:.+)Mobile/i, Rg = /Mobile(?:.+)Firefox\b/i, Pg = function(t3) {
    return t3 !== void 0 && t3.platform === "MacIntel" && typeof t3.maxTouchPoints == "number" && t3.maxTouchPoints > 1 && typeof MSStream == "undefined";
  };
  /*!
   * @pixi/settings - v6.2.0
   * Compiled Mon, 01 Nov 2021 16:52:10 UTC
   *
   * @pixi/settings is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   */
  var Cg, Ig, Og, Lg, Ng, Dg, Fg, Bg, Ug, kg, Gg, Hg, zg, jg, Vg, Wg, Xg, qg, Yg, Zg = function(t3) {
    var e3 = { userAgent: "", platform: "", maxTouchPoints: 0 };
    t3 || typeof navigator == "undefined" ? typeof t3 == "string" ? e3.userAgent = t3 : t3 && t3.userAgent && (e3 = { userAgent: t3.userAgent, platform: t3.platform, maxTouchPoints: t3.maxTouchPoints || 0 }) : e3 = { userAgent: navigator.userAgent, platform: navigator.platform, maxTouchPoints: navigator.maxTouchPoints || 0 };
    var n2 = e3.userAgent, i2 = n2.split("[FBAN");
    i2[1] !== void 0 && (n2 = i2[0]), (i2 = n2.split("Twitter"))[1] !== void 0 && (n2 = i2[0]);
    var r3 = function(t4) {
      return function(e4) {
        return e4.test(t4);
      };
    }(n2), o3 = { apple: { phone: r3(fg) && !r3(Tg), ipod: r3(mg), tablet: !r3(fg) && (r3(gg) || Pg(e3)) && !r3(Tg), universal: r3(vg), device: (r3(fg) || r3(mg) || r3(gg) || r3(vg) || Pg(e3)) && !r3(Tg) }, amazon: { phone: r3(xg), tablet: !r3(xg) && r3(bg), device: r3(xg) || r3(bg) }, android: { phone: !r3(Tg) && r3(xg) || !r3(Tg) && r3(_g), tablet: !r3(Tg) && !r3(xg) && !r3(_g) && (r3(bg) || r3(yg)), device: !r3(Tg) && (r3(xg) || r3(bg) || r3(_g) || r3(yg)) || r3(/\bokhttp\b/i) }, windows: { phone: r3(Tg), tablet: r3(wg), device: r3(Tg) || r3(wg) }, other: { blackberry: r3(Sg), blackberry10: r3(Eg), opera: r3(Mg), firefox: r3(Rg), chrome: r3(Ag), device: r3(Sg) || r3(Eg) || r3(Mg) || r3(Rg) || r3(Ag) }, any: false, phone: false, tablet: false };
    return o3.any = o3.apple.device || o3.android.device || o3.windows.device || o3.other.device, o3.phone = o3.apple.phone || o3.android.phone || o3.windows.phone, o3.tablet = o3.apple.tablet || o3.android.tablet || o3.windows.tablet, o3;
  }(self.navigator);
  !function(t3) {
    t3[t3.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", t3[t3.WEBGL = 1] = "WEBGL", t3[t3.WEBGL2 = 2] = "WEBGL2";
  }(Cg || (Cg = {})), function(t3) {
    t3[t3.UNKNOWN = 0] = "UNKNOWN", t3[t3.WEBGL = 1] = "WEBGL", t3[t3.CANVAS = 2] = "CANVAS";
  }(Ig || (Ig = {})), function(t3) {
    t3[t3.COLOR = 16384] = "COLOR", t3[t3.DEPTH = 256] = "DEPTH", t3[t3.STENCIL = 1024] = "STENCIL";
  }(Og || (Og = {})), function(t3) {
    t3[t3.NORMAL = 0] = "NORMAL", t3[t3.ADD = 1] = "ADD", t3[t3.MULTIPLY = 2] = "MULTIPLY", t3[t3.SCREEN = 3] = "SCREEN", t3[t3.OVERLAY = 4] = "OVERLAY", t3[t3.DARKEN = 5] = "DARKEN", t3[t3.LIGHTEN = 6] = "LIGHTEN", t3[t3.COLOR_DODGE = 7] = "COLOR_DODGE", t3[t3.COLOR_BURN = 8] = "COLOR_BURN", t3[t3.HARD_LIGHT = 9] = "HARD_LIGHT", t3[t3.SOFT_LIGHT = 10] = "SOFT_LIGHT", t3[t3.DIFFERENCE = 11] = "DIFFERENCE", t3[t3.EXCLUSION = 12] = "EXCLUSION", t3[t3.HUE = 13] = "HUE", t3[t3.SATURATION = 14] = "SATURATION", t3[t3.COLOR = 15] = "COLOR", t3[t3.LUMINOSITY = 16] = "LUMINOSITY", t3[t3.NORMAL_NPM = 17] = "NORMAL_NPM", t3[t3.ADD_NPM = 18] = "ADD_NPM", t3[t3.SCREEN_NPM = 19] = "SCREEN_NPM", t3[t3.NONE = 20] = "NONE", t3[t3.SRC_OVER = 0] = "SRC_OVER", t3[t3.SRC_IN = 21] = "SRC_IN", t3[t3.SRC_OUT = 22] = "SRC_OUT", t3[t3.SRC_ATOP = 23] = "SRC_ATOP", t3[t3.DST_OVER = 24] = "DST_OVER", t3[t3.DST_IN = 25] = "DST_IN", t3[t3.DST_OUT = 26] = "DST_OUT", t3[t3.DST_ATOP = 27] = "DST_ATOP", t3[t3.ERASE = 26] = "ERASE", t3[t3.SUBTRACT = 28] = "SUBTRACT", t3[t3.XOR = 29] = "XOR";
  }(Lg || (Lg = {})), function(t3) {
    t3[t3.POINTS = 0] = "POINTS", t3[t3.LINES = 1] = "LINES", t3[t3.LINE_LOOP = 2] = "LINE_LOOP", t3[t3.LINE_STRIP = 3] = "LINE_STRIP", t3[t3.TRIANGLES = 4] = "TRIANGLES", t3[t3.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", t3[t3.TRIANGLE_FAN = 6] = "TRIANGLE_FAN";
  }(Ng || (Ng = {})), function(t3) {
    t3[t3.RGBA = 6408] = "RGBA", t3[t3.RGB = 6407] = "RGB", t3[t3.RG = 33319] = "RG", t3[t3.RED = 6403] = "RED", t3[t3.RGBA_INTEGER = 36249] = "RGBA_INTEGER", t3[t3.RGB_INTEGER = 36248] = "RGB_INTEGER", t3[t3.RG_INTEGER = 33320] = "RG_INTEGER", t3[t3.RED_INTEGER = 36244] = "RED_INTEGER", t3[t3.ALPHA = 6406] = "ALPHA", t3[t3.LUMINANCE = 6409] = "LUMINANCE", t3[t3.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", t3[t3.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", t3[t3.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL";
  }(Dg || (Dg = {})), function(t3) {
    t3[t3.TEXTURE_2D = 3553] = "TEXTURE_2D", t3[t3.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", t3[t3.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", t3[t3.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", t3[t3.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", t3[t3.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", t3[t3.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", t3[t3.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", t3[t3.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
  }(Fg || (Fg = {})), function(t3) {
    t3[t3.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", t3[t3.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", t3[t3.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", t3[t3.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", t3[t3.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", t3[t3.UNSIGNED_INT = 5125] = "UNSIGNED_INT", t3[t3.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", t3[t3.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", t3[t3.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", t3[t3.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", t3[t3.BYTE = 5120] = "BYTE", t3[t3.SHORT = 5122] = "SHORT", t3[t3.INT = 5124] = "INT", t3[t3.FLOAT = 5126] = "FLOAT", t3[t3.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", t3[t3.HALF_FLOAT = 36193] = "HALF_FLOAT";
  }(Bg || (Bg = {})), function(t3) {
    t3[t3.FLOAT = 0] = "FLOAT", t3[t3.INT = 1] = "INT", t3[t3.UINT = 2] = "UINT";
  }(Ug || (Ug = {})), function(t3) {
    t3[t3.NEAREST = 0] = "NEAREST", t3[t3.LINEAR = 1] = "LINEAR";
  }(kg || (kg = {})), function(t3) {
    t3[t3.CLAMP = 33071] = "CLAMP", t3[t3.REPEAT = 10497] = "REPEAT", t3[t3.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT";
  }(Gg || (Gg = {})), function(t3) {
    t3[t3.OFF = 0] = "OFF", t3[t3.POW2 = 1] = "POW2", t3[t3.ON = 2] = "ON", t3[t3.ON_MANUAL = 3] = "ON_MANUAL";
  }(Hg || (Hg = {})), function(t3) {
    t3[t3.NPM = 0] = "NPM", t3[t3.UNPACK = 1] = "UNPACK", t3[t3.PMA = 2] = "PMA", t3[t3.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", t3[t3.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", t3[t3.PREMULTIPLY_ALPHA = 2] = "PREMULTIPLY_ALPHA", t3[t3.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA";
  }(zg || (zg = {})), function(t3) {
    t3[t3.NO = 0] = "NO", t3[t3.YES = 1] = "YES", t3[t3.AUTO = 2] = "AUTO", t3[t3.BLEND = 0] = "BLEND", t3[t3.CLEAR = 1] = "CLEAR", t3[t3.BLIT = 2] = "BLIT";
  }(jg || (jg = {})), function(t3) {
    t3[t3.AUTO = 0] = "AUTO", t3[t3.MANUAL = 1] = "MANUAL";
  }(Vg || (Vg = {})), function(t3) {
    t3.LOW = "lowp", t3.MEDIUM = "mediump", t3.HIGH = "highp";
  }(Wg || (Wg = {})), function(t3) {
    t3[t3.NONE = 0] = "NONE", t3[t3.SCISSOR = 1] = "SCISSOR", t3[t3.STENCIL = 2] = "STENCIL", t3[t3.SPRITE = 3] = "SPRITE";
  }(Xg || (Xg = {})), function(t3) {
    t3[t3.NONE = 0] = "NONE", t3[t3.LOW = 2] = "LOW", t3[t3.MEDIUM = 4] = "MEDIUM", t3[t3.HIGH = 8] = "HIGH";
  }(qg || (qg = {})), function(t3) {
    t3[t3.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", t3[t3.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", t3[t3.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER";
  }(Yg || (Yg = {}));
  var Jg, $g, Kg, Qg, tv, ev, nv, iv, rv, ov, sv, av, lv, uv, hv, cv, dv, pv, fv, mv = { MIPMAP_TEXTURES: Hg.POW2, ANISOTROPIC_LEVEL: 0, RESOLUTION: 1, FILTER_RESOLUTION: 1, FILTER_MULTISAMPLE: qg.NONE, SPRITE_MAX_TEXTURES: function(t3) {
    var e3 = true;
    if (Zg.tablet || Zg.phone) {
      var n2;
      if (Zg.apple.device) {
        if (n2 = navigator.userAgent.match(/OS (\d+)_(\d+)?/))
          parseInt(n2[1], 10) < 11 && (e3 = false);
      }
      if (Zg.android.device) {
        if (n2 = navigator.userAgent.match(/Android\s([0-9.]*)/))
          parseInt(n2[1], 10) < 7 && (e3 = false);
      }
    }
    return e3 ? t3 : 4;
  }(32), SPRITE_BATCH_SIZE: 4096, RENDER_OPTIONS: { view: null, antialias: false, autoDensity: false, backgroundColor: 0, backgroundAlpha: 1, useContextAlpha: true, clearBeforeRender: true, preserveDrawingBuffer: false, width: 800, height: 600, legacy: false }, GC_MODE: Vg.AUTO, GC_MAX_IDLE: 3600, GC_MAX_CHECK_COUNT: 600, WRAP_MODE: Gg.CLAMP, SCALE_MODE: kg.LINEAR, PRECISION_VERTEX: Wg.HIGH, PRECISION_FRAGMENT: Zg.apple.device ? Wg.HIGH : Wg.MEDIUM, CAN_UPLOAD_SAME_BUFFER: !Zg.apple.device, CREATE_IMAGE_BITMAP: false, ROUND_PIXELS: false }, gv = n(9), vv = n.n(gv), _v = n(10), yv = n.n(_v), xv = n(5);
  !function(t3) {
    t3[t3.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", t3[t3.WEBGL = 1] = "WEBGL", t3[t3.WEBGL2 = 2] = "WEBGL2";
  }(Jg || (Jg = {})), function(t3) {
    t3[t3.UNKNOWN = 0] = "UNKNOWN", t3[t3.WEBGL = 1] = "WEBGL", t3[t3.CANVAS = 2] = "CANVAS";
  }($g || ($g = {})), function(t3) {
    t3[t3.COLOR = 16384] = "COLOR", t3[t3.DEPTH = 256] = "DEPTH", t3[t3.STENCIL = 1024] = "STENCIL";
  }(Kg || (Kg = {})), function(t3) {
    t3[t3.NORMAL = 0] = "NORMAL", t3[t3.ADD = 1] = "ADD", t3[t3.MULTIPLY = 2] = "MULTIPLY", t3[t3.SCREEN = 3] = "SCREEN", t3[t3.OVERLAY = 4] = "OVERLAY", t3[t3.DARKEN = 5] = "DARKEN", t3[t3.LIGHTEN = 6] = "LIGHTEN", t3[t3.COLOR_DODGE = 7] = "COLOR_DODGE", t3[t3.COLOR_BURN = 8] = "COLOR_BURN", t3[t3.HARD_LIGHT = 9] = "HARD_LIGHT", t3[t3.SOFT_LIGHT = 10] = "SOFT_LIGHT", t3[t3.DIFFERENCE = 11] = "DIFFERENCE", t3[t3.EXCLUSION = 12] = "EXCLUSION", t3[t3.HUE = 13] = "HUE", t3[t3.SATURATION = 14] = "SATURATION", t3[t3.COLOR = 15] = "COLOR", t3[t3.LUMINOSITY = 16] = "LUMINOSITY", t3[t3.NORMAL_NPM = 17] = "NORMAL_NPM", t3[t3.ADD_NPM = 18] = "ADD_NPM", t3[t3.SCREEN_NPM = 19] = "SCREEN_NPM", t3[t3.NONE = 20] = "NONE", t3[t3.SRC_OVER = 0] = "SRC_OVER", t3[t3.SRC_IN = 21] = "SRC_IN", t3[t3.SRC_OUT = 22] = "SRC_OUT", t3[t3.SRC_ATOP = 23] = "SRC_ATOP", t3[t3.DST_OVER = 24] = "DST_OVER", t3[t3.DST_IN = 25] = "DST_IN", t3[t3.DST_OUT = 26] = "DST_OUT", t3[t3.DST_ATOP = 27] = "DST_ATOP", t3[t3.ERASE = 26] = "ERASE", t3[t3.SUBTRACT = 28] = "SUBTRACT", t3[t3.XOR = 29] = "XOR";
  }(Qg || (Qg = {})), function(t3) {
    t3[t3.POINTS = 0] = "POINTS", t3[t3.LINES = 1] = "LINES", t3[t3.LINE_LOOP = 2] = "LINE_LOOP", t3[t3.LINE_STRIP = 3] = "LINE_STRIP", t3[t3.TRIANGLES = 4] = "TRIANGLES", t3[t3.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", t3[t3.TRIANGLE_FAN = 6] = "TRIANGLE_FAN";
  }(tv || (tv = {})), function(t3) {
    t3[t3.RGBA = 6408] = "RGBA", t3[t3.RGB = 6407] = "RGB", t3[t3.RG = 33319] = "RG", t3[t3.RED = 6403] = "RED", t3[t3.RGBA_INTEGER = 36249] = "RGBA_INTEGER", t3[t3.RGB_INTEGER = 36248] = "RGB_INTEGER", t3[t3.RG_INTEGER = 33320] = "RG_INTEGER", t3[t3.RED_INTEGER = 36244] = "RED_INTEGER", t3[t3.ALPHA = 6406] = "ALPHA", t3[t3.LUMINANCE = 6409] = "LUMINANCE", t3[t3.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", t3[t3.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", t3[t3.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL";
  }(ev || (ev = {})), function(t3) {
    t3[t3.TEXTURE_2D = 3553] = "TEXTURE_2D", t3[t3.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", t3[t3.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", t3[t3.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", t3[t3.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", t3[t3.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", t3[t3.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", t3[t3.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", t3[t3.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
  }(nv || (nv = {})), function(t3) {
    t3[t3.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", t3[t3.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", t3[t3.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", t3[t3.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", t3[t3.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", t3[t3.UNSIGNED_INT = 5125] = "UNSIGNED_INT", t3[t3.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", t3[t3.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", t3[t3.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", t3[t3.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", t3[t3.BYTE = 5120] = "BYTE", t3[t3.SHORT = 5122] = "SHORT", t3[t3.INT = 5124] = "INT", t3[t3.FLOAT = 5126] = "FLOAT", t3[t3.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", t3[t3.HALF_FLOAT = 36193] = "HALF_FLOAT";
  }(iv || (iv = {})), function(t3) {
    t3[t3.FLOAT = 0] = "FLOAT", t3[t3.INT = 1] = "INT", t3[t3.UINT = 2] = "UINT";
  }(rv || (rv = {})), function(t3) {
    t3[t3.NEAREST = 0] = "NEAREST", t3[t3.LINEAR = 1] = "LINEAR";
  }(ov || (ov = {})), function(t3) {
    t3[t3.CLAMP = 33071] = "CLAMP", t3[t3.REPEAT = 10497] = "REPEAT", t3[t3.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT";
  }(sv || (sv = {})), function(t3) {
    t3[t3.OFF = 0] = "OFF", t3[t3.POW2 = 1] = "POW2", t3[t3.ON = 2] = "ON", t3[t3.ON_MANUAL = 3] = "ON_MANUAL";
  }(av || (av = {})), function(t3) {
    t3[t3.NPM = 0] = "NPM", t3[t3.UNPACK = 1] = "UNPACK", t3[t3.PMA = 2] = "PMA", t3[t3.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", t3[t3.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", t3[t3.PREMULTIPLY_ALPHA = 2] = "PREMULTIPLY_ALPHA", t3[t3.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA";
  }(lv || (lv = {})), function(t3) {
    t3[t3.NO = 0] = "NO", t3[t3.YES = 1] = "YES", t3[t3.AUTO = 2] = "AUTO", t3[t3.BLEND = 0] = "BLEND", t3[t3.CLEAR = 1] = "CLEAR", t3[t3.BLIT = 2] = "BLIT";
  }(uv || (uv = {})), function(t3) {
    t3[t3.AUTO = 0] = "AUTO", t3[t3.MANUAL = 1] = "MANUAL";
  }(hv || (hv = {})), function(t3) {
    t3.LOW = "lowp", t3.MEDIUM = "mediump", t3.HIGH = "highp";
  }(cv || (cv = {})), function(t3) {
    t3[t3.NONE = 0] = "NONE", t3[t3.SCISSOR = 1] = "SCISSOR", t3[t3.STENCIL = 2] = "STENCIL", t3[t3.SPRITE = 3] = "SPRITE";
  }(dv || (dv = {})), function(t3) {
    t3[t3.NONE = 0] = "NONE", t3[t3.LOW = 2] = "LOW", t3[t3.MEDIUM = 4] = "MEDIUM", t3[t3.HIGH = 8] = "HIGH";
  }(pv || (pv = {})), function(t3) {
    t3[t3.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", t3[t3.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", t3[t3.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER";
  }(fv || (fv = {}));
  /*!
   * @pixi/utils - v6.2.0
   * Compiled Mon, 01 Nov 2021 16:52:10 UTC
   *
   * @pixi/utils is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   */
  var bv = { parse: xv.parse, format: xv.format, resolve: xv.resolve };
  mv.RETINA_PREFIX = /@([0-9\.]+)x/, mv.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = false;
  var Tv, wv = false;
  function Sv() {
    wv = true;
  }
  function Ev(t3) {
    var e3;
    if (!wv) {
      if (navigator.userAgent.toLowerCase().indexOf("chrome") > -1) {
        var n2 = ["\n %c %c %c PixiJS 6.2.0 - \u2730 " + t3 + " \u2730  %c  %c  http://www.pixijs.com/  %c %c \u2665%c\u2665%c\u2665 \n\n", "background: #ff66a5; padding:5px 0;", "background: #ff66a5; padding:5px 0;", "color: #ff66a5; background: #030307; padding:5px 0;", "background: #ff66a5; padding:5px 0;", "background: #ffc3dc; padding:5px 0;", "background: #ff66a5; padding:5px 0;", "color: #ff2424; background: #fff; padding:5px 0;", "color: #ff2424; background: #fff; padding:5px 0;", "color: #ff2424; background: #fff; padding:5px 0;"];
        (e3 = self.console).log.apply(e3, n2);
      } else
        self.console && self.console.log("PixiJS 6.2.0 - " + t3 + " - http://www.pixijs.com/");
      wv = true;
    }
  }
  function Mv() {
    return Tv === void 0 && (Tv = function() {
      var t3 = { stencil: true, failIfMajorPerformanceCaveat: mv.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT };
      try {
        if (!self.WebGLRenderingContext)
          return false;
        var e3 = document.createElement("canvas"), n2 = e3.getContext("webgl", t3) || e3.getContext("experimental-webgl", t3), i2 = !(!n2 || !n2.getContextAttributes().stencil);
        if (n2) {
          var r3 = n2.getExtension("WEBGL_lose_context");
          r3 && r3.loseContext();
        }
        return n2 = null, i2;
      } catch (t4) {
        return false;
      }
    }()), Tv;
  }
  var Av = { aliceblue: "#f0f8ff", antiquewhite: "#faebd7", aqua: "#00ffff", aquamarine: "#7fffd4", azure: "#f0ffff", beige: "#f5f5dc", bisque: "#ffe4c4", black: "#000000", blanchedalmond: "#ffebcd", blue: "#0000ff", blueviolet: "#8a2be2", brown: "#a52a2a", burlywood: "#deb887", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", cornflowerblue: "#6495ed", cornsilk: "#fff8dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkgray: "#a9a9a9", darkgreen: "#006400", darkgrey: "#a9a9a9", darkkhaki: "#bdb76b", darkmagenta: "#8b008b", darkolivegreen: "#556b2f", darkorange: "#ff8c00", darkorchid: "#9932cc", darkred: "#8b0000", darksalmon: "#e9967a", darkseagreen: "#8fbc8f", darkslateblue: "#483d8b", darkslategray: "#2f4f4f", darkslategrey: "#2f4f4f", darkturquoise: "#00ced1", darkviolet: "#9400d3", deeppink: "#ff1493", deepskyblue: "#00bfff", dimgray: "#696969", dimgrey: "#696969", dodgerblue: "#1e90ff", firebrick: "#b22222", floralwhite: "#fffaf0", forestgreen: "#228b22", fuchsia: "#ff00ff", gainsboro: "#dcdcdc", ghostwhite: "#f8f8ff", goldenrod: "#daa520", gold: "#ffd700", gray: "#808080", green: "#008000", greenyellow: "#adff2f", grey: "#808080", honeydew: "#f0fff0", hotpink: "#ff69b4", indianred: "#cd5c5c", indigo: "#4b0082", ivory: "#fffff0", khaki: "#f0e68c", lavenderblush: "#fff0f5", lavender: "#e6e6fa", lawngreen: "#7cfc00", lemonchiffon: "#fffacd", lightblue: "#add8e6", lightcoral: "#f08080", lightcyan: "#e0ffff", lightgoldenrodyellow: "#fafad2", lightgray: "#d3d3d3", lightgreen: "#90ee90", lightgrey: "#d3d3d3", lightpink: "#ffb6c1", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", lightskyblue: "#87cefa", lightslategray: "#778899", lightslategrey: "#778899", lightsteelblue: "#b0c4de", lightyellow: "#ffffe0", lime: "#00ff00", limegreen: "#32cd32", linen: "#faf0e6", magenta: "#ff00ff", maroon: "#800000", mediumaquamarine: "#66cdaa", mediumblue: "#0000cd", mediumorchid: "#ba55d3", mediumpurple: "#9370db", mediumseagreen: "#3cb371", mediumslateblue: "#7b68ee", mediumspringgreen: "#00fa9a", mediumturquoise: "#48d1cc", mediumvioletred: "#c71585", midnightblue: "#191970", mintcream: "#f5fffa", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", navajowhite: "#ffdead", navy: "#000080", oldlace: "#fdf5e6", olive: "#808000", olivedrab: "#6b8e23", orange: "#ffa500", orangered: "#ff4500", orchid: "#da70d6", palegoldenrod: "#eee8aa", palegreen: "#98fb98", paleturquoise: "#afeeee", palevioletred: "#db7093", papayawhip: "#ffefd5", peachpuff: "#ffdab9", peru: "#cd853f", pink: "#ffc0cb", plum: "#dda0dd", powderblue: "#b0e0e6", purple: "#800080", rebeccapurple: "#663399", red: "#ff0000", rosybrown: "#bc8f8f", royalblue: "#4169e1", saddlebrown: "#8b4513", salmon: "#fa8072", sandybrown: "#f4a460", seagreen: "#2e8b57", seashell: "#fff5ee", sienna: "#a0522d", silver: "#c0c0c0", skyblue: "#87ceeb", slateblue: "#6a5acd", slategray: "#708090", slategrey: "#708090", snow: "#fffafa", springgreen: "#00ff7f", steelblue: "#4682b4", tan: "#d2b48c", teal: "#008080", thistle: "#d8bfd8", tomato: "#ff6347", turquoise: "#40e0d0", violet: "#ee82ee", wheat: "#f5deb3", white: "#ffffff", whitesmoke: "#f5f5f5", yellow: "#ffff00", yellowgreen: "#9acd32" };
  function Rv(t3, e3) {
    return e3 === void 0 && (e3 = []), e3[0] = (t3 >> 16 & 255) / 255, e3[1] = (t3 >> 8 & 255) / 255, e3[2] = (255 & t3) / 255, e3;
  }
  function Pv(t3) {
    var e3 = t3.toString(16);
    return "#" + (e3 = "000000".substr(0, 6 - e3.length) + e3);
  }
  function Cv(t3) {
    return typeof t3 == "string" && (t3 = Av[t3.toLowerCase()] || t3)[0] === "#" && (t3 = t3.substr(1)), parseInt(t3, 16);
  }
  function Iv(t3) {
    return (255 * t3[0] << 16) + (255 * t3[1] << 8) + (255 * t3[2] | 0);
  }
  var Ov = function() {
    for (var t3 = [], e3 = [], n2 = 0; n2 < 32; n2++)
      t3[n2] = n2, e3[n2] = n2;
    t3[Qg.NORMAL_NPM] = Qg.NORMAL, t3[Qg.ADD_NPM] = Qg.ADD, t3[Qg.SCREEN_NPM] = Qg.SCREEN, e3[Qg.NORMAL] = Qg.NORMAL_NPM, e3[Qg.ADD] = Qg.ADD_NPM, e3[Qg.SCREEN] = Qg.SCREEN_NPM;
    var i2 = [];
    return i2.push(e3), i2.push(t3), i2;
  }();
  function Lv(t3, e3) {
    return Ov[e3 ? 1 : 0][t3];
  }
  function Nv(t3, e3, n2, i2) {
    return n2 = n2 || new Float32Array(4), i2 || i2 === void 0 ? (n2[0] = t3[0] * e3, n2[1] = t3[1] * e3, n2[2] = t3[2] * e3) : (n2[0] = t3[0], n2[1] = t3[1], n2[2] = t3[2]), n2[3] = e3, n2;
  }
  function Dv(t3, e3) {
    if (e3 === 1)
      return (255 * e3 << 24) + t3;
    if (e3 === 0)
      return 0;
    var n2 = t3 >> 16 & 255, i2 = t3 >> 8 & 255, r3 = 255 & t3;
    return (255 * e3 << 24) + ((n2 = n2 * e3 + 0.5 | 0) << 16) + ((i2 = i2 * e3 + 0.5 | 0) << 8) + (r3 = r3 * e3 + 0.5 | 0);
  }
  function Fv(t3, e3, n2, i2) {
    return (n2 = n2 || new Float32Array(4))[0] = (t3 >> 16 & 255) / 255, n2[1] = (t3 >> 8 & 255) / 255, n2[2] = (255 & t3) / 255, (i2 || i2 === void 0) && (n2[0] *= e3, n2[1] *= e3, n2[2] *= e3), n2[3] = e3, n2;
  }
  function Bv(t3, e3) {
    e3 === void 0 && (e3 = null);
    var n2 = 6 * t3;
    if ((e3 = e3 || new Uint16Array(n2)).length !== n2)
      throw new Error("Out buffer length is incorrect, got " + e3.length + " and expected " + n2);
    for (var i2 = 0, r3 = 0; i2 < n2; i2 += 6, r3 += 4)
      e3[i2 + 0] = r3 + 0, e3[i2 + 1] = r3 + 1, e3[i2 + 2] = r3 + 2, e3[i2 + 3] = r3 + 0, e3[i2 + 4] = r3 + 2, e3[i2 + 5] = r3 + 3;
    return e3;
  }
  function Uv(t3) {
    if (t3.BYTES_PER_ELEMENT === 4)
      return t3 instanceof Float32Array ? "Float32Array" : t3 instanceof Uint32Array ? "Uint32Array" : "Int32Array";
    if (t3.BYTES_PER_ELEMENT === 2) {
      if (t3 instanceof Uint16Array)
        return "Uint16Array";
    } else if (t3.BYTES_PER_ELEMENT === 1 && t3 instanceof Uint8Array)
      return "Uint8Array";
    return null;
  }
  var kv = { Float32Array, Uint32Array, Int32Array, Uint8Array };
  function Gv(t3, e3) {
    for (var n2 = 0, i2 = 0, r3 = {}, o3 = 0; o3 < t3.length; o3++)
      i2 += e3[o3], n2 += t3[o3].length;
    var s3 = new ArrayBuffer(4 * n2), a2 = null, l2 = 0;
    for (o3 = 0; o3 < t3.length; o3++) {
      var u2 = e3[o3], h2 = t3[o3], c2 = Uv(h2);
      r3[c2] || (r3[c2] = new kv[c2](s3)), a2 = r3[c2];
      for (var d2 = 0; d2 < h2.length; d2++) {
        a2[(d2 / u2 | 0) * i2 + l2 + d2 % u2] = h2[d2];
      }
      l2 += u2;
    }
    return new Float32Array(s3);
  }
  function Hv(t3) {
    return t3 += t3 === 0 ? 1 : 0, --t3, t3 |= t3 >>> 1, t3 |= t3 >>> 2, t3 |= t3 >>> 4, t3 |= t3 >>> 8, (t3 |= t3 >>> 16) + 1;
  }
  function zv(t3) {
    return !(t3 & t3 - 1 || !t3);
  }
  function jv(t3) {
    var e3 = (t3 > 65535 ? 1 : 0) << 4, n2 = ((t3 >>>= e3) > 255 ? 1 : 0) << 3;
    return e3 |= n2, e3 |= n2 = ((t3 >>>= n2) > 15 ? 1 : 0) << 2, (e3 |= n2 = ((t3 >>>= n2) > 3 ? 1 : 0) << 1) | (t3 >>>= n2) >> 1;
  }
  function Vv(t3, e3, n2) {
    var i2, r3 = t3.length;
    if (!(e3 >= r3 || n2 === 0)) {
      var o3 = r3 - (n2 = e3 + n2 > r3 ? r3 - e3 : n2);
      for (i2 = e3; i2 < o3; ++i2)
        t3[i2] = t3[i2 + n2];
      t3.length = o3;
    }
  }
  function Wv(t3) {
    return t3 === 0 ? 0 : t3 < 0 ? -1 : 1;
  }
  var Xv = 0;
  function qv() {
    return ++Xv;
  }
  var Yv = {};
  function Zv(t3, e3, n2) {
    if (n2 === void 0 && (n2 = 3), !Yv[e3]) {
      var i2 = new Error().stack;
      i2 === void 0 ? console.warn("PixiJS Deprecation Warning: ", e3 + "\nDeprecated since v" + t3) : (i2 = i2.split("\n").splice(n2).join("\n"), console.groupCollapsed ? (console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", e3 + "\nDeprecated since v" + t3), console.warn(i2), console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", e3 + "\nDeprecated since v" + t3), console.warn(i2))), Yv[e3] = true;
    }
  }
  var Jv = {}, $v = Object.create(null), Kv = Object.create(null);
  function Qv() {
    var t3;
    for (t3 in $v)
      $v[t3].destroy();
    for (t3 in Kv)
      Kv[t3].destroy();
  }
  function t_() {
    var t3;
    for (t3 in $v)
      delete $v[t3];
    for (t3 in Kv)
      delete Kv[t3];
  }
  var e_ = function() {
    function t3(t4, e3, n2) {
      this.canvas = document.createElement("canvas"), this.context = this.canvas.getContext("2d"), this.resolution = n2 || mv.RESOLUTION, this.resize(t4, e3);
    }
    return t3.prototype.clear = function() {
      this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }, t3.prototype.resize = function(t4, e3) {
      this.canvas.width = Math.round(t4 * this.resolution), this.canvas.height = Math.round(e3 * this.resolution);
    }, t3.prototype.destroy = function() {
      this.context = null, this.canvas = null;
    }, Object.defineProperty(t3.prototype, "width", { get: function() {
      return this.canvas.width;
    }, set: function(t4) {
      this.canvas.width = Math.round(t4);
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "height", { get: function() {
      return this.canvas.height;
    }, set: function(t4) {
      this.canvas.height = Math.round(t4);
    }, enumerable: false, configurable: true }), t3;
  }();
  function n_(t3) {
    var e3, n2, i2, r3 = t3.width, o3 = t3.height, s3 = t3.getContext("2d"), a2 = s3.getImageData(0, 0, r3, o3).data, l2 = a2.length, u2 = { top: null, left: null, right: null, bottom: null }, h2 = null;
    for (e3 = 0; e3 < l2; e3 += 4)
      a2[e3 + 3] !== 0 && (n2 = e3 / 4 % r3, i2 = ~~(e3 / 4 / r3), u2.top === null && (u2.top = i2), (u2.left === null || n2 < u2.left) && (u2.left = n2), (u2.right === null || u2.right < n2) && (u2.right = n2 + 1), (u2.bottom === null || u2.bottom < i2) && (u2.bottom = i2));
    return u2.top !== null && (r3 = u2.right - u2.left, o3 = u2.bottom - u2.top + 1, h2 = s3.getImageData(u2.left, u2.top, r3, o3)), { height: o3, width: r3, data: h2 };
  }
  var i_, r_ = /^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;charset=([\w-]+))?(?:;(base64))?,(.*)/i;
  function o_(t3) {
    var e3 = r_.exec(t3);
    if (e3)
      return { mediaType: e3[1] ? e3[1].toLowerCase() : void 0, subType: e3[2] ? e3[2].toLowerCase() : void 0, charset: e3[3] ? e3[3].toLowerCase() : void 0, encoding: e3[4] ? e3[4].toLowerCase() : void 0, data: e3[5] };
  }
  function s_(t3, e3) {
    if (e3 === void 0 && (e3 = self.location), t3.indexOf("data:") === 0)
      return "";
    e3 = e3 || self.location, i_ || (i_ = document.createElement("a")), i_.href = t3;
    var n2 = bv.parse(i_.href), i2 = !n2.port && e3.port === "" || n2.port === e3.port;
    return n2.hostname === e3.hostname && i2 && n2.protocol === e3.protocol ? "" : "anonymous";
  }
  function a_(t3, e3) {
    var n2 = mv.RETINA_PREFIX.exec(t3);
    return n2 ? parseFloat(n2[1]) : e3 !== void 0 ? e3 : 1;
  }
  /*!
   * @pixi/math - v6.2.0
   * Compiled Mon, 01 Nov 2021 16:52:10 UTC
   *
   * @pixi/math is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   */
  var l_, u_ = 2 * Math.PI, h_ = 180 / Math.PI, c_ = Math.PI / 180;
  !function(t3) {
    t3[t3.POLY = 0] = "POLY", t3[t3.RECT = 1] = "RECT", t3[t3.CIRC = 2] = "CIRC", t3[t3.ELIP = 3] = "ELIP", t3[t3.RREC = 4] = "RREC";
  }(l_ || (l_ = {}));
  var d_ = function() {
    function t3(t4, e3, n2, i2) {
      t4 === void 0 && (t4 = 0), e3 === void 0 && (e3 = 0), n2 === void 0 && (n2 = 0), i2 === void 0 && (i2 = 0), this.x = Number(t4), this.y = Number(e3), this.width = Number(n2), this.height = Number(i2), this.type = l_.RECT;
    }
    return Object.defineProperty(t3.prototype, "left", { get: function() {
      return this.x;
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "right", { get: function() {
      return this.x + this.width;
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "top", { get: function() {
      return this.y;
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "bottom", { get: function() {
      return this.y + this.height;
    }, enumerable: false, configurable: true }), Object.defineProperty(t3, "EMPTY", { get: function() {
      return new t3(0, 0, 0, 0);
    }, enumerable: false, configurable: true }), t3.prototype.clone = function() {
      return new t3(this.x, this.y, this.width, this.height);
    }, t3.prototype.copyFrom = function(t4) {
      return this.x = t4.x, this.y = t4.y, this.width = t4.width, this.height = t4.height, this;
    }, t3.prototype.copyTo = function(t4) {
      return t4.x = this.x, t4.y = this.y, t4.width = this.width, t4.height = this.height, t4;
    }, t3.prototype.contains = function(t4, e3) {
      return !(this.width <= 0 || this.height <= 0) && (t4 >= this.x && t4 < this.x + this.width && e3 >= this.y && e3 < this.y + this.height);
    }, t3.prototype.pad = function(t4, e3) {
      return t4 === void 0 && (t4 = 0), e3 === void 0 && (e3 = t4), this.x -= t4, this.y -= e3, this.width += 2 * t4, this.height += 2 * e3, this;
    }, t3.prototype.fit = function(t4) {
      var e3 = Math.max(this.x, t4.x), n2 = Math.min(this.x + this.width, t4.x + t4.width), i2 = Math.max(this.y, t4.y), r3 = Math.min(this.y + this.height, t4.y + t4.height);
      return this.x = e3, this.width = Math.max(n2 - e3, 0), this.y = i2, this.height = Math.max(r3 - i2, 0), this;
    }, t3.prototype.ceil = function(t4, e3) {
      t4 === void 0 && (t4 = 1), e3 === void 0 && (e3 = 1e-3);
      var n2 = Math.ceil((this.x + this.width - e3) * t4) / t4, i2 = Math.ceil((this.y + this.height - e3) * t4) / t4;
      return this.x = Math.floor((this.x + e3) * t4) / t4, this.y = Math.floor((this.y + e3) * t4) / t4, this.width = n2 - this.x, this.height = i2 - this.y, this;
    }, t3.prototype.enlarge = function(t4) {
      var e3 = Math.min(this.x, t4.x), n2 = Math.max(this.x + this.width, t4.x + t4.width), i2 = Math.min(this.y, t4.y), r3 = Math.max(this.y + this.height, t4.y + t4.height);
      return this.x = e3, this.width = n2 - e3, this.y = i2, this.height = r3 - i2, this;
    }, t3.prototype.toString = function() {
      return "[@pixi/math:Rectangle x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + "]";
    }, t3;
  }(), p_ = function() {
    function t3(t4, e3, n2) {
      t4 === void 0 && (t4 = 0), e3 === void 0 && (e3 = 0), n2 === void 0 && (n2 = 0), this.x = t4, this.y = e3, this.radius = n2, this.type = l_.CIRC;
    }
    return t3.prototype.clone = function() {
      return new t3(this.x, this.y, this.radius);
    }, t3.prototype.contains = function(t4, e3) {
      if (this.radius <= 0)
        return false;
      var n2 = this.radius * this.radius, i2 = this.x - t4, r3 = this.y - e3;
      return (i2 *= i2) + (r3 *= r3) <= n2;
    }, t3.prototype.getBounds = function() {
      return new d_(this.x - this.radius, this.y - this.radius, 2 * this.radius, 2 * this.radius);
    }, t3.prototype.toString = function() {
      return "[@pixi/math:Circle x=" + this.x + " y=" + this.y + " radius=" + this.radius + "]";
    }, t3;
  }(), f_ = function() {
    function t3(t4, e3, n2, i2) {
      t4 === void 0 && (t4 = 0), e3 === void 0 && (e3 = 0), n2 === void 0 && (n2 = 0), i2 === void 0 && (i2 = 0), this.x = t4, this.y = e3, this.width = n2, this.height = i2, this.type = l_.ELIP;
    }
    return t3.prototype.clone = function() {
      return new t3(this.x, this.y, this.width, this.height);
    }, t3.prototype.contains = function(t4, e3) {
      if (this.width <= 0 || this.height <= 0)
        return false;
      var n2 = (t4 - this.x) / this.width, i2 = (e3 - this.y) / this.height;
      return (n2 *= n2) + (i2 *= i2) <= 1;
    }, t3.prototype.getBounds = function() {
      return new d_(this.x - this.width, this.y - this.height, this.width, this.height);
    }, t3.prototype.toString = function() {
      return "[@pixi/math:Ellipse x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + "]";
    }, t3;
  }(), m_ = function() {
    function t3() {
      for (var t4 = arguments, e3 = [], n2 = 0; n2 < arguments.length; n2++)
        e3[n2] = t4[n2];
      var i2 = Array.isArray(e3[0]) ? e3[0] : e3;
      if (typeof i2[0] != "number") {
        for (var r3 = [], o3 = 0, s3 = i2.length; o3 < s3; o3++)
          r3.push(i2[o3].x, i2[o3].y);
        i2 = r3;
      }
      this.points = i2, this.type = l_.POLY, this.closeStroke = true;
    }
    return t3.prototype.clone = function() {
      var e3 = new t3(this.points.slice());
      return e3.closeStroke = this.closeStroke, e3;
    }, t3.prototype.contains = function(t4, e3) {
      for (var n2 = false, i2 = this.points.length / 2, r3 = 0, o3 = i2 - 1; r3 < i2; o3 = r3++) {
        var s3 = this.points[2 * r3], a2 = this.points[2 * r3 + 1], l2 = this.points[2 * o3], u2 = this.points[2 * o3 + 1];
        a2 > e3 != u2 > e3 && t4 < (e3 - a2) / (u2 - a2) * (l2 - s3) + s3 && (n2 = !n2);
      }
      return n2;
    }, t3.prototype.toString = function() {
      return "[@pixi/math:PolygoncloseStroke=" + this.closeStroke + "points=" + this.points.reduce(function(t4, e3) {
        return t4 + ", " + e3;
      }, "") + "]";
    }, t3;
  }(), g_ = function() {
    function t3(t4, e3, n2, i2, r3) {
      t4 === void 0 && (t4 = 0), e3 === void 0 && (e3 = 0), n2 === void 0 && (n2 = 0), i2 === void 0 && (i2 = 0), r3 === void 0 && (r3 = 20), this.x = t4, this.y = e3, this.width = n2, this.height = i2, this.radius = r3, this.type = l_.RREC;
    }
    return t3.prototype.clone = function() {
      return new t3(this.x, this.y, this.width, this.height, this.radius);
    }, t3.prototype.contains = function(t4, e3) {
      if (this.width <= 0 || this.height <= 0)
        return false;
      if (t4 >= this.x && t4 <= this.x + this.width && e3 >= this.y && e3 <= this.y + this.height) {
        if (e3 >= this.y + this.radius && e3 <= this.y + this.height - this.radius || t4 >= this.x + this.radius && t4 <= this.x + this.width - this.radius)
          return true;
        var n2 = t4 - (this.x + this.radius), i2 = e3 - (this.y + this.radius), r3 = this.radius * this.radius;
        if (n2 * n2 + i2 * i2 <= r3)
          return true;
        if ((n2 = t4 - (this.x + this.width - this.radius)) * n2 + i2 * i2 <= r3)
          return true;
        if (n2 * n2 + (i2 = e3 - (this.y + this.height - this.radius)) * i2 <= r3)
          return true;
        if ((n2 = t4 - (this.x + this.radius)) * n2 + i2 * i2 <= r3)
          return true;
      }
      return false;
    }, t3.prototype.toString = function() {
      return "[@pixi/math:RoundedRectangle x=" + this.x + " y=" + this.y + "width=" + this.width + " height=" + this.height + " radius=" + this.radius + "]";
    }, t3;
  }(), v_ = function() {
    function t3(t4, e3) {
      t4 === void 0 && (t4 = 0), e3 === void 0 && (e3 = 0), this.x = 0, this.y = 0, this.x = t4, this.y = e3;
    }
    return t3.prototype.clone = function() {
      return new t3(this.x, this.y);
    }, t3.prototype.copyFrom = function(t4) {
      return this.set(t4.x, t4.y), this;
    }, t3.prototype.copyTo = function(t4) {
      return t4.set(this.x, this.y), t4;
    }, t3.prototype.equals = function(t4) {
      return t4.x === this.x && t4.y === this.y;
    }, t3.prototype.set = function(t4, e3) {
      return t4 === void 0 && (t4 = 0), e3 === void 0 && (e3 = t4), this.x = t4, this.y = e3, this;
    }, t3.prototype.toString = function() {
      return "[@pixi/math:Point x=" + this.x + " y=" + this.y + "]";
    }, t3;
  }(), __ = function() {
    function t3(t4, e3, n2, i2) {
      n2 === void 0 && (n2 = 0), i2 === void 0 && (i2 = 0), this._x = n2, this._y = i2, this.cb = t4, this.scope = e3;
    }
    return t3.prototype.clone = function(e3, n2) {
      return e3 === void 0 && (e3 = this.cb), n2 === void 0 && (n2 = this.scope), new t3(e3, n2, this._x, this._y);
    }, t3.prototype.set = function(t4, e3) {
      return t4 === void 0 && (t4 = 0), e3 === void 0 && (e3 = t4), this._x === t4 && this._y === e3 || (this._x = t4, this._y = e3, this.cb.call(this.scope)), this;
    }, t3.prototype.copyFrom = function(t4) {
      return this._x === t4.x && this._y === t4.y || (this._x = t4.x, this._y = t4.y, this.cb.call(this.scope)), this;
    }, t3.prototype.copyTo = function(t4) {
      return t4.set(this._x, this._y), t4;
    }, t3.prototype.equals = function(t4) {
      return t4.x === this._x && t4.y === this._y;
    }, t3.prototype.toString = function() {
      return "[@pixi/math:ObservablePoint x=0 y=0 scope=" + this.scope + "]";
    }, Object.defineProperty(t3.prototype, "x", { get: function() {
      return this._x;
    }, set: function(t4) {
      this._x !== t4 && (this._x = t4, this.cb.call(this.scope));
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "y", { get: function() {
      return this._y;
    }, set: function(t4) {
      this._y !== t4 && (this._y = t4, this.cb.call(this.scope));
    }, enumerable: false, configurable: true }), t3;
  }(), y_ = function() {
    function t3(t4, e3, n2, i2, r3, o3) {
      t4 === void 0 && (t4 = 1), e3 === void 0 && (e3 = 0), n2 === void 0 && (n2 = 0), i2 === void 0 && (i2 = 1), r3 === void 0 && (r3 = 0), o3 === void 0 && (o3 = 0), this.array = null, this.a = t4, this.b = e3, this.c = n2, this.d = i2, this.tx = r3, this.ty = o3;
    }
    return t3.prototype.fromArray = function(t4) {
      this.a = t4[0], this.b = t4[1], this.c = t4[3], this.d = t4[4], this.tx = t4[2], this.ty = t4[5];
    }, t3.prototype.set = function(t4, e3, n2, i2, r3, o3) {
      return this.a = t4, this.b = e3, this.c = n2, this.d = i2, this.tx = r3, this.ty = o3, this;
    }, t3.prototype.toArray = function(t4, e3) {
      this.array || (this.array = new Float32Array(9));
      var n2 = e3 || this.array;
      return t4 ? (n2[0] = this.a, n2[1] = this.b, n2[2] = 0, n2[3] = this.c, n2[4] = this.d, n2[5] = 0, n2[6] = this.tx, n2[7] = this.ty, n2[8] = 1) : (n2[0] = this.a, n2[1] = this.c, n2[2] = this.tx, n2[3] = this.b, n2[4] = this.d, n2[5] = this.ty, n2[6] = 0, n2[7] = 0, n2[8] = 1), n2;
    }, t3.prototype.apply = function(t4, e3) {
      e3 = e3 || new v_();
      var n2 = t4.x, i2 = t4.y;
      return e3.x = this.a * n2 + this.c * i2 + this.tx, e3.y = this.b * n2 + this.d * i2 + this.ty, e3;
    }, t3.prototype.applyInverse = function(t4, e3) {
      e3 = e3 || new v_();
      var n2 = 1 / (this.a * this.d + this.c * -this.b), i2 = t4.x, r3 = t4.y;
      return e3.x = this.d * n2 * i2 + -this.c * n2 * r3 + (this.ty * this.c - this.tx * this.d) * n2, e3.y = this.a * n2 * r3 + -this.b * n2 * i2 + (-this.ty * this.a + this.tx * this.b) * n2, e3;
    }, t3.prototype.translate = function(t4, e3) {
      return this.tx += t4, this.ty += e3, this;
    }, t3.prototype.scale = function(t4, e3) {
      return this.a *= t4, this.d *= e3, this.c *= t4, this.b *= e3, this.tx *= t4, this.ty *= e3, this;
    }, t3.prototype.rotate = function(t4) {
      var e3 = Math.cos(t4), n2 = Math.sin(t4), i2 = this.a, r3 = this.c, o3 = this.tx;
      return this.a = i2 * e3 - this.b * n2, this.b = i2 * n2 + this.b * e3, this.c = r3 * e3 - this.d * n2, this.d = r3 * n2 + this.d * e3, this.tx = o3 * e3 - this.ty * n2, this.ty = o3 * n2 + this.ty * e3, this;
    }, t3.prototype.append = function(t4) {
      var e3 = this.a, n2 = this.b, i2 = this.c, r3 = this.d;
      return this.a = t4.a * e3 + t4.b * i2, this.b = t4.a * n2 + t4.b * r3, this.c = t4.c * e3 + t4.d * i2, this.d = t4.c * n2 + t4.d * r3, this.tx = t4.tx * e3 + t4.ty * i2 + this.tx, this.ty = t4.tx * n2 + t4.ty * r3 + this.ty, this;
    }, t3.prototype.setTransform = function(t4, e3, n2, i2, r3, o3, s3, a2, l2) {
      return this.a = Math.cos(s3 + l2) * r3, this.b = Math.sin(s3 + l2) * r3, this.c = -Math.sin(s3 - a2) * o3, this.d = Math.cos(s3 - a2) * o3, this.tx = t4 - (n2 * this.a + i2 * this.c), this.ty = e3 - (n2 * this.b + i2 * this.d), this;
    }, t3.prototype.prepend = function(t4) {
      var e3 = this.tx;
      if (t4.a !== 1 || t4.b !== 0 || t4.c !== 0 || t4.d !== 1) {
        var n2 = this.a, i2 = this.c;
        this.a = n2 * t4.a + this.b * t4.c, this.b = n2 * t4.b + this.b * t4.d, this.c = i2 * t4.a + this.d * t4.c, this.d = i2 * t4.b + this.d * t4.d;
      }
      return this.tx = e3 * t4.a + this.ty * t4.c + t4.tx, this.ty = e3 * t4.b + this.ty * t4.d + t4.ty, this;
    }, t3.prototype.decompose = function(t4) {
      var e3 = this.a, n2 = this.b, i2 = this.c, r3 = this.d, o3 = t4.pivot, s3 = -Math.atan2(-i2, r3), a2 = Math.atan2(n2, e3), l2 = Math.abs(s3 + a2);
      return l2 < 1e-5 || Math.abs(u_ - l2) < 1e-5 ? (t4.rotation = a2, t4.skew.x = t4.skew.y = 0) : (t4.rotation = 0, t4.skew.x = s3, t4.skew.y = a2), t4.scale.x = Math.sqrt(e3 * e3 + n2 * n2), t4.scale.y = Math.sqrt(i2 * i2 + r3 * r3), t4.position.x = this.tx + (o3.x * e3 + o3.y * i2), t4.position.y = this.ty + (o3.x * n2 + o3.y * r3), t4;
    }, t3.prototype.invert = function() {
      var t4 = this.a, e3 = this.b, n2 = this.c, i2 = this.d, r3 = this.tx, o3 = t4 * i2 - e3 * n2;
      return this.a = i2 / o3, this.b = -e3 / o3, this.c = -n2 / o3, this.d = t4 / o3, this.tx = (n2 * this.ty - i2 * r3) / o3, this.ty = -(t4 * this.ty - e3 * r3) / o3, this;
    }, t3.prototype.identity = function() {
      return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this;
    }, t3.prototype.clone = function() {
      var e3 = new t3();
      return e3.a = this.a, e3.b = this.b, e3.c = this.c, e3.d = this.d, e3.tx = this.tx, e3.ty = this.ty, e3;
    }, t3.prototype.copyTo = function(t4) {
      return t4.a = this.a, t4.b = this.b, t4.c = this.c, t4.d = this.d, t4.tx = this.tx, t4.ty = this.ty, t4;
    }, t3.prototype.copyFrom = function(t4) {
      return this.a = t4.a, this.b = t4.b, this.c = t4.c, this.d = t4.d, this.tx = t4.tx, this.ty = t4.ty, this;
    }, t3.prototype.toString = function() {
      return "[@pixi/math:Matrix a=" + this.a + " b=" + this.b + " c=" + this.c + " d=" + this.d + " tx=" + this.tx + " ty=" + this.ty + "]";
    }, Object.defineProperty(t3, "IDENTITY", { get: function() {
      return new t3();
    }, enumerable: false, configurable: true }), Object.defineProperty(t3, "TEMP_MATRIX", { get: function() {
      return new t3();
    }, enumerable: false, configurable: true }), t3;
  }(), x_ = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1], b_ = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1], T_ = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1], w_ = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1], S_ = [], E_ = [], M_ = Math.sign;
  !function() {
    for (var t3 = 0; t3 < 16; t3++) {
      var e3 = [];
      S_.push(e3);
      for (var n2 = 0; n2 < 16; n2++)
        for (var i2 = M_(x_[t3] * x_[n2] + T_[t3] * b_[n2]), r3 = M_(b_[t3] * x_[n2] + w_[t3] * b_[n2]), o3 = M_(x_[t3] * T_[n2] + T_[t3] * w_[n2]), s3 = M_(b_[t3] * T_[n2] + w_[t3] * w_[n2]), a2 = 0; a2 < 16; a2++)
          if (x_[a2] === i2 && b_[a2] === r3 && T_[a2] === o3 && w_[a2] === s3) {
            e3.push(a2);
            break;
          }
    }
    for (t3 = 0; t3 < 16; t3++) {
      var l2 = new y_();
      l2.set(x_[t3], b_[t3], T_[t3], w_[t3], 0, 0), E_.push(l2);
    }
  }();
  var A_ = { E: 0, SE: 1, S: 2, SW: 3, W: 4, NW: 5, N: 6, NE: 7, MIRROR_VERTICAL: 8, MAIN_DIAGONAL: 10, MIRROR_HORIZONTAL: 12, REVERSE_DIAGONAL: 14, uX: function(t3) {
    return x_[t3];
  }, uY: function(t3) {
    return b_[t3];
  }, vX: function(t3) {
    return T_[t3];
  }, vY: function(t3) {
    return w_[t3];
  }, inv: function(t3) {
    return 8 & t3 ? 15 & t3 : 7 & -t3;
  }, add: function(t3, e3) {
    return S_[t3][e3];
  }, sub: function(t3, e3) {
    return S_[t3][A_.inv(e3)];
  }, rotate180: function(t3) {
    return 4 ^ t3;
  }, isVertical: function(t3) {
    return (3 & t3) == 2;
  }, byDirection: function(t3, e3) {
    return 2 * Math.abs(t3) <= Math.abs(e3) ? e3 >= 0 ? A_.S : A_.N : 2 * Math.abs(e3) <= Math.abs(t3) ? t3 > 0 ? A_.E : A_.W : e3 > 0 ? t3 > 0 ? A_.SE : A_.SW : t3 > 0 ? A_.NE : A_.NW;
  }, matrixAppendRotationInv: function(t3, e3, n2, i2) {
    n2 === void 0 && (n2 = 0), i2 === void 0 && (i2 = 0);
    var r3 = E_[A_.inv(e3)];
    r3.tx = n2, r3.ty = i2, t3.append(r3);
  } }, R_ = function() {
    function t3() {
      this.worldTransform = new y_(), this.localTransform = new y_(), this.position = new __(this.onChange, this, 0, 0), this.scale = new __(this.onChange, this, 1, 1), this.pivot = new __(this.onChange, this, 0, 0), this.skew = new __(this.updateSkew, this, 0, 0), this._rotation = 0, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._localID = 0, this._currentLocalID = 0, this._worldID = 0, this._parentID = 0;
    }
    return t3.prototype.onChange = function() {
      this._localID++;
    }, t3.prototype.updateSkew = function() {
      this._cx = Math.cos(this._rotation + this.skew.y), this._sx = Math.sin(this._rotation + this.skew.y), this._cy = -Math.sin(this._rotation - this.skew.x), this._sy = Math.cos(this._rotation - this.skew.x), this._localID++;
    }, t3.prototype.toString = function() {
      return "[@pixi/math:Transform position=(" + this.position.x + ", " + this.position.y + ") rotation=" + this.rotation + " scale=(" + this.scale.x + ", " + this.scale.y + ") skew=(" + this.skew.x + ", " + this.skew.y + ") ]";
    }, t3.prototype.updateLocalTransform = function() {
      var t4 = this.localTransform;
      this._localID !== this._currentLocalID && (t4.a = this._cx * this.scale.x, t4.b = this._sx * this.scale.x, t4.c = this._cy * this.scale.y, t4.d = this._sy * this.scale.y, t4.tx = this.position.x - (this.pivot.x * t4.a + this.pivot.y * t4.c), t4.ty = this.position.y - (this.pivot.x * t4.b + this.pivot.y * t4.d), this._currentLocalID = this._localID, this._parentID = -1);
    }, t3.prototype.updateTransform = function(t4) {
      var e3 = this.localTransform;
      if (this._localID !== this._currentLocalID && (e3.a = this._cx * this.scale.x, e3.b = this._sx * this.scale.x, e3.c = this._cy * this.scale.y, e3.d = this._sy * this.scale.y, e3.tx = this.position.x - (this.pivot.x * e3.a + this.pivot.y * e3.c), e3.ty = this.position.y - (this.pivot.x * e3.b + this.pivot.y * e3.d), this._currentLocalID = this._localID, this._parentID = -1), this._parentID !== t4._worldID) {
        var n2 = t4.worldTransform, i2 = this.worldTransform;
        i2.a = e3.a * n2.a + e3.b * n2.c, i2.b = e3.a * n2.b + e3.b * n2.d, i2.c = e3.c * n2.a + e3.d * n2.c, i2.d = e3.c * n2.b + e3.d * n2.d, i2.tx = e3.tx * n2.a + e3.ty * n2.c + n2.tx, i2.ty = e3.tx * n2.b + e3.ty * n2.d + n2.ty, this._parentID = t4._worldID, this._worldID++;
      }
    }, t3.prototype.setFromMatrix = function(t4) {
      t4.decompose(this), this._localID++;
    }, Object.defineProperty(t3.prototype, "rotation", { get: function() {
      return this._rotation;
    }, set: function(t4) {
      this._rotation !== t4 && (this._rotation = t4, this.updateSkew());
    }, enumerable: false, configurable: true }), t3.IDENTITY = new t3(), t3;
  }();
  /*!
   * @pixi/display - v6.2.0
   * Compiled Mon, 01 Nov 2021 16:52:10 UTC
   *
   * @pixi/display is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   */
  mv.SORTABLE_CHILDREN = false;
  var P_ = function() {
    function t3() {
      this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.rect = null, this.updateID = -1;
    }
    return t3.prototype.isEmpty = function() {
      return this.minX > this.maxX || this.minY > this.maxY;
    }, t3.prototype.clear = function() {
      this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0;
    }, t3.prototype.getRectangle = function(t4) {
      return this.minX > this.maxX || this.minY > this.maxY ? d_.EMPTY : ((t4 = t4 || new d_(0, 0, 1, 1)).x = this.minX, t4.y = this.minY, t4.width = this.maxX - this.minX, t4.height = this.maxY - this.minY, t4);
    }, t3.prototype.addPoint = function(t4) {
      this.minX = Math.min(this.minX, t4.x), this.maxX = Math.max(this.maxX, t4.x), this.minY = Math.min(this.minY, t4.y), this.maxY = Math.max(this.maxY, t4.y);
    }, t3.prototype.addPointMatrix = function(t4, e3) {
      var n2 = t4.a, i2 = t4.b, r3 = t4.c, o3 = t4.d, s3 = t4.tx, a2 = t4.ty, l2 = n2 * e3.x + r3 * e3.y + s3, u2 = i2 * e3.x + o3 * e3.y + a2;
      this.minX = Math.min(this.minX, l2), this.maxX = Math.max(this.maxX, l2), this.minY = Math.min(this.minY, u2), this.maxY = Math.max(this.maxY, u2);
    }, t3.prototype.addQuad = function(t4) {
      var e3 = this.minX, n2 = this.minY, i2 = this.maxX, r3 = this.maxY, o3 = t4[0], s3 = t4[1];
      e3 = o3 < e3 ? o3 : e3, n2 = s3 < n2 ? s3 : n2, i2 = o3 > i2 ? o3 : i2, r3 = s3 > r3 ? s3 : r3, e3 = (o3 = t4[2]) < e3 ? o3 : e3, n2 = (s3 = t4[3]) < n2 ? s3 : n2, i2 = o3 > i2 ? o3 : i2, r3 = s3 > r3 ? s3 : r3, e3 = (o3 = t4[4]) < e3 ? o3 : e3, n2 = (s3 = t4[5]) < n2 ? s3 : n2, i2 = o3 > i2 ? o3 : i2, r3 = s3 > r3 ? s3 : r3, e3 = (o3 = t4[6]) < e3 ? o3 : e3, n2 = (s3 = t4[7]) < n2 ? s3 : n2, i2 = o3 > i2 ? o3 : i2, r3 = s3 > r3 ? s3 : r3, this.minX = e3, this.minY = n2, this.maxX = i2, this.maxY = r3;
    }, t3.prototype.addFrame = function(t4, e3, n2, i2, r3) {
      this.addFrameMatrix(t4.worldTransform, e3, n2, i2, r3);
    }, t3.prototype.addFrameMatrix = function(t4, e3, n2, i2, r3) {
      var o3 = t4.a, s3 = t4.b, a2 = t4.c, l2 = t4.d, u2 = t4.tx, h2 = t4.ty, c2 = this.minX, d2 = this.minY, p2 = this.maxX, f2 = this.maxY, m2 = o3 * e3 + a2 * n2 + u2, g2 = s3 * e3 + l2 * n2 + h2;
      c2 = m2 < c2 ? m2 : c2, d2 = g2 < d2 ? g2 : d2, p2 = m2 > p2 ? m2 : p2, f2 = g2 > f2 ? g2 : f2, c2 = (m2 = o3 * i2 + a2 * n2 + u2) < c2 ? m2 : c2, d2 = (g2 = s3 * i2 + l2 * n2 + h2) < d2 ? g2 : d2, p2 = m2 > p2 ? m2 : p2, f2 = g2 > f2 ? g2 : f2, c2 = (m2 = o3 * e3 + a2 * r3 + u2) < c2 ? m2 : c2, d2 = (g2 = s3 * e3 + l2 * r3 + h2) < d2 ? g2 : d2, p2 = m2 > p2 ? m2 : p2, f2 = g2 > f2 ? g2 : f2, c2 = (m2 = o3 * i2 + a2 * r3 + u2) < c2 ? m2 : c2, d2 = (g2 = s3 * i2 + l2 * r3 + h2) < d2 ? g2 : d2, p2 = m2 > p2 ? m2 : p2, f2 = g2 > f2 ? g2 : f2, this.minX = c2, this.minY = d2, this.maxX = p2, this.maxY = f2;
    }, t3.prototype.addVertexData = function(t4, e3, n2) {
      for (var i2 = this.minX, r3 = this.minY, o3 = this.maxX, s3 = this.maxY, a2 = e3; a2 < n2; a2 += 2) {
        var l2 = t4[a2], u2 = t4[a2 + 1];
        i2 = l2 < i2 ? l2 : i2, r3 = u2 < r3 ? u2 : r3, o3 = l2 > o3 ? l2 : o3, s3 = u2 > s3 ? u2 : s3;
      }
      this.minX = i2, this.minY = r3, this.maxX = o3, this.maxY = s3;
    }, t3.prototype.addVertices = function(t4, e3, n2, i2) {
      this.addVerticesMatrix(t4.worldTransform, e3, n2, i2);
    }, t3.prototype.addVerticesMatrix = function(t4, e3, n2, i2, r3, o3) {
      r3 === void 0 && (r3 = 0), o3 === void 0 && (o3 = r3);
      for (var s3 = t4.a, a2 = t4.b, l2 = t4.c, u2 = t4.d, h2 = t4.tx, c2 = t4.ty, d2 = this.minX, p2 = this.minY, f2 = this.maxX, m2 = this.maxY, g2 = n2; g2 < i2; g2 += 2) {
        var v2 = e3[g2], _2 = e3[g2 + 1], y2 = s3 * v2 + l2 * _2 + h2, x2 = u2 * _2 + a2 * v2 + c2;
        d2 = Math.min(d2, y2 - r3), f2 = Math.max(f2, y2 + r3), p2 = Math.min(p2, x2 - o3), m2 = Math.max(m2, x2 + o3);
      }
      this.minX = d2, this.minY = p2, this.maxX = f2, this.maxY = m2;
    }, t3.prototype.addBounds = function(t4) {
      var e3 = this.minX, n2 = this.minY, i2 = this.maxX, r3 = this.maxY;
      this.minX = t4.minX < e3 ? t4.minX : e3, this.minY = t4.minY < n2 ? t4.minY : n2, this.maxX = t4.maxX > i2 ? t4.maxX : i2, this.maxY = t4.maxY > r3 ? t4.maxY : r3;
    }, t3.prototype.addBoundsMask = function(t4, e3) {
      var n2 = t4.minX > e3.minX ? t4.minX : e3.minX, i2 = t4.minY > e3.minY ? t4.minY : e3.minY, r3 = t4.maxX < e3.maxX ? t4.maxX : e3.maxX, o3 = t4.maxY < e3.maxY ? t4.maxY : e3.maxY;
      if (n2 <= r3 && i2 <= o3) {
        var s3 = this.minX, a2 = this.minY, l2 = this.maxX, u2 = this.maxY;
        this.minX = n2 < s3 ? n2 : s3, this.minY = i2 < a2 ? i2 : a2, this.maxX = r3 > l2 ? r3 : l2, this.maxY = o3 > u2 ? o3 : u2;
      }
    }, t3.prototype.addBoundsMatrix = function(t4, e3) {
      this.addFrameMatrix(e3, t4.minX, t4.minY, t4.maxX, t4.maxY);
    }, t3.prototype.addBoundsArea = function(t4, e3) {
      var n2 = t4.minX > e3.x ? t4.minX : e3.x, i2 = t4.minY > e3.y ? t4.minY : e3.y, r3 = t4.maxX < e3.x + e3.width ? t4.maxX : e3.x + e3.width, o3 = t4.maxY < e3.y + e3.height ? t4.maxY : e3.y + e3.height;
      if (n2 <= r3 && i2 <= o3) {
        var s3 = this.minX, a2 = this.minY, l2 = this.maxX, u2 = this.maxY;
        this.minX = n2 < s3 ? n2 : s3, this.minY = i2 < a2 ? i2 : a2, this.maxX = r3 > l2 ? r3 : l2, this.maxY = o3 > u2 ? o3 : u2;
      }
    }, t3.prototype.pad = function(t4, e3) {
      t4 === void 0 && (t4 = 0), e3 === void 0 && (e3 = t4), this.isEmpty() || (this.minX -= t4, this.maxX += t4, this.minY -= e3, this.maxY += e3);
    }, t3.prototype.addFramePad = function(t4, e3, n2, i2, r3, o3) {
      t4 -= r3, e3 -= o3, n2 += r3, i2 += o3, this.minX = this.minX < t4 ? this.minX : t4, this.maxX = this.maxX > n2 ? this.maxX : n2, this.minY = this.minY < e3 ? this.minY : e3, this.maxY = this.maxY > i2 ? this.maxY : i2;
    }, t3;
  }(), C_ = function(t3, e3) {
    return (C_ = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e4) {
      t4.__proto__ = e4;
    } || function(t4, e4) {
      for (var n2 in e4)
        e4.hasOwnProperty(n2) && (t4[n2] = e4[n2]);
    })(t3, e3);
  };
  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */
  function I_(t3, e3) {
    function n2() {
      this.constructor = t3;
    }
    C_(t3, e3), t3.prototype = e3 === null ? Object.create(e3) : (n2.prototype = e3.prototype, new n2());
  }
  var O_, L_, N_, D_, F_, B_, U_, k_, G_, H_, z_, j_, V_, W_, X_, q_, Y_, Z_, J_, $_ = function(t3) {
    function e3() {
      var e4 = t3.call(this) || this;
      return e4.tempDisplayObjectParent = null, e4.transform = new R_(), e4.alpha = 1, e4.visible = true, e4.renderable = true, e4.parent = null, e4.worldAlpha = 1, e4._lastSortedIndex = 0, e4._zIndex = 0, e4.filterArea = null, e4.filters = null, e4._enabledFilters = null, e4._bounds = new P_(), e4._localBounds = null, e4._boundsID = 0, e4._boundsRect = null, e4._localBoundsRect = null, e4._mask = null, e4._maskRefCount = 0, e4._destroyed = false, e4.isSprite = false, e4.isMask = false, e4;
    }
    return I_(e3, t3), e3.mixin = function(t4) {
      for (var n2 = Object.keys(t4), i2 = 0; i2 < n2.length; ++i2) {
        var r3 = n2[i2];
        Object.defineProperty(e3.prototype, r3, Object.getOwnPropertyDescriptor(t4, r3));
      }
    }, Object.defineProperty(e3.prototype, "destroyed", { get: function() {
      return this._destroyed;
    }, enumerable: false, configurable: true }), e3.prototype._recursivePostUpdateTransform = function() {
      this.parent ? (this.parent._recursivePostUpdateTransform(), this.transform.updateTransform(this.parent.transform)) : this.transform.updateTransform(this._tempDisplayObjectParent.transform);
    }, e3.prototype.updateTransform = function() {
      this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;
    }, e3.prototype.getBounds = function(t4, e4) {
      return t4 || (this.parent ? (this._recursivePostUpdateTransform(), this.updateTransform()) : (this.parent = this._tempDisplayObjectParent, this.updateTransform(), this.parent = null)), this._bounds.updateID !== this._boundsID && (this.calculateBounds(), this._bounds.updateID = this._boundsID), e4 || (this._boundsRect || (this._boundsRect = new d_()), e4 = this._boundsRect), this._bounds.getRectangle(e4);
    }, e3.prototype.getLocalBounds = function(t4) {
      t4 || (this._localBoundsRect || (this._localBoundsRect = new d_()), t4 = this._localBoundsRect), this._localBounds || (this._localBounds = new P_());
      var e4 = this.transform, n2 = this.parent;
      this.parent = null, this.transform = this._tempDisplayObjectParent.transform;
      var i2 = this._bounds, r3 = this._boundsID;
      this._bounds = this._localBounds;
      var o3 = this.getBounds(false, t4);
      return this.parent = n2, this.transform = e4, this._bounds = i2, this._bounds.updateID += this._boundsID - r3, o3;
    }, e3.prototype.toGlobal = function(t4, e4, n2) {
      return n2 === void 0 && (n2 = false), n2 || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.apply(t4, e4);
    }, e3.prototype.toLocal = function(t4, e4, n2, i2) {
      return e4 && (t4 = e4.toGlobal(t4, n2, i2)), i2 || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.applyInverse(t4, n2);
    }, e3.prototype.setParent = function(t4) {
      if (!t4 || !t4.addChild)
        throw new Error("setParent: Argument must be a Container");
      return t4.addChild(this), t4;
    }, e3.prototype.setTransform = function(t4, e4, n2, i2, r3, o3, s3, a2, l2) {
      return t4 === void 0 && (t4 = 0), e4 === void 0 && (e4 = 0), n2 === void 0 && (n2 = 1), i2 === void 0 && (i2 = 1), r3 === void 0 && (r3 = 0), o3 === void 0 && (o3 = 0), s3 === void 0 && (s3 = 0), a2 === void 0 && (a2 = 0), l2 === void 0 && (l2 = 0), this.position.x = t4, this.position.y = e4, this.scale.x = n2 || 1, this.scale.y = i2 || 1, this.rotation = r3, this.skew.x = o3, this.skew.y = s3, this.pivot.x = a2, this.pivot.y = l2, this;
    }, e3.prototype.destroy = function(t4) {
      this.parent && this.parent.removeChild(this), this.emit("destroyed"), this.removeAllListeners(), this.transform = null, this.parent = null, this._bounds = null, this.mask = null, this.filters = null, this.filterArea = null, this.hitArea = null, this.interactive = false, this.interactiveChildren = false, this._destroyed = true;
    }, Object.defineProperty(e3.prototype, "_tempDisplayObjectParent", { get: function() {
      return this.tempDisplayObjectParent === null && (this.tempDisplayObjectParent = new K_()), this.tempDisplayObjectParent;
    }, enumerable: false, configurable: true }), e3.prototype.enableTempParent = function() {
      var t4 = this.parent;
      return this.parent = this._tempDisplayObjectParent, t4;
    }, e3.prototype.disableTempParent = function(t4) {
      this.parent = t4;
    }, Object.defineProperty(e3.prototype, "x", { get: function() {
      return this.position.x;
    }, set: function(t4) {
      this.transform.position.x = t4;
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "y", { get: function() {
      return this.position.y;
    }, set: function(t4) {
      this.transform.position.y = t4;
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "worldTransform", { get: function() {
      return this.transform.worldTransform;
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "localTransform", { get: function() {
      return this.transform.localTransform;
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "position", { get: function() {
      return this.transform.position;
    }, set: function(t4) {
      this.transform.position.copyFrom(t4);
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "scale", { get: function() {
      return this.transform.scale;
    }, set: function(t4) {
      this.transform.scale.copyFrom(t4);
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "pivot", { get: function() {
      return this.transform.pivot;
    }, set: function(t4) {
      this.transform.pivot.copyFrom(t4);
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "skew", { get: function() {
      return this.transform.skew;
    }, set: function(t4) {
      this.transform.skew.copyFrom(t4);
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "rotation", { get: function() {
      return this.transform.rotation;
    }, set: function(t4) {
      this.transform.rotation = t4;
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "angle", { get: function() {
      return this.transform.rotation * h_;
    }, set: function(t4) {
      this.transform.rotation = t4 * c_;
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "zIndex", { get: function() {
      return this._zIndex;
    }, set: function(t4) {
      this._zIndex = t4, this.parent && (this.parent.sortDirty = true);
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "worldVisible", { get: function() {
      var t4 = this;
      do {
        if (!t4.visible)
          return false;
        t4 = t4.parent;
      } while (t4);
      return true;
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "mask", { get: function() {
      return this._mask;
    }, set: function(t4) {
      if (this._mask !== t4) {
        var e4;
        if (this._mask)
          (e4 = this._mask.maskObject || this._mask)._maskRefCount--, e4._maskRefCount === 0 && (e4.renderable = true, e4.isMask = false);
        if (this._mask = t4, this._mask)
          (e4 = this._mask.maskObject || this._mask)._maskRefCount === 0 && (e4.renderable = false, e4.isMask = true), e4._maskRefCount++;
      }
    }, enumerable: false, configurable: true }), e3;
  }(vv.a), K_ = function(t3) {
    function e3() {
      var e4 = t3 !== null && t3.apply(this, arguments) || this;
      return e4.sortDirty = null, e4;
    }
    return I_(e3, t3), e3;
  }($_);
  function Q_(t3, e3) {
    return t3.zIndex === e3.zIndex ? t3._lastSortedIndex - e3._lastSortedIndex : t3.zIndex - e3.zIndex;
  }
  $_.prototype.displayObjectUpdateTransform = $_.prototype.updateTransform, function(t3) {
    t3[t3.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", t3[t3.WEBGL = 1] = "WEBGL", t3[t3.WEBGL2 = 2] = "WEBGL2";
  }(O_ || (O_ = {})), function(t3) {
    t3[t3.UNKNOWN = 0] = "UNKNOWN", t3[t3.WEBGL = 1] = "WEBGL", t3[t3.CANVAS = 2] = "CANVAS";
  }(L_ || (L_ = {})), function(t3) {
    t3[t3.COLOR = 16384] = "COLOR", t3[t3.DEPTH = 256] = "DEPTH", t3[t3.STENCIL = 1024] = "STENCIL";
  }(N_ || (N_ = {})), function(t3) {
    t3[t3.NORMAL = 0] = "NORMAL", t3[t3.ADD = 1] = "ADD", t3[t3.MULTIPLY = 2] = "MULTIPLY", t3[t3.SCREEN = 3] = "SCREEN", t3[t3.OVERLAY = 4] = "OVERLAY", t3[t3.DARKEN = 5] = "DARKEN", t3[t3.LIGHTEN = 6] = "LIGHTEN", t3[t3.COLOR_DODGE = 7] = "COLOR_DODGE", t3[t3.COLOR_BURN = 8] = "COLOR_BURN", t3[t3.HARD_LIGHT = 9] = "HARD_LIGHT", t3[t3.SOFT_LIGHT = 10] = "SOFT_LIGHT", t3[t3.DIFFERENCE = 11] = "DIFFERENCE", t3[t3.EXCLUSION = 12] = "EXCLUSION", t3[t3.HUE = 13] = "HUE", t3[t3.SATURATION = 14] = "SATURATION", t3[t3.COLOR = 15] = "COLOR", t3[t3.LUMINOSITY = 16] = "LUMINOSITY", t3[t3.NORMAL_NPM = 17] = "NORMAL_NPM", t3[t3.ADD_NPM = 18] = "ADD_NPM", t3[t3.SCREEN_NPM = 19] = "SCREEN_NPM", t3[t3.NONE = 20] = "NONE", t3[t3.SRC_OVER = 0] = "SRC_OVER", t3[t3.SRC_IN = 21] = "SRC_IN", t3[t3.SRC_OUT = 22] = "SRC_OUT", t3[t3.SRC_ATOP = 23] = "SRC_ATOP", t3[t3.DST_OVER = 24] = "DST_OVER", t3[t3.DST_IN = 25] = "DST_IN", t3[t3.DST_OUT = 26] = "DST_OUT", t3[t3.DST_ATOP = 27] = "DST_ATOP", t3[t3.ERASE = 26] = "ERASE", t3[t3.SUBTRACT = 28] = "SUBTRACT", t3[t3.XOR = 29] = "XOR";
  }(D_ || (D_ = {})), function(t3) {
    t3[t3.POINTS = 0] = "POINTS", t3[t3.LINES = 1] = "LINES", t3[t3.LINE_LOOP = 2] = "LINE_LOOP", t3[t3.LINE_STRIP = 3] = "LINE_STRIP", t3[t3.TRIANGLES = 4] = "TRIANGLES", t3[t3.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", t3[t3.TRIANGLE_FAN = 6] = "TRIANGLE_FAN";
  }(F_ || (F_ = {})), function(t3) {
    t3[t3.RGBA = 6408] = "RGBA", t3[t3.RGB = 6407] = "RGB", t3[t3.RG = 33319] = "RG", t3[t3.RED = 6403] = "RED", t3[t3.RGBA_INTEGER = 36249] = "RGBA_INTEGER", t3[t3.RGB_INTEGER = 36248] = "RGB_INTEGER", t3[t3.RG_INTEGER = 33320] = "RG_INTEGER", t3[t3.RED_INTEGER = 36244] = "RED_INTEGER", t3[t3.ALPHA = 6406] = "ALPHA", t3[t3.LUMINANCE = 6409] = "LUMINANCE", t3[t3.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", t3[t3.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", t3[t3.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL";
  }(B_ || (B_ = {})), function(t3) {
    t3[t3.TEXTURE_2D = 3553] = "TEXTURE_2D", t3[t3.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", t3[t3.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", t3[t3.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", t3[t3.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", t3[t3.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", t3[t3.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", t3[t3.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", t3[t3.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
  }(U_ || (U_ = {})), function(t3) {
    t3[t3.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", t3[t3.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", t3[t3.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", t3[t3.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", t3[t3.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", t3[t3.UNSIGNED_INT = 5125] = "UNSIGNED_INT", t3[t3.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", t3[t3.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", t3[t3.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", t3[t3.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", t3[t3.BYTE = 5120] = "BYTE", t3[t3.SHORT = 5122] = "SHORT", t3[t3.INT = 5124] = "INT", t3[t3.FLOAT = 5126] = "FLOAT", t3[t3.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", t3[t3.HALF_FLOAT = 36193] = "HALF_FLOAT";
  }(k_ || (k_ = {})), function(t3) {
    t3[t3.FLOAT = 0] = "FLOAT", t3[t3.INT = 1] = "INT", t3[t3.UINT = 2] = "UINT";
  }(G_ || (G_ = {})), function(t3) {
    t3[t3.NEAREST = 0] = "NEAREST", t3[t3.LINEAR = 1] = "LINEAR";
  }(H_ || (H_ = {})), function(t3) {
    t3[t3.CLAMP = 33071] = "CLAMP", t3[t3.REPEAT = 10497] = "REPEAT", t3[t3.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT";
  }(z_ || (z_ = {})), function(t3) {
    t3[t3.OFF = 0] = "OFF", t3[t3.POW2 = 1] = "POW2", t3[t3.ON = 2] = "ON", t3[t3.ON_MANUAL = 3] = "ON_MANUAL";
  }(j_ || (j_ = {})), function(t3) {
    t3[t3.NPM = 0] = "NPM", t3[t3.UNPACK = 1] = "UNPACK", t3[t3.PMA = 2] = "PMA", t3[t3.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", t3[t3.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", t3[t3.PREMULTIPLY_ALPHA = 2] = "PREMULTIPLY_ALPHA", t3[t3.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA";
  }(V_ || (V_ = {})), function(t3) {
    t3[t3.NO = 0] = "NO", t3[t3.YES = 1] = "YES", t3[t3.AUTO = 2] = "AUTO", t3[t3.BLEND = 0] = "BLEND", t3[t3.CLEAR = 1] = "CLEAR", t3[t3.BLIT = 2] = "BLIT";
  }(W_ || (W_ = {})), function(t3) {
    t3[t3.AUTO = 0] = "AUTO", t3[t3.MANUAL = 1] = "MANUAL";
  }(X_ || (X_ = {})), function(t3) {
    t3.LOW = "lowp", t3.MEDIUM = "mediump", t3.HIGH = "highp";
  }(q_ || (q_ = {})), function(t3) {
    t3[t3.NONE = 0] = "NONE", t3[t3.SCISSOR = 1] = "SCISSOR", t3[t3.STENCIL = 2] = "STENCIL", t3[t3.SPRITE = 3] = "SPRITE";
  }(Y_ || (Y_ = {})), function(t3) {
    t3[t3.NONE = 0] = "NONE", t3[t3.LOW = 2] = "LOW", t3[t3.MEDIUM = 4] = "MEDIUM", t3[t3.HIGH = 8] = "HIGH";
  }(Z_ || (Z_ = {})), function(t3) {
    t3[t3.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", t3[t3.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", t3[t3.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER";
  }(J_ || (J_ = {}));
  var ty = function(t3) {
    function e3() {
      var e4 = t3.call(this) || this;
      return e4.children = [], e4.sortableChildren = mv.SORTABLE_CHILDREN, e4.sortDirty = false, e4;
    }
    return I_(e3, t3), e3.prototype.onChildrenChange = function(t4) {
    }, e3.prototype.addChild = function() {
      for (var t4 = arguments, e4 = [], n2 = 0; n2 < arguments.length; n2++)
        e4[n2] = t4[n2];
      if (e4.length > 1)
        for (var i2 = 0; i2 < e4.length; i2++)
          this.addChild(e4[i2]);
      else {
        var r3 = e4[0];
        r3.parent && r3.parent.removeChild(r3), r3.parent = this, this.sortDirty = true, r3.transform._parentID = -1, this.children.push(r3), this._boundsID++, this.onChildrenChange(this.children.length - 1), this.emit("childAdded", r3, this, this.children.length - 1), r3.emit("added", this);
      }
      return e4[0];
    }, e3.prototype.addChildAt = function(t4, e4) {
      if (e4 < 0 || e4 > this.children.length)
        throw new Error(t4 + "addChildAt: The index " + e4 + " supplied is out of bounds " + this.children.length);
      return t4.parent && t4.parent.removeChild(t4), t4.parent = this, this.sortDirty = true, t4.transform._parentID = -1, this.children.splice(e4, 0, t4), this._boundsID++, this.onChildrenChange(e4), t4.emit("added", this), this.emit("childAdded", t4, this, e4), t4;
    }, e3.prototype.swapChildren = function(t4, e4) {
      if (t4 !== e4) {
        var n2 = this.getChildIndex(t4), i2 = this.getChildIndex(e4);
        this.children[n2] = e4, this.children[i2] = t4, this.onChildrenChange(n2 < i2 ? n2 : i2);
      }
    }, e3.prototype.getChildIndex = function(t4) {
      var e4 = this.children.indexOf(t4);
      if (e4 === -1)
        throw new Error("The supplied DisplayObject must be a child of the caller");
      return e4;
    }, e3.prototype.setChildIndex = function(t4, e4) {
      if (e4 < 0 || e4 >= this.children.length)
        throw new Error("The index " + e4 + " supplied is out of bounds " + this.children.length);
      var n2 = this.getChildIndex(t4);
      Vv(this.children, n2, 1), this.children.splice(e4, 0, t4), this.onChildrenChange(e4);
    }, e3.prototype.getChildAt = function(t4) {
      if (t4 < 0 || t4 >= this.children.length)
        throw new Error("getChildAt: Index (" + t4 + ") does not exist.");
      return this.children[t4];
    }, e3.prototype.removeChild = function() {
      for (var t4 = arguments, e4 = [], n2 = 0; n2 < arguments.length; n2++)
        e4[n2] = t4[n2];
      if (e4.length > 1)
        for (var i2 = 0; i2 < e4.length; i2++)
          this.removeChild(e4[i2]);
      else {
        var r3 = e4[0], o3 = this.children.indexOf(r3);
        if (o3 === -1)
          return null;
        r3.parent = null, r3.transform._parentID = -1, Vv(this.children, o3, 1), this._boundsID++, this.onChildrenChange(o3), r3.emit("removed", this), this.emit("childRemoved", r3, this, o3);
      }
      return e4[0];
    }, e3.prototype.removeChildAt = function(t4) {
      var e4 = this.getChildAt(t4);
      return e4.parent = null, e4.transform._parentID = -1, Vv(this.children, t4, 1), this._boundsID++, this.onChildrenChange(t4), e4.emit("removed", this), this.emit("childRemoved", e4, this, t4), e4;
    }, e3.prototype.removeChildren = function(t4, e4) {
      t4 === void 0 && (t4 = 0), e4 === void 0 && (e4 = this.children.length);
      var n2, i2 = t4, r3 = e4 - i2;
      if (r3 > 0 && r3 <= e4) {
        n2 = this.children.splice(i2, r3);
        for (var o3 = 0; o3 < n2.length; ++o3)
          n2[o3].parent = null, n2[o3].transform && (n2[o3].transform._parentID = -1);
        this._boundsID++, this.onChildrenChange(t4);
        for (o3 = 0; o3 < n2.length; ++o3)
          n2[o3].emit("removed", this), this.emit("childRemoved", n2[o3], this, o3);
        return n2;
      }
      if (r3 === 0 && this.children.length === 0)
        return [];
      throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
    }, e3.prototype.sortChildren = function() {
      for (var t4 = false, e4 = 0, n2 = this.children.length; e4 < n2; ++e4) {
        var i2 = this.children[e4];
        i2._lastSortedIndex = e4, t4 || i2.zIndex === 0 || (t4 = true);
      }
      t4 && this.children.length > 1 && this.children.sort(Q_), this.sortDirty = false;
    }, e3.prototype.updateTransform = function() {
      this.sortableChildren && this.sortDirty && this.sortChildren(), this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;
      for (var t4 = 0, e4 = this.children.length; t4 < e4; ++t4) {
        var n2 = this.children[t4];
        n2.visible && n2.updateTransform();
      }
    }, e3.prototype.calculateBounds = function() {
      this._bounds.clear(), this._calculateBounds();
      for (var t4 = 0; t4 < this.children.length; t4++) {
        var e4 = this.children[t4];
        if (e4.visible && e4.renderable)
          if (e4.calculateBounds(), e4._mask) {
            var n2 = e4._mask.maskObject || e4._mask;
            n2.calculateBounds(), this._bounds.addBoundsMask(e4._bounds, n2._bounds);
          } else
            e4.filterArea ? this._bounds.addBoundsArea(e4._bounds, e4.filterArea) : this._bounds.addBounds(e4._bounds);
      }
      this._bounds.updateID = this._boundsID;
    }, e3.prototype.getLocalBounds = function(e4, n2) {
      n2 === void 0 && (n2 = false);
      var i2 = t3.prototype.getLocalBounds.call(this, e4);
      if (!n2)
        for (var r3 = 0, o3 = this.children.length; r3 < o3; ++r3) {
          var s3 = this.children[r3];
          s3.visible && s3.updateTransform();
        }
      return i2;
    }, e3.prototype._calculateBounds = function() {
    }, e3.prototype.render = function(t4) {
      if (this.visible && !(this.worldAlpha <= 0) && this.renderable)
        if (this._mask || this.filters && this.filters.length)
          this.renderAdvanced(t4);
        else {
          this._render(t4);
          for (var e4 = 0, n2 = this.children.length; e4 < n2; ++e4)
            this.children[e4].render(t4);
        }
    }, e3.prototype.renderAdvanced = function(t4) {
      var e4 = this.filters, n2 = this._mask;
      if (e4) {
        this._enabledFilters || (this._enabledFilters = []), this._enabledFilters.length = 0;
        for (var i2 = 0; i2 < e4.length; i2++)
          e4[i2].enabled && this._enabledFilters.push(e4[i2]);
      }
      var r3 = e4 && this._enabledFilters && this._enabledFilters.length || n2 && (!n2.isMaskData || n2.enabled && (n2.autoDetect || n2.type !== Y_.NONE));
      r3 && t4.batch.flush(), e4 && this._enabledFilters && this._enabledFilters.length && t4.filter.push(this, this._enabledFilters), n2 && t4.mask.push(this, this._mask), this._render(t4);
      i2 = 0;
      for (var o3 = this.children.length; i2 < o3; i2++)
        this.children[i2].render(t4);
      r3 && t4.batch.flush(), n2 && t4.mask.pop(this), e4 && this._enabledFilters && this._enabledFilters.length && t4.filter.pop();
    }, e3.prototype._render = function(t4) {
    }, e3.prototype.destroy = function(e4) {
      t3.prototype.destroy.call(this), this.sortDirty = false;
      var n2 = typeof e4 == "boolean" ? e4 : e4 && e4.children, i2 = this.removeChildren(0, this.children.length);
      if (n2)
        for (var r3 = 0; r3 < i2.length; ++r3)
          i2[r3].destroy(e4);
    }, Object.defineProperty(e3.prototype, "width", { get: function() {
      return this.scale.x * this.getLocalBounds().width;
    }, set: function(t4) {
      var e4 = this.getLocalBounds().width;
      this.scale.x = e4 !== 0 ? t4 / e4 : 1, this._width = t4;
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "height", { get: function() {
      return this.scale.y * this.getLocalBounds().height;
    }, set: function(t4) {
      var e4 = this.getLocalBounds().height;
      this.scale.y = e4 !== 0 ? t4 / e4 : 1, this._height = t4;
    }, enumerable: false, configurable: true }), e3;
  }($_);
  ty.prototype.containerUpdateTransform = ty.prototype.updateTransform;
  $_.mixin({ accessible: false, accessibleTitle: null, accessibleHint: null, tabIndex: 0, _accessibleActive: false, _accessibleDiv: null, accessibleType: "button", accessiblePointerEvents: "auto", accessibleChildren: true, renderId: -1 });
  var ey, ny = function() {
    function t3(t4) {
      this.debug = false, this._isActive = false, this._isMobileAccessibility = false, this.pool = [], this.renderId = 0, this.children = [], this.androidUpdateCount = 0, this.androidUpdateFrequency = 500, this._hookDiv = null, (Zg.tablet || Zg.phone) && this.createTouchHook();
      var e3 = document.createElement("div");
      e3.style.width = "100px", e3.style.height = "100px", e3.style.position = "absolute", e3.style.top = "0px", e3.style.left = "0px", e3.style.zIndex = 2 .toString(), this.div = e3, this.renderer = t4, this._onKeyDown = this._onKeyDown.bind(this), this._onMouseMove = this._onMouseMove.bind(this), self.addEventListener("keydown", this._onKeyDown, false);
    }
    return Object.defineProperty(t3.prototype, "isActive", { get: function() {
      return this._isActive;
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "isMobileAccessibility", { get: function() {
      return this._isMobileAccessibility;
    }, enumerable: false, configurable: true }), t3.prototype.createTouchHook = function() {
      var t4 = this, e3 = document.createElement("button");
      e3.style.width = "1px", e3.style.height = "1px", e3.style.position = "absolute", e3.style.top = "-1000px", e3.style.left = "-1000px", e3.style.zIndex = 2 .toString(), e3.style.backgroundColor = "#FF0000", e3.title = "select to enable accessibility for this content", e3.addEventListener("focus", function() {
        t4._isMobileAccessibility = true, t4.activate(), t4.destroyTouchHook();
      }), document.body.appendChild(e3), this._hookDiv = e3;
    }, t3.prototype.destroyTouchHook = function() {
      this._hookDiv && (document.body.removeChild(this._hookDiv), this._hookDiv = null);
    }, t3.prototype.activate = function() {
      var t4;
      this._isActive || (this._isActive = true, self.document.addEventListener("mousemove", this._onMouseMove, true), self.removeEventListener("keydown", this._onKeyDown, false), this.renderer.on("postrender", this.update, this), (t4 = this.renderer.view.parentNode) === null || t4 === void 0 || t4.appendChild(this.div));
    }, t3.prototype.deactivate = function() {
      var t4;
      this._isActive && !this._isMobileAccessibility && (this._isActive = false, self.document.removeEventListener("mousemove", this._onMouseMove, true), self.addEventListener("keydown", this._onKeyDown, false), this.renderer.off("postrender", this.update), (t4 = this.div.parentNode) === null || t4 === void 0 || t4.removeChild(this.div));
    }, t3.prototype.updateAccessibleObjects = function(t4) {
      if (t4.visible && t4.accessibleChildren) {
        t4.accessible && t4.interactive && (t4._accessibleActive || this.addChild(t4), t4.renderId = this.renderId);
        var e3 = t4.children;
        if (e3)
          for (var n2 = 0; n2 < e3.length; n2++)
            this.updateAccessibleObjects(e3[n2]);
      }
    }, t3.prototype.update = function() {
      var t4 = performance.now();
      if (!(Zg.android.device && t4 < this.androidUpdateCount) && (this.androidUpdateCount = t4 + this.androidUpdateFrequency, this.renderer.renderingToScreen)) {
        this.renderer._lastObjectRendered && this.updateAccessibleObjects(this.renderer._lastObjectRendered);
        var e3 = this.renderer.view.getBoundingClientRect(), n2 = e3.left, i2 = e3.top, r3 = e3.width, o3 = e3.height, s3 = this.renderer, a2 = s3.width, l2 = s3.height, u2 = s3.resolution, h2 = r3 / a2 * u2, c2 = o3 / l2 * u2, d2 = this.div;
        d2.style.left = n2 + "px", d2.style.top = i2 + "px", d2.style.width = a2 + "px", d2.style.height = l2 + "px";
        for (var p2 = 0; p2 < this.children.length; p2++) {
          var f2 = this.children[p2];
          if (f2.renderId !== this.renderId)
            f2._accessibleActive = false, Vv(this.children, p2, 1), this.div.removeChild(f2._accessibleDiv), this.pool.push(f2._accessibleDiv), f2._accessibleDiv = null, p2--;
          else {
            d2 = f2._accessibleDiv;
            var m2 = f2.hitArea, g2 = f2.worldTransform;
            f2.hitArea ? (d2.style.left = (g2.tx + m2.x * g2.a) * h2 + "px", d2.style.top = (g2.ty + m2.y * g2.d) * c2 + "px", d2.style.width = m2.width * g2.a * h2 + "px", d2.style.height = m2.height * g2.d * c2 + "px") : (m2 = f2.getBounds(), this.capHitArea(m2), d2.style.left = m2.x * h2 + "px", d2.style.top = m2.y * c2 + "px", d2.style.width = m2.width * h2 + "px", d2.style.height = m2.height * c2 + "px", d2.title !== f2.accessibleTitle && f2.accessibleTitle !== null && (d2.title = f2.accessibleTitle), d2.getAttribute("aria-label") !== f2.accessibleHint && f2.accessibleHint !== null && d2.setAttribute("aria-label", f2.accessibleHint)), f2.accessibleTitle === d2.title && f2.tabIndex === d2.tabIndex || (d2.title = f2.accessibleTitle, d2.tabIndex = f2.tabIndex, this.debug && this.updateDebugHTML(d2));
          }
        }
        this.renderId++;
      }
    }, t3.prototype.updateDebugHTML = function(t4) {
      t4.innerHTML = "type: " + t4.type + "</br> title : " + t4.title + "</br> tabIndex: " + t4.tabIndex;
    }, t3.prototype.capHitArea = function(t4) {
      t4.x < 0 && (t4.width += t4.x, t4.x = 0), t4.y < 0 && (t4.height += t4.y, t4.y = 0);
      var e3 = this.renderer, n2 = e3.width, i2 = e3.height;
      t4.x + t4.width > n2 && (t4.width = n2 - t4.x), t4.y + t4.height > i2 && (t4.height = i2 - t4.y);
    }, t3.prototype.addChild = function(t4) {
      var e3 = this.pool.pop();
      e3 || ((e3 = document.createElement("button")).style.width = "100px", e3.style.height = "100px", e3.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent", e3.style.position = "absolute", e3.style.zIndex = 2 .toString(), e3.style.borderStyle = "none", navigator.userAgent.toLowerCase().indexOf("chrome") > -1 ? e3.setAttribute("aria-live", "off") : e3.setAttribute("aria-live", "polite"), navigator.userAgent.match(/rv:.*Gecko\//) ? e3.setAttribute("aria-relevant", "additions") : e3.setAttribute("aria-relevant", "text"), e3.addEventListener("click", this._onClick.bind(this)), e3.addEventListener("focus", this._onFocus.bind(this)), e3.addEventListener("focusout", this._onFocusOut.bind(this))), e3.style.pointerEvents = t4.accessiblePointerEvents, e3.type = t4.accessibleType, t4.accessibleTitle && t4.accessibleTitle !== null ? e3.title = t4.accessibleTitle : t4.accessibleHint && t4.accessibleHint !== null || (e3.title = "displayObject " + t4.tabIndex), t4.accessibleHint && t4.accessibleHint !== null && e3.setAttribute("aria-label", t4.accessibleHint), this.debug && this.updateDebugHTML(e3), t4._accessibleActive = true, t4._accessibleDiv = e3, e3.displayObject = t4, this.children.push(t4), this.div.appendChild(t4._accessibleDiv), t4._accessibleDiv.tabIndex = t4.tabIndex;
    }, t3.prototype._onClick = function(t4) {
      var e3 = this.renderer.plugins.interaction, n2 = t4.target.displayObject, i2 = e3.eventData;
      e3.dispatchEvent(n2, "click", i2), e3.dispatchEvent(n2, "pointertap", i2), e3.dispatchEvent(n2, "tap", i2);
    }, t3.prototype._onFocus = function(t4) {
      t4.target.getAttribute("aria-live") || t4.target.setAttribute("aria-live", "assertive");
      var e3 = this.renderer.plugins.interaction, n2 = t4.target.displayObject, i2 = e3.eventData;
      e3.dispatchEvent(n2, "mouseover", i2);
    }, t3.prototype._onFocusOut = function(t4) {
      t4.target.getAttribute("aria-live") || t4.target.setAttribute("aria-live", "polite");
      var e3 = this.renderer.plugins.interaction, n2 = t4.target.displayObject, i2 = e3.eventData;
      e3.dispatchEvent(n2, "mouseout", i2);
    }, t3.prototype._onKeyDown = function(t4) {
      t4.keyCode === 9 && this.activate();
    }, t3.prototype._onMouseMove = function(t4) {
      t4.movementX === 0 && t4.movementY === 0 || this.deactivate();
    }, t3.prototype.destroy = function() {
      this.destroyTouchHook(), this.div = null, self.document.removeEventListener("mousemove", this._onMouseMove, true), self.removeEventListener("keydown", this._onKeyDown), this.pool = null, this.children = null, this.renderer = null;
    }, t3;
  }();
  /*!
   * @pixi/ticker - v6.2.0
   * Compiled Mon, 01 Nov 2021 16:52:10 UTC
   *
   * @pixi/ticker is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   */
  mv.TARGET_FPMS = 0.06, function(t3) {
    t3[t3.INTERACTION = 50] = "INTERACTION", t3[t3.HIGH = 25] = "HIGH", t3[t3.NORMAL = 0] = "NORMAL", t3[t3.LOW = -25] = "LOW", t3[t3.UTILITY = -50] = "UTILITY";
  }(ey || (ey = {}));
  var iy = function() {
    function t3(t4, e3, n2, i2) {
      e3 === void 0 && (e3 = null), n2 === void 0 && (n2 = 0), i2 === void 0 && (i2 = false), this.next = null, this.previous = null, this._destroyed = false, this.fn = t4, this.context = e3, this.priority = n2, this.once = i2;
    }
    return t3.prototype.match = function(t4, e3) {
      return e3 === void 0 && (e3 = null), this.fn === t4 && this.context === e3;
    }, t3.prototype.emit = function(t4) {
      this.fn && (this.context ? this.fn.call(this.context, t4) : this.fn(t4));
      var e3 = this.next;
      return this.once && this.destroy(true), this._destroyed && (this.next = null), e3;
    }, t3.prototype.connect = function(t4) {
      this.previous = t4, t4.next && (t4.next.previous = this), this.next = t4.next, t4.next = this;
    }, t3.prototype.destroy = function(t4) {
      t4 === void 0 && (t4 = false), this._destroyed = true, this.fn = null, this.context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous);
      var e3 = this.next;
      return this.next = t4 ? null : e3, this.previous = null, e3;
    }, t3;
  }(), ry = function() {
    function t3() {
      var t4 = this;
      this.autoStart = false, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = false, this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this._protected = false, this._lastFrame = -1, this._head = new iy(null, null, 1 / 0), this.deltaMS = 1 / mv.TARGET_FPMS, this.elapsedMS = 1 / mv.TARGET_FPMS, this._tick = function(e3) {
        t4._requestId = null, t4.started && (t4.update(e3), t4.started && t4._requestId === null && t4._head.next && (t4._requestId = requestAnimationFrame(t4._tick)));
      };
    }
    return t3.prototype._requestIfNeeded = function() {
      this._requestId === null && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick));
    }, t3.prototype._cancelIfNeeded = function() {
      this._requestId !== null && (cancelAnimationFrame(this._requestId), this._requestId = null);
    }, t3.prototype._startIfPossible = function() {
      this.started ? this._requestIfNeeded() : this.autoStart && this.start();
    }, t3.prototype.add = function(t4, e3, n2) {
      return n2 === void 0 && (n2 = ey.NORMAL), this._addListener(new iy(t4, e3, n2));
    }, t3.prototype.addOnce = function(t4, e3, n2) {
      return n2 === void 0 && (n2 = ey.NORMAL), this._addListener(new iy(t4, e3, n2, true));
    }, t3.prototype._addListener = function(t4) {
      var e3 = this._head.next, n2 = this._head;
      if (e3) {
        for (; e3; ) {
          if (t4.priority > e3.priority) {
            t4.connect(n2);
            break;
          }
          n2 = e3, e3 = e3.next;
        }
        t4.previous || t4.connect(n2);
      } else
        t4.connect(n2);
      return this._startIfPossible(), this;
    }, t3.prototype.remove = function(t4, e3) {
      for (var n2 = this._head.next; n2; )
        n2 = n2.match(t4, e3) ? n2.destroy() : n2.next;
      return this._head.next || this._cancelIfNeeded(), this;
    }, Object.defineProperty(t3.prototype, "count", { get: function() {
      if (!this._head)
        return 0;
      for (var t4 = 0, e3 = this._head; e3 = e3.next; )
        t4++;
      return t4;
    }, enumerable: false, configurable: true }), t3.prototype.start = function() {
      this.started || (this.started = true, this._requestIfNeeded());
    }, t3.prototype.stop = function() {
      this.started && (this.started = false, this._cancelIfNeeded());
    }, t3.prototype.destroy = function() {
      if (!this._protected) {
        this.stop();
        for (var t4 = this._head.next; t4; )
          t4 = t4.destroy(true);
        this._head.destroy(), this._head = null;
      }
    }, t3.prototype.update = function(t4) {
      var e3;
      if (t4 === void 0 && (t4 = performance.now()), t4 > this.lastTime) {
        if ((e3 = this.elapsedMS = t4 - this.lastTime) > this._maxElapsedMS && (e3 = this._maxElapsedMS), e3 *= this.speed, this._minElapsedMS) {
          var n2 = t4 - this._lastFrame | 0;
          if (n2 < this._minElapsedMS)
            return;
          this._lastFrame = t4 - n2 % this._minElapsedMS;
        }
        this.deltaMS = e3, this.deltaTime = this.deltaMS * mv.TARGET_FPMS;
        for (var i2 = this._head, r3 = i2.next; r3; )
          r3 = r3.emit(this.deltaTime);
        i2.next || this._cancelIfNeeded();
      } else
        this.deltaTime = this.deltaMS = this.elapsedMS = 0;
      this.lastTime = t4;
    }, Object.defineProperty(t3.prototype, "FPS", { get: function() {
      return 1e3 / this.elapsedMS;
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "minFPS", { get: function() {
      return 1e3 / this._maxElapsedMS;
    }, set: function(t4) {
      var e3 = Math.min(this.maxFPS, t4), n2 = Math.min(Math.max(0, e3) / 1e3, mv.TARGET_FPMS);
      this._maxElapsedMS = 1 / n2;
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "maxFPS", { get: function() {
      return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0;
    }, set: function(t4) {
      if (t4 === 0)
        this._minElapsedMS = 0;
      else {
        var e3 = Math.max(this.minFPS, t4);
        this._minElapsedMS = 1 / (e3 / 1e3);
      }
    }, enumerable: false, configurable: true }), Object.defineProperty(t3, "shared", { get: function() {
      if (!t3._shared) {
        var e3 = t3._shared = new t3();
        e3.autoStart = true, e3._protected = true;
      }
      return t3._shared;
    }, enumerable: false, configurable: true }), Object.defineProperty(t3, "system", { get: function() {
      if (!t3._system) {
        var e3 = t3._system = new t3();
        e3.autoStart = true, e3._protected = true;
      }
      return t3._system;
    }, enumerable: false, configurable: true }), t3;
  }(), oy = function() {
    function t3() {
    }
    return t3.init = function(t4) {
      var e3 = this;
      t4 = Object.assign({ autoStart: true, sharedTicker: false }, t4), Object.defineProperty(this, "ticker", { set: function(t5) {
        this._ticker && this._ticker.remove(this.render, this), this._ticker = t5, t5 && t5.add(this.render, this, ey.LOW);
      }, get: function() {
        return this._ticker;
      } }), this.stop = function() {
        e3._ticker.stop();
      }, this.start = function() {
        e3._ticker.start();
      }, this._ticker = null, this.ticker = t4.sharedTicker ? ry.shared : new ry(), t4.autoStart && this.start();
    }, t3.destroy = function() {
      if (this._ticker) {
        var t4 = this._ticker;
        this.ticker = null, t4.destroy();
      }
    }, t3;
  }(), sy = function() {
    function t3() {
      this.pressure = 0, this.rotationAngle = 0, this.twist = 0, this.tangentialPressure = 0, this.global = new v_(), this.target = null, this.originalEvent = null, this.identifier = null, this.isPrimary = false, this.button = 0, this.buttons = 0, this.width = 0, this.height = 0, this.tiltX = 0, this.tiltY = 0, this.pointerType = null, this.pressure = 0, this.rotationAngle = 0, this.twist = 0, this.tangentialPressure = 0;
    }
    return Object.defineProperty(t3.prototype, "pointerId", { get: function() {
      return this.identifier;
    }, enumerable: false, configurable: true }), t3.prototype.getLocalPosition = function(t4, e3, n2) {
      return t4.worldTransform.applyInverse(n2 || this.global, e3);
    }, t3.prototype.copyEvent = function(t4) {
      "isPrimary" in t4 && t4.isPrimary && (this.isPrimary = true), this.button = "button" in t4 && t4.button;
      var e3 = "buttons" in t4 && t4.buttons;
      this.buttons = Number.isInteger(e3) ? e3 : "which" in t4 && t4.which, this.width = "width" in t4 && t4.width, this.height = "height" in t4 && t4.height, this.tiltX = "tiltX" in t4 && t4.tiltX, this.tiltY = "tiltY" in t4 && t4.tiltY, this.pointerType = "pointerType" in t4 && t4.pointerType, this.pressure = "pressure" in t4 && t4.pressure, this.rotationAngle = "rotationAngle" in t4 && t4.rotationAngle, this.twist = "twist" in t4 && t4.twist || 0, this.tangentialPressure = "tangentialPressure" in t4 && t4.tangentialPressure || 0;
    }, t3.prototype.reset = function() {
      this.isPrimary = false;
    }, t3;
  }(), ay = function(t3, e3) {
    return (ay = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e4) {
      t4.__proto__ = e4;
    } || function(t4, e4) {
      for (var n2 in e4)
        e4.hasOwnProperty(n2) && (t4[n2] = e4[n2]);
    })(t3, e3);
  };
  var ly = function() {
    function t3() {
      this.stopped = false, this.stopsPropagatingAt = null, this.stopPropagationHint = false, this.target = null, this.currentTarget = null, this.type = null, this.data = null;
    }
    return t3.prototype.stopPropagation = function() {
      this.stopped = true, this.stopPropagationHint = true, this.stopsPropagatingAt = this.currentTarget;
    }, t3.prototype.reset = function() {
      this.stopped = false, this.stopsPropagatingAt = null, this.stopPropagationHint = false, this.currentTarget = null, this.target = null;
    }, t3;
  }(), uy = function() {
    function t3(e3) {
      this._pointerId = e3, this._flags = t3.FLAGS.NONE;
    }
    return t3.prototype._doSet = function(t4, e3) {
      this._flags = e3 ? this._flags | t4 : this._flags & ~t4;
    }, Object.defineProperty(t3.prototype, "pointerId", { get: function() {
      return this._pointerId;
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "flags", { get: function() {
      return this._flags;
    }, set: function(t4) {
      this._flags = t4;
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "none", { get: function() {
      return this._flags === t3.FLAGS.NONE;
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "over", { get: function() {
      return (this._flags & t3.FLAGS.OVER) != 0;
    }, set: function(e3) {
      this._doSet(t3.FLAGS.OVER, e3);
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "rightDown", { get: function() {
      return (this._flags & t3.FLAGS.RIGHT_DOWN) != 0;
    }, set: function(e3) {
      this._doSet(t3.FLAGS.RIGHT_DOWN, e3);
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "leftDown", { get: function() {
      return (this._flags & t3.FLAGS.LEFT_DOWN) != 0;
    }, set: function(e3) {
      this._doSet(t3.FLAGS.LEFT_DOWN, e3);
    }, enumerable: false, configurable: true }), t3.FLAGS = Object.freeze({ NONE: 0, OVER: 1, LEFT_DOWN: 2, RIGHT_DOWN: 4 }), t3;
  }(), hy = function() {
    function t3() {
      this._tempPoint = new v_();
    }
    return t3.prototype.recursiveFindHit = function(t4, e3, n2, i2, r3) {
      if (!e3 || !e3.visible)
        return false;
      var o3 = t4.data.global, s3 = false, a2 = r3 = e3.interactive || r3, l2 = true;
      if (e3.hitArea ? (i2 && (e3.worldTransform.applyInverse(o3, this._tempPoint), e3.hitArea.contains(this._tempPoint.x, this._tempPoint.y) ? s3 = true : (i2 = false, l2 = false)), a2 = false) : e3._mask && i2 && (e3._mask.containsPoint && e3._mask.containsPoint(o3) || (i2 = false)), l2 && e3.interactiveChildren && e3.children)
        for (var u2 = e3.children, h2 = u2.length - 1; h2 >= 0; h2--) {
          var c2 = u2[h2], d2 = this.recursiveFindHit(t4, c2, n2, i2, a2);
          if (d2) {
            if (!c2.parent)
              continue;
            a2 = false, d2 && (t4.target && (i2 = false), s3 = true);
          }
        }
      return r3 && (i2 && !t4.target && !e3.hitArea && e3.containsPoint && e3.containsPoint(o3) && (s3 = true), e3.interactive && (s3 && !t4.target && (t4.target = e3), n2 && n2(t4, e3, !!s3))), s3;
    }, t3.prototype.findHit = function(t4, e3, n2, i2) {
      this.recursiveFindHit(t4, e3, n2, i2, false);
    }, t3;
  }(), cy = { interactive: false, interactiveChildren: true, hitArea: null, get buttonMode() {
    return this.cursor === "pointer";
  }, set buttonMode(t3) {
    t3 ? this.cursor = "pointer" : this.cursor === "pointer" && (this.cursor = null);
  }, cursor: null, get trackedPointers() {
    return this._trackedPointers === void 0 && (this._trackedPointers = {}), this._trackedPointers;
  }, _trackedPointers: void 0 };
  $_.mixin(cy);
  var dy = { target: null, data: { global: null } }, py = function(t3) {
    function e3(e4, n2) {
      var i2 = t3.call(this) || this;
      return n2 = n2 || {}, i2.renderer = e4, i2.autoPreventDefault = n2.autoPreventDefault === void 0 || n2.autoPreventDefault, i2.interactionFrequency = n2.interactionFrequency || 10, i2.mouse = new sy(), i2.mouse.identifier = 1, i2.mouse.global.set(-999999), i2.activeInteractionData = {}, i2.activeInteractionData[1] = i2.mouse, i2.interactionDataPool = [], i2.eventData = new ly(), i2.interactionDOMElement = null, i2.moveWhenInside = false, i2.eventsAdded = false, i2.tickerAdded = false, i2.mouseOverRenderer = !("PointerEvent" in self), i2.supportsTouchEvents = "ontouchstart" in self, i2.supportsPointerEvents = !!self.PointerEvent, i2.onPointerUp = i2.onPointerUp.bind(i2), i2.processPointerUp = i2.processPointerUp.bind(i2), i2.onPointerCancel = i2.onPointerCancel.bind(i2), i2.processPointerCancel = i2.processPointerCancel.bind(i2), i2.onPointerDown = i2.onPointerDown.bind(i2), i2.processPointerDown = i2.processPointerDown.bind(i2), i2.onPointerMove = i2.onPointerMove.bind(i2), i2.processPointerMove = i2.processPointerMove.bind(i2), i2.onPointerOut = i2.onPointerOut.bind(i2), i2.processPointerOverOut = i2.processPointerOverOut.bind(i2), i2.onPointerOver = i2.onPointerOver.bind(i2), i2.cursorStyles = { default: "inherit", pointer: "pointer" }, i2.currentCursorMode = null, i2.cursor = null, i2.resolution = 1, i2.delayedEvents = [], i2.search = new hy(), i2._tempDisplayObject = new K_(), i2._eventListenerOptions = { capture: true, passive: false }, i2._useSystemTicker = n2.useSystemTicker === void 0 || n2.useSystemTicker, i2.setTargetElement(i2.renderer.view, i2.renderer.resolution), i2;
    }
    return function(t4, e4) {
      function n2() {
        this.constructor = t4;
      }
      ay(t4, e4), t4.prototype = e4 === null ? Object.create(e4) : (n2.prototype = e4.prototype, new n2());
    }(e3, t3), Object.defineProperty(e3.prototype, "useSystemTicker", { get: function() {
      return this._useSystemTicker;
    }, set: function(t4) {
      this._useSystemTicker = t4, t4 ? this.addTickerListener() : this.removeTickerListener();
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "lastObjectRendered", { get: function() {
      return this.renderer._lastObjectRendered || this._tempDisplayObject;
    }, enumerable: false, configurable: true }), e3.prototype.hitTest = function(t4, e4) {
      return dy.target = null, dy.data.global = t4, e4 || (e4 = this.lastObjectRendered), this.processInteractive(dy, e4, null, true), dy.target;
    }, e3.prototype.setTargetElement = function(t4, e4) {
      e4 === void 0 && (e4 = 1), this.removeTickerListener(), this.removeEvents(), this.interactionDOMElement = t4, this.resolution = e4, this.addEvents(), this.addTickerListener();
    }, e3.prototype.addTickerListener = function() {
      !this.tickerAdded && this.interactionDOMElement && this._useSystemTicker && (ry.system.add(this.tickerUpdate, this, ey.INTERACTION), this.tickerAdded = true);
    }, e3.prototype.removeTickerListener = function() {
      this.tickerAdded && (ry.system.remove(this.tickerUpdate, this), this.tickerAdded = false);
    }, e3.prototype.addEvents = function() {
      if (!this.eventsAdded && this.interactionDOMElement) {
        var t4 = this.interactionDOMElement.style;
        self.navigator.msPointerEnabled ? (t4.msContentZooming = "none", t4.msTouchAction = "none") : this.supportsPointerEvents && (t4.touchAction = "none"), this.supportsPointerEvents ? (self.document.addEventListener("pointermove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.addEventListener("pointerdown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener("pointerleave", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.addEventListener("pointerover", this.onPointerOver, this._eventListenerOptions), self.addEventListener("pointercancel", this.onPointerCancel, this._eventListenerOptions), self.addEventListener("pointerup", this.onPointerUp, this._eventListenerOptions)) : (self.document.addEventListener("mousemove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.addEventListener("mousedown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener("mouseout", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.addEventListener("mouseover", this.onPointerOver, this._eventListenerOptions), self.addEventListener("mouseup", this.onPointerUp, this._eventListenerOptions)), this.supportsTouchEvents && (this.interactionDOMElement.addEventListener("touchstart", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener("touchcancel", this.onPointerCancel, this._eventListenerOptions), this.interactionDOMElement.addEventListener("touchend", this.onPointerUp, this._eventListenerOptions), this.interactionDOMElement.addEventListener("touchmove", this.onPointerMove, this._eventListenerOptions)), this.eventsAdded = true;
      }
    }, e3.prototype.removeEvents = function() {
      if (this.eventsAdded && this.interactionDOMElement) {
        var t4 = this.interactionDOMElement.style;
        self.navigator.msPointerEnabled ? (t4.msContentZooming = "", t4.msTouchAction = "") : this.supportsPointerEvents && (t4.touchAction = ""), this.supportsPointerEvents ? (self.document.removeEventListener("pointermove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("pointerdown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("pointerleave", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("pointerover", this.onPointerOver, this._eventListenerOptions), self.removeEventListener("pointercancel", this.onPointerCancel, this._eventListenerOptions), self.removeEventListener("pointerup", this.onPointerUp, this._eventListenerOptions)) : (self.document.removeEventListener("mousemove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("mousedown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("mouseout", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("mouseover", this.onPointerOver, this._eventListenerOptions), self.removeEventListener("mouseup", this.onPointerUp, this._eventListenerOptions)), this.supportsTouchEvents && (this.interactionDOMElement.removeEventListener("touchstart", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("touchcancel", this.onPointerCancel, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("touchend", this.onPointerUp, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("touchmove", this.onPointerMove, this._eventListenerOptions)), this.interactionDOMElement = null, this.eventsAdded = false;
      }
    }, e3.prototype.tickerUpdate = function(t4) {
      this._deltaTime += t4, this._deltaTime < this.interactionFrequency || (this._deltaTime = 0, this.update());
    }, e3.prototype.update = function() {
      if (this.interactionDOMElement)
        if (this._didMove)
          this._didMove = false;
        else {
          for (var t4 in this.cursor = null, this.activeInteractionData)
            if (this.activeInteractionData.hasOwnProperty(t4)) {
              var e4 = this.activeInteractionData[t4];
              if (e4.originalEvent && e4.pointerType !== "touch") {
                var n2 = this.configureInteractionEventForDOMEvent(this.eventData, e4.originalEvent, e4);
                this.processInteractive(n2, this.lastObjectRendered, this.processPointerOverOut, true);
              }
            }
          this.setCursorMode(this.cursor);
        }
    }, e3.prototype.setCursorMode = function(t4) {
      t4 = t4 || "default";
      var e4 = true;
      if (self.OffscreenCanvas && this.interactionDOMElement instanceof OffscreenCanvas && (e4 = false), this.currentCursorMode !== t4) {
        this.currentCursorMode = t4;
        var n2 = this.cursorStyles[t4];
        if (n2)
          switch (typeof n2) {
            case "string":
              e4 && (this.interactionDOMElement.style.cursor = n2);
              break;
            case "function":
              n2(t4);
              break;
            case "object":
              e4 && Object.assign(this.interactionDOMElement.style, n2);
          }
        else
          e4 && typeof t4 == "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, t4) && (this.interactionDOMElement.style.cursor = t4);
      }
    }, e3.prototype.dispatchEvent = function(t4, e4, n2) {
      n2.stopPropagationHint && t4 !== n2.stopsPropagatingAt || (n2.currentTarget = t4, n2.type = e4, t4.emit(e4, n2), t4[e4] && t4[e4](n2));
    }, e3.prototype.delayDispatchEvent = function(t4, e4, n2) {
      this.delayedEvents.push({ displayObject: t4, eventString: e4, eventData: n2 });
    }, e3.prototype.mapPositionToPoint = function(t4, e4, n2) {
      var i2;
      i2 = this.interactionDOMElement.parentElement ? this.interactionDOMElement.getBoundingClientRect() : { x: 0, y: 0, width: this.interactionDOMElement.width, height: this.interactionDOMElement.height, left: 0, top: 0 };
      var r3 = 1 / this.resolution;
      t4.x = (e4 - i2.left) * (this.interactionDOMElement.width / i2.width) * r3, t4.y = (n2 - i2.top) * (this.interactionDOMElement.height / i2.height) * r3;
    }, e3.prototype.processInteractive = function(t4, e4, n2, i2) {
      var r3 = this.search.findHit(t4, e4, n2, i2), o3 = this.delayedEvents;
      if (!o3.length)
        return r3;
      t4.stopPropagationHint = false;
      var s3 = o3.length;
      this.delayedEvents = [];
      for (var a2 = 0; a2 < s3; a2++) {
        var l2 = o3[a2], u2 = l2.displayObject, h2 = l2.eventString, c2 = l2.eventData;
        c2.stopsPropagatingAt === u2 && (c2.stopPropagationHint = true), this.dispatchEvent(u2, h2, c2);
      }
      return r3;
    }, e3.prototype.onPointerDown = function(t4) {
      if (!this.supportsTouchEvents || t4.pointerType !== "touch") {
        var e4 = this.normalizeToPointerData(t4);
        if (this.autoPreventDefault && e4[0].isNormalized)
          (t4.cancelable || !("cancelable" in t4)) && t4.preventDefault();
        for (var n2 = e4.length, i2 = 0; i2 < n2; i2++) {
          var r3 = e4[i2], o3 = this.getInteractionDataForPointerId(r3), s3 = this.configureInteractionEventForDOMEvent(this.eventData, r3, o3);
          if (s3.data.originalEvent = t4, this.processInteractive(s3, this.lastObjectRendered, this.processPointerDown, true), this.emit("pointerdown", s3), r3.pointerType === "touch")
            this.emit("touchstart", s3);
          else if (r3.pointerType === "mouse" || r3.pointerType === "pen") {
            var a2 = r3.button === 2;
            this.emit(a2 ? "rightdown" : "mousedown", this.eventData);
          }
        }
      }
    }, e3.prototype.processPointerDown = function(t4, e4, n2) {
      var i2 = t4.data, r3 = t4.data.identifier;
      if (n2) {
        if (e4.trackedPointers[r3] || (e4.trackedPointers[r3] = new uy(r3)), this.dispatchEvent(e4, "pointerdown", t4), i2.pointerType === "touch")
          this.dispatchEvent(e4, "touchstart", t4);
        else if (i2.pointerType === "mouse" || i2.pointerType === "pen") {
          var o3 = i2.button === 2;
          o3 ? e4.trackedPointers[r3].rightDown = true : e4.trackedPointers[r3].leftDown = true, this.dispatchEvent(e4, o3 ? "rightdown" : "mousedown", t4);
        }
      }
    }, e3.prototype.onPointerComplete = function(t4, e4, n2) {
      for (var i2 = this.normalizeToPointerData(t4), r3 = i2.length, o3 = t4.target !== this.interactionDOMElement ? "outside" : "", s3 = 0; s3 < r3; s3++) {
        var a2 = i2[s3], l2 = this.getInteractionDataForPointerId(a2), u2 = this.configureInteractionEventForDOMEvent(this.eventData, a2, l2);
        if (u2.data.originalEvent = t4, this.processInteractive(u2, this.lastObjectRendered, n2, e4 || !o3), this.emit(e4 ? "pointercancel" : "pointerup" + o3, u2), a2.pointerType === "mouse" || a2.pointerType === "pen") {
          var h2 = a2.button === 2;
          this.emit(h2 ? "rightup" + o3 : "mouseup" + o3, u2);
        } else
          a2.pointerType === "touch" && (this.emit(e4 ? "touchcancel" : "touchend" + o3, u2), this.releaseInteractionDataForPointerId(a2.pointerId));
      }
    }, e3.prototype.onPointerCancel = function(t4) {
      this.supportsTouchEvents && t4.pointerType === "touch" || this.onPointerComplete(t4, true, this.processPointerCancel);
    }, e3.prototype.processPointerCancel = function(t4, e4) {
      var n2 = t4.data, i2 = t4.data.identifier;
      e4.trackedPointers[i2] !== void 0 && (delete e4.trackedPointers[i2], this.dispatchEvent(e4, "pointercancel", t4), n2.pointerType === "touch" && this.dispatchEvent(e4, "touchcancel", t4));
    }, e3.prototype.onPointerUp = function(t4) {
      this.supportsTouchEvents && t4.pointerType === "touch" || this.onPointerComplete(t4, false, this.processPointerUp);
    }, e3.prototype.processPointerUp = function(t4, e4, n2) {
      var i2 = t4.data, r3 = t4.data.identifier, o3 = e4.trackedPointers[r3], s3 = i2.pointerType === "touch", a2 = i2.pointerType === "mouse" || i2.pointerType === "pen", l2 = false;
      if (a2) {
        var u2 = i2.button === 2, h2 = uy.FLAGS, c2 = u2 ? h2.RIGHT_DOWN : h2.LEFT_DOWN, d2 = o3 !== void 0 && o3.flags & c2;
        n2 ? (this.dispatchEvent(e4, u2 ? "rightup" : "mouseup", t4), d2 && (this.dispatchEvent(e4, u2 ? "rightclick" : "click", t4), l2 = true)) : d2 && this.dispatchEvent(e4, u2 ? "rightupoutside" : "mouseupoutside", t4), o3 && (u2 ? o3.rightDown = false : o3.leftDown = false);
      }
      n2 ? (this.dispatchEvent(e4, "pointerup", t4), s3 && this.dispatchEvent(e4, "touchend", t4), o3 && (a2 && !l2 || this.dispatchEvent(e4, "pointertap", t4), s3 && (this.dispatchEvent(e4, "tap", t4), o3.over = false))) : o3 && (this.dispatchEvent(e4, "pointerupoutside", t4), s3 && this.dispatchEvent(e4, "touchendoutside", t4)), o3 && o3.none && delete e4.trackedPointers[r3];
    }, e3.prototype.onPointerMove = function(t4) {
      if (!this.supportsTouchEvents || t4.pointerType !== "touch") {
        var e4 = this.normalizeToPointerData(t4);
        e4[0].pointerType !== "mouse" && e4[0].pointerType !== "pen" || (this._didMove = true, this.cursor = null);
        for (var n2 = e4.length, i2 = 0; i2 < n2; i2++) {
          var r3 = e4[i2], o3 = this.getInteractionDataForPointerId(r3), s3 = this.configureInteractionEventForDOMEvent(this.eventData, r3, o3);
          s3.data.originalEvent = t4, this.processInteractive(s3, this.lastObjectRendered, this.processPointerMove, true), this.emit("pointermove", s3), r3.pointerType === "touch" && this.emit("touchmove", s3), r3.pointerType !== "mouse" && r3.pointerType !== "pen" || this.emit("mousemove", s3);
        }
        e4[0].pointerType === "mouse" && this.setCursorMode(this.cursor);
      }
    }, e3.prototype.processPointerMove = function(t4, e4, n2) {
      var i2 = t4.data, r3 = i2.pointerType === "touch", o3 = i2.pointerType === "mouse" || i2.pointerType === "pen";
      o3 && this.processPointerOverOut(t4, e4, n2), this.moveWhenInside && !n2 || (this.dispatchEvent(e4, "pointermove", t4), r3 && this.dispatchEvent(e4, "touchmove", t4), o3 && this.dispatchEvent(e4, "mousemove", t4));
    }, e3.prototype.onPointerOut = function(t4) {
      if (!this.supportsTouchEvents || t4.pointerType !== "touch") {
        var e4 = this.normalizeToPointerData(t4)[0];
        e4.pointerType === "mouse" && (this.mouseOverRenderer = false, this.setCursorMode(null));
        var n2 = this.getInteractionDataForPointerId(e4), i2 = this.configureInteractionEventForDOMEvent(this.eventData, e4, n2);
        i2.data.originalEvent = e4, this.processInteractive(i2, this.lastObjectRendered, this.processPointerOverOut, false), this.emit("pointerout", i2), e4.pointerType === "mouse" || e4.pointerType === "pen" ? this.emit("mouseout", i2) : this.releaseInteractionDataForPointerId(n2.identifier);
      }
    }, e3.prototype.processPointerOverOut = function(t4, e4, n2) {
      var i2 = t4.data, r3 = t4.data.identifier, o3 = i2.pointerType === "mouse" || i2.pointerType === "pen", s3 = e4.trackedPointers[r3];
      n2 && !s3 && (s3 = e4.trackedPointers[r3] = new uy(r3)), s3 !== void 0 && (n2 && this.mouseOverRenderer ? (s3.over || (s3.over = true, this.delayDispatchEvent(e4, "pointerover", t4), o3 && this.delayDispatchEvent(e4, "mouseover", t4)), o3 && this.cursor === null && (this.cursor = e4.cursor)) : s3.over && (s3.over = false, this.dispatchEvent(e4, "pointerout", this.eventData), o3 && this.dispatchEvent(e4, "mouseout", t4), s3.none && delete e4.trackedPointers[r3]));
    }, e3.prototype.onPointerOver = function(t4) {
      var e4 = this.normalizeToPointerData(t4)[0], n2 = this.getInteractionDataForPointerId(e4), i2 = this.configureInteractionEventForDOMEvent(this.eventData, e4, n2);
      i2.data.originalEvent = e4, e4.pointerType === "mouse" && (this.mouseOverRenderer = true), this.emit("pointerover", i2), e4.pointerType !== "mouse" && e4.pointerType !== "pen" || this.emit("mouseover", i2);
    }, e3.prototype.getInteractionDataForPointerId = function(t4) {
      var e4, n2 = t4.pointerId;
      return n2 === 1 || t4.pointerType === "mouse" ? e4 = this.mouse : this.activeInteractionData[n2] ? e4 = this.activeInteractionData[n2] : ((e4 = this.interactionDataPool.pop() || new sy()).identifier = n2, this.activeInteractionData[n2] = e4), e4.copyEvent(t4), e4;
    }, e3.prototype.releaseInteractionDataForPointerId = function(t4) {
      var e4 = this.activeInteractionData[t4];
      e4 && (delete this.activeInteractionData[t4], e4.reset(), this.interactionDataPool.push(e4));
    }, e3.prototype.configureInteractionEventForDOMEvent = function(t4, e4, n2) {
      return t4.data = n2, this.mapPositionToPoint(n2.global, e4.clientX, e4.clientY), e4.pointerType === "touch" && (e4.globalX = n2.global.x, e4.globalY = n2.global.y), n2.originalEvent = e4, t4.reset(), t4;
    }, e3.prototype.normalizeToPointerData = function(t4) {
      var e4 = [];
      if (this.supportsTouchEvents && t4 instanceof TouchEvent)
        for (var n2 = 0, i2 = t4.changedTouches.length; n2 < i2; n2++) {
          var r3 = t4.changedTouches[n2];
          r3.button === void 0 && (r3.button = t4.touches.length ? 1 : 0), r3.buttons === void 0 && (r3.buttons = t4.touches.length ? 1 : 0), r3.isPrimary === void 0 && (r3.isPrimary = t4.touches.length === 1 && t4.type === "touchstart"), r3.width === void 0 && (r3.width = r3.radiusX || 1), r3.height === void 0 && (r3.height = r3.radiusY || 1), r3.tiltX === void 0 && (r3.tiltX = 0), r3.tiltY === void 0 && (r3.tiltY = 0), r3.pointerType === void 0 && (r3.pointerType = "touch"), r3.pointerId === void 0 && (r3.pointerId = r3.identifier || 0), r3.pressure === void 0 && (r3.pressure = r3.force || 0.5), r3.twist === void 0 && (r3.twist = 0), r3.tangentialPressure === void 0 && (r3.tangentialPressure = 0), r3.layerX === void 0 && (r3.layerX = r3.offsetX = r3.clientX), r3.layerY === void 0 && (r3.layerY = r3.offsetY = r3.clientY), r3.isNormalized = true, e4.push(r3);
        }
      else if (self.MouseEvent && (!(t4 instanceof MouseEvent) || this.supportsPointerEvents && t4 instanceof self.PointerEvent))
        e4.push(t4);
      else {
        var o3 = t4;
        o3.isPrimary === void 0 && (o3.isPrimary = true), o3.width === void 0 && (o3.width = 1), o3.height === void 0 && (o3.height = 1), o3.tiltX === void 0 && (o3.tiltX = 0), o3.tiltY === void 0 && (o3.tiltY = 0), o3.pointerType === void 0 && (o3.pointerType = "mouse"), o3.pointerId === void 0 && (o3.pointerId = 1), o3.pressure === void 0 && (o3.pressure = 0.5), o3.twist === void 0 && (o3.twist = 0), o3.tangentialPressure === void 0 && (o3.tangentialPressure = 0), o3.isNormalized = true, e4.push(o3);
      }
      return e4;
    }, e3.prototype.destroy = function() {
      this.removeEvents(), this.removeTickerListener(), this.removeAllListeners(), this.renderer = null, this.mouse = null, this.eventData = null, this.interactionDOMElement = null, this.onPointerDown = null, this.processPointerDown = null, this.onPointerUp = null, this.processPointerUp = null, this.onPointerCancel = null, this.processPointerCancel = null, this.onPointerMove = null, this.processPointerMove = null, this.onPointerOut = null, this.processPointerOverOut = null, this.onPointerOver = null, this.search = null;
    }, e3;
  }(vv.a), fy = function() {
    function t3(t4) {
      this.items = [], this._name = t4, this._aliasCount = 0;
    }
    return t3.prototype.emit = function(t4, e3, n2, i2, r3, o3, s3, a2) {
      if (arguments.length > 8)
        throw new Error("max arguments reached");
      var l2 = this, u2 = l2.name, h2 = l2.items;
      this._aliasCount++;
      for (var c2 = 0, d2 = h2.length; c2 < d2; c2++)
        h2[c2][u2](t4, e3, n2, i2, r3, o3, s3, a2);
      return h2 === this.items && this._aliasCount--, this;
    }, t3.prototype.ensureNonAliasedItems = function() {
      this._aliasCount > 0 && this.items.length > 1 && (this._aliasCount = 0, this.items = this.items.slice(0));
    }, t3.prototype.add = function(t4) {
      return t4[this._name] && (this.ensureNonAliasedItems(), this.remove(t4), this.items.push(t4)), this;
    }, t3.prototype.remove = function(t4) {
      var e3 = this.items.indexOf(t4);
      return e3 !== -1 && (this.ensureNonAliasedItems(), this.items.splice(e3, 1)), this;
    }, t3.prototype.contains = function(t4) {
      return this.items.indexOf(t4) !== -1;
    }, t3.prototype.removeAll = function() {
      return this.ensureNonAliasedItems(), this.items.length = 0, this;
    }, t3.prototype.destroy = function() {
      this.removeAll(), this.items = null, this._name = null;
    }, Object.defineProperty(t3.prototype, "empty", { get: function() {
      return this.items.length === 0;
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "name", { get: function() {
      return this._name;
    }, enumerable: false, configurable: true }), t3;
  }();
  Object.defineProperties(fy.prototype, { dispatch: { value: fy.prototype.emit }, run: { value: fy.prototype.emit } }), mv.PREFER_ENV = Zg.any ? Jg.WEBGL : Jg.WEBGL2, mv.STRICT_TEXTURE_CACHE = false;
  var my = [];
  function gy(t3, e3) {
    if (!t3)
      return null;
    var n2 = "";
    if (typeof t3 == "string") {
      var i2 = /\.(\w{3,4})(?:$|\?|#)/i.exec(t3);
      i2 && (n2 = i2[1].toLowerCase());
    }
    for (var r3 = my.length - 1; r3 >= 0; --r3) {
      var o3 = my[r3];
      if (o3.test && o3.test(t3, n2))
        return new o3(t3, e3);
    }
    throw new Error("Unrecognized source type to auto-detect Resource");
  }
  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */
  var vy = function(t3, e3) {
    return (vy = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e4) {
      t4.__proto__ = e4;
    } || function(t4, e4) {
      for (var n2 in e4)
        e4.hasOwnProperty(n2) && (t4[n2] = e4[n2]);
    })(t3, e3);
  };
  function _y(t3, e3) {
    function n2() {
      this.constructor = t3;
    }
    vy(t3, e3), t3.prototype = e3 === null ? Object.create(e3) : (n2.prototype = e3.prototype, new n2());
  }
  var yy = function() {
    return (yy = Object.assign || function(t3) {
      for (var e3, n2 = arguments, i2 = 1, r3 = arguments.length; i2 < r3; i2++)
        for (var o3 in e3 = n2[i2])
          Object.prototype.hasOwnProperty.call(e3, o3) && (t3[o3] = e3[o3]);
      return t3;
    }).apply(this, arguments);
  };
  var xy = function() {
    function t3(t4, e3) {
      t4 === void 0 && (t4 = 0), e3 === void 0 && (e3 = 0), this._width = t4, this._height = e3, this.destroyed = false, this.internal = false, this.onResize = new fy("setRealSize"), this.onUpdate = new fy("update"), this.onError = new fy("onError");
    }
    return t3.prototype.bind = function(t4) {
      this.onResize.add(t4), this.onUpdate.add(t4), this.onError.add(t4), (this._width || this._height) && this.onResize.emit(this._width, this._height);
    }, t3.prototype.unbind = function(t4) {
      this.onResize.remove(t4), this.onUpdate.remove(t4), this.onError.remove(t4);
    }, t3.prototype.resize = function(t4, e3) {
      t4 === this._width && e3 === this._height || (this._width = t4, this._height = e3, this.onResize.emit(t4, e3));
    }, Object.defineProperty(t3.prototype, "valid", { get: function() {
      return !!this._width && !!this._height;
    }, enumerable: false, configurable: true }), t3.prototype.update = function() {
      this.destroyed || this.onUpdate.emit();
    }, t3.prototype.load = function() {
      return Promise.resolve(this);
    }, Object.defineProperty(t3.prototype, "width", { get: function() {
      return this._width;
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "height", { get: function() {
      return this._height;
    }, enumerable: false, configurable: true }), t3.prototype.style = function(t4, e3, n2) {
      return false;
    }, t3.prototype.dispose = function() {
    }, t3.prototype.destroy = function() {
      this.destroyed || (this.destroyed = true, this.dispose(), this.onError.removeAll(), this.onError = null, this.onResize.removeAll(), this.onResize = null, this.onUpdate.removeAll(), this.onUpdate = null);
    }, t3.test = function(t4, e3) {
      return false;
    }, t3;
  }(), by = function(t3) {
    function e3(e4, n2) {
      var i2 = this, r3 = n2 || {}, o3 = r3.width, s3 = r3.height;
      if (!o3 || !s3)
        throw new Error("BufferResource width or height invalid");
      return (i2 = t3.call(this, o3, s3) || this).data = e4, i2;
    }
    return _y(e3, t3), e3.prototype.upload = function(t4, e4, n2) {
      var i2 = t4.gl;
      i2.pixelStorei(i2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e4.alphaMode === lv.UNPACK);
      var r3 = e4.realWidth, o3 = e4.realHeight;
      return n2.width === r3 && n2.height === o3 ? i2.texSubImage2D(e4.target, 0, 0, 0, r3, o3, e4.format, n2.type, this.data) : (n2.width = r3, n2.height = o3, i2.texImage2D(e4.target, 0, n2.internalFormat, r3, o3, 0, e4.format, n2.type, this.data)), true;
    }, e3.prototype.dispose = function() {
      this.data = null;
    }, e3.test = function(t4) {
      return t4 instanceof Float32Array || t4 instanceof Uint8Array || t4 instanceof Uint32Array;
    }, e3;
  }(xy), Ty = { scaleMode: ov.NEAREST, format: ev.RGBA, alphaMode: lv.NPM }, wy = function(t3) {
    function e3(e4, n2) {
      e4 === void 0 && (e4 = null), n2 === void 0 && (n2 = null);
      var i2 = t3.call(this) || this, r3 = (n2 = n2 || {}).alphaMode, o3 = n2.mipmap, s3 = n2.anisotropicLevel, a2 = n2.scaleMode, l2 = n2.width, u2 = n2.height, h2 = n2.wrapMode, c2 = n2.format, d2 = n2.type, p2 = n2.target, f2 = n2.resolution, m2 = n2.resourceOptions;
      return !e4 || e4 instanceof xy || ((e4 = gy(e4, m2)).internal = true), i2.resolution = f2 || mv.RESOLUTION, i2.width = Math.round((l2 || 0) * i2.resolution) / i2.resolution, i2.height = Math.round((u2 || 0) * i2.resolution) / i2.resolution, i2._mipmap = o3 !== void 0 ? o3 : mv.MIPMAP_TEXTURES, i2.anisotropicLevel = s3 !== void 0 ? s3 : mv.ANISOTROPIC_LEVEL, i2._wrapMode = h2 || mv.WRAP_MODE, i2._scaleMode = a2 !== void 0 ? a2 : mv.SCALE_MODE, i2.format = c2 || ev.RGBA, i2.type = d2 || iv.UNSIGNED_BYTE, i2.target = p2 || nv.TEXTURE_2D, i2.alphaMode = r3 !== void 0 ? r3 : lv.UNPACK, i2.uid = qv(), i2.touched = 0, i2.isPowerOfTwo = false, i2._refreshPOT(), i2._glTextures = {}, i2.dirtyId = 0, i2.dirtyStyleId = 0, i2.cacheId = null, i2.valid = l2 > 0 && u2 > 0, i2.textureCacheIds = [], i2.destroyed = false, i2.resource = null, i2._batchEnabled = 0, i2._batchLocation = 0, i2.parentTextureArray = null, i2.setResource(e4), i2;
    }
    return _y(e3, t3), Object.defineProperty(e3.prototype, "realWidth", { get: function() {
      return Math.round(this.width * this.resolution);
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "realHeight", { get: function() {
      return Math.round(this.height * this.resolution);
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "mipmap", { get: function() {
      return this._mipmap;
    }, set: function(t4) {
      this._mipmap !== t4 && (this._mipmap = t4, this.dirtyStyleId++);
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "scaleMode", { get: function() {
      return this._scaleMode;
    }, set: function(t4) {
      this._scaleMode !== t4 && (this._scaleMode = t4, this.dirtyStyleId++);
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "wrapMode", { get: function() {
      return this._wrapMode;
    }, set: function(t4) {
      this._wrapMode !== t4 && (this._wrapMode = t4, this.dirtyStyleId++);
    }, enumerable: false, configurable: true }), e3.prototype.setStyle = function(t4, e4) {
      var n2;
      return t4 !== void 0 && t4 !== this.scaleMode && (this.scaleMode = t4, n2 = true), e4 !== void 0 && e4 !== this.mipmap && (this.mipmap = e4, n2 = true), n2 && this.dirtyStyleId++, this;
    }, e3.prototype.setSize = function(t4, e4, n2) {
      return n2 = n2 || this.resolution, this.setRealSize(t4 * n2, e4 * n2, n2);
    }, e3.prototype.setRealSize = function(t4, e4, n2) {
      return this.resolution = n2 || this.resolution, this.width = Math.round(t4) / this.resolution, this.height = Math.round(e4) / this.resolution, this._refreshPOT(), this.update(), this;
    }, e3.prototype._refreshPOT = function() {
      this.isPowerOfTwo = zv(this.realWidth) && zv(this.realHeight);
    }, e3.prototype.setResolution = function(t4) {
      var e4 = this.resolution;
      return e4 === t4 || (this.resolution = t4, this.valid && (this.width = Math.round(this.width * e4) / t4, this.height = Math.round(this.height * e4) / t4, this.emit("update", this)), this._refreshPOT()), this;
    }, e3.prototype.setResource = function(t4) {
      if (this.resource === t4)
        return this;
      if (this.resource)
        throw new Error("Resource can be set only once");
      return t4.bind(this), this.resource = t4, this;
    }, e3.prototype.update = function() {
      this.valid ? (this.dirtyId++, this.dirtyStyleId++, this.emit("update", this)) : this.width > 0 && this.height > 0 && (this.valid = true, this.emit("loaded", this), this.emit("update", this));
    }, e3.prototype.onError = function(t4) {
      this.emit("error", this, t4);
    }, e3.prototype.destroy = function() {
      this.resource && (this.resource.unbind(this), this.resource.internal && this.resource.destroy(), this.resource = null), this.cacheId && (delete Kv[this.cacheId], delete $v[this.cacheId], this.cacheId = null), this.dispose(), e3.removeFromCache(this), this.textureCacheIds = null, this.destroyed = true;
    }, e3.prototype.dispose = function() {
      this.emit("dispose", this);
    }, e3.prototype.castToBaseTexture = function() {
      return this;
    }, e3.from = function(t4, n2, i2) {
      i2 === void 0 && (i2 = mv.STRICT_TEXTURE_CACHE);
      var r3 = typeof t4 == "string", o3 = null;
      if (r3)
        o3 = t4;
      else {
        if (!t4._pixiId) {
          var s3 = n2 && n2.pixiIdPrefix || "pixiid";
          t4._pixiId = s3 + "_" + qv();
        }
        o3 = t4._pixiId;
      }
      var a2 = Kv[o3];
      if (r3 && i2 && !a2)
        throw new Error('The cacheId "' + o3 + '" does not exist in BaseTextureCache.');
      return a2 || ((a2 = new e3(t4, n2)).cacheId = o3, e3.addToCache(a2, o3)), a2;
    }, e3.fromBuffer = function(t4, n2, i2, r3) {
      t4 = t4 || new Float32Array(n2 * i2 * 4);
      var o3 = new by(t4, { width: n2, height: i2 }), s3 = t4 instanceof Float32Array ? iv.FLOAT : iv.UNSIGNED_BYTE;
      return new e3(o3, Object.assign(Ty, r3 || { width: n2, height: i2, type: s3 }));
    }, e3.addToCache = function(t4, e4) {
      e4 && (t4.textureCacheIds.indexOf(e4) === -1 && t4.textureCacheIds.push(e4), Kv[e4] && console.warn("BaseTexture added to the cache with an id [" + e4 + "] that already had an entry"), Kv[e4] = t4);
    }, e3.removeFromCache = function(t4) {
      if (typeof t4 == "string") {
        var e4 = Kv[t4];
        if (e4) {
          var n2 = e4.textureCacheIds.indexOf(t4);
          return n2 > -1 && e4.textureCacheIds.splice(n2, 1), delete Kv[t4], e4;
        }
      } else if (t4 && t4.textureCacheIds) {
        for (var i2 = 0; i2 < t4.textureCacheIds.length; ++i2)
          delete Kv[t4.textureCacheIds[i2]];
        return t4.textureCacheIds.length = 0, t4;
      }
      return null;
    }, e3._globalBatch = 0, e3;
  }(vv.a), Sy = function(t3) {
    function e3(e4, n2) {
      var i2 = this, r3 = n2 || {}, o3 = r3.width, s3 = r3.height;
      (i2 = t3.call(this, o3, s3) || this).items = [], i2.itemDirtyIds = [];
      for (var a2 = 0; a2 < e4; a2++) {
        var l2 = new wy();
        i2.items.push(l2), i2.itemDirtyIds.push(-2);
      }
      return i2.length = e4, i2._load = null, i2.baseTexture = null, i2;
    }
    return _y(e3, t3), e3.prototype.initFromArray = function(t4, e4) {
      for (var n2 = 0; n2 < this.length; n2++)
        t4[n2] && (t4[n2].castToBaseTexture ? this.addBaseTextureAt(t4[n2].castToBaseTexture(), n2) : t4[n2] instanceof xy ? this.addResourceAt(t4[n2], n2) : this.addResourceAt(gy(t4[n2], e4), n2));
    }, e3.prototype.dispose = function() {
      for (var t4 = 0, e4 = this.length; t4 < e4; t4++)
        this.items[t4].destroy();
      this.items = null, this.itemDirtyIds = null, this._load = null;
    }, e3.prototype.addResourceAt = function(t4, e4) {
      if (!this.items[e4])
        throw new Error("Index " + e4 + " is out of bounds");
      return t4.valid && !this.valid && this.resize(t4.width, t4.height), this.items[e4].setResource(t4), this;
    }, e3.prototype.bind = function(e4) {
      if (this.baseTexture !== null)
        throw new Error("Only one base texture per TextureArray is allowed");
      t3.prototype.bind.call(this, e4);
      for (var n2 = 0; n2 < this.length; n2++)
        this.items[n2].parentTextureArray = e4, this.items[n2].on("update", e4.update, e4);
    }, e3.prototype.unbind = function(e4) {
      t3.prototype.unbind.call(this, e4);
      for (var n2 = 0; n2 < this.length; n2++)
        this.items[n2].parentTextureArray = null, this.items[n2].off("update", e4.update, e4);
    }, e3.prototype.load = function() {
      var t4 = this;
      if (this._load)
        return this._load;
      var e4 = this.items.map(function(t5) {
        return t5.resource;
      }).filter(function(t5) {
        return t5;
      }).map(function(t5) {
        return t5.load();
      });
      return this._load = Promise.all(e4).then(function() {
        var e5 = t4.items[0], n2 = e5.realWidth, i2 = e5.realHeight;
        return t4.resize(n2, i2), Promise.resolve(t4);
      }), this._load;
    }, e3;
  }(xy), Ey = function(t3) {
    function e3(e4, n2) {
      var i2, r3, o3 = this, s3 = n2 || {}, a2 = s3.width, l2 = s3.height;
      return Array.isArray(e4) ? (i2 = e4, r3 = e4.length) : r3 = e4, o3 = t3.call(this, r3, { width: a2, height: l2 }) || this, i2 && o3.initFromArray(i2, n2), o3;
    }
    return _y(e3, t3), e3.prototype.addBaseTextureAt = function(t4, e4) {
      if (!t4.resource)
        throw new Error("ArrayResource does not support RenderTexture");
      return this.addResourceAt(t4.resource, e4), this;
    }, e3.prototype.bind = function(e4) {
      t3.prototype.bind.call(this, e4), e4.target = nv.TEXTURE_2D_ARRAY;
    }, e3.prototype.upload = function(t4, e4, n2) {
      var i2 = this.length, r3 = this.itemDirtyIds, o3 = this.items, s3 = t4.gl;
      n2.dirtyId < 0 && s3.texImage3D(s3.TEXTURE_2D_ARRAY, 0, n2.internalFormat, this._width, this._height, i2, 0, e4.format, n2.type, null);
      for (var a2 = 0; a2 < i2; a2++) {
        var l2 = o3[a2];
        r3[a2] < l2.dirtyId && (r3[a2] = l2.dirtyId, l2.valid && s3.texSubImage3D(s3.TEXTURE_2D_ARRAY, 0, 0, 0, a2, l2.resource.width, l2.resource.height, 1, e4.format, n2.type, l2.resource.source));
      }
      return true;
    }, e3;
  }(Sy), My = function(t3) {
    function e3(e4) {
      var n2 = this, i2 = e4, r3 = i2.naturalWidth || i2.videoWidth || i2.width, o3 = i2.naturalHeight || i2.videoHeight || i2.height;
      return (n2 = t3.call(this, r3, o3) || this).source = e4, n2.noSubImage = false, n2;
    }
    return _y(e3, t3), e3.crossOrigin = function(t4, e4, n2) {
      n2 === void 0 && e4.indexOf("data:") !== 0 ? t4.crossOrigin = s_(e4) : n2 !== false && (t4.crossOrigin = typeof n2 == "string" ? n2 : "anonymous");
    }, e3.prototype.upload = function(t4, e4, n2, i2) {
      var r3 = t4.gl, o3 = e4.realWidth, s3 = e4.realHeight;
      return i2 = i2 || this.source, r3.pixelStorei(r3.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e4.alphaMode === lv.UNPACK), this.noSubImage || e4.target !== r3.TEXTURE_2D || n2.width !== o3 || n2.height !== s3 ? (n2.width = o3, n2.height = s3, r3.texImage2D(e4.target, 0, n2.internalFormat, e4.format, n2.type, i2)) : r3.texSubImage2D(r3.TEXTURE_2D, 0, 0, 0, e4.format, n2.type, i2), true;
    }, e3.prototype.update = function() {
      if (!this.destroyed) {
        var e4 = this.source, n2 = e4.naturalWidth || e4.videoWidth || e4.width, i2 = e4.naturalHeight || e4.videoHeight || e4.height;
        this.resize(n2, i2), t3.prototype.update.call(this);
      }
    }, e3.prototype.dispose = function() {
      this.source = null;
    }, e3;
  }(xy), Ay = function(t3) {
    function e3(e4) {
      return t3.call(this, e4) || this;
    }
    return _y(e3, t3), e3.test = function(t4) {
      var e4 = self.OffscreenCanvas;
      return !!(e4 && t4 instanceof e4) || self.HTMLCanvasElement && t4 instanceof HTMLCanvasElement;
    }, e3;
  }(My), Ry = function(t3) {
    function e3(n2, i2) {
      var r3 = this, o3 = i2 || {}, s3 = o3.width, a2 = o3.height, l2 = o3.autoLoad, u2 = o3.linkBaseTexture;
      if (n2 && n2.length !== e3.SIDES)
        throw new Error("Invalid length. Got " + n2.length + ", expected 6");
      r3 = t3.call(this, 6, { width: s3, height: a2 }) || this;
      for (var h2 = 0; h2 < e3.SIDES; h2++)
        r3.items[h2].target = nv.TEXTURE_CUBE_MAP_POSITIVE_X + h2;
      return r3.linkBaseTexture = u2 !== false, n2 && r3.initFromArray(n2, i2), l2 !== false && r3.load(), r3;
    }
    return _y(e3, t3), e3.prototype.bind = function(e4) {
      t3.prototype.bind.call(this, e4), e4.target = nv.TEXTURE_CUBE_MAP;
    }, e3.prototype.addBaseTextureAt = function(t4, e4, n2) {
      if (!this.items[e4])
        throw new Error("Index " + e4 + " is out of bounds");
      if (!this.linkBaseTexture || t4.parentTextureArray || Object.keys(t4._glTextures).length > 0) {
        if (!t4.resource)
          throw new Error("CubeResource does not support copying of renderTexture.");
        this.addResourceAt(t4.resource, e4);
      } else
        t4.target = nv.TEXTURE_CUBE_MAP_POSITIVE_X + e4, t4.parentTextureArray = this.baseTexture, this.items[e4] = t4;
      return t4.valid && !this.valid && this.resize(t4.realWidth, t4.realHeight), this.items[e4] = t4, this;
    }, e3.prototype.upload = function(t4, n2, i2) {
      for (var r3 = this.itemDirtyIds, o3 = 0; o3 < e3.SIDES; o3++) {
        var s3 = this.items[o3];
        r3[o3] < s3.dirtyId && (s3.valid && s3.resource ? (s3.resource.upload(t4, s3, i2), r3[o3] = s3.dirtyId) : r3[o3] < -1 && (t4.gl.texImage2D(s3.target, 0, i2.internalFormat, n2.realWidth, n2.realHeight, 0, n2.format, i2.type, null), r3[o3] = -1));
      }
      return true;
    }, e3.test = function(t4) {
      return Array.isArray(t4) && t4.length === e3.SIDES;
    }, e3.SIDES = 6, e3;
  }(Sy), Py = function(t3) {
    function e3(e4, n2) {
      var i2 = this;
      if (n2 = n2 || {}, !(e4 instanceof HTMLImageElement)) {
        var r3 = new Image();
        My.crossOrigin(r3, e4, n2.crossorigin), r3.src = e4, e4 = r3;
      }
      return i2 = t3.call(this, e4) || this, !e4.complete && i2._width && i2._height && (i2._width = 0, i2._height = 0), i2.url = e4.src, i2._process = null, i2.preserveBitmap = false, i2.createBitmap = (n2.createBitmap !== void 0 ? n2.createBitmap : mv.CREATE_IMAGE_BITMAP) && !!self.createImageBitmap, i2.alphaMode = typeof n2.alphaMode == "number" ? n2.alphaMode : null, i2.bitmap = null, i2._load = null, n2.autoLoad !== false && i2.load(), i2;
    }
    return _y(e3, t3), e3.prototype.load = function(t4) {
      var e4 = this;
      return this._load || (t4 !== void 0 && (this.createBitmap = t4), this._load = new Promise(function(t5, n2) {
        var i2 = e4.source;
        e4.url = i2.src;
        var r3 = function() {
          e4.destroyed || (i2.onload = null, i2.onerror = null, e4.resize(i2.width, i2.height), e4._load = null, e4.createBitmap ? t5(e4.process()) : t5(e4));
        };
        i2.complete && i2.src ? r3() : (i2.onload = r3, i2.onerror = function(t6) {
          n2(t6), e4.onError.emit(t6);
        });
      })), this._load;
    }, e3.prototype.process = function() {
      var t4 = this, e4 = this.source;
      if (this._process !== null)
        return this._process;
      if (this.bitmap !== null || !self.createImageBitmap)
        return Promise.resolve(this);
      var n2 = self.createImageBitmap, i2 = !e4.crossOrigin || e4.crossOrigin === "anonymous";
      return this._process = fetch(e4.src, { mode: i2 ? "cors" : "no-cors" }).then(function(t5) {
        return t5.blob();
      }).then(function(i3) {
        return n2(i3, 0, 0, e4.width, e4.height, { premultiplyAlpha: t4.alphaMode === lv.UNPACK ? "premultiply" : "none" });
      }).then(function(e5) {
        return t4.destroyed ? Promise.reject() : (t4.bitmap = e5, t4.update(), t4._process = null, Promise.resolve(t4));
      }), this._process;
    }, e3.prototype.upload = function(e4, n2, i2) {
      if (typeof this.alphaMode == "number" && (n2.alphaMode = this.alphaMode), !this.createBitmap)
        return t3.prototype.upload.call(this, e4, n2, i2);
      if (!this.bitmap && (this.process(), !this.bitmap))
        return false;
      if (t3.prototype.upload.call(this, e4, n2, i2, this.bitmap), !this.preserveBitmap) {
        var r3 = true, o3 = n2._glTextures;
        for (var s3 in o3) {
          var a2 = o3[s3];
          if (a2 !== i2 && a2.dirtyId !== n2.dirtyId) {
            r3 = false;
            break;
          }
        }
        r3 && (this.bitmap.close && this.bitmap.close(), this.bitmap = null);
      }
      return true;
    }, e3.prototype.dispose = function() {
      this.source.onload = null, this.source.onerror = null, t3.prototype.dispose.call(this), this.bitmap && (this.bitmap.close(), this.bitmap = null), this._process = null, this._load = null;
    }, e3.test = function(t4) {
      return typeof t4 == "string" || t4 instanceof HTMLImageElement;
    }, e3;
  }(My), Cy = function(t3) {
    function e3(e4, n2) {
      var i2 = this;
      return n2 = n2 || {}, (i2 = t3.call(this, document.createElement("canvas")) || this)._width = 0, i2._height = 0, i2.svg = e4, i2.scale = n2.scale || 1, i2._overrideWidth = n2.width, i2._overrideHeight = n2.height, i2._resolve = null, i2._crossorigin = n2.crossorigin, i2._load = null, n2.autoLoad !== false && i2.load(), i2;
    }
    return _y(e3, t3), e3.prototype.load = function() {
      var t4 = this;
      return this._load || (this._load = new Promise(function(n2) {
        if (t4._resolve = function() {
          t4.resize(t4.source.width, t4.source.height), n2(t4);
        }, e3.SVG_XML.test(t4.svg.trim())) {
          if (!btoa)
            throw new Error("Your browser doesn't support base64 conversions.");
          t4.svg = "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(t4.svg)));
        }
        t4._loadSvg();
      })), this._load;
    }, e3.prototype._loadSvg = function() {
      var t4 = this, e4 = new Image();
      My.crossOrigin(e4, this.svg, this._crossorigin), e4.src = this.svg, e4.onerror = function(n2) {
        t4._resolve && (e4.onerror = null, t4.onError.emit(n2));
      }, e4.onload = function() {
        if (t4._resolve) {
          var n2 = e4.width, i2 = e4.height;
          if (!n2 || !i2)
            throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
          var r3 = n2 * t4.scale, o3 = i2 * t4.scale;
          (t4._overrideWidth || t4._overrideHeight) && (r3 = t4._overrideWidth || t4._overrideHeight / i2 * n2, o3 = t4._overrideHeight || t4._overrideWidth / n2 * i2), r3 = Math.round(r3), o3 = Math.round(o3);
          var s3 = t4.source;
          s3.width = r3, s3.height = o3, s3._pixiId = "canvas_" + qv(), s3.getContext("2d").drawImage(e4, 0, 0, n2, i2, 0, 0, r3, o3), t4._resolve(), t4._resolve = null;
        }
      };
    }, e3.getSize = function(t4) {
      var n2 = e3.SVG_SIZE.exec(t4), i2 = {};
      return n2 && (i2[n2[1]] = Math.round(parseFloat(n2[3])), i2[n2[5]] = Math.round(parseFloat(n2[7]))), i2;
    }, e3.prototype.dispose = function() {
      t3.prototype.dispose.call(this), this._resolve = null, this._crossorigin = null;
    }, e3.test = function(t4, n2) {
      return n2 === "svg" || typeof t4 == "string" && /^data:image\/svg\+xml(;(charset=utf8|utf8))?;base64/.test(t4) || typeof t4 == "string" && e3.SVG_XML.test(t4);
    }, e3.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m, e3.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i, e3;
  }(My), Iy = function(t3) {
    function e3(n2, i2) {
      var r3 = this;
      if (i2 = i2 || {}, !(n2 instanceof HTMLVideoElement)) {
        var o3 = document.createElement("video");
        o3.setAttribute("preload", "auto"), o3.setAttribute("webkit-playsinline", ""), o3.setAttribute("playsinline", ""), typeof n2 == "string" && (n2 = [n2]);
        var s3 = n2[0].src || n2[0];
        My.crossOrigin(o3, s3, i2.crossorigin);
        for (var a2 = 0; a2 < n2.length; ++a2) {
          var l2 = document.createElement("source"), u2 = n2[a2], h2 = u2.src, c2 = u2.mime, d2 = (h2 = h2 || n2[a2]).split("?").shift().toLowerCase(), p2 = d2.substr(d2.lastIndexOf(".") + 1);
          c2 = c2 || e3.MIME_TYPES[p2] || "video/" + p2, l2.src = h2, l2.type = c2, o3.appendChild(l2);
        }
        n2 = o3;
      }
      return (r3 = t3.call(this, n2) || this).noSubImage = true, r3._autoUpdate = true, r3._isConnectedToTicker = false, r3._updateFPS = i2.updateFPS || 0, r3._msToNextUpdate = 0, r3.autoPlay = i2.autoPlay !== false, r3._load = null, r3._resolve = null, r3._onCanPlay = r3._onCanPlay.bind(r3), r3._onError = r3._onError.bind(r3), i2.autoLoad !== false && r3.load(), r3;
    }
    return _y(e3, t3), e3.prototype.update = function(e4) {
      if (!this.destroyed) {
        var n2 = ry.shared.elapsedMS * this.source.playbackRate;
        this._msToNextUpdate = Math.floor(this._msToNextUpdate - n2), (!this._updateFPS || this._msToNextUpdate <= 0) && (t3.prototype.update.call(this), this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0);
      }
    }, e3.prototype.load = function() {
      var t4 = this;
      if (this._load)
        return this._load;
      var e4 = this.source;
      return (e4.readyState === e4.HAVE_ENOUGH_DATA || e4.readyState === e4.HAVE_FUTURE_DATA) && e4.width && e4.height && (e4.complete = true), e4.addEventListener("play", this._onPlayStart.bind(this)), e4.addEventListener("pause", this._onPlayStop.bind(this)), this._isSourceReady() ? this._onCanPlay() : (e4.addEventListener("canplay", this._onCanPlay), e4.addEventListener("canplaythrough", this._onCanPlay), e4.addEventListener("error", this._onError, true)), this._load = new Promise(function(n2) {
        t4.valid ? n2(t4) : (t4._resolve = n2, e4.load());
      }), this._load;
    }, e3.prototype._onError = function(t4) {
      this.source.removeEventListener("error", this._onError, true), this.onError.emit(t4);
    }, e3.prototype._isSourcePlaying = function() {
      var t4 = this.source;
      return t4.currentTime > 0 && t4.paused === false && t4.ended === false && t4.readyState > 2;
    }, e3.prototype._isSourceReady = function() {
      var t4 = this.source;
      return t4.readyState === 3 || t4.readyState === 4;
    }, e3.prototype._onPlayStart = function() {
      this.valid || this._onCanPlay(), this.autoUpdate && !this._isConnectedToTicker && (ry.shared.add(this.update, this), this._isConnectedToTicker = true);
    }, e3.prototype._onPlayStop = function() {
      this._isConnectedToTicker && (ry.shared.remove(this.update, this), this._isConnectedToTicker = false);
    }, e3.prototype._onCanPlay = function() {
      var t4 = this.source;
      t4.removeEventListener("canplay", this._onCanPlay), t4.removeEventListener("canplaythrough", this._onCanPlay);
      var e4 = this.valid;
      this.resize(t4.videoWidth, t4.videoHeight), !e4 && this._resolve && (this._resolve(this), this._resolve = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && t4.play();
    }, e3.prototype.dispose = function() {
      this._isConnectedToTicker && (ry.shared.remove(this.update, this), this._isConnectedToTicker = false);
      var e4 = this.source;
      e4 && (e4.removeEventListener("error", this._onError, true), e4.pause(), e4.src = "", e4.load()), t3.prototype.dispose.call(this);
    }, Object.defineProperty(e3.prototype, "autoUpdate", { get: function() {
      return this._autoUpdate;
    }, set: function(t4) {
      t4 !== this._autoUpdate && (this._autoUpdate = t4, !this._autoUpdate && this._isConnectedToTicker ? (ry.shared.remove(this.update, this), this._isConnectedToTicker = false) : this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying() && (ry.shared.add(this.update, this), this._isConnectedToTicker = true));
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "updateFPS", { get: function() {
      return this._updateFPS;
    }, set: function(t4) {
      t4 !== this._updateFPS && (this._updateFPS = t4);
    }, enumerable: false, configurable: true }), e3.test = function(t4, n2) {
      return self.HTMLVideoElement && t4 instanceof HTMLVideoElement || e3.TYPES.indexOf(n2) > -1;
    }, e3.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"], e3.MIME_TYPES = { ogv: "video/ogg", mov: "video/quicktime", m4v: "video/mp4" }, e3;
  }(My), Oy = function(t3) {
    function e3(e4) {
      return t3.call(this, e4) || this;
    }
    return _y(e3, t3), e3.test = function(t4) {
      return !!self.createImageBitmap && t4 instanceof ImageBitmap;
    }, e3;
  }(My);
  my.push(Py, Oy, Ay, Iy, Cy, by, Ry, Ey);
  var Ly = { __proto__: null, Resource: xy, BaseImageResource: My, INSTALLED: my, autoDetectResource: gy, AbstractMultiResource: Sy, ArrayResource: Ey, BufferResource: by, CanvasResource: Ay, CubeResource: Ry, ImageResource: Py, SVGResource: Cy, VideoResource: Iy, ImageBitmapResource: Oy }, Ny = function(t3) {
    function e3() {
      return t3 !== null && t3.apply(this, arguments) || this;
    }
    return _y(e3, t3), e3.prototype.upload = function(t4, e4, n2) {
      var i2 = t4.gl;
      i2.pixelStorei(i2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e4.alphaMode === lv.UNPACK);
      var r3 = e4.realWidth, o3 = e4.realHeight;
      return n2.width === r3 && n2.height === o3 ? i2.texSubImage2D(e4.target, 0, 0, 0, r3, o3, e4.format, n2.type, this.data) : (n2.width = r3, n2.height = o3, i2.texImage2D(e4.target, 0, n2.internalFormat, r3, o3, 0, e4.format, n2.type, this.data)), true;
    }, e3;
  }(by), Dy = function() {
    function t3(t4, e3) {
      this.width = Math.round(t4 || 100), this.height = Math.round(e3 || 100), this.stencil = false, this.depth = false, this.dirtyId = 0, this.dirtyFormat = 0, this.dirtySize = 0, this.depthTexture = null, this.colorTextures = [], this.glFramebuffers = {}, this.disposeRunner = new fy("disposeFramebuffer"), this.multisample = pv.NONE;
    }
    return Object.defineProperty(t3.prototype, "colorTexture", { get: function() {
      return this.colorTextures[0];
    }, enumerable: false, configurable: true }), t3.prototype.addColorTexture = function(t4, e3) {
      return t4 === void 0 && (t4 = 0), this.colorTextures[t4] = e3 || new wy(null, { scaleMode: ov.NEAREST, resolution: 1, mipmap: av.OFF, width: this.width, height: this.height }), this.dirtyId++, this.dirtyFormat++, this;
    }, t3.prototype.addDepthTexture = function(t4) {
      return this.depthTexture = t4 || new wy(new Ny(null, { width: this.width, height: this.height }), { scaleMode: ov.NEAREST, resolution: 1, width: this.width, height: this.height, mipmap: av.OFF, format: ev.DEPTH_COMPONENT, type: iv.UNSIGNED_SHORT }), this.dirtyId++, this.dirtyFormat++, this;
    }, t3.prototype.enableDepth = function() {
      return this.depth = true, this.dirtyId++, this.dirtyFormat++, this;
    }, t3.prototype.enableStencil = function() {
      return this.stencil = true, this.dirtyId++, this.dirtyFormat++, this;
    }, t3.prototype.resize = function(t4, e3) {
      if (t4 = Math.round(t4), e3 = Math.round(e3), t4 !== this.width || e3 !== this.height) {
        this.width = t4, this.height = e3, this.dirtyId++, this.dirtySize++;
        for (var n2 = 0; n2 < this.colorTextures.length; n2++) {
          var i2 = this.colorTextures[n2], r3 = i2.resolution;
          i2.setSize(t4 / r3, e3 / r3);
        }
        if (this.depthTexture) {
          r3 = this.depthTexture.resolution;
          this.depthTexture.setSize(t4 / r3, e3 / r3);
        }
      }
    }, t3.prototype.dispose = function() {
      this.disposeRunner.emit(this, false);
    }, t3.prototype.destroyDepthTexture = function() {
      this.depthTexture && (this.depthTexture.destroy(), this.depthTexture = null, ++this.dirtyId, ++this.dirtyFormat);
    }, t3;
  }(), Fy = function(t3) {
    function e3(e4) {
      var n2 = this;
      if (typeof e4 == "number") {
        var i2 = arguments[0], r3 = arguments[1], o3 = arguments[2], s3 = arguments[3];
        e4 = { width: i2, height: r3, scaleMode: o3, resolution: s3 };
      }
      return e4.width = e4.width || 100, e4.height = e4.height || 100, e4.multisample = e4.multisample !== void 0 ? e4.multisample : pv.NONE, (n2 = t3.call(this, null, e4) || this).mipmap = av.OFF, n2.valid = true, n2.clearColor = [0, 0, 0, 0], n2.framebuffer = new Dy(n2.realWidth, n2.realHeight).addColorTexture(0, n2), n2.framebuffer.multisample = e4.multisample, n2.maskStack = [], n2.filterStack = [{}], n2;
    }
    return _y(e3, t3), e3.prototype.resize = function(t4, e4) {
      this.framebuffer.resize(t4 * this.resolution, e4 * this.resolution), this.setRealSize(this.framebuffer.width, this.framebuffer.height);
    }, e3.prototype.dispose = function() {
      this.framebuffer.dispose(), t3.prototype.dispose.call(this);
    }, e3.prototype.destroy = function() {
      t3.prototype.destroy.call(this), this.framebuffer.destroyDepthTexture(), this.framebuffer = null;
    }, e3;
  }(wy), By = function() {
    function t3() {
      this.x0 = 0, this.y0 = 0, this.x1 = 1, this.y1 = 0, this.x2 = 1, this.y2 = 1, this.x3 = 0, this.y3 = 1, this.uvsFloat32 = new Float32Array(8);
    }
    return t3.prototype.set = function(t4, e3, n2) {
      var i2 = e3.width, r3 = e3.height;
      if (n2) {
        var o3 = t4.width / 2 / i2, s3 = t4.height / 2 / r3, a2 = t4.x / i2 + o3, l2 = t4.y / r3 + s3;
        n2 = A_.add(n2, A_.NW), this.x0 = a2 + o3 * A_.uX(n2), this.y0 = l2 + s3 * A_.uY(n2), n2 = A_.add(n2, 2), this.x1 = a2 + o3 * A_.uX(n2), this.y1 = l2 + s3 * A_.uY(n2), n2 = A_.add(n2, 2), this.x2 = a2 + o3 * A_.uX(n2), this.y2 = l2 + s3 * A_.uY(n2), n2 = A_.add(n2, 2), this.x3 = a2 + o3 * A_.uX(n2), this.y3 = l2 + s3 * A_.uY(n2);
      } else
        this.x0 = t4.x / i2, this.y0 = t4.y / r3, this.x1 = (t4.x + t4.width) / i2, this.y1 = t4.y / r3, this.x2 = (t4.x + t4.width) / i2, this.y2 = (t4.y + t4.height) / r3, this.x3 = t4.x / i2, this.y3 = (t4.y + t4.height) / r3;
      this.uvsFloat32[0] = this.x0, this.uvsFloat32[1] = this.y0, this.uvsFloat32[2] = this.x1, this.uvsFloat32[3] = this.y1, this.uvsFloat32[4] = this.x2, this.uvsFloat32[5] = this.y2, this.uvsFloat32[6] = this.x3, this.uvsFloat32[7] = this.y3;
    }, t3.prototype.toString = function() {
      return "[@pixi/core:TextureUvs x0=" + this.x0 + " y0=" + this.y0 + " x1=" + this.x1 + " y1=" + this.y1 + " x2=" + this.x2 + " y2=" + this.y2 + " x3=" + this.x3 + " y3=" + this.y3 + "]";
    }, t3;
  }(), Uy = new By(), ky = function(t3) {
    function e3(n2, i2, r3, o3, s3, a2) {
      var l2 = t3.call(this) || this;
      if (l2.noFrame = false, i2 || (l2.noFrame = true, i2 = new d_(0, 0, 1, 1)), n2 instanceof e3 && (n2 = n2.baseTexture), l2.baseTexture = n2, l2._frame = i2, l2.trim = o3, l2.valid = false, l2._uvs = Uy, l2.uvMatrix = null, l2.orig = r3 || i2, l2._rotate = Number(s3 || 0), s3 === true)
        l2._rotate = 2;
      else if (l2._rotate % 2 != 0)
        throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
      return l2.defaultAnchor = a2 ? new v_(a2.x, a2.y) : new v_(0, 0), l2._updateID = 0, l2.textureCacheIds = [], n2.valid ? l2.noFrame ? n2.valid && l2.onBaseTextureUpdated(n2) : l2.frame = i2 : n2.once("loaded", l2.onBaseTextureUpdated, l2), l2.noFrame && n2.on("update", l2.onBaseTextureUpdated, l2), l2;
    }
    return _y(e3, t3), e3.prototype.update = function() {
      this.baseTexture.resource && this.baseTexture.resource.update();
    }, e3.prototype.onBaseTextureUpdated = function(t4) {
      if (this.noFrame) {
        if (!this.baseTexture.valid)
          return;
        this._frame.width = t4.width, this._frame.height = t4.height, this.valid = true, this.updateUvs();
      } else
        this.frame = this._frame;
      this.emit("update", this);
    }, e3.prototype.destroy = function(t4) {
      if (this.baseTexture) {
        if (t4) {
          var n2 = this.baseTexture.resource;
          n2 && n2.url && $v[n2.url] && e3.removeFromCache(n2.url), this.baseTexture.destroy();
        }
        this.baseTexture.off("loaded", this.onBaseTextureUpdated, this), this.baseTexture.off("update", this.onBaseTextureUpdated, this), this.baseTexture = null;
      }
      this._frame = null, this._uvs = null, this.trim = null, this.orig = null, this.valid = false, e3.removeFromCache(this), this.textureCacheIds = null;
    }, e3.prototype.clone = function() {
      var t4 = this._frame.clone(), n2 = this._frame === this.orig ? t4 : this.orig.clone(), i2 = new e3(this.baseTexture, !this.noFrame && t4, n2, this.trim && this.trim.clone(), this.rotate, this.defaultAnchor);
      return this.noFrame && (i2._frame = t4), i2;
    }, e3.prototype.updateUvs = function() {
      this._uvs === Uy && (this._uvs = new By()), this._uvs.set(this._frame, this.baseTexture, this.rotate), this._updateID++;
    }, e3.from = function(t4, n2, i2) {
      n2 === void 0 && (n2 = {}), i2 === void 0 && (i2 = mv.STRICT_TEXTURE_CACHE);
      var r3 = typeof t4 == "string", o3 = null;
      if (r3)
        o3 = t4;
      else if (t4 instanceof wy) {
        if (!t4.cacheId) {
          var s3 = n2 && n2.pixiIdPrefix || "pixiid";
          t4.cacheId = s3 + "-" + qv(), wy.addToCache(t4, t4.cacheId);
        }
        o3 = t4.cacheId;
      } else {
        if (!t4._pixiId) {
          s3 = n2 && n2.pixiIdPrefix || "pixiid";
          t4._pixiId = s3 + "_" + qv();
        }
        o3 = t4._pixiId;
      }
      var a2 = $v[o3];
      if (r3 && i2 && !a2)
        throw new Error('The cacheId "' + o3 + '" does not exist in TextureCache.');
      return a2 || t4 instanceof wy ? !a2 && t4 instanceof wy && (a2 = new e3(t4), e3.addToCache(a2, o3)) : (n2.resolution || (n2.resolution = a_(t4)), (a2 = new e3(new wy(t4, n2))).baseTexture.cacheId = o3, wy.addToCache(a2.baseTexture, o3), e3.addToCache(a2, o3)), a2;
    }, e3.fromURL = function(t4, n2) {
      var i2 = Object.assign({ autoLoad: false }, n2 == null ? void 0 : n2.resourceOptions), r3 = e3.from(t4, Object.assign({ resourceOptions: i2 }, n2), false), o3 = r3.baseTexture.resource;
      return r3.baseTexture.valid ? Promise.resolve(r3) : o3.load().then(function() {
        return Promise.resolve(r3);
      });
    }, e3.fromBuffer = function(t4, n2, i2, r3) {
      return new e3(wy.fromBuffer(t4, n2, i2, r3));
    }, e3.fromLoader = function(t4, n2, i2, r3) {
      var o3 = new wy(t4, Object.assign({ scaleMode: mv.SCALE_MODE, resolution: a_(n2) }, r3)), s3 = o3.resource;
      s3 instanceof Py && (s3.url = n2);
      var a2 = new e3(o3);
      return i2 || (i2 = n2), wy.addToCache(a2.baseTexture, i2), e3.addToCache(a2, i2), i2 !== n2 && (wy.addToCache(a2.baseTexture, n2), e3.addToCache(a2, n2)), a2.baseTexture.valid ? Promise.resolve(a2) : new Promise(function(t5) {
        a2.baseTexture.once("loaded", function() {
          return t5(a2);
        });
      });
    }, e3.addToCache = function(t4, e4) {
      e4 && (t4.textureCacheIds.indexOf(e4) === -1 && t4.textureCacheIds.push(e4), $v[e4] && console.warn("Texture added to the cache with an id [" + e4 + "] that already had an entry"), $v[e4] = t4);
    }, e3.removeFromCache = function(t4) {
      if (typeof t4 == "string") {
        var e4 = $v[t4];
        if (e4) {
          var n2 = e4.textureCacheIds.indexOf(t4);
          return n2 > -1 && e4.textureCacheIds.splice(n2, 1), delete $v[t4], e4;
        }
      } else if (t4 && t4.textureCacheIds) {
        for (var i2 = 0; i2 < t4.textureCacheIds.length; ++i2)
          $v[t4.textureCacheIds[i2]] === t4 && delete $v[t4.textureCacheIds[i2]];
        return t4.textureCacheIds.length = 0, t4;
      }
      return null;
    }, Object.defineProperty(e3.prototype, "resolution", { get: function() {
      return this.baseTexture.resolution;
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "frame", { get: function() {
      return this._frame;
    }, set: function(t4) {
      this._frame = t4, this.noFrame = false;
      var e4 = t4.x, n2 = t4.y, i2 = t4.width, r3 = t4.height, o3 = e4 + i2 > this.baseTexture.width, s3 = n2 + r3 > this.baseTexture.height;
      if (o3 || s3) {
        var a2 = o3 && s3 ? "and" : "or", l2 = "X: " + e4 + " + " + i2 + " = " + (e4 + i2) + " > " + this.baseTexture.width, u2 = "Y: " + n2 + " + " + r3 + " = " + (n2 + r3) + " > " + this.baseTexture.height;
        throw new Error("Texture Error: frame does not fit inside the base Texture dimensions: " + l2 + " " + a2 + " " + u2);
      }
      this.valid = i2 && r3 && this.baseTexture.valid, this.trim || this.rotate || (this.orig = t4), this.valid && this.updateUvs();
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "rotate", { get: function() {
      return this._rotate;
    }, set: function(t4) {
      this._rotate = t4, this.valid && this.updateUvs();
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "width", { get: function() {
      return this.orig.width;
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "height", { get: function() {
      return this.orig.height;
    }, enumerable: false, configurable: true }), e3.prototype.castToBaseTexture = function() {
      return this.baseTexture;
    }, e3;
  }(vv.a);
  function Gy(t3) {
    t3.destroy = function() {
    }, t3.on = function() {
    }, t3.once = function() {
    }, t3.emit = function() {
    };
  }
  ky.EMPTY = new ky(new wy()), Gy(ky.EMPTY), Gy(ky.EMPTY.baseTexture), ky.WHITE = function() {
    var t3 = document.createElement("canvas");
    t3.width = 16, t3.height = 16;
    var e3 = t3.getContext("2d");
    return e3.fillStyle = "white", e3.fillRect(0, 0, 16, 16), new ky(new wy(new Ay(t3)));
  }(), Gy(ky.WHITE), Gy(ky.WHITE.baseTexture);
  var Hy = function(t3) {
    function e3(e4, n2) {
      var i2 = t3.call(this, e4, n2) || this;
      return i2.valid = true, i2.filterFrame = null, i2.filterPoolKey = null, i2.updateUvs(), i2;
    }
    return _y(e3, t3), Object.defineProperty(e3.prototype, "framebuffer", { get: function() {
      return this.baseTexture.framebuffer;
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "multisample", { get: function() {
      return this.framebuffer.multisample;
    }, set: function(t4) {
      this.framebuffer.multisample = t4;
    }, enumerable: false, configurable: true }), e3.prototype.resize = function(t4, e4, n2) {
      n2 === void 0 && (n2 = true);
      var i2 = this.baseTexture.resolution, r3 = Math.round(t4 * i2) / i2, o3 = Math.round(e4 * i2) / i2;
      this.valid = r3 > 0 && o3 > 0, this._frame.width = this.orig.width = r3, this._frame.height = this.orig.height = o3, n2 && this.baseTexture.resize(r3, o3), this.updateUvs();
    }, e3.prototype.setResolution = function(t4) {
      var e4 = this.baseTexture;
      e4.resolution !== t4 && (e4.setResolution(t4), this.resize(e4.width, e4.height, false));
    }, e3.create = function(t4) {
      for (var n2 = arguments, i2 = [], r3 = 1; r3 < arguments.length; r3++)
        i2[r3 - 1] = n2[r3];
      return typeof t4 == "number" && (Zv("6.0.0", "Arguments (width, height, scaleMode, resolution) have been deprecated."), t4 = { width: t4, height: i2[0], scaleMode: i2[1], resolution: i2[2] }), new e3(new Fy(t4));
    }, e3;
  }(ky), zy = function() {
    function t3(t4) {
      this.texturePool = {}, this.textureOptions = t4 || {}, this.enableFullScreen = false, this._pixelsWidth = 0, this._pixelsHeight = 0;
    }
    return t3.prototype.createTexture = function(t4, e3, n2) {
      n2 === void 0 && (n2 = pv.NONE);
      var i2 = new Fy(Object.assign({ width: t4, height: e3, resolution: 1, multisample: n2 }, this.textureOptions));
      return new Hy(i2);
    }, t3.prototype.getOptimalTexture = function(t4, e3, n2, i2) {
      var r3;
      n2 === void 0 && (n2 = 1), i2 === void 0 && (i2 = pv.NONE), t4 = Math.ceil(t4 * n2), e3 = Math.ceil(e3 * n2), this.enableFullScreen && t4 === this._pixelsWidth && e3 === this._pixelsHeight ? r3 = i2 > 1 ? -i2 : -1 : (r3 = ((65535 & (t4 = Hv(t4))) << 16 | 65535 & (e3 = Hv(e3))) >>> 0, i2 > 1 && (r3 += 4294967296 * i2)), this.texturePool[r3] || (this.texturePool[r3] = []);
      var o3 = this.texturePool[r3].pop();
      return o3 || (o3 = this.createTexture(t4, e3, i2)), o3.filterPoolKey = r3, o3.setResolution(n2), o3;
    }, t3.prototype.getFilterTexture = function(t4, e3, n2) {
      var i2 = this.getOptimalTexture(t4.width, t4.height, e3 || t4.resolution, n2 || pv.NONE);
      return i2.filterFrame = t4.filterFrame, i2;
    }, t3.prototype.returnTexture = function(t4) {
      var e3 = t4.filterPoolKey;
      t4.filterFrame = null, this.texturePool[e3].push(t4);
    }, t3.prototype.returnFilterTexture = function(t4) {
      this.returnTexture(t4);
    }, t3.prototype.clear = function(t4) {
      if (t4 = t4 !== false)
        for (var e3 in this.texturePool) {
          var n2 = this.texturePool[e3];
          if (n2)
            for (var i2 = 0; i2 < n2.length; i2++)
              n2[i2].destroy(true);
        }
      this.texturePool = {};
    }, t3.prototype.setScreenSize = function(t4) {
      if (t4.width !== this._pixelsWidth || t4.height !== this._pixelsHeight) {
        for (var e3 in this.enableFullScreen = t4.width > 0 && t4.height > 0, this.texturePool)
          if (Number(e3) < 0) {
            var n2 = this.texturePool[e3];
            if (n2)
              for (var i2 = 0; i2 < n2.length; i2++)
                n2[i2].destroy(true);
            this.texturePool[e3] = [];
          }
        this._pixelsWidth = t4.width, this._pixelsHeight = t4.height;
      }
    }, t3.SCREEN_KEY = -1, t3;
  }(), jy = function() {
    function t3(t4, e3, n2, i2, r3, o3, s3) {
      e3 === void 0 && (e3 = 0), n2 === void 0 && (n2 = false), i2 === void 0 && (i2 = iv.FLOAT), this.buffer = t4, this.size = e3, this.normalized = n2, this.type = i2, this.stride = r3, this.start = o3, this.instance = s3;
    }
    return t3.prototype.destroy = function() {
      this.buffer = null;
    }, t3.from = function(e3, n2, i2, r3, o3) {
      return new t3(e3, n2, i2, r3, o3);
    }, t3;
  }(), Vy = 0, Wy = function() {
    function t3(t4, e3, n2) {
      e3 === void 0 && (e3 = true), n2 === void 0 && (n2 = false), this.data = t4 || new Float32Array(1), this._glBuffers = {}, this._updateID = 0, this.index = n2, this.static = e3, this.id = Vy++, this.disposeRunner = new fy("disposeBuffer");
    }
    return t3.prototype.update = function(t4) {
      t4 instanceof Array && (t4 = new Float32Array(t4)), this.data = t4 || this.data, this._updateID++;
    }, t3.prototype.dispose = function() {
      this.disposeRunner.emit(this, false);
    }, t3.prototype.destroy = function() {
      this.dispose(), this.data = null;
    }, Object.defineProperty(t3.prototype, "index", { get: function() {
      return this.type === fv.ELEMENT_ARRAY_BUFFER;
    }, set: function(t4) {
      this.type = t4 ? fv.ELEMENT_ARRAY_BUFFER : fv.ARRAY_BUFFER;
    }, enumerable: false, configurable: true }), t3.from = function(e3) {
      return e3 instanceof Array && (e3 = new Float32Array(e3)), new t3(e3);
    }, t3;
  }(), Xy = { Float32Array, Uint32Array, Int32Array, Uint8Array };
  var qy = { 5126: 4, 5123: 2, 5121: 1 }, Yy = 0, Zy = { Float32Array, Uint32Array, Int32Array, Uint8Array, Uint16Array }, Jy = function() {
    function t3(t4, e3) {
      t4 === void 0 && (t4 = []), e3 === void 0 && (e3 = {}), this.buffers = t4, this.indexBuffer = null, this.attributes = e3, this.glVertexArrayObjects = {}, this.id = Yy++, this.instanced = false, this.instanceCount = 1, this.disposeRunner = new fy("disposeGeometry"), this.refCount = 0;
    }
    return t3.prototype.addAttribute = function(t4, e3, n2, i2, r3, o3, s3, a2) {
      if (n2 === void 0 && (n2 = 0), i2 === void 0 && (i2 = false), a2 === void 0 && (a2 = false), !e3)
        throw new Error("You must pass a buffer when creating an attribute");
      e3 instanceof Wy || (e3 instanceof Array && (e3 = new Float32Array(e3)), e3 = new Wy(e3));
      var l2 = t4.split("|");
      if (l2.length > 1) {
        for (var u2 = 0; u2 < l2.length; u2++)
          this.addAttribute(l2[u2], e3, n2, i2, r3);
        return this;
      }
      var h2 = this.buffers.indexOf(e3);
      return h2 === -1 && (this.buffers.push(e3), h2 = this.buffers.length - 1), this.attributes[t4] = new jy(h2, n2, i2, r3, o3, s3, a2), this.instanced = this.instanced || a2, this;
    }, t3.prototype.getAttribute = function(t4) {
      return this.attributes[t4];
    }, t3.prototype.getBuffer = function(t4) {
      return this.buffers[this.getAttribute(t4).buffer];
    }, t3.prototype.addIndex = function(t4) {
      return t4 instanceof Wy || (t4 instanceof Array && (t4 = new Uint16Array(t4)), t4 = new Wy(t4)), t4.type = fv.ELEMENT_ARRAY_BUFFER, this.indexBuffer = t4, this.buffers.indexOf(t4) === -1 && this.buffers.push(t4), this;
    }, t3.prototype.getIndex = function() {
      return this.indexBuffer;
    }, t3.prototype.interleave = function() {
      if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer)
        return this;
      var t4, e3 = [], n2 = [], i2 = new Wy();
      for (t4 in this.attributes) {
        var r3 = this.attributes[t4], o3 = this.buffers[r3.buffer];
        e3.push(o3.data), n2.push(r3.size * qy[r3.type] / 4), r3.buffer = 0;
      }
      for (i2.data = function(t5, e4) {
        for (var n3 = 0, i3 = 0, r4 = {}, o4 = 0; o4 < t5.length; o4++)
          i3 += e4[o4], n3 += t5[o4].length;
        var s3 = new ArrayBuffer(4 * n3), a2 = null, l2 = 0;
        for (o4 = 0; o4 < t5.length; o4++) {
          var u2 = e4[o4], h2 = t5[o4], c2 = Uv(h2);
          r4[c2] || (r4[c2] = new Xy[c2](s3)), a2 = r4[c2];
          for (var d2 = 0; d2 < h2.length; d2++) {
            a2[(d2 / u2 | 0) * i3 + l2 + d2 % u2] = h2[d2];
          }
          l2 += u2;
        }
        return new Float32Array(s3);
      }(e3, n2), t4 = 0; t4 < this.buffers.length; t4++)
        this.buffers[t4] !== this.indexBuffer && this.buffers[t4].destroy();
      return this.buffers = [i2], this.indexBuffer && this.buffers.push(this.indexBuffer), this;
    }, t3.prototype.getSize = function() {
      for (var t4 in this.attributes) {
        var e3 = this.attributes[t4];
        return this.buffers[e3.buffer].data.length / (e3.stride / 4 || e3.size);
      }
      return 0;
    }, t3.prototype.dispose = function() {
      this.disposeRunner.emit(this, false);
    }, t3.prototype.destroy = function() {
      this.dispose(), this.buffers = null, this.indexBuffer = null, this.attributes = null;
    }, t3.prototype.clone = function() {
      for (var e3 = new t3(), n2 = 0; n2 < this.buffers.length; n2++)
        e3.buffers[n2] = new Wy(this.buffers[n2].data.slice(0));
      for (var n2 in this.attributes) {
        var i2 = this.attributes[n2];
        e3.attributes[n2] = new jy(i2.buffer, i2.size, i2.normalized, i2.type, i2.stride, i2.start, i2.instance);
      }
      return this.indexBuffer && (e3.indexBuffer = e3.buffers[this.buffers.indexOf(this.indexBuffer)], e3.indexBuffer.type = fv.ELEMENT_ARRAY_BUFFER), e3;
    }, t3.merge = function(e3) {
      for (var n2, i2 = new t3(), r3 = [], o3 = [], s3 = [], a2 = 0; a2 < e3.length; a2++) {
        n2 = e3[a2];
        for (var l2 = 0; l2 < n2.buffers.length; l2++)
          o3[l2] = o3[l2] || 0, o3[l2] += n2.buffers[l2].data.length, s3[l2] = 0;
      }
      for (a2 = 0; a2 < n2.buffers.length; a2++)
        r3[a2] = new Zy[Uv(n2.buffers[a2].data)](o3[a2]), i2.buffers[a2] = new Wy(r3[a2]);
      for (a2 = 0; a2 < e3.length; a2++) {
        n2 = e3[a2];
        for (l2 = 0; l2 < n2.buffers.length; l2++)
          r3[l2].set(n2.buffers[l2].data, s3[l2]), s3[l2] += n2.buffers[l2].data.length;
      }
      if (i2.attributes = n2.attributes, n2.indexBuffer) {
        i2.indexBuffer = i2.buffers[n2.buffers.indexOf(n2.indexBuffer)], i2.indexBuffer.type = fv.ELEMENT_ARRAY_BUFFER;
        var u2 = 0, h2 = 0, c2 = 0, d2 = 0;
        for (a2 = 0; a2 < n2.buffers.length; a2++)
          if (n2.buffers[a2] !== n2.indexBuffer) {
            d2 = a2;
            break;
          }
        for (var a2 in n2.attributes) {
          var p2 = n2.attributes[a2];
          (0 | p2.buffer) === d2 && (h2 += p2.size * qy[p2.type] / 4);
        }
        for (a2 = 0; a2 < e3.length; a2++) {
          var f2 = e3[a2].indexBuffer.data;
          for (l2 = 0; l2 < f2.length; l2++)
            i2.indexBuffer.data[l2 + c2] += u2;
          u2 += e3[a2].buffers[d2].data.length / h2, c2 += f2.length;
        }
      }
      return i2;
    }, t3;
  }(), $y = function(t3) {
    function e3() {
      var e4 = t3.call(this) || this;
      return e4.addAttribute("aVertexPosition", new Float32Array([0, 0, 1, 0, 1, 1, 0, 1])).addIndex([0, 1, 3, 2]), e4;
    }
    return _y(e3, t3), e3;
  }(Jy), Ky = function(t3) {
    function e3() {
      var e4 = t3.call(this) || this;
      return e4.vertices = new Float32Array([-1, -1, 1, -1, 1, 1, -1, 1]), e4.uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), e4.vertexBuffer = new Wy(e4.vertices), e4.uvBuffer = new Wy(e4.uvs), e4.addAttribute("aVertexPosition", e4.vertexBuffer).addAttribute("aTextureCoord", e4.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]), e4;
    }
    return _y(e3, t3), e3.prototype.map = function(t4, e4) {
      var n2 = 0, i2 = 0;
      return this.uvs[0] = n2, this.uvs[1] = i2, this.uvs[2] = n2 + e4.width / t4.width, this.uvs[3] = i2, this.uvs[4] = n2 + e4.width / t4.width, this.uvs[5] = i2 + e4.height / t4.height, this.uvs[6] = n2, this.uvs[7] = i2 + e4.height / t4.height, n2 = e4.x, i2 = e4.y, this.vertices[0] = n2, this.vertices[1] = i2, this.vertices[2] = n2 + e4.width, this.vertices[3] = i2, this.vertices[4] = n2 + e4.width, this.vertices[5] = i2 + e4.height, this.vertices[6] = n2, this.vertices[7] = i2 + e4.height, this.invalidate(), this;
    }, e3.prototype.invalidate = function() {
      return this.vertexBuffer._updateID++, this.uvBuffer._updateID++, this;
    }, e3;
  }(Jy), Qy = 0, tx = function() {
    function t3(t4, e3, n2) {
      this.group = true, this.syncUniforms = {}, this.dirtyId = 0, this.id = Qy++, this.static = !!e3, this.ubo = !!n2, t4 instanceof Wy ? (this.buffer = t4, this.buffer.type = fv.UNIFORM_BUFFER, this.autoManage = false, this.ubo = true) : (this.uniforms = t4, this.ubo && (this.buffer = new Wy(new Float32Array(1)), this.buffer.type = fv.UNIFORM_BUFFER, this.autoManage = true));
    }
    return t3.prototype.update = function() {
      this.dirtyId++, !this.autoManage && this.buffer && this.buffer.update();
    }, t3.prototype.add = function(e3, n2, i2) {
      if (this.ubo)
        throw new Error("[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them");
      this.uniforms[e3] = new t3(n2, i2);
    }, t3.from = function(e3, n2, i2) {
      return new t3(e3, n2, i2);
    }, t3.uboFrom = function(e3, n2) {
      return new t3(e3, n2 == null || n2, true);
    }, t3;
  }(), ex = function() {
    function t3() {
      this.renderTexture = null, this.target = null, this.legacy = false, this.resolution = 1, this.multisample = pv.NONE, this.sourceFrame = new d_(), this.destinationFrame = new d_(), this.bindingSourceFrame = new d_(), this.bindingDestinationFrame = new d_(), this.filters = [], this.transform = null;
    }
    return t3.prototype.clear = function() {
      this.target = null, this.filters = null, this.renderTexture = null;
    }, t3;
  }(), nx = [new v_(), new v_(), new v_(), new v_()], ix = new y_(), rx = function() {
    function t3(t4) {
      this.renderer = t4, this.defaultFilterStack = [{}], this.texturePool = new zy(), this.texturePool.setScreenSize(t4.view), this.statePool = [], this.quad = new $y(), this.quadUv = new Ky(), this.tempRect = new d_(), this.activeState = {}, this.globalUniforms = new tx({ outputFrame: new d_(), inputSize: new Float32Array(4), inputPixel: new Float32Array(4), inputClamp: new Float32Array(4), resolution: 1, filterArea: new Float32Array(4), filterClamp: new Float32Array(4) }, true), this.forceClear = false, this.useMaxPadding = false;
    }
    return t3.prototype.push = function(t4, e3) {
      for (var n2 = this.renderer, i2 = this.defaultFilterStack, r3 = this.statePool.pop() || new ex(), o3 = this.renderer.renderTexture, s3 = e3[0].resolution, a2 = e3[0].multisample, l2 = e3[0].padding, u2 = e3[0].autoFit, h2 = e3[0].legacy, c2 = 1; c2 < e3.length; c2++) {
        var d2 = e3[c2];
        s3 = Math.min(s3, d2.resolution), a2 = Math.min(a2, d2.multisample), l2 = this.useMaxPadding ? Math.max(l2, d2.padding) : l2 + d2.padding, u2 = u2 && d2.autoFit, h2 = h2 || d2.legacy;
      }
      if (i2.length === 1 && (this.defaultFilterStack[0].renderTexture = o3.current), i2.push(r3), r3.resolution = s3, r3.multisample = a2, r3.legacy = h2, r3.target = t4, r3.sourceFrame.copyFrom(t4.filterArea || t4.getBounds(true)), r3.sourceFrame.pad(l2), u2) {
        var p2 = this.tempRect.copyFrom(o3.sourceFrame);
        n2.projection.transform && this.transformAABB(ix.copyFrom(n2.projection.transform).invert(), p2), r3.sourceFrame.fit(p2);
      }
      this.roundFrame(r3.sourceFrame, o3.current ? o3.current.resolution : n2.resolution, o3.sourceFrame, o3.destinationFrame, n2.projection.transform), r3.renderTexture = this.getOptimalFilterTexture(r3.sourceFrame.width, r3.sourceFrame.height, s3, a2), r3.filters = e3, r3.destinationFrame.width = r3.renderTexture.width, r3.destinationFrame.height = r3.renderTexture.height;
      var f2 = this.tempRect;
      f2.x = 0, f2.y = 0, f2.width = r3.sourceFrame.width, f2.height = r3.sourceFrame.height, r3.renderTexture.filterFrame = r3.sourceFrame, r3.bindingSourceFrame.copyFrom(o3.sourceFrame), r3.bindingDestinationFrame.copyFrom(o3.destinationFrame), r3.transform = n2.projection.transform, n2.projection.transform = null, o3.bind(r3.renderTexture, r3.sourceFrame, f2), n2.framebuffer.clear(0, 0, 0, 0);
    }, t3.prototype.pop = function() {
      var t4 = this.defaultFilterStack, e3 = t4.pop(), n2 = e3.filters;
      this.activeState = e3;
      var i2 = this.globalUniforms.uniforms;
      i2.outputFrame = e3.sourceFrame, i2.resolution = e3.resolution;
      var r3 = i2.inputSize, o3 = i2.inputPixel, s3 = i2.inputClamp;
      if (r3[0] = e3.destinationFrame.width, r3[1] = e3.destinationFrame.height, r3[2] = 1 / r3[0], r3[3] = 1 / r3[1], o3[0] = Math.round(r3[0] * e3.resolution), o3[1] = Math.round(r3[1] * e3.resolution), o3[2] = 1 / o3[0], o3[3] = 1 / o3[1], s3[0] = 0.5 * o3[2], s3[1] = 0.5 * o3[3], s3[2] = e3.sourceFrame.width * r3[2] - 0.5 * o3[2], s3[3] = e3.sourceFrame.height * r3[3] - 0.5 * o3[3], e3.legacy) {
        var a2 = i2.filterArea;
        a2[0] = e3.destinationFrame.width, a2[1] = e3.destinationFrame.height, a2[2] = e3.sourceFrame.x, a2[3] = e3.sourceFrame.y, i2.filterClamp = i2.inputClamp;
      }
      this.globalUniforms.update();
      var l2 = t4[t4.length - 1];
      if (this.renderer.framebuffer.blit(), n2.length === 1)
        n2[0].apply(this, e3.renderTexture, l2.renderTexture, uv.BLEND, e3), this.returnFilterTexture(e3.renderTexture);
      else {
        var u2 = e3.renderTexture, h2 = this.getOptimalFilterTexture(u2.width, u2.height, e3.resolution);
        h2.filterFrame = u2.filterFrame;
        var c2 = 0;
        for (c2 = 0; c2 < n2.length - 1; ++c2) {
          c2 === 1 && e3.multisample > 1 && ((h2 = this.getOptimalFilterTexture(u2.width, u2.height, e3.resolution)).filterFrame = u2.filterFrame), n2[c2].apply(this, u2, h2, uv.CLEAR, e3);
          var d2 = u2;
          u2 = h2, h2 = d2;
        }
        n2[c2].apply(this, u2, l2.renderTexture, uv.BLEND, e3), c2 > 1 && e3.multisample > 1 && this.returnFilterTexture(e3.renderTexture), this.returnFilterTexture(u2), this.returnFilterTexture(h2);
      }
      e3.clear(), this.statePool.push(e3);
    }, t3.prototype.bindAndClear = function(t4, e3) {
      e3 === void 0 && (e3 = uv.CLEAR);
      var n2 = this.renderer, i2 = n2.renderTexture, r3 = n2.state;
      if (t4 === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? this.renderer.projection.transform = this.activeState.transform : this.renderer.projection.transform = null, t4 && t4.filterFrame) {
        var o3 = this.tempRect;
        o3.x = 0, o3.y = 0, o3.width = t4.filterFrame.width, o3.height = t4.filterFrame.height, i2.bind(t4, t4.filterFrame, o3);
      } else
        t4 !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? i2.bind(t4) : this.renderer.renderTexture.bind(t4, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);
      var s3 = 1 & r3.stateId || this.forceClear;
      (e3 === uv.CLEAR || e3 === uv.BLIT && s3) && this.renderer.framebuffer.clear(0, 0, 0, 0);
    }, t3.prototype.applyFilter = function(t4, e3, n2, i2) {
      var r3 = this.renderer;
      r3.state.set(t4.state), this.bindAndClear(n2, i2), t4.uniforms.uSampler = e3, t4.uniforms.filterGlobals = this.globalUniforms, r3.shader.bind(t4), t4.legacy = !!t4.program.attributeData.aTextureCoord, t4.legacy ? (this.quadUv.map(e3._frame, e3.filterFrame), r3.geometry.bind(this.quadUv), r3.geometry.draw(tv.TRIANGLES)) : (r3.geometry.bind(this.quad), r3.geometry.draw(tv.TRIANGLE_STRIP));
    }, t3.prototype.calculateSpriteMatrix = function(t4, e3) {
      var n2 = this.activeState, i2 = n2.sourceFrame, r3 = n2.destinationFrame, o3 = e3._texture.orig, s3 = t4.set(r3.width, 0, 0, r3.height, i2.x, i2.y), a2 = e3.worldTransform.copyTo(y_.TEMP_MATRIX);
      return a2.invert(), s3.prepend(a2), s3.scale(1 / o3.width, 1 / o3.height), s3.translate(e3.anchor.x, e3.anchor.y), s3;
    }, t3.prototype.destroy = function() {
      this.renderer = null, this.texturePool.clear(false);
    }, t3.prototype.getOptimalFilterTexture = function(t4, e3, n2, i2) {
      return n2 === void 0 && (n2 = 1), i2 === void 0 && (i2 = pv.NONE), this.texturePool.getOptimalTexture(t4, e3, n2, i2);
    }, t3.prototype.getFilterTexture = function(t4, e3, n2) {
      if (typeof t4 == "number") {
        var i2 = t4;
        t4 = e3, e3 = i2;
      }
      t4 = t4 || this.activeState.renderTexture;
      var r3 = this.texturePool.getOptimalTexture(t4.width, t4.height, e3 || t4.resolution, n2 || pv.NONE);
      return r3.filterFrame = t4.filterFrame, r3;
    }, t3.prototype.returnFilterTexture = function(t4) {
      this.texturePool.returnTexture(t4);
    }, t3.prototype.emptyPool = function() {
      this.texturePool.clear(true);
    }, t3.prototype.resize = function() {
      this.texturePool.setScreenSize(this.renderer.view);
    }, t3.prototype.transformAABB = function(t4, e3) {
      var n2 = nx[0], i2 = nx[1], r3 = nx[2], o3 = nx[3];
      n2.set(e3.left, e3.top), i2.set(e3.left, e3.bottom), r3.set(e3.right, e3.top), o3.set(e3.right, e3.bottom), t4.apply(n2, n2), t4.apply(i2, i2), t4.apply(r3, r3), t4.apply(o3, o3);
      var s3 = Math.min(n2.x, i2.x, r3.x, o3.x), a2 = Math.min(n2.y, i2.y, r3.y, o3.y), l2 = Math.max(n2.x, i2.x, r3.x, o3.x), u2 = Math.max(n2.y, i2.y, r3.y, o3.y);
      e3.x = s3, e3.y = a2, e3.width = l2 - s3, e3.height = u2 - a2;
    }, t3.prototype.roundFrame = function(t4, e3, n2, i2, r3) {
      if (r3) {
        var o3 = r3.a, s3 = r3.b, a2 = r3.c, l2 = r3.d;
        if ((Math.abs(s3) > 1e-4 || Math.abs(a2) > 1e-4) && (Math.abs(o3) > 1e-4 || Math.abs(l2) > 1e-4))
          return;
      }
      (r3 = r3 ? ix.copyFrom(r3) : ix.identity()).translate(-n2.x, -n2.y).scale(i2.width / n2.width, i2.height / n2.height).translate(i2.x, i2.y), this.transformAABB(r3, t4), t4.ceil(e3), this.transformAABB(r3.invert(), t4);
    }, t3;
  }(), ox = function() {
    function t3(t4) {
      this.renderer = t4;
    }
    return t3.prototype.flush = function() {
    }, t3.prototype.destroy = function() {
      this.renderer = null;
    }, t3.prototype.start = function() {
    }, t3.prototype.stop = function() {
      this.flush();
    }, t3.prototype.render = function(t4) {
    }, t3;
  }(), sx = function() {
    function t3(t4) {
      this.renderer = t4, this.emptyRenderer = new ox(t4), this.currentRenderer = this.emptyRenderer;
    }
    return t3.prototype.setObjectRenderer = function(t4) {
      this.currentRenderer !== t4 && (this.currentRenderer.stop(), this.currentRenderer = t4, this.currentRenderer.start());
    }, t3.prototype.flush = function() {
      this.setObjectRenderer(this.emptyRenderer);
    }, t3.prototype.reset = function() {
      this.setObjectRenderer(this.emptyRenderer);
    }, t3.prototype.copyBoundTextures = function(t4, e3) {
      for (var n2 = this.renderer.texture.boundTextures, i2 = e3 - 1; i2 >= 0; --i2)
        t4[i2] = n2[i2] || null, t4[i2] && (t4[i2]._batchLocation = i2);
    }, t3.prototype.boundArray = function(t4, e3, n2, i2) {
      for (var r3 = t4.elements, o3 = t4.ids, s3 = t4.count, a2 = 0, l2 = 0; l2 < s3; l2++) {
        var u2 = r3[l2], h2 = u2._batchLocation;
        if (h2 >= 0 && h2 < i2 && e3[h2] === u2)
          o3[l2] = h2;
        else
          for (; a2 < i2; ) {
            var c2 = e3[a2];
            if (!c2 || c2._batchEnabled !== n2 || c2._batchLocation !== a2) {
              o3[l2] = a2, u2._batchLocation = a2, e3[a2] = u2;
              break;
            }
            a2++;
          }
      }
    }, t3.prototype.destroy = function() {
      this.renderer = null;
    }, t3;
  }(), ax = 0, lx = function() {
    function t3(t4) {
      this.renderer = t4, this.webGLVersion = 1, this.extensions = {}, this.supports = { uint32Indices: false }, this.handleContextLost = this.handleContextLost.bind(this), this.handleContextRestored = this.handleContextRestored.bind(this), t4.view.addEventListener("webglcontextlost", this.handleContextLost, false), t4.view.addEventListener("webglcontextrestored", this.handleContextRestored, false);
    }
    return Object.defineProperty(t3.prototype, "isLost", { get: function() {
      return !this.gl || this.gl.isContextLost();
    }, enumerable: false, configurable: true }), t3.prototype.contextChange = function(t4) {
      this.gl = t4, this.renderer.gl = t4, this.renderer.CONTEXT_UID = ax++, t4.isContextLost() && t4.getExtension("WEBGL_lose_context") && t4.getExtension("WEBGL_lose_context").restoreContext();
    }, t3.prototype.initFromContext = function(t4) {
      this.gl = t4, this.validateContext(t4), this.renderer.gl = t4, this.renderer.CONTEXT_UID = ax++, this.renderer.runners.contextChange.emit(t4);
    }, t3.prototype.initFromOptions = function(t4) {
      var e3 = this.createContext(this.renderer.view, t4);
      this.initFromContext(e3);
    }, t3.prototype.createContext = function(t4, e3) {
      var n2;
      if (mv.PREFER_ENV >= Jg.WEBGL2 && (n2 = t4.getContext("webgl2", e3)), n2)
        this.webGLVersion = 2;
      else if (this.webGLVersion = 1, !(n2 = t4.getContext("webgl", e3) || t4.getContext("experimental-webgl", e3)))
        throw new Error("This browser does not support WebGL. Try using the canvas renderer");
      return this.gl = n2, this.getExtensions(), this.gl;
    }, t3.prototype.getExtensions = function() {
      var t4 = this.gl, e3 = { anisotropicFiltering: t4.getExtension("EXT_texture_filter_anisotropic"), floatTextureLinear: t4.getExtension("OES_texture_float_linear"), s3tc: t4.getExtension("WEBGL_compressed_texture_s3tc"), s3tc_sRGB: t4.getExtension("WEBGL_compressed_texture_s3tc_srgb"), etc: t4.getExtension("WEBGL_compressed_texture_etc"), etc1: t4.getExtension("WEBGL_compressed_texture_etc1"), pvrtc: t4.getExtension("WEBGL_compressed_texture_pvrtc") || t4.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"), atc: t4.getExtension("WEBGL_compressed_texture_atc"), astc: t4.getExtension("WEBGL_compressed_texture_astc") };
      this.webGLVersion === 1 ? Object.assign(this.extensions, e3, { drawBuffers: t4.getExtension("WEBGL_draw_buffers"), depthTexture: t4.getExtension("WEBGL_depth_texture"), loseContext: t4.getExtension("WEBGL_lose_context"), vertexArrayObject: t4.getExtension("OES_vertex_array_object") || t4.getExtension("MOZ_OES_vertex_array_object") || t4.getExtension("WEBKIT_OES_vertex_array_object"), uint32ElementIndex: t4.getExtension("OES_element_index_uint"), floatTexture: t4.getExtension("OES_texture_float"), floatTextureLinear: t4.getExtension("OES_texture_float_linear"), textureHalfFloat: t4.getExtension("OES_texture_half_float"), textureHalfFloatLinear: t4.getExtension("OES_texture_half_float_linear") }) : this.webGLVersion === 2 && Object.assign(this.extensions, e3, { colorBufferFloat: t4.getExtension("EXT_color_buffer_float") });
    }, t3.prototype.handleContextLost = function(t4) {
      t4.preventDefault();
    }, t3.prototype.handleContextRestored = function() {
      this.renderer.runners.contextChange.emit(this.gl);
    }, t3.prototype.destroy = function() {
      var t4 = this.renderer.view;
      this.renderer = null, t4.removeEventListener("webglcontextlost", this.handleContextLost), t4.removeEventListener("webglcontextrestored", this.handleContextRestored), this.gl.useProgram(null), this.extensions.loseContext && this.extensions.loseContext.loseContext();
    }, t3.prototype.postrender = function() {
      this.renderer.renderingToScreen && this.gl.flush();
    }, t3.prototype.validateContext = function(t4) {
      var e3 = t4.getContextAttributes(), n2 = "WebGL2RenderingContext" in self && t4 instanceof self.WebGL2RenderingContext;
      n2 && (this.webGLVersion = 2), e3.stencil || console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
      var i2 = n2 || !!t4.getExtension("OES_element_index_uint");
      this.supports.uint32Indices = i2, i2 || console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly");
    }, t3;
  }(), ux = function(t3) {
    this.framebuffer = t3, this.stencil = null, this.dirtyId = -1, this.dirtyFormat = -1, this.dirtySize = -1, this.multisample = pv.NONE, this.msaaBuffer = null, this.blitFramebuffer = null, this.mipLevel = 0;
  }, hx = new d_(), cx = function() {
    function t3(t4) {
      this.renderer = t4, this.managedFramebuffers = [], this.unknownFramebuffer = new Dy(10, 10), this.msaaSamples = null;
    }
    return t3.prototype.contextChange = function() {
      var t4 = this.gl = this.renderer.gl;
      if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.current = this.unknownFramebuffer, this.viewport = new d_(), this.hasMRT = true, this.writeDepthTexture = true, this.disposeAll(true), this.renderer.context.webGLVersion === 1) {
        var e3 = this.renderer.context.extensions.drawBuffers, n2 = this.renderer.context.extensions.depthTexture;
        mv.PREFER_ENV === Jg.WEBGL_LEGACY && (e3 = null, n2 = null), e3 ? t4.drawBuffers = function(t5) {
          return e3.drawBuffersWEBGL(t5);
        } : (this.hasMRT = false, t4.drawBuffers = function() {
        }), n2 || (this.writeDepthTexture = false);
      } else
        this.msaaSamples = t4.getInternalformatParameter(t4.RENDERBUFFER, t4.RGBA8, t4.SAMPLES);
    }, t3.prototype.bind = function(t4, e3, n2) {
      n2 === void 0 && (n2 = 0);
      var i2 = this.gl;
      if (t4) {
        var r3 = t4.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(t4);
        this.current !== t4 && (this.current = t4, i2.bindFramebuffer(i2.FRAMEBUFFER, r3.framebuffer)), r3.mipLevel !== n2 && (t4.dirtyId++, t4.dirtyFormat++, r3.mipLevel = n2), r3.dirtyId !== t4.dirtyId && (r3.dirtyId = t4.dirtyId, r3.dirtyFormat !== t4.dirtyFormat ? (r3.dirtyFormat = t4.dirtyFormat, r3.dirtySize = t4.dirtySize, this.updateFramebuffer(t4, n2)) : r3.dirtySize !== t4.dirtySize && (r3.dirtySize = t4.dirtySize, this.resizeFramebuffer(t4)));
        for (var o3 = 0; o3 < t4.colorTextures.length; o3++) {
          var s3 = t4.colorTextures[o3];
          this.renderer.texture.unbind(s3.parentTextureArray || s3);
        }
        if (t4.depthTexture && this.renderer.texture.unbind(t4.depthTexture), e3) {
          var a2 = e3.width >> n2, l2 = e3.height >> n2, u2 = a2 / e3.width;
          this.setViewport(e3.x * u2, e3.y * u2, a2, l2);
        } else {
          a2 = t4.width >> n2, l2 = t4.height >> n2;
          this.setViewport(0, 0, a2, l2);
        }
      } else
        this.current && (this.current = null, i2.bindFramebuffer(i2.FRAMEBUFFER, null)), e3 ? this.setViewport(e3.x, e3.y, e3.width, e3.height) : this.setViewport(0, 0, this.renderer.width, this.renderer.height);
    }, t3.prototype.setViewport = function(t4, e3, n2, i2) {
      var r3 = this.viewport;
      t4 = Math.round(t4), e3 = Math.round(e3), n2 = Math.round(n2), i2 = Math.round(i2), r3.width === n2 && r3.height === i2 && r3.x === t4 && r3.y === e3 || (r3.x = t4, r3.y = e3, r3.width = n2, r3.height = i2, this.gl.viewport(t4, e3, n2, i2));
    }, Object.defineProperty(t3.prototype, "size", { get: function() {
      return this.current ? { x: 0, y: 0, width: this.current.width, height: this.current.height } : { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height };
    }, enumerable: false, configurable: true }), t3.prototype.clear = function(t4, e3, n2, i2, r3) {
      r3 === void 0 && (r3 = Kg.COLOR | Kg.DEPTH);
      var o3 = this.gl;
      o3.clearColor(t4, e3, n2, i2), o3.clear(r3);
    }, t3.prototype.initFramebuffer = function(t4) {
      var e3 = this.gl, n2 = new ux(e3.createFramebuffer());
      return n2.multisample = this.detectSamples(t4.multisample), t4.glFramebuffers[this.CONTEXT_UID] = n2, this.managedFramebuffers.push(t4), t4.disposeRunner.add(this), n2;
    }, t3.prototype.resizeFramebuffer = function(t4) {
      var e3 = this.gl, n2 = t4.glFramebuffers[this.CONTEXT_UID];
      n2.msaaBuffer && (e3.bindRenderbuffer(e3.RENDERBUFFER, n2.msaaBuffer), e3.renderbufferStorageMultisample(e3.RENDERBUFFER, n2.multisample, e3.RGBA8, t4.width, t4.height)), n2.stencil && (e3.bindRenderbuffer(e3.RENDERBUFFER, n2.stencil), n2.msaaBuffer ? e3.renderbufferStorageMultisample(e3.RENDERBUFFER, n2.multisample, e3.DEPTH24_STENCIL8, t4.width, t4.height) : e3.renderbufferStorage(e3.RENDERBUFFER, e3.DEPTH_STENCIL, t4.width, t4.height));
      var i2 = t4.colorTextures, r3 = i2.length;
      e3.drawBuffers || (r3 = Math.min(r3, 1));
      for (var o3 = 0; o3 < r3; o3++) {
        var s3 = i2[o3], a2 = s3.parentTextureArray || s3;
        this.renderer.texture.bind(a2, 0);
      }
      t4.depthTexture && this.writeDepthTexture && this.renderer.texture.bind(t4.depthTexture, 0);
    }, t3.prototype.updateFramebuffer = function(t4, e3) {
      var n2 = this.gl, i2 = t4.glFramebuffers[this.CONTEXT_UID], r3 = t4.colorTextures, o3 = r3.length;
      n2.drawBuffers || (o3 = Math.min(o3, 1)), i2.multisample > 1 && this.canMultisampleFramebuffer(t4) ? (i2.msaaBuffer = i2.msaaBuffer || n2.createRenderbuffer(), n2.bindRenderbuffer(n2.RENDERBUFFER, i2.msaaBuffer), n2.renderbufferStorageMultisample(n2.RENDERBUFFER, i2.multisample, n2.RGBA8, t4.width, t4.height), n2.framebufferRenderbuffer(n2.FRAMEBUFFER, n2.COLOR_ATTACHMENT0, n2.RENDERBUFFER, i2.msaaBuffer)) : i2.msaaBuffer && (n2.deleteRenderbuffer(i2.msaaBuffer), i2.msaaBuffer = null, i2.blitFramebuffer && (i2.blitFramebuffer.dispose(), i2.blitFramebuffer = null));
      for (var s3 = [], a2 = 0; a2 < o3; a2++) {
        var l2 = r3[a2], u2 = l2.parentTextureArray || l2;
        this.renderer.texture.bind(u2, 0), a2 === 0 && i2.msaaBuffer || (n2.framebufferTexture2D(n2.FRAMEBUFFER, n2.COLOR_ATTACHMENT0 + a2, l2.target, u2._glTextures[this.CONTEXT_UID].texture, e3), s3.push(n2.COLOR_ATTACHMENT0 + a2));
      }
      if ((s3.length > 1 && n2.drawBuffers(s3), t4.depthTexture) && this.writeDepthTexture) {
        var h2 = t4.depthTexture;
        this.renderer.texture.bind(h2, 0), n2.framebufferTexture2D(n2.FRAMEBUFFER, n2.DEPTH_ATTACHMENT, n2.TEXTURE_2D, h2._glTextures[this.CONTEXT_UID].texture, e3);
      }
      !t4.stencil && !t4.depth || t4.depthTexture && this.writeDepthTexture ? i2.stencil && (n2.deleteRenderbuffer(i2.stencil), i2.stencil = null) : (i2.stencil = i2.stencil || n2.createRenderbuffer(), n2.bindRenderbuffer(n2.RENDERBUFFER, i2.stencil), i2.msaaBuffer ? n2.renderbufferStorageMultisample(n2.RENDERBUFFER, i2.multisample, n2.DEPTH24_STENCIL8, t4.width, t4.height) : n2.renderbufferStorage(n2.RENDERBUFFER, n2.DEPTH_STENCIL, t4.width, t4.height), n2.framebufferRenderbuffer(n2.FRAMEBUFFER, n2.DEPTH_STENCIL_ATTACHMENT, n2.RENDERBUFFER, i2.stencil));
    }, t3.prototype.canMultisampleFramebuffer = function(t4) {
      return this.renderer.context.webGLVersion !== 1 && t4.colorTextures.length <= 1 && !t4.depthTexture;
    }, t3.prototype.detectSamples = function(t4) {
      var e3 = this.msaaSamples, n2 = pv.NONE;
      if (t4 <= 1 || e3 === null)
        return n2;
      for (var i2 = 0; i2 < e3.length; i2++)
        if (e3[i2] <= t4) {
          n2 = e3[i2];
          break;
        }
      return n2 === 1 && (n2 = pv.NONE), n2;
    }, t3.prototype.blit = function(t4, e3, n2) {
      var i2 = this.current, r3 = this.renderer, o3 = this.gl, s3 = this.CONTEXT_UID;
      if (r3.context.webGLVersion === 2 && i2) {
        var a2 = i2.glFramebuffers[s3];
        if (a2) {
          if (!t4) {
            if (!a2.msaaBuffer)
              return;
            var l2 = i2.colorTextures[0];
            if (!l2)
              return;
            a2.blitFramebuffer || (a2.blitFramebuffer = new Dy(i2.width, i2.height), a2.blitFramebuffer.addColorTexture(0, l2)), (t4 = a2.blitFramebuffer).colorTextures[0] !== l2 && (t4.colorTextures[0] = l2, t4.dirtyId++, t4.dirtyFormat++), t4.width === i2.width && t4.height === i2.height || (t4.width = i2.width, t4.height = i2.height, t4.dirtyId++, t4.dirtySize++);
          }
          e3 || ((e3 = hx).width = i2.width, e3.height = i2.height), n2 || (n2 = e3);
          var u2 = e3.width === n2.width && e3.height === n2.height;
          this.bind(t4), o3.bindFramebuffer(o3.READ_FRAMEBUFFER, a2.framebuffer), o3.blitFramebuffer(e3.x, e3.y, e3.width, e3.height, n2.x, n2.y, n2.width, n2.height, o3.COLOR_BUFFER_BIT, u2 ? o3.NEAREST : o3.LINEAR);
        }
      }
    }, t3.prototype.disposeFramebuffer = function(t4, e3) {
      var n2 = t4.glFramebuffers[this.CONTEXT_UID], i2 = this.gl;
      if (n2) {
        delete t4.glFramebuffers[this.CONTEXT_UID];
        var r3 = this.managedFramebuffers.indexOf(t4);
        r3 >= 0 && this.managedFramebuffers.splice(r3, 1), t4.disposeRunner.remove(this), e3 || (i2.deleteFramebuffer(n2.framebuffer), n2.msaaBuffer && i2.deleteRenderbuffer(n2.msaaBuffer), n2.stencil && i2.deleteRenderbuffer(n2.stencil)), n2.blitFramebuffer && n2.blitFramebuffer.dispose();
      }
    }, t3.prototype.disposeAll = function(t4) {
      var e3 = this.managedFramebuffers;
      this.managedFramebuffers = [];
      for (var n2 = 0; n2 < e3.length; n2++)
        this.disposeFramebuffer(e3[n2], t4);
    }, t3.prototype.forceStencil = function() {
      var t4 = this.current;
      if (t4) {
        var e3 = t4.glFramebuffers[this.CONTEXT_UID];
        if (e3 && !e3.stencil) {
          t4.stencil = true;
          var n2 = t4.width, i2 = t4.height, r3 = this.gl, o3 = r3.createRenderbuffer();
          r3.bindRenderbuffer(r3.RENDERBUFFER, o3), e3.msaaBuffer ? r3.renderbufferStorageMultisample(r3.RENDERBUFFER, e3.multisample, r3.DEPTH24_STENCIL8, n2, i2) : r3.renderbufferStorage(r3.RENDERBUFFER, r3.DEPTH_STENCIL, n2, i2), e3.stencil = o3, r3.framebufferRenderbuffer(r3.FRAMEBUFFER, r3.DEPTH_STENCIL_ATTACHMENT, r3.RENDERBUFFER, o3);
        }
      }
    }, t3.prototype.reset = function() {
      this.current = this.unknownFramebuffer, this.viewport = new d_();
    }, t3.prototype.destroy = function() {
      this.renderer = null;
    }, t3;
  }(), dx = { 5126: 4, 5123: 2, 5121: 1 }, px = function() {
    function t3(t4) {
      this.renderer = t4, this._activeGeometry = null, this._activeVao = null, this.hasVao = true, this.hasInstance = true, this.canUseUInt32ElementIndex = false, this.managedGeometries = {};
    }
    return t3.prototype.contextChange = function() {
      this.disposeAll(true);
      var t4 = this.gl = this.renderer.gl, e3 = this.renderer.context;
      if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, e3.webGLVersion !== 2) {
        var n2 = this.renderer.context.extensions.vertexArrayObject;
        mv.PREFER_ENV === Jg.WEBGL_LEGACY && (n2 = null), n2 ? (t4.createVertexArray = function() {
          return n2.createVertexArrayOES();
        }, t4.bindVertexArray = function(t5) {
          return n2.bindVertexArrayOES(t5);
        }, t4.deleteVertexArray = function(t5) {
          return n2.deleteVertexArrayOES(t5);
        }) : (this.hasVao = false, t4.createVertexArray = function() {
          return null;
        }, t4.bindVertexArray = function() {
          return null;
        }, t4.deleteVertexArray = function() {
          return null;
        });
      }
      if (e3.webGLVersion !== 2) {
        var i2 = t4.getExtension("ANGLE_instanced_arrays");
        i2 ? (t4.vertexAttribDivisor = function(t5, e4) {
          return i2.vertexAttribDivisorANGLE(t5, e4);
        }, t4.drawElementsInstanced = function(t5, e4, n3, r3, o3) {
          return i2.drawElementsInstancedANGLE(t5, e4, n3, r3, o3);
        }, t4.drawArraysInstanced = function(t5, e4, n3, r3) {
          return i2.drawArraysInstancedANGLE(t5, e4, n3, r3);
        }) : this.hasInstance = false;
      }
      this.canUseUInt32ElementIndex = e3.webGLVersion === 2 || !!e3.extensions.uint32ElementIndex;
    }, t3.prototype.bind = function(t4, e3) {
      e3 = e3 || this.renderer.shader.shader;
      var n2 = this.gl, i2 = t4.glVertexArrayObjects[this.CONTEXT_UID], r3 = false;
      i2 || (this.managedGeometries[t4.id] = t4, t4.disposeRunner.add(this), t4.glVertexArrayObjects[this.CONTEXT_UID] = i2 = {}, r3 = true);
      var o3 = i2[e3.program.id] || this.initGeometryVao(t4, e3, r3);
      this._activeGeometry = t4, this._activeVao !== o3 && (this._activeVao = o3, this.hasVao ? n2.bindVertexArray(o3) : this.activateVao(t4, e3.program)), this.updateBuffers();
    }, t3.prototype.reset = function() {
      this.unbind();
    }, t3.prototype.updateBuffers = function() {
      for (var t4 = this._activeGeometry, e3 = this.renderer.buffer, n2 = 0; n2 < t4.buffers.length; n2++) {
        var i2 = t4.buffers[n2];
        e3.update(i2);
      }
    }, t3.prototype.checkCompatibility = function(t4, e3) {
      var n2 = t4.attributes, i2 = e3.attributeData;
      for (var r3 in i2)
        if (!n2[r3])
          throw new Error('shader and geometry incompatible, geometry missing the "' + r3 + '" attribute');
    }, t3.prototype.getSignature = function(t4, e3) {
      var n2 = t4.attributes, i2 = e3.attributeData, r3 = ["g", t4.id];
      for (var o3 in n2)
        i2[o3] && r3.push(o3);
      return r3.join("-");
    }, t3.prototype.initGeometryVao = function(t4, e3, n2) {
      n2 === void 0 && (n2 = true);
      var i2 = this.gl, r3 = this.CONTEXT_UID, o3 = this.renderer.buffer, s3 = e3.program;
      s3.glPrograms[r3] || this.renderer.shader.generateProgram(e3), this.checkCompatibility(t4, s3);
      var a2 = this.getSignature(t4, s3), l2 = t4.glVertexArrayObjects[this.CONTEXT_UID], u2 = l2[a2];
      if (u2)
        return l2[s3.id] = u2, u2;
      var h2 = t4.buffers, c2 = t4.attributes, d2 = {}, p2 = {};
      for (var f2 in h2)
        d2[f2] = 0, p2[f2] = 0;
      for (var f2 in c2)
        !c2[f2].size && s3.attributeData[f2] ? c2[f2].size = s3.attributeData[f2].size : c2[f2].size || console.warn("PIXI Geometry attribute '" + f2 + "' size cannot be determined (likely the bound shader does not have the attribute)"), d2[c2[f2].buffer] += c2[f2].size * dx[c2[f2].type];
      for (var f2 in c2) {
        var m2 = c2[f2], g2 = m2.size;
        m2.stride === void 0 && (d2[m2.buffer] === g2 * dx[m2.type] ? m2.stride = 0 : m2.stride = d2[m2.buffer]), m2.start === void 0 && (m2.start = p2[m2.buffer], p2[m2.buffer] += g2 * dx[m2.type]);
      }
      u2 = i2.createVertexArray(), i2.bindVertexArray(u2);
      for (var v2 = 0; v2 < h2.length; v2++) {
        var _2 = h2[v2];
        o3.bind(_2), n2 && _2._glBuffers[r3].refCount++;
      }
      return this.activateVao(t4, s3), this._activeVao = u2, l2[s3.id] = u2, l2[a2] = u2, u2;
    }, t3.prototype.disposeGeometry = function(t4, e3) {
      var n2;
      if (this.managedGeometries[t4.id]) {
        delete this.managedGeometries[t4.id];
        var i2 = t4.glVertexArrayObjects[this.CONTEXT_UID], r3 = this.gl, o3 = t4.buffers, s3 = (n2 = this.renderer) === null || n2 === void 0 ? void 0 : n2.buffer;
        if (t4.disposeRunner.remove(this), i2) {
          if (s3)
            for (var a2 = 0; a2 < o3.length; a2++) {
              var l2 = o3[a2]._glBuffers[this.CONTEXT_UID];
              l2 && (l2.refCount--, l2.refCount !== 0 || e3 || s3.dispose(o3[a2], e3));
            }
          if (!e3) {
            for (var u2 in i2)
              if (u2[0] === "g") {
                var h2 = i2[u2];
                this._activeVao === h2 && this.unbind(), r3.deleteVertexArray(h2);
              }
          }
          delete t4.glVertexArrayObjects[this.CONTEXT_UID];
        }
      }
    }, t3.prototype.disposeAll = function(t4) {
      for (var e3 = Object.keys(this.managedGeometries), n2 = 0; n2 < e3.length; n2++)
        this.disposeGeometry(this.managedGeometries[e3[n2]], t4);
    }, t3.prototype.activateVao = function(t4, e3) {
      var n2 = this.gl, i2 = this.CONTEXT_UID, r3 = this.renderer.buffer, o3 = t4.buffers, s3 = t4.attributes;
      t4.indexBuffer && r3.bind(t4.indexBuffer);
      var a2 = null;
      for (var l2 in s3) {
        var u2 = s3[l2], h2 = o3[u2.buffer], c2 = h2._glBuffers[i2];
        if (e3.attributeData[l2]) {
          a2 !== c2 && (r3.bind(h2), a2 = c2);
          var d2 = e3.attributeData[l2].location;
          if (n2.enableVertexAttribArray(d2), n2.vertexAttribPointer(d2, u2.size, u2.type || n2.FLOAT, u2.normalized, u2.stride, u2.start), u2.instance) {
            if (!this.hasInstance)
              throw new Error("geometry error, GPU Instancing is not supported on this device");
            n2.vertexAttribDivisor(d2, 1);
          }
        }
      }
    }, t3.prototype.draw = function(t4, e3, n2, i2) {
      var r3 = this.gl, o3 = this._activeGeometry;
      if (o3.indexBuffer) {
        var s3 = o3.indexBuffer.data.BYTES_PER_ELEMENT, a2 = s3 === 2 ? r3.UNSIGNED_SHORT : r3.UNSIGNED_INT;
        s3 === 2 || s3 === 4 && this.canUseUInt32ElementIndex ? o3.instanced ? r3.drawElementsInstanced(t4, e3 || o3.indexBuffer.data.length, a2, (n2 || 0) * s3, i2 || 1) : r3.drawElements(t4, e3 || o3.indexBuffer.data.length, a2, (n2 || 0) * s3) : console.warn("unsupported index buffer type: uint32");
      } else
        o3.instanced ? r3.drawArraysInstanced(t4, n2, e3 || o3.getSize(), i2 || 1) : r3.drawArrays(t4, n2, e3 || o3.getSize());
      return this;
    }, t3.prototype.unbind = function() {
      this.gl.bindVertexArray(null), this._activeVao = null, this._activeGeometry = null;
    }, t3.prototype.destroy = function() {
      this.renderer = null;
    }, t3;
  }(), fx = function() {
    function t3(t4) {
      t4 === void 0 && (t4 = null), this.type = dv.NONE, this.autoDetect = true, this.maskObject = t4 || null, this.pooled = false, this.isMaskData = true, this.resolution = null, this.multisample = mv.FILTER_MULTISAMPLE, this.enabled = true, this._filters = null, this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null, this._scissorRectLocal = null, this._target = null;
    }
    return Object.defineProperty(t3.prototype, "filter", { get: function() {
      return this._filters ? this._filters[0] : null;
    }, set: function(t4) {
      t4 ? this._filters ? this._filters[0] = t4 : this._filters = [t4] : this._filters = null;
    }, enumerable: false, configurable: true }), t3.prototype.reset = function() {
      this.pooled && (this.maskObject = null, this.type = dv.NONE, this.autoDetect = true), this._target = null, this._scissorRectLocal = null;
    }, t3.prototype.copyCountersOrReset = function(t4) {
      t4 ? (this._stencilCounter = t4._stencilCounter, this._scissorCounter = t4._scissorCounter, this._scissorRect = t4._scissorRect) : (this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null);
    }, t3;
  }();
  function mx(t3, e3, n2) {
    var i2 = t3.createShader(e3);
    return t3.shaderSource(i2, n2), t3.compileShader(i2), i2;
  }
  function gx(t3, e3) {
    var n2 = t3.getShaderSource(e3).split("\n").map(function(t4, e4) {
      return e4 + ": " + t4;
    }), i2 = t3.getShaderInfoLog(e3), r3 = i2.split("\n"), o3 = {}, s3 = r3.map(function(t4) {
      return parseFloat(t4.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"));
    }).filter(function(t4) {
      return !(!t4 || o3[t4]) && (o3[t4] = true, true);
    }), a2 = [""];
    s3.forEach(function(t4) {
      n2[t4 - 1] = "%c" + n2[t4 - 1] + "%c", a2.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
    });
    var l2 = n2.join("\n");
    a2[0] = l2, console.error(i2), console.groupCollapsed("click to view full shader code"), console.warn.apply(console, a2), console.groupEnd();
  }
  function vx(t3) {
    for (var e3 = new Array(t3), n2 = 0; n2 < e3.length; n2++)
      e3[n2] = false;
    return e3;
  }
  function _x(t3, e3) {
    switch (t3) {
      case "float":
        return 0;
      case "vec2":
        return new Float32Array(2 * e3);
      case "vec3":
        return new Float32Array(3 * e3);
      case "vec4":
        return new Float32Array(4 * e3);
      case "int":
      case "uint":
      case "sampler2D":
      case "sampler2DArray":
        return 0;
      case "ivec2":
        return new Int32Array(2 * e3);
      case "ivec3":
        return new Int32Array(3 * e3);
      case "ivec4":
        return new Int32Array(4 * e3);
      case "uvec2":
        return new Uint32Array(2 * e3);
      case "uvec3":
        return new Uint32Array(3 * e3);
      case "uvec4":
        return new Uint32Array(4 * e3);
      case "bool":
        return false;
      case "bvec2":
        return vx(2 * e3);
      case "bvec3":
        return vx(3 * e3);
      case "bvec4":
        return vx(4 * e3);
      case "mat2":
        return new Float32Array([1, 0, 0, 1]);
      case "mat3":
        return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
      case "mat4":
        return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
    }
    return null;
  }
  var yx, xx = {}, bx = xx;
  function Tx() {
    if (!yx) {
      yx = cv.MEDIUM;
      var t3 = function() {
        if (bx === xx || bx && bx.isContextLost()) {
          var t4 = document.createElement("canvas"), e4 = void 0;
          mv.PREFER_ENV >= Jg.WEBGL2 && (e4 = t4.getContext("webgl2", {})), e4 || ((e4 = t4.getContext("webgl", {}) || t4.getContext("experimental-webgl", {})) ? e4.getExtension("WEBGL_draw_buffers") : e4 = null), bx = e4;
        }
        return bx;
      }();
      if (t3 && t3.getShaderPrecisionFormat) {
        var e3 = t3.getShaderPrecisionFormat(t3.FRAGMENT_SHADER, t3.HIGH_FLOAT);
        yx = e3.precision ? cv.HIGH : cv.MEDIUM;
      }
    }
    return yx;
  }
  function wx(t3, e3, n2) {
    if (t3.substring(0, 9) !== "precision") {
      var i2 = e3;
      return e3 === cv.HIGH && n2 !== cv.HIGH && (i2 = cv.MEDIUM), "precision " + i2 + " float;\n" + t3;
    }
    return n2 !== cv.HIGH && t3.substring(0, 15) === "precision highp" ? t3.replace("precision highp", "precision mediump") : t3;
  }
  var Sx = { float: 1, vec2: 2, vec3: 3, vec4: 4, int: 1, ivec2: 2, ivec3: 3, ivec4: 4, uint: 1, uvec2: 2, uvec3: 3, uvec4: 4, bool: 1, bvec2: 2, bvec3: 3, bvec4: 4, mat2: 4, mat3: 9, mat4: 16, sampler2D: 1 };
  function Ex(t3) {
    return Sx[t3];
  }
  var Mx = null, Ax = { FLOAT: "float", FLOAT_VEC2: "vec2", FLOAT_VEC3: "vec3", FLOAT_VEC4: "vec4", INT: "int", INT_VEC2: "ivec2", INT_VEC3: "ivec3", INT_VEC4: "ivec4", UNSIGNED_INT: "uint", UNSIGNED_INT_VEC2: "uvec2", UNSIGNED_INT_VEC3: "uvec3", UNSIGNED_INT_VEC4: "uvec4", BOOL: "bool", BOOL_VEC2: "bvec2", BOOL_VEC3: "bvec3", BOOL_VEC4: "bvec4", FLOAT_MAT2: "mat2", FLOAT_MAT3: "mat3", FLOAT_MAT4: "mat4", SAMPLER_2D: "sampler2D", INT_SAMPLER_2D: "sampler2D", UNSIGNED_INT_SAMPLER_2D: "sampler2D", SAMPLER_CUBE: "samplerCube", INT_SAMPLER_CUBE: "samplerCube", UNSIGNED_INT_SAMPLER_CUBE: "samplerCube", SAMPLER_2D_ARRAY: "sampler2DArray", INT_SAMPLER_2D_ARRAY: "sampler2DArray", UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray" };
  function Rx(t3, e3) {
    if (!Mx) {
      var n2 = Object.keys(Ax);
      Mx = {};
      for (var i2 = 0; i2 < n2.length; ++i2) {
        var r3 = n2[i2];
        Mx[t3[r3]] = Ax[r3];
      }
    }
    return Mx[e3];
  }
  var Px = [{ test: function(t3) {
    return t3.type === "float" && t3.size === 1;
  }, code: function(t3) {
    return '\n            if(uv["' + t3 + '"] !== ud["' + t3 + '"].value)\n            {\n                ud["' + t3 + '"].value = uv["' + t3 + '"]\n                gl.uniform1f(ud["' + t3 + '"].location, uv["' + t3 + '"])\n            }\n            ';
  } }, { test: function(t3) {
    return (t3.type === "sampler2D" || t3.type === "samplerCube" || t3.type === "sampler2DArray") && t3.size === 1 && !t3.isArray;
  }, code: function(t3) {
    return 't = syncData.textureCount++;\n\n            renderer.texture.bind(uv["' + t3 + '"], t);\n\n            if(ud["' + t3 + '"].value !== t)\n            {\n                ud["' + t3 + '"].value = t;\n                gl.uniform1i(ud["' + t3 + '"].location, t);\n; // eslint-disable-line max-len\n            }';
  } }, { test: function(t3, e3) {
    return t3.type === "mat3" && t3.size === 1 && e3.a !== void 0;
  }, code: function(t3) {
    return '\n            gl.uniformMatrix3fv(ud["' + t3 + '"].location, false, uv["' + t3 + '"].toArray(true));\n            ';
  }, codeUbo: function(t3) {
    return "\n                var " + t3 + "_matrix = uv." + t3 + ".toArray(true);\n\n                data[offset] = " + t3 + "_matrix[0];\n                data[offset+1] = " + t3 + "_matrix[1];\n                data[offset+2] = " + t3 + "_matrix[2];\n        \n                data[offset + 4] = " + t3 + "_matrix[3];\n                data[offset + 5] = " + t3 + "_matrix[4];\n                data[offset + 6] = " + t3 + "_matrix[5];\n        \n                data[offset + 8] = " + t3 + "_matrix[6];\n                data[offset + 9] = " + t3 + "_matrix[7];\n                data[offset + 10] = " + t3 + "_matrix[8];\n            ";
  } }, { test: function(t3, e3) {
    return t3.type === "vec2" && t3.size === 1 && e3.x !== void 0;
  }, code: function(t3) {
    return '\n                cv = ud["' + t3 + '"].value;\n                v = uv["' + t3 + '"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    gl.uniform2f(ud["' + t3 + '"].location, v.x, v.y);\n                }';
  }, codeUbo: function(t3) {
    return "\n                v = uv." + t3 + ";\n\n                data[offset] = v.x;\n                data[offset+1] = v.y;\n            ";
  } }, { test: function(t3) {
    return t3.type === "vec2" && t3.size === 1;
  }, code: function(t3) {
    return '\n                cv = ud["' + t3 + '"].value;\n                v = uv["' + t3 + '"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    gl.uniform2f(ud["' + t3 + '"].location, v[0], v[1]);\n                }\n            ';
  } }, { test: function(t3, e3) {
    return t3.type === "vec4" && t3.size === 1 && e3.width !== void 0;
  }, code: function(t3) {
    return '\n                cv = ud["' + t3 + '"].value;\n                v = uv["' + t3 + '"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    cv[2] = v.width;\n                    cv[3] = v.height;\n                    gl.uniform4f(ud["' + t3 + '"].location, v.x, v.y, v.width, v.height)\n                }';
  }, codeUbo: function(t3) {
    return "\n                    v = uv." + t3 + ";\n\n                    data[offset] = v.x;\n                    data[offset+1] = v.y;\n                    data[offset+2] = v.width;\n                    data[offset+3] = v.height;\n                ";
  } }, { test: function(t3) {
    return t3.type === "vec4" && t3.size === 1;
  }, code: function(t3) {
    return '\n                cv = ud["' + t3 + '"].value;\n                v = uv["' + t3 + '"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    cv[2] = v[2];\n                    cv[3] = v[3];\n\n                    gl.uniform4f(ud["' + t3 + '"].location, v[0], v[1], v[2], v[3])\n                }';
  } }], Cx = { float: "\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1f(location, v);\n    }", vec2: "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2f(location, v[0], v[1])\n    }", vec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }", vec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4f(location, v[0], v[1], v[2], v[3]);\n    }", int: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }", ivec2: "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }", ivec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }", ivec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }", uint: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1ui(location, v);\n    }", uvec2: "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2ui(location, v[0], v[1]);\n    }", uvec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3ui(location, v[0], v[1], v[2]);\n    }", uvec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);\n    }", bool: "\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1i(location, v);\n    }", bvec2: "\n    if (cv[0] != v[0] || cv[1] != v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }", bvec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }", bvec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }", mat2: "gl.uniformMatrix2fv(location, false, v)", mat3: "gl.uniformMatrix3fv(location, false, v)", mat4: "gl.uniformMatrix4fv(location, false, v)", sampler2D: "gl.uniform1i(location, v)", samplerCube: "gl.uniform1i(location, v)", sampler2DArray: "gl.uniform1i(location, v)" }, Ix = { float: "gl.uniform1fv(location, v)", vec2: "gl.uniform2fv(location, v)", vec3: "gl.uniform3fv(location, v)", vec4: "gl.uniform4fv(location, v)", mat4: "gl.uniformMatrix4fv(location, false, v)", mat3: "gl.uniformMatrix3fv(location, false, v)", mat2: "gl.uniformMatrix2fv(location, false, v)", int: "gl.uniform1iv(location, v)", ivec2: "gl.uniform2iv(location, v)", ivec3: "gl.uniform3iv(location, v)", ivec4: "gl.uniform4iv(location, v)", uint: "gl.uniform1uiv(location, v)", uvec2: "gl.uniform2uiv(location, v)", uvec3: "gl.uniform3uiv(location, v)", uvec4: "gl.uniform4uiv(location, v)", bool: "gl.uniform1iv(location, v)", bvec2: "gl.uniform2iv(location, v)", bvec3: "gl.uniform3iv(location, v)", bvec4: "gl.uniform4iv(location, v)", sampler2D: "gl.uniform1iv(location, v)", samplerCube: "gl.uniform1iv(location, v)", sampler2DArray: "gl.uniform1iv(location, v)" };
  var Ox, Lx = ["precision mediump float;", "void main(void){", "float test = 0.1;", "%forloop%", "gl_FragColor = vec4(0.0);", "}"].join("\n");
  function Nx(t3) {
    for (var e3 = "", n2 = 0; n2 < t3; ++n2)
      n2 > 0 && (e3 += "\nelse "), n2 < t3 - 1 && (e3 += "if(test == " + n2 + ".0){}");
    return e3;
  }
  var Dx = 0, Fx = {}, Bx = function() {
    function t3(e3, n2, i2) {
      i2 === void 0 && (i2 = "pixi-shader"), this.id = Dx++, this.vertexSrc = e3 || t3.defaultVertexSrc, this.fragmentSrc = n2 || t3.defaultFragmentSrc, this.vertexSrc = this.vertexSrc.trim(), this.fragmentSrc = this.fragmentSrc.trim(), this.vertexSrc.substring(0, 8) !== "#version" && (i2 = i2.replace(/\s+/g, "-"), Fx[i2] ? (Fx[i2]++, i2 += "-" + Fx[i2]) : Fx[i2] = 1, this.vertexSrc = "#define SHADER_NAME " + i2 + "\n" + this.vertexSrc, this.fragmentSrc = "#define SHADER_NAME " + i2 + "\n" + this.fragmentSrc, this.vertexSrc = wx(this.vertexSrc, mv.PRECISION_VERTEX, cv.HIGH), this.fragmentSrc = wx(this.fragmentSrc, mv.PRECISION_FRAGMENT, Tx())), this.glPrograms = {}, this.syncUniforms = null;
    }
    return Object.defineProperty(t3, "defaultVertexSrc", { get: function() {
      return "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n";
    }, enumerable: false, configurable: true }), Object.defineProperty(t3, "defaultFragmentSrc", { get: function() {
      return "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}";
    }, enumerable: false, configurable: true }), t3.from = function(e3, n2, i2) {
      var r3 = e3 + n2, o3 = Jv[r3];
      return o3 || (Jv[r3] = o3 = new t3(e3, n2, i2)), o3;
    }, t3;
  }(), Ux = function() {
    function t3(t4, e3) {
      this.uniformBindCount = 0, this.program = t4, this.uniformGroup = e3 ? e3 instanceof tx ? e3 : new tx(e3) : new tx({});
    }
    return t3.prototype.checkUniformExists = function(t4, e3) {
      if (e3.uniforms[t4])
        return true;
      for (var n2 in e3.uniforms) {
        var i2 = e3.uniforms[n2];
        if (i2.group && this.checkUniformExists(t4, i2))
          return true;
      }
      return false;
    }, t3.prototype.destroy = function() {
      this.uniformGroup = null;
    }, Object.defineProperty(t3.prototype, "uniforms", { get: function() {
      return this.uniformGroup.uniforms;
    }, enumerable: false, configurable: true }), t3.from = function(e3, n2, i2) {
      return new t3(Bx.from(e3, n2), i2);
    }, t3;
  }(), kx = function() {
    function t3() {
      this.data = 0, this.blendMode = Qg.NORMAL, this.polygonOffset = 0, this.blend = true, this.depthMask = true;
    }
    return Object.defineProperty(t3.prototype, "blend", { get: function() {
      return !!(1 & this.data);
    }, set: function(t4) {
      !!(1 & this.data) !== t4 && (this.data ^= 1);
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "offsets", { get: function() {
      return !!(2 & this.data);
    }, set: function(t4) {
      !!(2 & this.data) !== t4 && (this.data ^= 2);
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "culling", { get: function() {
      return !!(4 & this.data);
    }, set: function(t4) {
      !!(4 & this.data) !== t4 && (this.data ^= 4);
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "depthTest", { get: function() {
      return !!(8 & this.data);
    }, set: function(t4) {
      !!(8 & this.data) !== t4 && (this.data ^= 8);
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "depthMask", { get: function() {
      return !!(32 & this.data);
    }, set: function(t4) {
      !!(32 & this.data) !== t4 && (this.data ^= 32);
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "clockwiseFrontFace", { get: function() {
      return !!(16 & this.data);
    }, set: function(t4) {
      !!(16 & this.data) !== t4 && (this.data ^= 16);
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "blendMode", { get: function() {
      return this._blendMode;
    }, set: function(t4) {
      this.blend = t4 !== Qg.NONE, this._blendMode = t4;
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "polygonOffset", { get: function() {
      return this._polygonOffset;
    }, set: function(t4) {
      this.offsets = !!t4, this._polygonOffset = t4;
    }, enumerable: false, configurable: true }), t3.prototype.toString = function() {
      return "[@pixi/core:State blendMode=" + this.blendMode + " clockwiseFrontFace=" + this.clockwiseFrontFace + " culling=" + this.culling + " depthMask=" + this.depthMask + " polygonOffset=" + this.polygonOffset + "]";
    }, t3.for2d = function() {
      var e3 = new t3();
      return e3.depthTest = false, e3.blend = true, e3;
    }, t3;
  }(), Gx = function(t3) {
    function e3(n2, i2, r3) {
      var o3 = this, s3 = Bx.from(n2 || e3.defaultVertexSrc, i2 || e3.defaultFragmentSrc);
      return (o3 = t3.call(this, s3, r3) || this).padding = 0, o3.resolution = mv.FILTER_RESOLUTION, o3.multisample = mv.FILTER_MULTISAMPLE, o3.enabled = true, o3.autoFit = true, o3.state = new kx(), o3;
    }
    return _y(e3, t3), e3.prototype.apply = function(t4, e4, n2, i2, r3) {
      t4.applyFilter(this, e4, n2, i2);
    }, Object.defineProperty(e3.prototype, "blendMode", { get: function() {
      return this.state.blendMode;
    }, set: function(t4) {
      this.state.blendMode = t4;
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "resolution", { get: function() {
      return this._resolution;
    }, set: function(t4) {
      this._resolution = t4;
    }, enumerable: false, configurable: true }), Object.defineProperty(e3, "defaultVertexSrc", { get: function() {
      return "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";
    }, enumerable: false, configurable: true }), Object.defineProperty(e3, "defaultFragmentSrc", { get: function() {
      return "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n";
    }, enumerable: false, configurable: true }), e3;
  }(Ux), Hx = new y_(), zx = function() {
    function t3(t4, e3) {
      this._texture = t4, this.mapCoord = new y_(), this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, this.clampMargin = e3 === void 0 ? 0.5 : e3, this.isSimple = false;
    }
    return Object.defineProperty(t3.prototype, "texture", { get: function() {
      return this._texture;
    }, set: function(t4) {
      this._texture = t4, this._textureID = -1;
    }, enumerable: false, configurable: true }), t3.prototype.multiplyUvs = function(t4, e3) {
      e3 === void 0 && (e3 = t4);
      for (var n2 = this.mapCoord, i2 = 0; i2 < t4.length; i2 += 2) {
        var r3 = t4[i2], o3 = t4[i2 + 1];
        e3[i2] = r3 * n2.a + o3 * n2.c + n2.tx, e3[i2 + 1] = r3 * n2.b + o3 * n2.d + n2.ty;
      }
      return e3;
    }, t3.prototype.update = function(t4) {
      var e3 = this._texture;
      if (!e3 || !e3.valid)
        return false;
      if (!t4 && this._textureID === e3._updateID)
        return false;
      this._textureID = e3._updateID, this._updateID++;
      var n2 = e3._uvs;
      this.mapCoord.set(n2.x1 - n2.x0, n2.y1 - n2.y0, n2.x3 - n2.x0, n2.y3 - n2.y0, n2.x0, n2.y0);
      var i2 = e3.orig, r3 = e3.trim;
      r3 && (Hx.set(i2.width / r3.width, 0, 0, i2.height / r3.height, -r3.x / r3.width, -r3.y / r3.height), this.mapCoord.append(Hx));
      var o3 = e3.baseTexture, s3 = this.uClampFrame, a2 = this.clampMargin / o3.resolution, l2 = this.clampOffset;
      return s3[0] = (e3._frame.x + a2 + l2) / o3.width, s3[1] = (e3._frame.y + a2 + l2) / o3.height, s3[2] = (e3._frame.x + e3._frame.width - a2 + l2) / o3.width, s3[3] = (e3._frame.y + e3._frame.height - a2 + l2) / o3.height, this.uClampOffset[0] = l2 / o3.realWidth, this.uClampOffset[1] = l2 / o3.realHeight, this.isSimple = e3._frame.width === o3.width && e3._frame.height === o3.height && e3.rotate === 0, true;
    }, t3;
  }(), jx = function(t3) {
    function e3(e4, n2, i2) {
      var r3 = this, o3 = null;
      return typeof e4 != "string" && n2 === void 0 && i2 === void 0 && (o3 = e4, e4 = void 0, n2 = void 0, i2 = void 0), (r3 = t3.call(this, e4 || "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n", n2 || "varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    gl_FragColor = original;\n}\n", i2) || this).maskSprite = o3, r3.maskMatrix = new y_(), r3;
    }
    return _y(e3, t3), Object.defineProperty(e3.prototype, "maskSprite", { get: function() {
      return this._maskSprite;
    }, set: function(t4) {
      this._maskSprite = t4, this._maskSprite && (this._maskSprite.renderable = false);
    }, enumerable: false, configurable: true }), e3.prototype.apply = function(t4, e4, n2, i2) {
      var r3 = this._maskSprite, o3 = r3._texture;
      o3.valid && (o3.uvMatrix || (o3.uvMatrix = new zx(o3, 0)), o3.uvMatrix.update(), this.uniforms.npmAlpha = o3.baseTexture.alphaMode ? 0 : 1, this.uniforms.mask = o3, this.uniforms.otherMatrix = t4.calculateSpriteMatrix(this.maskMatrix, r3).prepend(o3.uvMatrix.mapCoord), this.uniforms.alpha = r3.worldAlpha, this.uniforms.maskClamp = o3.uvMatrix.uClampFrame, t4.applyFilter(this, e4, n2, i2));
    }, e3;
  }(Gx), Vx = function() {
    function t3(t4) {
      this.renderer = t4, this.enableScissor = true, this.alphaMaskPool = [], this.maskDataPool = [], this.maskStack = [], this.alphaMaskIndex = 0;
    }
    return t3.prototype.setMaskStack = function(t4) {
      this.maskStack = t4, this.renderer.scissor.setMaskStack(t4), this.renderer.stencil.setMaskStack(t4);
    }, t3.prototype.push = function(t4, e3) {
      var n2 = e3;
      if (!n2.isMaskData) {
        var i2 = this.maskDataPool.pop() || new fx();
        i2.pooled = true, i2.maskObject = e3, n2 = i2;
      }
      var r3 = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;
      if (n2.copyCountersOrReset(r3), n2.autoDetect && this.detect(n2), n2._target = t4, n2.type !== dv.SPRITE && this.maskStack.push(n2), n2.enabled)
        switch (n2.type) {
          case dv.SCISSOR:
            this.renderer.scissor.push(n2);
            break;
          case dv.STENCIL:
            this.renderer.stencil.push(n2);
            break;
          case dv.SPRITE:
            n2.copyCountersOrReset(null), this.pushSpriteMask(n2);
        }
      n2.type === dv.SPRITE && this.maskStack.push(n2);
    }, t3.prototype.pop = function(t4) {
      var e3 = this.maskStack.pop();
      if (e3 && e3._target === t4) {
        if (e3.enabled)
          switch (e3.type) {
            case dv.SCISSOR:
              this.renderer.scissor.pop();
              break;
            case dv.STENCIL:
              this.renderer.stencil.pop(e3.maskObject);
              break;
            case dv.SPRITE:
              this.popSpriteMask(e3);
          }
        if (e3.reset(), e3.pooled && this.maskDataPool.push(e3), this.maskStack.length !== 0) {
          var n2 = this.maskStack[this.maskStack.length - 1];
          n2.type === dv.SPRITE && n2._filters && (n2._filters[0].maskSprite = n2.maskObject);
        }
      }
    }, t3.prototype.detect = function(t4) {
      t4.maskObject.isSprite ? t4.type = dv.SPRITE : this.enableScissor && this.renderer.scissor.testScissor(t4) ? t4.type = dv.SCISSOR : t4.type = dv.STENCIL;
    }, t3.prototype.pushSpriteMask = function(t4) {
      var e3, n2, i2 = t4.maskObject, r3 = t4._target, o3 = t4._filters;
      o3 || (o3 = this.alphaMaskPool[this.alphaMaskIndex]) || (o3 = this.alphaMaskPool[this.alphaMaskIndex] = [new jx()]);
      var s3, a2, l2 = this.renderer, u2 = l2.renderTexture;
      if (u2.current) {
        var h2 = u2.current;
        s3 = t4.resolution || h2.resolution, a2 = (e3 = t4.multisample) !== null && e3 !== void 0 ? e3 : h2.multisample;
      } else
        s3 = t4.resolution || l2.resolution, a2 = (n2 = t4.multisample) !== null && n2 !== void 0 ? n2 : l2.multisample;
      o3[0].resolution = s3, o3[0].multisample = a2, o3[0].maskSprite = i2;
      var c2 = r3.filterArea;
      r3.filterArea = i2.getBounds(true), l2.filter.push(r3, o3), r3.filterArea = c2, t4._filters || this.alphaMaskIndex++;
    }, t3.prototype.popSpriteMask = function(t4) {
      this.renderer.filter.pop(), t4._filters ? t4._filters[0].maskSprite = null : (this.alphaMaskIndex--, this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null);
    }, t3.prototype.destroy = function() {
      this.renderer = null;
    }, t3;
  }(), Wx = function() {
    function t3(t4) {
      this.renderer = t4, this.maskStack = [], this.glConst = 0;
    }
    return t3.prototype.getStackLength = function() {
      return this.maskStack.length;
    }, t3.prototype.setMaskStack = function(t4) {
      var e3 = this.renderer.gl, n2 = this.getStackLength();
      this.maskStack = t4;
      var i2 = this.getStackLength();
      i2 !== n2 && (i2 === 0 ? e3.disable(this.glConst) : (e3.enable(this.glConst), this._useCurrent()));
    }, t3.prototype._useCurrent = function() {
    }, t3.prototype.destroy = function() {
      this.renderer = null, this.maskStack = null;
    }, t3;
  }(), Xx = new y_(), qx = function(t3) {
    function e3(e4) {
      var n2 = t3.call(this, e4) || this;
      return n2.glConst = WebGLRenderingContext.SCISSOR_TEST, n2;
    }
    return _y(e3, t3), e3.prototype.getStackLength = function() {
      var t4 = this.maskStack[this.maskStack.length - 1];
      return t4 ? t4._scissorCounter : 0;
    }, e3.prototype.calcScissorRect = function(t4) {
      if (!t4._scissorRectLocal) {
        var e4 = t4._scissorRect, n2 = t4.maskObject, i2 = this.renderer, r3 = i2.renderTexture;
        n2.renderable = true;
        var o3 = n2.getBounds();
        this.roundFrameToPixels(o3, r3.current ? r3.current.resolution : i2.resolution, r3.sourceFrame, r3.destinationFrame, i2.projection.transform), n2.renderable = false, e4 && o3.fit(e4), t4._scissorRectLocal = o3;
      }
    }, e3.isMatrixRotated = function(t4) {
      if (!t4)
        return false;
      var e4 = t4.a, n2 = t4.b, i2 = t4.c, r3 = t4.d;
      return (Math.abs(n2) > 1e-4 || Math.abs(i2) > 1e-4) && (Math.abs(e4) > 1e-4 || Math.abs(r3) > 1e-4);
    }, e3.prototype.testScissor = function(t4) {
      var n2 = t4.maskObject;
      if (!n2.isFastRect || !n2.isFastRect())
        return false;
      if (e3.isMatrixRotated(n2.worldTransform))
        return false;
      if (e3.isMatrixRotated(this.renderer.projection.transform))
        return false;
      this.calcScissorRect(t4);
      var i2 = t4._scissorRectLocal;
      return i2.width > 0 && i2.height > 0;
    }, e3.prototype.roundFrameToPixels = function(t4, n2, i2, r3, o3) {
      e3.isMatrixRotated(o3) || ((o3 = o3 ? Xx.copyFrom(o3) : Xx.identity()).translate(-i2.x, -i2.y).scale(r3.width / i2.width, r3.height / i2.height).translate(r3.x, r3.y), this.renderer.filter.transformAABB(o3, t4), t4.fit(r3), t4.x = Math.round(t4.x * n2), t4.y = Math.round(t4.y * n2), t4.width = Math.round(t4.width * n2), t4.height = Math.round(t4.height * n2));
    }, e3.prototype.push = function(t4) {
      t4._scissorRectLocal || this.calcScissorRect(t4);
      var e4 = this.renderer.gl;
      t4._scissorRect || e4.enable(e4.SCISSOR_TEST), t4._scissorCounter++, t4._scissorRect = t4._scissorRectLocal, this._useCurrent();
    }, e3.prototype.pop = function() {
      var t4 = this.renderer.gl;
      this.getStackLength() > 0 ? this._useCurrent() : t4.disable(t4.SCISSOR_TEST);
    }, e3.prototype._useCurrent = function() {
      var t4, e4 = this.maskStack[this.maskStack.length - 1]._scissorRect;
      t4 = this.renderer.renderTexture.current ? e4.y : this.renderer.height - e4.height - e4.y, this.renderer.gl.scissor(e4.x, t4, e4.width, e4.height);
    }, e3;
  }(Wx), Yx = function(t3) {
    function e3(e4) {
      var n2 = t3.call(this, e4) || this;
      return n2.glConst = WebGLRenderingContext.STENCIL_TEST, n2;
    }
    return _y(e3, t3), e3.prototype.getStackLength = function() {
      var t4 = this.maskStack[this.maskStack.length - 1];
      return t4 ? t4._stencilCounter : 0;
    }, e3.prototype.push = function(t4) {
      var e4 = t4.maskObject, n2 = this.renderer.gl, i2 = t4._stencilCounter;
      i2 === 0 && (this.renderer.framebuffer.forceStencil(), n2.enable(n2.STENCIL_TEST)), t4._stencilCounter++, n2.colorMask(false, false, false, false), n2.stencilFunc(n2.EQUAL, i2, 4294967295), n2.stencilOp(n2.KEEP, n2.KEEP, n2.INCR), e4.renderable = true, e4.render(this.renderer), this.renderer.batch.flush(), e4.renderable = false, this._useCurrent();
    }, e3.prototype.pop = function(t4) {
      var e4 = this.renderer.gl;
      this.getStackLength() === 0 ? (e4.disable(e4.STENCIL_TEST), e4.clearStencil(0), e4.clear(e4.STENCIL_BUFFER_BIT)) : (e4.colorMask(false, false, false, false), e4.stencilOp(e4.KEEP, e4.KEEP, e4.DECR), t4.renderable = true, t4.render(this.renderer), this.renderer.batch.flush(), t4.renderable = false, this._useCurrent());
    }, e3.prototype._useCurrent = function() {
      var t4 = this.renderer.gl;
      t4.colorMask(true, true, true, true), t4.stencilFunc(t4.EQUAL, this.getStackLength(), 4294967295), t4.stencilOp(t4.KEEP, t4.KEEP, t4.KEEP);
    }, e3;
  }(Wx), Zx = function() {
    function t3(t4) {
      this.renderer = t4, this.destinationFrame = null, this.sourceFrame = null, this.defaultFrame = null, this.projectionMatrix = new y_(), this.transform = null;
    }
    return t3.prototype.update = function(t4, e3, n2, i2) {
      this.destinationFrame = t4 || this.destinationFrame || this.defaultFrame, this.sourceFrame = e3 || this.sourceFrame || t4, this.calculateProjection(this.destinationFrame, this.sourceFrame, n2, i2), this.transform && this.projectionMatrix.append(this.transform);
      var r3 = this.renderer;
      r3.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix, r3.globalUniforms.update(), r3.shader.shader && r3.shader.syncUniformGroup(r3.shader.shader.uniforms.globals);
    }, t3.prototype.calculateProjection = function(t4, e3, n2, i2) {
      var r3 = this.projectionMatrix, o3 = i2 ? -1 : 1;
      r3.identity(), r3.a = 1 / e3.width * 2, r3.d = o3 * (1 / e3.height * 2), r3.tx = -1 - e3.x * r3.a, r3.ty = -o3 - e3.y * r3.d;
    }, t3.prototype.setTransform = function(t4) {
    }, t3.prototype.destroy = function() {
      this.renderer = null;
    }, t3;
  }(), Jx = new d_(), $x = new d_(), Kx = function() {
    function t3(t4) {
      this.renderer = t4, this.clearColor = t4._backgroundColorRgba, this.defaultMaskStack = [], this.current = null, this.sourceFrame = new d_(), this.destinationFrame = new d_(), this.viewportFrame = new d_();
    }
    return t3.prototype.bind = function(t4, e3, n2) {
      t4 === void 0 && (t4 = null);
      var i2, r3, o3, s3 = this.renderer;
      this.current = t4, t4 ? (o3 = (i2 = t4.baseTexture).resolution, e3 || (Jx.width = t4.frame.width, Jx.height = t4.frame.height, e3 = Jx), n2 || ($x.x = t4.frame.x, $x.y = t4.frame.y, $x.width = e3.width, $x.height = e3.height, n2 = $x), r3 = i2.framebuffer) : (o3 = s3.resolution, e3 || (Jx.width = s3.screen.width, Jx.height = s3.screen.height, e3 = Jx), n2 || ((n2 = Jx).width = e3.width, n2.height = e3.height));
      var a2 = this.viewportFrame;
      a2.x = n2.x * o3, a2.y = n2.y * o3, a2.width = n2.width * o3, a2.height = n2.height * o3, t4 || (a2.y = s3.view.height - (a2.y + a2.height)), a2.ceil(), this.renderer.framebuffer.bind(r3, a2), this.renderer.projection.update(n2, e3, o3, !r3), t4 ? this.renderer.mask.setMaskStack(i2.maskStack) : this.renderer.mask.setMaskStack(this.defaultMaskStack), this.sourceFrame.copyFrom(e3), this.destinationFrame.copyFrom(n2);
    }, t3.prototype.clear = function(t4, e3) {
      t4 = this.current ? t4 || this.current.baseTexture.clearColor : t4 || this.clearColor;
      var n2 = this.destinationFrame, i2 = this.current ? this.current.baseTexture : this.renderer.screen, r3 = n2.width !== i2.width || n2.height !== i2.height;
      if (r3) {
        var o3 = this.viewportFrame, s3 = o3.x, a2 = o3.y, l2 = o3.width, u2 = o3.height;
        s3 = Math.round(s3), a2 = Math.round(a2), l2 = Math.round(l2), u2 = Math.round(u2), this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST), this.renderer.gl.scissor(s3, a2, l2, u2);
      }
      this.renderer.framebuffer.clear(t4[0], t4[1], t4[2], t4[3], e3), r3 && this.renderer.scissor.pop();
    }, t3.prototype.resize = function() {
      this.bind(null);
    }, t3.prototype.reset = function() {
      this.bind(null);
    }, t3.prototype.destroy = function() {
      this.renderer = null;
    }, t3;
  }();
  function Qx(t3, e3, n2, i2, r3) {
    n2.buffer.update(r3);
  }
  var tb = { float: "\n        data[offset] = v;\n    ", vec2: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n    ", vec3: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n    ", vec4: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n        data[offset+3] = v[3];\n    ", mat2: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n\n        data[offset+4] = v[2];\n        data[offset+5] = v[3];\n    ", mat3: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];\n    ", mat4: "\n        for(var i = 0; i < 16; i++)\n        {\n            data[offset + i] = v[i];\n        }\n    " }, eb = { float: 4, vec2: 8, vec3: 12, vec4: 16, int: 4, ivec2: 8, ivec3: 12, ivec4: 16, uint: 4, uvec2: 8, uvec3: 12, uvec4: 16, bool: 4, bvec2: 8, bvec3: 12, bvec4: 16, mat2: 32, mat3: 48, mat4: 64 };
  function nb(t3, e3) {
    if (!t3.autoManage)
      return { size: 0, syncFunc: Qx };
    for (var n2 = function(t4) {
      for (var e4 = t4.map(function(t5) {
        return { data: t5, offset: 0, dataLen: 0, dirty: 0 };
      }), n3 = 0, i3 = 0, r4 = 0, o4 = 0; o4 < e4.length; o4++) {
        var s4 = e4[o4];
        if (n3 = eb[s4.data.type], s4.data.size > 1 && (n3 = Math.max(n3, 16) * s4.data.size), s4.dataLen = n3, i3 % n3 != 0 && i3 < 16) {
          var a3 = i3 % n3 % 16;
          i3 += a3, r4 += a3;
        }
        i3 + n3 > 16 ? (r4 = 16 * Math.ceil(r4 / 16), s4.offset = r4, r4 += n3, i3 = n3) : (s4.offset = r4, i3 += n3, r4 += n3);
      }
      return { uboElements: e4, size: r4 = 16 * Math.ceil(r4 / 16) };
    }(function(t4, e4) {
      var n3 = [];
      for (var i3 in t4)
        e4[i3] && n3.push(e4[i3]);
      return n3.sort(function(t5, e5) {
        return t5.index - e5.index;
      }), n3;
    }(t3.uniforms, e3)), i2 = n2.uboElements, r3 = n2.size, o3 = ["\n    var v = null;\n    var v2 = null;\n    var cv = null;\n    var t = 0;\n    var gl = renderer.gl\n    var index = 0;\n    var data = buffer.data;\n    "], s3 = 0; s3 < i2.length; s3++) {
      for (var a2 = i2[s3], l2 = t3.uniforms[a2.data.name], u2 = a2.data.name, h2 = false, c2 = 0; c2 < Px.length; c2++) {
        var d2 = Px[c2];
        if (d2.codeUbo && d2.test(a2.data, l2)) {
          o3.push("offset = " + a2.offset / 4 + ";", Px[c2].codeUbo(a2.data.name, l2)), h2 = true;
          break;
        }
      }
      if (!h2)
        if (a2.data.size > 1) {
          var p2 = Ex(a2.data.type), f2 = Math.max(eb[a2.data.type] / 16, 1), m2 = p2 / f2, g2 = (4 - m2 % 4) % 4;
          o3.push("\n                cv = ud." + u2 + ".value;\n                v = uv." + u2 + ";\n                offset = " + a2.offset / 4 + ";\n\n                t = 0;\n\n                for(var i=0; i < " + a2.data.size * f2 + "; i++)\n                {\n                    for(var j = 0; j < " + m2 + "; j++)\n                    {\n                        data[offset++] = v[t++];\n                    }\n                    offset += " + g2 + ";\n                }\n\n                ");
        } else {
          var v2 = tb[a2.data.type];
          o3.push("\n                cv = ud." + u2 + ".value;\n                v = uv." + u2 + ";\n                offset = " + a2.offset / 4 + ";\n                " + v2 + ";\n                ");
        }
    }
    return o3.push("\n       renderer.buffer.update(buffer);\n    "), { size: r3, syncFunc: new Function("ud", "uv", "renderer", "syncData", "buffer", o3.join("\n")) };
  }
  var ib = function() {
    function t3(t4, e3) {
      this.program = t4, this.uniformData = e3, this.uniformGroups = {}, this.uniformDirtyGroups = {}, this.uniformBufferBindings = {};
    }
    return t3.prototype.destroy = function() {
      this.uniformData = null, this.uniformGroups = null, this.uniformDirtyGroups = null, this.uniformBufferBindings = null, this.program = null;
    }, t3;
  }();
  function rb(t3, e3) {
    var n2 = mx(t3, t3.VERTEX_SHADER, e3.vertexSrc), i2 = mx(t3, t3.FRAGMENT_SHADER, e3.fragmentSrc), r3 = t3.createProgram();
    if (t3.attachShader(r3, n2), t3.attachShader(r3, i2), t3.linkProgram(r3), t3.getProgramParameter(r3, t3.LINK_STATUS) || function(t4, e4, n3, i3) {
      t4.getProgramParameter(e4, t4.LINK_STATUS) || (t4.getShaderParameter(n3, t4.COMPILE_STATUS) || gx(t4, n3), t4.getShaderParameter(i3, t4.COMPILE_STATUS) || gx(t4, i3), console.error("PixiJS Error: Could not initialize shader."), t4.getProgramInfoLog(e4) !== "" && console.warn("PixiJS Warning: gl.getProgramInfoLog()", t4.getProgramInfoLog(e4)));
    }(t3, r3, n2, i2), e3.attributeData = function(t4, e4) {
      for (var n3 = {}, i3 = e4.getProgramParameter(t4, e4.ACTIVE_ATTRIBUTES), r4 = 0; r4 < i3; r4++) {
        var o4 = e4.getActiveAttrib(t4, r4);
        if (o4.name.indexOf("gl_") !== 0) {
          var s4 = Rx(e4, o4.type), a3 = { type: s4, name: o4.name, size: Ex(s4), location: e4.getAttribLocation(t4, o4.name) };
          n3[o4.name] = a3;
        }
      }
      return n3;
    }(r3, t3), e3.uniformData = function(t4, e4) {
      for (var n3 = {}, i3 = e4.getProgramParameter(t4, e4.ACTIVE_UNIFORMS), r4 = 0; r4 < i3; r4++) {
        var o4 = e4.getActiveUniform(t4, r4), s4 = o4.name.replace(/\[.*?\]$/, ""), a3 = !!o4.name.match(/\[.*?\]$/), l3 = Rx(e4, o4.type);
        n3[s4] = { name: s4, index: r4, type: l3, size: o4.size, isArray: a3, value: _x(l3, o4.size) };
      }
      return n3;
    }(r3, t3), !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(e3.vertexSrc)) {
      var o3 = Object.keys(e3.attributeData);
      o3.sort(function(t4, e4) {
        return t4 > e4 ? 1 : -1;
      });
      for (var s3 = 0; s3 < o3.length; s3++)
        e3.attributeData[o3[s3]].location = s3, t3.bindAttribLocation(r3, s3, o3[s3]);
      t3.linkProgram(r3);
    }
    t3.deleteShader(n2), t3.deleteShader(i2);
    var a2 = {};
    for (var s3 in e3.uniformData) {
      var l2 = e3.uniformData[s3];
      a2[s3] = { location: t3.getUniformLocation(r3, s3), value: _x(l2.type, l2.size) };
    }
    return new ib(r3, a2);
  }
  var ob = 0, sb = { textureCount: 0, uboCount: 0 }, ab = function() {
    function t3(t4) {
      this.destroyed = false, this.renderer = t4, this.systemCheck(), this.gl = null, this.shader = null, this.program = null, this.cache = {}, this._uboCache = {}, this.id = ob++;
    }
    return t3.prototype.systemCheck = function() {
      if (!function() {
        if (typeof Ox == "boolean")
          return Ox;
        try {
          var t4 = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
          Ox = t4({ a: "b" }, "a", "b") === true;
        } catch (t5) {
          Ox = false;
        }
        return Ox;
      }())
        throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.");
    }, t3.prototype.contextChange = function(t4) {
      this.gl = t4, this.reset();
    }, t3.prototype.bind = function(t4, e3) {
      t4.uniforms.globals = this.renderer.globalUniforms;
      var n2 = t4.program, i2 = n2.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(t4);
      return this.shader = t4, this.program !== n2 && (this.program = n2, this.gl.useProgram(i2.program)), e3 || (sb.textureCount = 0, sb.uboCount = 0, this.syncUniformGroup(t4.uniformGroup, sb)), i2;
    }, t3.prototype.setUniforms = function(t4) {
      var e3 = this.shader.program, n2 = e3.glPrograms[this.renderer.CONTEXT_UID];
      e3.syncUniforms(n2.uniformData, t4, this.renderer);
    }, t3.prototype.syncUniformGroup = function(t4, e3) {
      var n2 = this.getGlProgram();
      t4.static && t4.dirtyId === n2.uniformDirtyGroups[t4.id] || (n2.uniformDirtyGroups[t4.id] = t4.dirtyId, this.syncUniforms(t4, n2, e3));
    }, t3.prototype.syncUniforms = function(t4, e3, n2) {
      (t4.syncUniforms[this.shader.program.id] || this.createSyncGroups(t4))(e3.uniformData, t4.uniforms, this.renderer, n2);
    }, t3.prototype.createSyncGroups = function(t4) {
      var e3 = this.getSignature(t4, this.shader.program.uniformData, "u");
      return this.cache[e3] || (this.cache[e3] = function(t5, e4) {
        var n2, i2 = ["\n        var v = null;\n        var cv = null;\n        var cu = null;\n        var t = 0;\n        var gl = renderer.gl;\n    "];
        for (var r3 in t5.uniforms) {
          var o3 = e4[r3];
          if (o3) {
            for (var s3 = t5.uniforms[r3], a2 = false, l2 = 0; l2 < Px.length; l2++)
              if (Px[l2].test(o3, s3)) {
                i2.push(Px[l2].code(r3, s3)), a2 = true;
                break;
              }
            if (!a2) {
              var u2 = (o3.size === 1 ? Cx : Ix)[o3.type].replace("location", 'ud["' + r3 + '"].location');
              i2.push('\n            cu = ud["' + r3 + '"];\n            cv = cu.value;\n            v = uv["' + r3 + '"];\n            ' + u2 + ";");
            }
          } else
            ((n2 = t5.uniforms[r3]) === null || n2 === void 0 ? void 0 : n2.group) && (t5.uniforms[r3].ubo ? i2.push("\n                        renderer.shader.syncUniformBufferGroup(uv." + r3 + ", '" + r3 + "');\n                    ") : i2.push("\n                        renderer.shader.syncUniformGroup(uv." + r3 + ", syncData);\n                    "));
        }
        return new Function("ud", "uv", "renderer", "syncData", i2.join("\n"));
      }(t4, this.shader.program.uniformData)), t4.syncUniforms[this.shader.program.id] = this.cache[e3], t4.syncUniforms[this.shader.program.id];
    }, t3.prototype.syncUniformBufferGroup = function(t4, e3) {
      var n2 = this.getGlProgram();
      if (!t4.static || t4.dirtyId !== 0 || !n2.uniformGroups[t4.id]) {
        t4.dirtyId = 0;
        var i2 = n2.uniformGroups[t4.id] || this.createSyncBufferGroup(t4, n2, e3);
        t4.buffer.update(), i2(n2.uniformData, t4.uniforms, this.renderer, sb, t4.buffer);
      }
      this.renderer.buffer.bindBufferBase(t4.buffer, n2.uniformBufferBindings[e3]);
    }, t3.prototype.createSyncBufferGroup = function(t4, e3, n2) {
      var i2 = this.renderer.gl;
      this.renderer.buffer.bind(t4.buffer);
      var r3 = this.gl.getUniformBlockIndex(e3.program, n2);
      e3.uniformBufferBindings[n2] = this.shader.uniformBindCount, i2.uniformBlockBinding(e3.program, r3, this.shader.uniformBindCount), this.shader.uniformBindCount++;
      var o3 = this.getSignature(t4, this.shader.program.uniformData, "ubo"), s3 = this._uboCache[o3];
      if (s3 || (s3 = this._uboCache[o3] = nb(t4, this.shader.program.uniformData)), t4.autoManage) {
        var a2 = new Float32Array(s3.size / 4);
        t4.buffer.update(a2);
      }
      return e3.uniformGroups[t4.id] = s3.syncFunc, e3.uniformGroups[t4.id];
    }, t3.prototype.getSignature = function(t4, e3, n2) {
      var i2 = t4.uniforms, r3 = [n2 + "-"];
      for (var o3 in i2)
        r3.push(o3), e3[o3] && r3.push(e3[o3].type);
      return r3.join("-");
    }, t3.prototype.getGlProgram = function() {
      return this.shader ? this.shader.program.glPrograms[this.renderer.CONTEXT_UID] : null;
    }, t3.prototype.generateProgram = function(t4) {
      var e3 = this.gl, n2 = t4.program, i2 = rb(e3, n2);
      return n2.glPrograms[this.renderer.CONTEXT_UID] = i2, i2;
    }, t3.prototype.reset = function() {
      this.program = null, this.shader = null;
    }, t3.prototype.destroy = function() {
      this.renderer = null, this.destroyed = true;
    }, t3;
  }();
  var lb = function() {
    function t3() {
      this.gl = null, this.stateId = 0, this.polygonOffset = 0, this.blendMode = Qg.NONE, this._blendEq = false, this.map = [], this.map[0] = this.setBlend, this.map[1] = this.setOffset, this.map[2] = this.setCullFace, this.map[3] = this.setDepthTest, this.map[4] = this.setFrontFace, this.map[5] = this.setDepthMask, this.checks = [], this.defaultState = new kx(), this.defaultState.blend = true;
    }
    return t3.prototype.contextChange = function(t4) {
      this.gl = t4, this.blendModes = function(t5, e3) {
        return e3 === void 0 && (e3 = []), e3[Qg.NORMAL] = [t5.ONE, t5.ONE_MINUS_SRC_ALPHA], e3[Qg.ADD] = [t5.ONE, t5.ONE], e3[Qg.MULTIPLY] = [t5.DST_COLOR, t5.ONE_MINUS_SRC_ALPHA, t5.ONE, t5.ONE_MINUS_SRC_ALPHA], e3[Qg.SCREEN] = [t5.ONE, t5.ONE_MINUS_SRC_COLOR, t5.ONE, t5.ONE_MINUS_SRC_ALPHA], e3[Qg.OVERLAY] = [t5.ONE, t5.ONE_MINUS_SRC_ALPHA], e3[Qg.DARKEN] = [t5.ONE, t5.ONE_MINUS_SRC_ALPHA], e3[Qg.LIGHTEN] = [t5.ONE, t5.ONE_MINUS_SRC_ALPHA], e3[Qg.COLOR_DODGE] = [t5.ONE, t5.ONE_MINUS_SRC_ALPHA], e3[Qg.COLOR_BURN] = [t5.ONE, t5.ONE_MINUS_SRC_ALPHA], e3[Qg.HARD_LIGHT] = [t5.ONE, t5.ONE_MINUS_SRC_ALPHA], e3[Qg.SOFT_LIGHT] = [t5.ONE, t5.ONE_MINUS_SRC_ALPHA], e3[Qg.DIFFERENCE] = [t5.ONE, t5.ONE_MINUS_SRC_ALPHA], e3[Qg.EXCLUSION] = [t5.ONE, t5.ONE_MINUS_SRC_ALPHA], e3[Qg.HUE] = [t5.ONE, t5.ONE_MINUS_SRC_ALPHA], e3[Qg.SATURATION] = [t5.ONE, t5.ONE_MINUS_SRC_ALPHA], e3[Qg.COLOR] = [t5.ONE, t5.ONE_MINUS_SRC_ALPHA], e3[Qg.LUMINOSITY] = [t5.ONE, t5.ONE_MINUS_SRC_ALPHA], e3[Qg.NONE] = [0, 0], e3[Qg.NORMAL_NPM] = [t5.SRC_ALPHA, t5.ONE_MINUS_SRC_ALPHA, t5.ONE, t5.ONE_MINUS_SRC_ALPHA], e3[Qg.ADD_NPM] = [t5.SRC_ALPHA, t5.ONE, t5.ONE, t5.ONE], e3[Qg.SCREEN_NPM] = [t5.SRC_ALPHA, t5.ONE_MINUS_SRC_COLOR, t5.ONE, t5.ONE_MINUS_SRC_ALPHA], e3[Qg.SRC_IN] = [t5.DST_ALPHA, t5.ZERO], e3[Qg.SRC_OUT] = [t5.ONE_MINUS_DST_ALPHA, t5.ZERO], e3[Qg.SRC_ATOP] = [t5.DST_ALPHA, t5.ONE_MINUS_SRC_ALPHA], e3[Qg.DST_OVER] = [t5.ONE_MINUS_DST_ALPHA, t5.ONE], e3[Qg.DST_IN] = [t5.ZERO, t5.SRC_ALPHA], e3[Qg.DST_OUT] = [t5.ZERO, t5.ONE_MINUS_SRC_ALPHA], e3[Qg.DST_ATOP] = [t5.ONE_MINUS_DST_ALPHA, t5.SRC_ALPHA], e3[Qg.XOR] = [t5.ONE_MINUS_DST_ALPHA, t5.ONE_MINUS_SRC_ALPHA], e3[Qg.SUBTRACT] = [t5.ONE, t5.ONE, t5.ONE, t5.ONE, t5.FUNC_REVERSE_SUBTRACT, t5.FUNC_ADD], e3;
      }(t4), this.set(this.defaultState), this.reset();
    }, t3.prototype.set = function(t4) {
      if (t4 = t4 || this.defaultState, this.stateId !== t4.data) {
        for (var e3 = this.stateId ^ t4.data, n2 = 0; e3; )
          1 & e3 && this.map[n2].call(this, !!(t4.data & 1 << n2)), e3 >>= 1, n2++;
        this.stateId = t4.data;
      }
      for (n2 = 0; n2 < this.checks.length; n2++)
        this.checks[n2](this, t4);
    }, t3.prototype.forceState = function(t4) {
      t4 = t4 || this.defaultState;
      for (var e3 = 0; e3 < this.map.length; e3++)
        this.map[e3].call(this, !!(t4.data & 1 << e3));
      for (e3 = 0; e3 < this.checks.length; e3++)
        this.checks[e3](this, t4);
      this.stateId = t4.data;
    }, t3.prototype.setBlend = function(e3) {
      this.updateCheck(t3.checkBlendMode, e3), this.gl[e3 ? "enable" : "disable"](this.gl.BLEND);
    }, t3.prototype.setOffset = function(e3) {
      this.updateCheck(t3.checkPolygonOffset, e3), this.gl[e3 ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
    }, t3.prototype.setDepthTest = function(t4) {
      this.gl[t4 ? "enable" : "disable"](this.gl.DEPTH_TEST);
    }, t3.prototype.setDepthMask = function(t4) {
      this.gl.depthMask(t4);
    }, t3.prototype.setCullFace = function(t4) {
      this.gl[t4 ? "enable" : "disable"](this.gl.CULL_FACE);
    }, t3.prototype.setFrontFace = function(t4) {
      this.gl.frontFace(this.gl[t4 ? "CW" : "CCW"]);
    }, t3.prototype.setBlendMode = function(t4) {
      if (t4 !== this.blendMode) {
        this.blendMode = t4;
        var e3 = this.blendModes[t4], n2 = this.gl;
        e3.length === 2 ? n2.blendFunc(e3[0], e3[1]) : n2.blendFuncSeparate(e3[0], e3[1], e3[2], e3[3]), e3.length === 6 ? (this._blendEq = true, n2.blendEquationSeparate(e3[4], e3[5])) : this._blendEq && (this._blendEq = false, n2.blendEquationSeparate(n2.FUNC_ADD, n2.FUNC_ADD));
      }
    }, t3.prototype.setPolygonOffset = function(t4, e3) {
      this.gl.polygonOffset(t4, e3);
    }, t3.prototype.reset = function() {
      this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false), this.forceState(this.defaultState), this._blendEq = true, this.blendMode = -1, this.setBlendMode(0);
    }, t3.prototype.updateCheck = function(t4, e3) {
      var n2 = this.checks.indexOf(t4);
      e3 && n2 === -1 ? this.checks.push(t4) : e3 || n2 === -1 || this.checks.splice(n2, 1);
    }, t3.checkBlendMode = function(t4, e3) {
      t4.setBlendMode(e3.blendMode);
    }, t3.checkPolygonOffset = function(t4, e3) {
      t4.setPolygonOffset(1, e3.polygonOffset);
    }, t3.prototype.destroy = function() {
      this.gl = null;
    }, t3;
  }(), ub = function() {
    function t3(t4) {
      this.renderer = t4, this.count = 0, this.checkCount = 0, this.maxIdle = mv.GC_MAX_IDLE, this.checkCountMax = mv.GC_MAX_CHECK_COUNT, this.mode = mv.GC_MODE;
    }
    return t3.prototype.postrender = function() {
      this.renderer.renderingToScreen && (this.count++, this.mode !== hv.MANUAL && (this.checkCount++, this.checkCount > this.checkCountMax && (this.checkCount = 0, this.run())));
    }, t3.prototype.run = function() {
      for (var t4 = this.renderer.texture, e3 = t4.managedTextures, n2 = false, i2 = 0; i2 < e3.length; i2++) {
        var r3 = e3[i2];
        !r3.framebuffer && this.count - r3.touched > this.maxIdle && (t4.destroyTexture(r3, true), e3[i2] = null, n2 = true);
      }
      if (n2) {
        var o3 = 0;
        for (i2 = 0; i2 < e3.length; i2++)
          e3[i2] !== null && (e3[o3++] = e3[i2]);
        e3.length = o3;
      }
    }, t3.prototype.unload = function(t4) {
      var e3 = this.renderer.texture, n2 = t4._texture;
      n2 && !n2.framebuffer && e3.destroyTexture(n2);
      for (var i2 = t4.children.length - 1; i2 >= 0; i2--)
        this.unload(t4.children[i2]);
    }, t3.prototype.destroy = function() {
      this.renderer = null;
    }, t3;
  }();
  var hb = function(t3) {
    this.texture = t3, this.width = -1, this.height = -1, this.dirtyId = -1, this.dirtyStyleId = -1, this.mipmap = false, this.wrapMode = 33071, this.type = iv.UNSIGNED_BYTE, this.internalFormat = ev.RGBA, this.samplerType = 0;
  }, cb = function() {
    function t3(t4) {
      this.renderer = t4, this.boundTextures = [], this.currentLocation = -1, this.managedTextures = [], this._unknownBoundTextures = false, this.unknownTexture = new wy(), this.hasIntegerTextures = false;
    }
    return t3.prototype.contextChange = function() {
      var t4 = this.gl = this.renderer.gl;
      this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.webGLVersion = this.renderer.context.webGLVersion, this.internalFormats = function(t5) {
        var e4, n3, i3, r3, o3, s3, a2, l2, u2, h2, c2, d2, p2, f2, m2, g2, v2, _2, y2, x2, b2, T2, w2;
        return "WebGL2RenderingContext" in self && t5 instanceof self.WebGL2RenderingContext ? ((e4 = {})[iv.UNSIGNED_BYTE] = ((n3 = {})[ev.RGBA] = t5.RGBA8, n3[ev.RGB] = t5.RGB8, n3[ev.RG] = t5.RG8, n3[ev.RED] = t5.R8, n3[ev.RGBA_INTEGER] = t5.RGBA8UI, n3[ev.RGB_INTEGER] = t5.RGB8UI, n3[ev.RG_INTEGER] = t5.RG8UI, n3[ev.RED_INTEGER] = t5.R8UI, n3[ev.ALPHA] = t5.ALPHA, n3[ev.LUMINANCE] = t5.LUMINANCE, n3[ev.LUMINANCE_ALPHA] = t5.LUMINANCE_ALPHA, n3), e4[iv.BYTE] = ((i3 = {})[ev.RGBA] = t5.RGBA8_SNORM, i3[ev.RGB] = t5.RGB8_SNORM, i3[ev.RG] = t5.RG8_SNORM, i3[ev.RED] = t5.R8_SNORM, i3[ev.RGBA_INTEGER] = t5.RGBA8I, i3[ev.RGB_INTEGER] = t5.RGB8I, i3[ev.RG_INTEGER] = t5.RG8I, i3[ev.RED_INTEGER] = t5.R8I, i3), e4[iv.UNSIGNED_SHORT] = ((r3 = {})[ev.RGBA_INTEGER] = t5.RGBA16UI, r3[ev.RGB_INTEGER] = t5.RGB16UI, r3[ev.RG_INTEGER] = t5.RG16UI, r3[ev.RED_INTEGER] = t5.R16UI, r3[ev.DEPTH_COMPONENT] = t5.DEPTH_COMPONENT16, r3), e4[iv.SHORT] = ((o3 = {})[ev.RGBA_INTEGER] = t5.RGBA16I, o3[ev.RGB_INTEGER] = t5.RGB16I, o3[ev.RG_INTEGER] = t5.RG16I, o3[ev.RED_INTEGER] = t5.R16I, o3), e4[iv.UNSIGNED_INT] = ((s3 = {})[ev.RGBA_INTEGER] = t5.RGBA32UI, s3[ev.RGB_INTEGER] = t5.RGB32UI, s3[ev.RG_INTEGER] = t5.RG32UI, s3[ev.RED_INTEGER] = t5.R32UI, s3[ev.DEPTH_COMPONENT] = t5.DEPTH_COMPONENT24, s3), e4[iv.INT] = ((a2 = {})[ev.RGBA_INTEGER] = t5.RGBA32I, a2[ev.RGB_INTEGER] = t5.RGB32I, a2[ev.RG_INTEGER] = t5.RG32I, a2[ev.RED_INTEGER] = t5.R32I, a2), e4[iv.FLOAT] = ((l2 = {})[ev.RGBA] = t5.RGBA32F, l2[ev.RGB] = t5.RGB32F, l2[ev.RG] = t5.RG32F, l2[ev.RED] = t5.R32F, l2[ev.DEPTH_COMPONENT] = t5.DEPTH_COMPONENT32F, l2), e4[iv.HALF_FLOAT] = ((u2 = {})[ev.RGBA] = t5.RGBA16F, u2[ev.RGB] = t5.RGB16F, u2[ev.RG] = t5.RG16F, u2[ev.RED] = t5.R16F, u2), e4[iv.UNSIGNED_SHORT_5_6_5] = ((h2 = {})[ev.RGB] = t5.RGB565, h2), e4[iv.UNSIGNED_SHORT_4_4_4_4] = ((c2 = {})[ev.RGBA] = t5.RGBA4, c2), e4[iv.UNSIGNED_SHORT_5_5_5_1] = ((d2 = {})[ev.RGBA] = t5.RGB5_A1, d2), e4[iv.UNSIGNED_INT_2_10_10_10_REV] = ((p2 = {})[ev.RGBA] = t5.RGB10_A2, p2[ev.RGBA_INTEGER] = t5.RGB10_A2UI, p2), e4[iv.UNSIGNED_INT_10F_11F_11F_REV] = ((f2 = {})[ev.RGB] = t5.R11F_G11F_B10F, f2), e4[iv.UNSIGNED_INT_5_9_9_9_REV] = ((m2 = {})[ev.RGB] = t5.RGB9_E5, m2), e4[iv.UNSIGNED_INT_24_8] = ((g2 = {})[ev.DEPTH_STENCIL] = t5.DEPTH24_STENCIL8, g2), e4[iv.FLOAT_32_UNSIGNED_INT_24_8_REV] = ((v2 = {})[ev.DEPTH_STENCIL] = t5.DEPTH32F_STENCIL8, v2), w2 = e4) : ((_2 = {})[iv.UNSIGNED_BYTE] = ((y2 = {})[ev.RGBA] = t5.RGBA, y2[ev.RGB] = t5.RGB, y2[ev.ALPHA] = t5.ALPHA, y2[ev.LUMINANCE] = t5.LUMINANCE, y2[ev.LUMINANCE_ALPHA] = t5.LUMINANCE_ALPHA, y2), _2[iv.UNSIGNED_SHORT_5_6_5] = ((x2 = {})[ev.RGB] = t5.RGB, x2), _2[iv.UNSIGNED_SHORT_4_4_4_4] = ((b2 = {})[ev.RGBA] = t5.RGBA, b2), _2[iv.UNSIGNED_SHORT_5_5_5_1] = ((T2 = {})[ev.RGBA] = t5.RGBA, T2), w2 = _2), w2;
      }(t4);
      var e3 = t4.getParameter(t4.MAX_TEXTURE_IMAGE_UNITS);
      this.boundTextures.length = e3;
      for (var n2 = 0; n2 < e3; n2++)
        this.boundTextures[n2] = null;
      this.emptyTextures = {};
      var i2 = new hb(t4.createTexture());
      t4.bindTexture(t4.TEXTURE_2D, i2.texture), t4.texImage2D(t4.TEXTURE_2D, 0, t4.RGBA, 1, 1, 0, t4.RGBA, t4.UNSIGNED_BYTE, new Uint8Array(4)), this.emptyTextures[t4.TEXTURE_2D] = i2, this.emptyTextures[t4.TEXTURE_CUBE_MAP] = new hb(t4.createTexture()), t4.bindTexture(t4.TEXTURE_CUBE_MAP, this.emptyTextures[t4.TEXTURE_CUBE_MAP].texture);
      for (n2 = 0; n2 < 6; n2++)
        t4.texImage2D(t4.TEXTURE_CUBE_MAP_POSITIVE_X + n2, 0, t4.RGBA, 1, 1, 0, t4.RGBA, t4.UNSIGNED_BYTE, null);
      t4.texParameteri(t4.TEXTURE_CUBE_MAP, t4.TEXTURE_MAG_FILTER, t4.LINEAR), t4.texParameteri(t4.TEXTURE_CUBE_MAP, t4.TEXTURE_MIN_FILTER, t4.LINEAR);
      for (n2 = 0; n2 < this.boundTextures.length; n2++)
        this.bind(null, n2);
    }, t3.prototype.bind = function(t4, e3) {
      e3 === void 0 && (e3 = 0);
      var n2 = this.gl;
      if ((t4 = t4 == null ? void 0 : t4.castToBaseTexture()) && t4.valid && !t4.parentTextureArray) {
        t4.touched = this.renderer.textureGC.count;
        var i2 = t4._glTextures[this.CONTEXT_UID] || this.initTexture(t4);
        this.boundTextures[e3] !== t4 && (this.currentLocation !== e3 && (this.currentLocation = e3, n2.activeTexture(n2.TEXTURE0 + e3)), n2.bindTexture(t4.target, i2.texture)), i2.dirtyId !== t4.dirtyId && (this.currentLocation !== e3 && (this.currentLocation = e3, n2.activeTexture(n2.TEXTURE0 + e3)), this.updateTexture(t4)), this.boundTextures[e3] = t4;
      } else
        this.currentLocation !== e3 && (this.currentLocation = e3, n2.activeTexture(n2.TEXTURE0 + e3)), n2.bindTexture(n2.TEXTURE_2D, this.emptyTextures[n2.TEXTURE_2D].texture), this.boundTextures[e3] = null;
    }, t3.prototype.reset = function() {
      this._unknownBoundTextures = true, this.hasIntegerTextures = false, this.currentLocation = -1;
      for (var t4 = 0; t4 < this.boundTextures.length; t4++)
        this.boundTextures[t4] = this.unknownTexture;
    }, t3.prototype.unbind = function(t4) {
      var e3 = this.gl, n2 = this.boundTextures;
      if (this._unknownBoundTextures) {
        this._unknownBoundTextures = false;
        for (var i2 = 0; i2 < n2.length; i2++)
          n2[i2] === this.unknownTexture && this.bind(null, i2);
      }
      for (i2 = 0; i2 < n2.length; i2++)
        n2[i2] === t4 && (this.currentLocation !== i2 && (e3.activeTexture(e3.TEXTURE0 + i2), this.currentLocation = i2), e3.bindTexture(t4.target, this.emptyTextures[t4.target].texture), n2[i2] = null);
    }, t3.prototype.ensureSamplerType = function(t4) {
      var e3 = this.boundTextures, n2 = this.hasIntegerTextures, i2 = this.CONTEXT_UID;
      if (n2)
        for (var r3 = t4 - 1; r3 >= 0; --r3) {
          var o3 = e3[r3];
          if (o3)
            o3._glTextures[i2].samplerType !== rv.FLOAT && this.renderer.texture.unbind(o3);
        }
    }, t3.prototype.initTexture = function(t4) {
      var e3 = new hb(this.gl.createTexture());
      return e3.dirtyId = -1, t4._glTextures[this.CONTEXT_UID] = e3, this.managedTextures.push(t4), t4.on("dispose", this.destroyTexture, this), e3;
    }, t3.prototype.initTextureType = function(t4, e3) {
      var n2, i2;
      e3.internalFormat = (i2 = (n2 = this.internalFormats[t4.type]) === null || n2 === void 0 ? void 0 : n2[t4.format]) !== null && i2 !== void 0 ? i2 : t4.format, this.webGLVersion === 2 && t4.type === iv.HALF_FLOAT ? e3.type = this.gl.HALF_FLOAT : e3.type = t4.type;
    }, t3.prototype.updateTexture = function(t4) {
      var e3 = t4._glTextures[this.CONTEXT_UID];
      if (e3) {
        var n2 = this.renderer;
        if (this.initTextureType(t4, e3), t4.resource && t4.resource.upload(n2, t4, e3))
          e3.samplerType !== rv.FLOAT && (this.hasIntegerTextures = true);
        else {
          var i2 = t4.realWidth, r3 = t4.realHeight, o3 = n2.gl;
          (e3.width !== i2 || e3.height !== r3 || e3.dirtyId < 0) && (e3.width = i2, e3.height = r3, o3.texImage2D(t4.target, 0, e3.internalFormat, i2, r3, 0, t4.format, e3.type, null));
        }
        t4.dirtyStyleId !== e3.dirtyStyleId && this.updateTextureStyle(t4), e3.dirtyId = t4.dirtyId;
      }
    }, t3.prototype.destroyTexture = function(t4, e3) {
      var n2 = this.gl;
      if ((t4 = t4.castToBaseTexture())._glTextures[this.CONTEXT_UID] && (this.unbind(t4), n2.deleteTexture(t4._glTextures[this.CONTEXT_UID].texture), t4.off("dispose", this.destroyTexture, this), delete t4._glTextures[this.CONTEXT_UID], !e3)) {
        var i2 = this.managedTextures.indexOf(t4);
        i2 !== -1 && Vv(this.managedTextures, i2, 1);
      }
    }, t3.prototype.updateTextureStyle = function(t4) {
      var e3 = t4._glTextures[this.CONTEXT_UID];
      e3 && (t4.mipmap !== av.POW2 && this.webGLVersion === 2 || t4.isPowerOfTwo ? e3.mipmap = t4.mipmap >= 1 : e3.mipmap = false, this.webGLVersion === 2 || t4.isPowerOfTwo ? e3.wrapMode = t4.wrapMode : e3.wrapMode = sv.CLAMP, t4.resource && t4.resource.style(this.renderer, t4, e3) || this.setStyle(t4, e3), e3.dirtyStyleId = t4.dirtyStyleId);
    }, t3.prototype.setStyle = function(t4, e3) {
      var n2 = this.gl;
      if (e3.mipmap && t4.mipmap !== av.ON_MANUAL && n2.generateMipmap(t4.target), n2.texParameteri(t4.target, n2.TEXTURE_WRAP_S, e3.wrapMode), n2.texParameteri(t4.target, n2.TEXTURE_WRAP_T, e3.wrapMode), e3.mipmap) {
        n2.texParameteri(t4.target, n2.TEXTURE_MIN_FILTER, t4.scaleMode === ov.LINEAR ? n2.LINEAR_MIPMAP_LINEAR : n2.NEAREST_MIPMAP_NEAREST);
        var i2 = this.renderer.context.extensions.anisotropicFiltering;
        if (i2 && t4.anisotropicLevel > 0 && t4.scaleMode === ov.LINEAR) {
          var r3 = Math.min(t4.anisotropicLevel, n2.getParameter(i2.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
          n2.texParameterf(t4.target, i2.TEXTURE_MAX_ANISOTROPY_EXT, r3);
        }
      } else
        n2.texParameteri(t4.target, n2.TEXTURE_MIN_FILTER, t4.scaleMode === ov.LINEAR ? n2.LINEAR : n2.NEAREST);
      n2.texParameteri(t4.target, n2.TEXTURE_MAG_FILTER, t4.scaleMode === ov.LINEAR ? n2.LINEAR : n2.NEAREST);
    }, t3.prototype.destroy = function() {
      this.renderer = null;
    }, t3;
  }(), db = { __proto__: null, FilterSystem: rx, BatchSystem: sx, ContextSystem: lx, FramebufferSystem: cx, GeometrySystem: px, MaskSystem: Vx, ScissorSystem: qx, StencilSystem: Yx, ProjectionSystem: Zx, RenderTextureSystem: Kx, ShaderSystem: ab, StateSystem: lb, TextureGCSystem: ub, TextureSystem: cb }, pb = new y_(), fb = function(t3) {
    function e3(e4, n2) {
      e4 === void 0 && (e4 = $g.UNKNOWN);
      var i2 = t3.call(this) || this;
      return n2 = Object.assign({}, mv.RENDER_OPTIONS, n2), i2.options = n2, i2.type = e4, i2.screen = new d_(0, 0, n2.width, n2.height), i2.view = n2.view || document.createElement("canvas"), i2.resolution = n2.resolution || mv.RESOLUTION, i2.useContextAlpha = n2.useContextAlpha, i2.autoDensity = !!n2.autoDensity, i2.preserveDrawingBuffer = n2.preserveDrawingBuffer, i2.clearBeforeRender = n2.clearBeforeRender, i2._backgroundColor = 0, i2._backgroundColorRgba = [0, 0, 0, 1], i2._backgroundColorString = "#000000", i2.backgroundColor = n2.backgroundColor || i2._backgroundColor, i2.backgroundAlpha = n2.backgroundAlpha, n2.transparent !== void 0 && (Zv("6.0.0", "Option transparent is deprecated, please use backgroundAlpha instead."), i2.useContextAlpha = n2.transparent, i2.backgroundAlpha = n2.transparent ? 0 : 1), i2._lastObjectRendered = null, i2.plugins = {}, i2;
    }
    return _y(e3, t3), e3.prototype.initPlugins = function(t4) {
      for (var e4 in t4)
        this.plugins[e4] = new t4[e4](this);
    }, Object.defineProperty(e3.prototype, "width", { get: function() {
      return this.view.width;
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "height", { get: function() {
      return this.view.height;
    }, enumerable: false, configurable: true }), e3.prototype.resize = function(t4, e4) {
      this.view.width = Math.round(t4 * this.resolution), this.view.height = Math.round(e4 * this.resolution);
      var n2 = this.view.width / this.resolution, i2 = this.view.height / this.resolution;
      this.screen.width = n2, this.screen.height = i2, this.autoDensity && (this.view.style.width = n2 + "px", this.view.style.height = i2 + "px"), this.emit("resize", n2, i2);
    }, e3.prototype.generateTexture = function(t4, e4, n2, i2) {
      e4 === void 0 && (e4 = {}), typeof e4 == "number" && (Zv("6.1.0", "generateTexture options (scaleMode, resolution, region) are now object options."), e4 = { scaleMode: e4, resolution: n2, region: i2 });
      var r3 = e4.region, o3 = function(t5, e5) {
        var n3 = {};
        for (var i3 in t5)
          Object.prototype.hasOwnProperty.call(t5, i3) && e5.indexOf(i3) < 0 && (n3[i3] = t5[i3]);
        if (t5 != null && typeof Object.getOwnPropertySymbols == "function") {
          var r4 = 0;
          for (i3 = Object.getOwnPropertySymbols(t5); r4 < i3.length; r4++)
            e5.indexOf(i3[r4]) < 0 && (n3[i3[r4]] = t5[i3[r4]]);
        }
        return n3;
      }(e4, ["region"]);
      (i2 = r3 || t4.getLocalBounds(null, true)).width === 0 && (i2.width = 1), i2.height === 0 && (i2.height = 1);
      var s3 = Hy.create(yy({ width: i2.width, height: i2.height }, o3));
      return pb.tx = -i2.x, pb.ty = -i2.y, this.render(t4, { renderTexture: s3, clear: false, transform: pb, skipUpdateTransform: !!t4.parent }), s3;
    }, e3.prototype.destroy = function(t4) {
      for (var e4 in this.plugins)
        this.plugins[e4].destroy(), this.plugins[e4] = null;
      t4 && this.view.parentNode && this.view.parentNode.removeChild(this.view);
      this.plugins = null, this.type = $g.UNKNOWN, this.view = null, this.screen = null, this._tempDisplayObjectParent = null, this.options = null, this._backgroundColorRgba = null, this._backgroundColorString = null, this._lastObjectRendered = null;
    }, Object.defineProperty(e3.prototype, "backgroundColor", { get: function() {
      return this._backgroundColor;
    }, set: function(t4) {
      this._backgroundColor = t4, this._backgroundColorString = Pv(t4), Rv(t4, this._backgroundColorRgba);
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "backgroundAlpha", { get: function() {
      return this._backgroundColorRgba[3];
    }, set: function(t4) {
      this._backgroundColorRgba[3] = t4;
    }, enumerable: false, configurable: true }), e3;
  }(vv.a), mb = function(t3) {
    this.buffer = t3 || null, this.updateID = -1, this.byteLength = -1, this.refCount = 0;
  }, gb = function() {
    function t3(t4) {
      this.renderer = t4, this.managedBuffers = {}, this.boundBufferBases = {};
    }
    return t3.prototype.destroy = function() {
      this.renderer = null;
    }, t3.prototype.contextChange = function() {
      this.disposeAll(true), this.gl = this.renderer.gl, this.CONTEXT_UID = this.renderer.CONTEXT_UID;
    }, t3.prototype.bind = function(t4) {
      var e3 = this.gl, n2 = this.CONTEXT_UID, i2 = t4._glBuffers[n2] || this.createGLBuffer(t4);
      e3.bindBuffer(t4.type, i2.buffer);
    }, t3.prototype.bindBufferBase = function(t4, e3) {
      var n2 = this.gl, i2 = this.CONTEXT_UID;
      if (this.boundBufferBases[e3] !== t4) {
        var r3 = t4._glBuffers[i2] || this.createGLBuffer(t4);
        this.boundBufferBases[e3] = t4, n2.bindBufferBase(n2.UNIFORM_BUFFER, e3, r3.buffer);
      }
    }, t3.prototype.bindBufferRange = function(t4, e3, n2) {
      var i2 = this.gl, r3 = this.CONTEXT_UID;
      n2 = n2 || 0;
      var o3 = t4._glBuffers[r3] || this.createGLBuffer(t4);
      i2.bindBufferRange(i2.UNIFORM_BUFFER, e3 || 0, o3.buffer, 256 * n2, 256);
    }, t3.prototype.update = function(t4) {
      var e3 = this.gl, n2 = this.CONTEXT_UID, i2 = t4._glBuffers[n2];
      if (t4._updateID !== i2.updateID)
        if (i2.updateID = t4._updateID, e3.bindBuffer(t4.type, i2.buffer), i2.byteLength >= t4.data.byteLength)
          e3.bufferSubData(t4.type, 0, t4.data);
        else {
          var r3 = t4.static ? e3.STATIC_DRAW : e3.DYNAMIC_DRAW;
          i2.byteLength = t4.data.byteLength, e3.bufferData(t4.type, t4.data, r3);
        }
    }, t3.prototype.dispose = function(t4, e3) {
      if (this.managedBuffers[t4.id]) {
        delete this.managedBuffers[t4.id];
        var n2 = t4._glBuffers[this.CONTEXT_UID], i2 = this.gl;
        t4.disposeRunner.remove(this), n2 && (e3 || i2.deleteBuffer(n2.buffer), delete t4._glBuffers[this.CONTEXT_UID]);
      }
    }, t3.prototype.disposeAll = function(t4) {
      for (var e3 = Object.keys(this.managedBuffers), n2 = 0; n2 < e3.length; n2++)
        this.dispose(this.managedBuffers[e3[n2]], t4);
    }, t3.prototype.createGLBuffer = function(t4) {
      var e3 = this.CONTEXT_UID, n2 = this.gl;
      return t4._glBuffers[e3] = new mb(n2.createBuffer()), this.managedBuffers[t4.id] = t4, t4.disposeRunner.add(this), t4._glBuffers[e3];
    }, t3;
  }(), vb = function(t3) {
    function e3(n2) {
      var i2 = t3.call(this, $g.WEBGL, n2) || this;
      return n2 = i2.options, i2.gl = null, i2.CONTEXT_UID = 0, i2.runners = { destroy: new fy("destroy"), contextChange: new fy("contextChange"), reset: new fy("reset"), update: new fy("update"), postrender: new fy("postrender"), prerender: new fy("prerender"), resize: new fy("resize") }, i2.runners.contextChange.add(i2), i2.globalUniforms = new tx({ projectionMatrix: new y_() }, true), i2.addSystem(Vx, "mask").addSystem(lx, "context").addSystem(lb, "state").addSystem(ab, "shader").addSystem(cb, "texture").addSystem(gb, "buffer").addSystem(px, "geometry").addSystem(cx, "framebuffer").addSystem(qx, "scissor").addSystem(Yx, "stencil").addSystem(Zx, "projection").addSystem(ub, "textureGC").addSystem(rx, "filter").addSystem(Kx, "renderTexture").addSystem(sx, "batch"), i2.initPlugins(e3.__plugins), i2.multisample = void 0, n2.context ? i2.context.initFromContext(n2.context) : i2.context.initFromOptions({ alpha: !!i2.useContextAlpha, antialias: n2.antialias, premultipliedAlpha: i2.useContextAlpha && i2.useContextAlpha !== "notMultiplied", stencil: true, preserveDrawingBuffer: n2.preserveDrawingBuffer, powerPreference: i2.options.powerPreference }), i2.renderingToScreen = true, Ev(i2.context.webGLVersion === 2 ? "WebGL 2" : "WebGL 1"), i2.resize(i2.options.width, i2.options.height), i2;
    }
    return _y(e3, t3), e3.create = function(t4) {
      if (Mv())
        return new e3(t4);
      throw new Error('WebGL unsupported in this browser, use "pixi.js-legacy" for fallback canvas2d support.');
    }, e3.prototype.contextChange = function() {
      var t4, e4 = this.gl;
      if (this.context.webGLVersion === 1) {
        var n2 = e4.getParameter(e4.FRAMEBUFFER_BINDING);
        e4.bindFramebuffer(e4.FRAMEBUFFER, null), t4 = e4.getParameter(e4.SAMPLES), e4.bindFramebuffer(e4.FRAMEBUFFER, n2);
      } else {
        n2 = e4.getParameter(e4.DRAW_FRAMEBUFFER_BINDING);
        e4.bindFramebuffer(e4.DRAW_FRAMEBUFFER, null), t4 = e4.getParameter(e4.SAMPLES), e4.bindFramebuffer(e4.DRAW_FRAMEBUFFER, n2);
      }
      t4 >= pv.HIGH ? this.multisample = pv.HIGH : t4 >= pv.MEDIUM ? this.multisample = pv.MEDIUM : t4 >= pv.LOW ? this.multisample = pv.LOW : this.multisample = pv.NONE;
    }, e3.prototype.addSystem = function(t4, e4) {
      var n2 = new t4(this);
      if (this[e4])
        throw new Error('Whoops! The name "' + e4 + '" is already in use');
      for (var i2 in this[e4] = n2, this.runners)
        this.runners[i2].add(n2);
      return this;
    }, e3.prototype.render = function(t4, e4) {
      var n2, i2, r3, o3;
      if (e4 && (e4 instanceof Hy ? (Zv("6.0.0", "Renderer#render arguments changed, use options instead."), n2 = e4, i2 = arguments[2], r3 = arguments[3], o3 = arguments[4]) : (n2 = e4.renderTexture, i2 = e4.clear, r3 = e4.transform, o3 = e4.skipUpdateTransform)), this.renderingToScreen = !n2, this.runners.prerender.emit(), this.emit("prerender"), this.projection.transform = r3, !this.context.isLost) {
        if (n2 || (this._lastObjectRendered = t4), !o3) {
          var s3 = t4.enableTempParent();
          t4.updateTransform(), t4.disableTempParent(s3);
        }
        this.renderTexture.bind(n2), this.batch.currentRenderer.start(), (i2 !== void 0 ? i2 : this.clearBeforeRender) && this.renderTexture.clear(), t4.render(this), this.batch.currentRenderer.flush(), n2 && n2.baseTexture.update(), this.runners.postrender.emit(), this.projection.transform = null, this.emit("postrender");
      }
    }, e3.prototype.generateTexture = function(e4, n2, i2, r3) {
      n2 === void 0 && (n2 = {});
      var o3 = t3.prototype.generateTexture.call(this, e4, n2, i2, r3);
      return this.framebuffer.blit(), o3;
    }, e3.prototype.resize = function(e4, n2) {
      t3.prototype.resize.call(this, e4, n2), this.runners.resize.emit(this.screen.height, this.screen.width);
    }, e3.prototype.reset = function() {
      return this.runners.reset.emit(), this;
    }, e3.prototype.clear = function() {
      this.renderTexture.bind(), this.renderTexture.clear();
    }, e3.prototype.destroy = function(e4) {
      for (var n2 in this.runners.destroy.emit(), this.runners)
        this.runners[n2].destroy();
      t3.prototype.destroy.call(this, e4), this.gl = null;
    }, Object.defineProperty(e3.prototype, "extract", { get: function() {
      return Zv("6.0.0", "Renderer#extract has been deprecated, please use Renderer#plugins.extract instead."), this.plugins.extract;
    }, enumerable: false, configurable: true }), e3.registerPlugin = function(t4, n2) {
      e3.__plugins = e3.__plugins || {}, e3.__plugins[t4] = n2;
    }, e3;
  }(fb);
  var _b = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n", yb = function() {
    this.texArray = null, this.blend = 0, this.type = tv.TRIANGLES, this.start = 0, this.size = 0, this.data = null;
  }, xb = function() {
    function t3() {
      this.elements = [], this.ids = [], this.count = 0;
    }
    return t3.prototype.clear = function() {
      for (var t4 = 0; t4 < this.count; t4++)
        this.elements[t4] = null;
      this.count = 0;
    }, t3;
  }(), bb = function() {
    function t3(t4) {
      typeof t4 == "number" ? this.rawBinaryData = new ArrayBuffer(t4) : t4 instanceof Uint8Array ? this.rawBinaryData = t4.buffer : this.rawBinaryData = t4, this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData);
    }
    return Object.defineProperty(t3.prototype, "int8View", { get: function() {
      return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View;
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "uint8View", { get: function() {
      return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View;
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "int16View", { get: function() {
      return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View;
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "uint16View", { get: function() {
      return this._uint16View || (this._uint16View = new Uint16Array(this.rawBinaryData)), this._uint16View;
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "int32View", { get: function() {
      return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View;
    }, enumerable: false, configurable: true }), t3.prototype.view = function(t4) {
      return this[t4 + "View"];
    }, t3.prototype.destroy = function() {
      this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this._uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null;
    }, t3.sizeOf = function(t4) {
      switch (t4) {
        case "int8":
        case "uint8":
          return 1;
        case "int16":
        case "uint16":
          return 2;
        case "int32":
        case "uint32":
        case "float32":
          return 4;
        default:
          throw new Error(t4 + " isn't a valid view type");
      }
    }, t3;
  }(), Tb = function(t3) {
    function e3(e4) {
      var n2 = t3.call(this, e4) || this;
      return n2.shaderGenerator = null, n2.geometryClass = null, n2.vertexSize = null, n2.state = kx.for2d(), n2.size = 4 * mv.SPRITE_BATCH_SIZE, n2._vertexCount = 0, n2._indexCount = 0, n2._bufferedElements = [], n2._bufferedTextures = [], n2._bufferSize = 0, n2._shader = null, n2._packedGeometries = [], n2._packedGeometryPoolSize = 2, n2._flushId = 0, n2._aBuffers = {}, n2._iBuffers = {}, n2.MAX_TEXTURES = 1, n2.renderer.on("prerender", n2.onPrerender, n2), e4.runners.contextChange.add(n2), n2._dcIndex = 0, n2._aIndex = 0, n2._iIndex = 0, n2._attributeBuffer = null, n2._indexBuffer = null, n2._tempBoundTextures = [], n2;
    }
    return _y(e3, t3), e3.prototype.contextChange = function() {
      var t4 = this.renderer.gl;
      mv.PREFER_ENV === Jg.WEBGL_LEGACY ? this.MAX_TEXTURES = 1 : (this.MAX_TEXTURES = Math.min(t4.getParameter(t4.MAX_TEXTURE_IMAGE_UNITS), mv.SPRITE_MAX_TEXTURES), this.MAX_TEXTURES = function(t5, e5) {
        if (t5 === 0)
          throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
        for (var n2 = e5.createShader(e5.FRAGMENT_SHADER); ; ) {
          var i2 = Lx.replace(/%forloop%/gi, Nx(t5));
          if (e5.shaderSource(n2, i2), e5.compileShader(n2), e5.getShaderParameter(n2, e5.COMPILE_STATUS))
            break;
          t5 = t5 / 2 | 0;
        }
        return t5;
      }(this.MAX_TEXTURES, t4)), this._shader = this.shaderGenerator.generateShader(this.MAX_TEXTURES);
      for (var e4 = 0; e4 < this._packedGeometryPoolSize; e4++)
        this._packedGeometries[e4] = new this.geometryClass();
      this.initFlushBuffers();
    }, e3.prototype.initFlushBuffers = function() {
      for (var t4 = e3._drawCallPool, n2 = e3._textureArrayPool, i2 = this.size / 4, r3 = Math.floor(i2 / this.MAX_TEXTURES) + 1; t4.length < i2; )
        t4.push(new yb());
      for (; n2.length < r3; )
        n2.push(new xb());
      for (var o3 = 0; o3 < this.MAX_TEXTURES; o3++)
        this._tempBoundTextures[o3] = null;
    }, e3.prototype.onPrerender = function() {
      this._flushId = 0;
    }, e3.prototype.render = function(t4) {
      t4._texture.valid && (this._vertexCount + t4.vertexData.length / 2 > this.size && this.flush(), this._vertexCount += t4.vertexData.length / 2, this._indexCount += t4.indices.length, this._bufferedTextures[this._bufferSize] = t4._texture.baseTexture, this._bufferedElements[this._bufferSize++] = t4);
    }, e3.prototype.buildTexturesAndDrawCalls = function() {
      var t4 = this._bufferedTextures, n2 = this.MAX_TEXTURES, i2 = e3._textureArrayPool, r3 = this.renderer.batch, o3 = this._tempBoundTextures, s3 = this.renderer.textureGC.count, a2 = ++wy._globalBatch, l2 = 0, u2 = i2[0], h2 = 0;
      r3.copyBoundTextures(o3, n2);
      for (var c2 = 0; c2 < this._bufferSize; ++c2) {
        var d2 = t4[c2];
        t4[c2] = null, d2._batchEnabled !== a2 && (u2.count >= n2 && (r3.boundArray(u2, o3, a2, n2), this.buildDrawCalls(u2, h2, c2), h2 = c2, u2 = i2[++l2], ++a2), d2._batchEnabled = a2, d2.touched = s3, u2.elements[u2.count++] = d2);
      }
      u2.count > 0 && (r3.boundArray(u2, o3, a2, n2), this.buildDrawCalls(u2, h2, this._bufferSize), ++l2, ++a2);
      for (c2 = 0; c2 < o3.length; c2++)
        o3[c2] = null;
      wy._globalBatch = a2;
    }, e3.prototype.buildDrawCalls = function(t4, n2, i2) {
      var r3 = this._bufferedElements, o3 = this._attributeBuffer, s3 = this._indexBuffer, a2 = this.vertexSize, l2 = e3._drawCallPool, u2 = this._dcIndex, h2 = this._aIndex, c2 = this._iIndex, d2 = l2[u2];
      d2.start = this._iIndex, d2.texArray = t4;
      for (var p2 = n2; p2 < i2; ++p2) {
        var f2 = r3[p2], m2 = f2._texture.baseTexture, g2 = Ov[m2.alphaMode ? 1 : 0][f2.blendMode];
        r3[p2] = null, n2 < p2 && d2.blend !== g2 && (d2.size = c2 - d2.start, n2 = p2, (d2 = l2[++u2]).texArray = t4, d2.start = c2), this.packInterleavedGeometry(f2, o3, s3, h2, c2), h2 += f2.vertexData.length / 2 * a2, c2 += f2.indices.length, d2.blend = g2;
      }
      n2 < i2 && (d2.size = c2 - d2.start, ++u2), this._dcIndex = u2, this._aIndex = h2, this._iIndex = c2;
    }, e3.prototype.bindAndClearTexArray = function(t4) {
      for (var e4 = this.renderer.texture, n2 = 0; n2 < t4.count; n2++)
        e4.bind(t4.elements[n2], t4.ids[n2]), t4.elements[n2] = null;
      t4.count = 0;
    }, e3.prototype.updateGeometry = function() {
      var t4 = this._packedGeometries, e4 = this._attributeBuffer, n2 = this._indexBuffer;
      mv.CAN_UPLOAD_SAME_BUFFER ? (t4[this._flushId]._buffer.update(e4.rawBinaryData), t4[this._flushId]._indexBuffer.update(n2), this.renderer.geometry.updateBuffers()) : (this._packedGeometryPoolSize <= this._flushId && (this._packedGeometryPoolSize++, t4[this._flushId] = new this.geometryClass()), t4[this._flushId]._buffer.update(e4.rawBinaryData), t4[this._flushId]._indexBuffer.update(n2), this.renderer.geometry.bind(t4[this._flushId]), this.renderer.geometry.updateBuffers(), this._flushId++);
    }, e3.prototype.drawBatches = function() {
      for (var t4 = this._dcIndex, n2 = this.renderer, i2 = n2.gl, r3 = n2.state, o3 = e3._drawCallPool, s3 = null, a2 = 0; a2 < t4; a2++) {
        var l2 = o3[a2], u2 = l2.texArray, h2 = l2.type, c2 = l2.size, d2 = l2.start, p2 = l2.blend;
        s3 !== u2 && (s3 = u2, this.bindAndClearTexArray(u2)), this.state.blendMode = p2, r3.set(this.state), i2.drawElements(h2, c2, i2.UNSIGNED_SHORT, 2 * d2);
      }
    }, e3.prototype.flush = function() {
      this._vertexCount !== 0 && (this._attributeBuffer = this.getAttributeBuffer(this._vertexCount), this._indexBuffer = this.getIndexBuffer(this._indexCount), this._aIndex = 0, this._iIndex = 0, this._dcIndex = 0, this.buildTexturesAndDrawCalls(), this.updateGeometry(), this.drawBatches(), this._bufferSize = 0, this._vertexCount = 0, this._indexCount = 0);
    }, e3.prototype.start = function() {
      this.renderer.state.set(this.state), this.renderer.texture.ensureSamplerType(this.MAX_TEXTURES), this.renderer.shader.bind(this._shader), mv.CAN_UPLOAD_SAME_BUFFER && this.renderer.geometry.bind(this._packedGeometries[this._flushId]);
    }, e3.prototype.stop = function() {
      this.flush();
    }, e3.prototype.destroy = function() {
      for (var e4 = 0; e4 < this._packedGeometryPoolSize; e4++)
        this._packedGeometries[e4] && this._packedGeometries[e4].destroy();
      this.renderer.off("prerender", this.onPrerender, this), this._aBuffers = null, this._iBuffers = null, this._packedGeometries = null, this._attributeBuffer = null, this._indexBuffer = null, this._shader && (this._shader.destroy(), this._shader = null), t3.prototype.destroy.call(this);
    }, e3.prototype.getAttributeBuffer = function(t4) {
      var e4 = Hv(Math.ceil(t4 / 8)), n2 = jv(e4), i2 = 8 * e4;
      this._aBuffers.length <= n2 && (this._iBuffers.length = n2 + 1);
      var r3 = this._aBuffers[i2];
      return r3 || (this._aBuffers[i2] = r3 = new bb(i2 * this.vertexSize * 4)), r3;
    }, e3.prototype.getIndexBuffer = function(t4) {
      var e4 = Hv(Math.ceil(t4 / 12)), n2 = jv(e4), i2 = 12 * e4;
      this._iBuffers.length <= n2 && (this._iBuffers.length = n2 + 1);
      var r3 = this._iBuffers[n2];
      return r3 || (this._iBuffers[n2] = r3 = new Uint16Array(i2)), r3;
    }, e3.prototype.packInterleavedGeometry = function(t4, e4, n2, i2, r3) {
      for (var o3 = e4.uint32View, s3 = e4.float32View, a2 = i2 / this.vertexSize, l2 = t4.uvs, u2 = t4.indices, h2 = t4.vertexData, c2 = t4._texture.baseTexture._batchLocation, d2 = Math.min(t4.worldAlpha, 1), p2 = d2 < 1 && t4._texture.baseTexture.alphaMode ? Dv(t4._tintRGB, d2) : t4._tintRGB + (255 * d2 << 24), f2 = 0; f2 < h2.length; f2 += 2)
        s3[i2++] = h2[f2], s3[i2++] = h2[f2 + 1], s3[i2++] = l2[f2], s3[i2++] = l2[f2 + 1], o3[i2++] = p2, s3[i2++] = c2;
      for (f2 = 0; f2 < u2.length; f2++)
        n2[r3++] = a2 + u2[f2];
    }, e3._drawCallPool = [], e3._textureArrayPool = [], e3;
  }(ox), wb = function() {
    function t3(t4, e3) {
      if (this.vertexSrc = t4, this.fragTemplate = e3, this.programCache = {}, this.defaultGroupCache = {}, e3.indexOf("%count%") < 0)
        throw new Error('Fragment template must contain "%count%".');
      if (e3.indexOf("%forloop%") < 0)
        throw new Error('Fragment template must contain "%forloop%".');
    }
    return t3.prototype.generateShader = function(t4) {
      if (!this.programCache[t4]) {
        for (var e3 = new Int32Array(t4), n2 = 0; n2 < t4; n2++)
          e3[n2] = n2;
        this.defaultGroupCache[t4] = tx.from({ uSamplers: e3 }, true);
        var i2 = this.fragTemplate;
        i2 = (i2 = i2.replace(/%count%/gi, "" + t4)).replace(/%forloop%/gi, this.generateSampleSrc(t4)), this.programCache[t4] = new Bx(this.vertexSrc, i2);
      }
      var r3 = { tint: new Float32Array([1, 1, 1, 1]), translationMatrix: new y_(), default: this.defaultGroupCache[t4] };
      return new Ux(this.programCache[t4], r3);
    }, t3.prototype.generateSampleSrc = function(t4) {
      var e3 = "";
      e3 += "\n", e3 += "\n";
      for (var n2 = 0; n2 < t4; n2++)
        n2 > 0 && (e3 += "\nelse "), n2 < t4 - 1 && (e3 += "if(vTextureId < " + n2 + ".5)"), e3 += "\n{", e3 += "\n	color = texture2D(uSamplers[" + n2 + "], vTextureCoord);", e3 += "\n}";
      return e3 += "\n", e3 += "\n";
    }, t3;
  }(), Sb = function(t3) {
    function e3(e4) {
      e4 === void 0 && (e4 = false);
      var n2 = t3.call(this) || this;
      return n2._buffer = new Wy(null, e4, false), n2._indexBuffer = new Wy(null, e4, true), n2.addAttribute("aVertexPosition", n2._buffer, 2, false, iv.FLOAT).addAttribute("aTextureCoord", n2._buffer, 2, false, iv.FLOAT).addAttribute("aColor", n2._buffer, 4, true, iv.UNSIGNED_BYTE).addAttribute("aTextureId", n2._buffer, 1, true, iv.FLOAT).addIndex(n2._indexBuffer), n2;
    }
    return _y(e3, t3), e3;
  }(Jy), Eb = "precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor * tint;\n}\n", Mb = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = color * vColor;\n}\n", Ab = function() {
    function t3() {
    }
    return t3.create = function(t4) {
      var e3 = Object.assign({ vertex: Eb, fragment: Mb, geometryClass: Sb, vertexSize: 6 }, t4), n2 = e3.vertex, i2 = e3.fragment, r3 = e3.vertexSize, o3 = e3.geometryClass;
      return function(t5) {
        function e4(e5) {
          var s3 = t5.call(this, e5) || this;
          return s3.shaderGenerator = new wb(n2, i2), s3.geometryClass = o3, s3.vertexSize = r3, s3;
        }
        return _y(e4, t5), e4;
      }(Tb);
    }, Object.defineProperty(t3, "defaultVertexSrc", { get: function() {
      return Eb;
    }, enumerable: false, configurable: true }), Object.defineProperty(t3, "defaultFragmentTemplate", { get: function() {
      return Mb;
    }, enumerable: false, configurable: true }), t3;
  }().create(), Rb = {}, Pb = function(t3) {
    Object.defineProperty(Rb, t3, { get: function() {
      return Zv("6.0.0", "PIXI.systems." + t3 + " has moved to PIXI." + t3), Ly[t3];
    } });
  };
  for (var Cb in Ly)
    Pb(Cb);
  var Ib = {}, Ob = function(t3) {
    Object.defineProperty(Ib, t3, { get: function() {
      return Zv("6.0.0", "PIXI.resources." + t3 + " has moved to PIXI." + t3), db[t3];
    } });
  };
  for (var Cb in db)
    Ob(Cb);
  /*!
   * @pixi/app - v6.2.0
   * Compiled Mon, 01 Nov 2021 16:52:10 UTC
   *
   * @pixi/app is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   */
  var Lb = function() {
    function t3(e3) {
      var n2 = this;
      this.stage = new ty(), e3 = Object.assign({ forceCanvas: false }, e3), this.renderer = function(t4) {
        return vb.create(t4);
      }(e3), t3._plugins.forEach(function(t4) {
        t4.init.call(n2, e3);
      });
    }
    return t3.registerPlugin = function(e3) {
      t3._plugins.push(e3);
    }, t3.prototype.render = function() {
      this.renderer.render(this.stage);
    }, Object.defineProperty(t3.prototype, "view", { get: function() {
      return this.renderer.view;
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "screen", { get: function() {
      return this.renderer.screen;
    }, enumerable: false, configurable: true }), t3.prototype.destroy = function(e3, n2) {
      var i2 = this, r3 = t3._plugins.slice(0);
      r3.reverse(), r3.forEach(function(t4) {
        t4.destroy.call(i2);
      }), this.stage.destroy(n2), this.stage = null, this.renderer.destroy(e3), this.renderer = null;
    }, t3._plugins = [], t3;
  }(), Nb = function() {
    function t3() {
    }
    return t3.init = function(t4) {
      var e3 = this;
      Object.defineProperty(this, "resizeTo", { set: function(t5) {
        self.removeEventListener("resize", this.queueResize), this._resizeTo = t5, t5 && (self.addEventListener("resize", this.queueResize), this.resize());
      }, get: function() {
        return this._resizeTo;
      } }), this.queueResize = function() {
        e3._resizeTo && (e3.cancelResize(), e3._resizeId = requestAnimationFrame(function() {
          return e3.resize();
        }));
      }, this.cancelResize = function() {
        e3._resizeId && (cancelAnimationFrame(e3._resizeId), e3._resizeId = null);
      }, this.resize = function() {
        if (e3._resizeTo) {
          var t5, n2;
          if (e3.cancelResize(), e3._resizeTo === self)
            t5 = self.innerWidth, n2 = self.innerHeight;
          else {
            var i2 = e3._resizeTo;
            t5 = i2.clientWidth, n2 = i2.clientHeight;
          }
          e3.renderer.resize(t5, n2);
        }
      }, this._resizeId = null, this._resizeTo = null, this.resizeTo = t4.resizeTo || null;
    }, t3.destroy = function() {
      self.removeEventListener("resize", this.queueResize), this.cancelResize(), this.cancelResize = null, this.queueResize = null, this.resizeTo = null, this.resize = null;
    }, t3;
  }();
  Lb.registerPlugin(Nb);
  /*!
   * @pixi/extract - v6.2.0
   * Compiled Mon, 01 Nov 2021 16:52:10 UTC
   *
   * @pixi/extract is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   */
  var Db = new d_(), Fb = function() {
    function t3(t4) {
      this.renderer = t4;
    }
    return t3.prototype.image = function(t4, e3, n2) {
      var i2 = new Image();
      return i2.src = this.base64(t4, e3, n2), i2;
    }, t3.prototype.base64 = function(t4, e3, n2) {
      return this.canvas(t4).toDataURL(e3, n2);
    }, t3.prototype.canvas = function(e3) {
      var n2, i2, r3, o3 = this.renderer, s3 = false, a2 = false;
      e3 && (e3 instanceof Hy ? r3 = e3 : (r3 = this.renderer.generateTexture(e3), a2 = true)), r3 ? (n2 = r3.baseTexture.resolution, i2 = r3.frame, s3 = false, o3.renderTexture.bind(r3)) : (n2 = this.renderer.resolution, s3 = true, (i2 = Db).width = this.renderer.width, i2.height = this.renderer.height, o3.renderTexture.bind(null));
      var l2 = Math.floor(i2.width * n2 + 1e-4), u2 = Math.floor(i2.height * n2 + 1e-4), h2 = new e_(l2, u2, 1), c2 = new Uint8Array(4 * l2 * u2), d2 = o3.gl;
      d2.readPixels(i2.x * n2, i2.y * n2, l2, u2, d2.RGBA, d2.UNSIGNED_BYTE, c2);
      var p2 = h2.context.getImageData(0, 0, l2, u2);
      if (t3.arrayPostDivide(c2, p2.data), h2.context.putImageData(p2, 0, 0), s3) {
        var f2 = new e_(h2.width, h2.height, 1);
        f2.context.scale(1, -1), f2.context.drawImage(h2.canvas, 0, -u2), h2.destroy(), h2 = f2;
      }
      return a2 && r3.destroy(true), h2.canvas;
    }, t3.prototype.pixels = function(e3) {
      var n2, i2, r3, o3 = this.renderer, s3 = false;
      e3 && (e3 instanceof Hy ? r3 = e3 : (r3 = this.renderer.generateTexture(e3), s3 = true)), r3 ? (n2 = r3.baseTexture.resolution, i2 = r3.frame, o3.renderTexture.bind(r3)) : (n2 = o3.resolution, (i2 = Db).width = o3.width, i2.height = o3.height, o3.renderTexture.bind(null));
      var a2 = i2.width * n2, l2 = i2.height * n2, u2 = new Uint8Array(4 * a2 * l2), h2 = o3.gl;
      return h2.readPixels(i2.x * n2, i2.y * n2, a2, l2, h2.RGBA, h2.UNSIGNED_BYTE, u2), s3 && r3.destroy(true), t3.arrayPostDivide(u2, u2), u2;
    }, t3.prototype.destroy = function() {
      this.renderer = null;
    }, t3.arrayPostDivide = function(t4, e3) {
      for (var n2 = 0; n2 < t4.length; n2 += 4) {
        var i2 = e3[n2 + 3] = t4[n2 + 3];
        i2 !== 0 ? (e3[n2] = Math.round(Math.min(255 * t4[n2] / i2, 255)), e3[n2 + 1] = Math.round(Math.min(255 * t4[n2 + 1] / i2, 255)), e3[n2 + 2] = Math.round(Math.min(255 * t4[n2 + 2] / i2, 255))) : (e3[n2] = t4[n2], e3[n2 + 1] = t4[n2 + 1], e3[n2 + 2] = t4[n2 + 2]);
      }
    }, t3;
  }(), Bb = function() {
    function t3(t4, e3, n2) {
      e3 === void 0 && (e3 = false), this._fn = t4, this._once = e3, this._thisArg = n2, this._next = this._prev = this._owner = null;
    }
    return t3.prototype.detach = function() {
      return this._owner !== null && (this._owner.detach(this), true);
    }, t3;
  }();
  function Ub(t3, e3) {
    return t3._head ? (t3._tail._next = e3, e3._prev = t3._tail, t3._tail = e3) : (t3._head = e3, t3._tail = e3), e3._owner = t3, e3;
  }
  var kb = function() {
    function t3() {
      this._head = this._tail = void 0;
    }
    return t3.prototype.handlers = function(t4) {
      t4 === void 0 && (t4 = false);
      var e3 = this._head;
      if (t4)
        return !!e3;
      for (var n2 = []; e3; )
        n2.push(e3), e3 = e3._next;
      return n2;
    }, t3.prototype.has = function(t4) {
      if (!(t4 instanceof Bb))
        throw new Error("MiniSignal#has(): First arg must be a SignalBinding object.");
      return t4._owner === this;
    }, t3.prototype.dispatch = function() {
      for (var t4 = arguments, e3 = [], n2 = 0; n2 < arguments.length; n2++)
        e3[n2] = t4[n2];
      var i2 = this._head;
      if (!i2)
        return false;
      for (; i2; )
        i2._once && this.detach(i2), i2._fn.apply(i2._thisArg, e3), i2 = i2._next;
      return true;
    }, t3.prototype.add = function(t4, e3) {
      if (e3 === void 0 && (e3 = null), typeof t4 != "function")
        throw new Error("MiniSignal#add(): First arg must be a Function.");
      return Ub(this, new Bb(t4, false, e3));
    }, t3.prototype.once = function(t4, e3) {
      if (e3 === void 0 && (e3 = null), typeof t4 != "function")
        throw new Error("MiniSignal#once(): First arg must be a Function.");
      return Ub(this, new Bb(t4, true, e3));
    }, t3.prototype.detach = function(t4) {
      if (!(t4 instanceof Bb))
        throw new Error("MiniSignal#detach(): First arg must be a SignalBinding object.");
      return t4._owner !== this || (t4._prev && (t4._prev._next = t4._next), t4._next && (t4._next._prev = t4._prev), t4 === this._head ? (this._head = t4._next, t4._next === null && (this._tail = null)) : t4 === this._tail && (this._tail = t4._prev, this._tail._next = null), t4._owner = null), this;
    }, t3.prototype.detachAll = function() {
      var t4 = this._head;
      if (!t4)
        return this;
      for (this._head = this._tail = null; t4; )
        t4._owner = null, t4 = t4._next;
      return this;
    }, t3;
  }();
  function Gb(t3, e3) {
    e3 = e3 || {};
    for (var n2 = { key: ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"], q: { name: "queryKey", parser: /(?:^|&)([^&=]*)=?([^&]*)/g }, parser: { strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/, loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/ } }, i2 = n2.parser[e3.strictMode ? "strict" : "loose"].exec(t3), r3 = {}, o3 = 14; o3--; )
      r3[n2.key[o3]] = i2[o3] || "";
    return r3[n2.q.name] = {}, r3[n2.key[12]].replace(n2.q.parser, function(t4, e4, i3) {
      e4 && (r3[n2.q.name][e4] = i3);
    }), r3;
  }
  var Hb = !(!self.XDomainRequest || "withCredentials" in new XMLHttpRequest()), zb = null;
  function jb() {
  }
  function Vb(t3, e3, n2) {
    e3 && e3.indexOf(".") === 0 && (e3 = e3.substring(1)), e3 && (t3[e3] = n2);
  }
  function Wb(t3) {
    return t3.toString().replace("object ", "");
  }
  var Xb = function() {
    function t3(e3, n2, i2) {
      if (this._dequeue = jb, this._onLoadBinding = null, this._elementTimer = 0, this._boundComplete = null, this._boundOnError = null, this._boundOnProgress = null, this._boundOnTimeout = null, this._boundXhrOnError = null, this._boundXhrOnTimeout = null, this._boundXhrOnAbort = null, this._boundXhrOnLoad = null, typeof e3 != "string" || typeof n2 != "string")
        throw new Error("Both name and url are required for constructing a resource.");
      i2 = i2 || {}, this._flags = 0, this._setFlag(t3.STATUS_FLAGS.DATA_URL, n2.indexOf("data:") === 0), this.name = e3, this.url = n2, this.extension = this._getExtension(), this.data = null, this.crossOrigin = i2.crossOrigin === true ? "anonymous" : i2.crossOrigin, this.timeout = i2.timeout || 0, this.loadType = i2.loadType || this._determineLoadType(), this.xhrType = i2.xhrType, this.metadata = i2.metadata || {}, this.error = null, this.xhr = null, this.children = [], this.type = t3.TYPE.UNKNOWN, this.progressChunk = 0, this._dequeue = jb, this._onLoadBinding = null, this._elementTimer = 0, this._boundComplete = this.complete.bind(this), this._boundOnError = this._onError.bind(this), this._boundOnProgress = this._onProgress.bind(this), this._boundOnTimeout = this._onTimeout.bind(this), this._boundXhrOnError = this._xhrOnError.bind(this), this._boundXhrOnTimeout = this._xhrOnTimeout.bind(this), this._boundXhrOnAbort = this._xhrOnAbort.bind(this), this._boundXhrOnLoad = this._xhrOnLoad.bind(this), this.onStart = new kb(), this.onProgress = new kb(), this.onComplete = new kb(), this.onAfterMiddleware = new kb();
    }
    return t3.setExtensionLoadType = function(e3, n2) {
      Vb(t3._loadTypeMap, e3, n2);
    }, t3.setExtensionXhrType = function(e3, n2) {
      Vb(t3._xhrTypeMap, e3, n2);
    }, Object.defineProperty(t3.prototype, "isDataUrl", { get: function() {
      return this._hasFlag(t3.STATUS_FLAGS.DATA_URL);
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "isComplete", { get: function() {
      return this._hasFlag(t3.STATUS_FLAGS.COMPLETE);
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "isLoading", { get: function() {
      return this._hasFlag(t3.STATUS_FLAGS.LOADING);
    }, enumerable: false, configurable: true }), t3.prototype.complete = function() {
      this._clearEvents(), this._finish();
    }, t3.prototype.abort = function(e3) {
      if (!this.error) {
        if (this.error = new Error(e3), this._clearEvents(), this.xhr)
          this.xhr.abort();
        else if (this.xdr)
          this.xdr.abort();
        else if (this.data)
          if (this.data.src)
            this.data.src = t3.EMPTY_GIF;
          else
            for (; this.data.firstChild; )
              this.data.removeChild(this.data.firstChild);
        this._finish();
      }
    }, t3.prototype.load = function(e3) {
      var n2 = this;
      if (!this.isLoading)
        if (this.isComplete)
          e3 && setTimeout(function() {
            return e3(n2);
          }, 1);
        else
          switch (e3 && this.onComplete.once(e3), this._setFlag(t3.STATUS_FLAGS.LOADING, true), this.onStart.dispatch(this), this.crossOrigin !== false && typeof this.crossOrigin == "string" || (this.crossOrigin = this._determineCrossOrigin(this.url)), this.loadType) {
            case t3.LOAD_TYPE.IMAGE:
              this.type = t3.TYPE.IMAGE, this._loadElement("image");
              break;
            case t3.LOAD_TYPE.AUDIO:
              this.type = t3.TYPE.AUDIO, this._loadSourceElement("audio");
              break;
            case t3.LOAD_TYPE.VIDEO:
              this.type = t3.TYPE.VIDEO, this._loadSourceElement("video");
              break;
            case t3.LOAD_TYPE.XHR:
            default:
              Hb && this.crossOrigin ? this._loadXdr() : this._loadXhr();
          }
    }, t3.prototype._hasFlag = function(t4) {
      return (this._flags & t4) != 0;
    }, t3.prototype._setFlag = function(t4, e3) {
      this._flags = e3 ? this._flags | t4 : this._flags & ~t4;
    }, t3.prototype._clearEvents = function() {
      clearTimeout(this._elementTimer), this.data && this.data.removeEventListener && (this.data.removeEventListener("error", this._boundOnError, false), this.data.removeEventListener("load", this._boundComplete, false), this.data.removeEventListener("progress", this._boundOnProgress, false), this.data.removeEventListener("canplaythrough", this._boundComplete, false)), this.xhr && (this.xhr.removeEventListener ? (this.xhr.removeEventListener("error", this._boundXhrOnError, false), this.xhr.removeEventListener("timeout", this._boundXhrOnTimeout, false), this.xhr.removeEventListener("abort", this._boundXhrOnAbort, false), this.xhr.removeEventListener("progress", this._boundOnProgress, false), this.xhr.removeEventListener("load", this._boundXhrOnLoad, false)) : (this.xhr.onerror = null, this.xhr.ontimeout = null, this.xhr.onprogress = null, this.xhr.onload = null));
    }, t3.prototype._finish = function() {
      if (this.isComplete)
        throw new Error("Complete called again for an already completed resource.");
      this._setFlag(t3.STATUS_FLAGS.COMPLETE, true), this._setFlag(t3.STATUS_FLAGS.LOADING, false), this.onComplete.dispatch(this);
    }, t3.prototype._loadElement = function(t4) {
      this.metadata.loadElement ? this.data = this.metadata.loadElement : t4 === "image" && self.Image !== void 0 ? this.data = new Image() : this.data = document.createElement(t4), this.crossOrigin && (this.data.crossOrigin = this.crossOrigin), this.metadata.skipSource || (this.data.src = this.url), this.data.addEventListener("error", this._boundOnError, false), this.data.addEventListener("load", this._boundComplete, false), this.data.addEventListener("progress", this._boundOnProgress, false), this.timeout && (this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout));
    }, t3.prototype._loadSourceElement = function(t4) {
      if (this.metadata.loadElement ? this.data = this.metadata.loadElement : t4 === "audio" && self.Audio !== void 0 ? this.data = new Audio() : this.data = document.createElement(t4), this.data !== null) {
        if (this.crossOrigin && (this.data.crossOrigin = this.crossOrigin), !this.metadata.skipSource)
          if (navigator.isCocoonJS)
            this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;
          else if (Array.isArray(this.url))
            for (var e3 = this.metadata.mimeType, n2 = 0; n2 < this.url.length; ++n2)
              this.data.appendChild(this._createSource(t4, this.url[n2], Array.isArray(e3) ? e3[n2] : e3));
          else {
            e3 = this.metadata.mimeType;
            this.data.appendChild(this._createSource(t4, this.url, Array.isArray(e3) ? e3[0] : e3));
          }
        this.data.addEventListener("error", this._boundOnError, false), this.data.addEventListener("load", this._boundComplete, false), this.data.addEventListener("progress", this._boundOnProgress, false), this.data.addEventListener("canplaythrough", this._boundComplete, false), this.data.load(), this.timeout && (this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout));
      } else
        this.abort("Unsupported element: " + t4);
    }, t3.prototype._loadXhr = function() {
      typeof this.xhrType != "string" && (this.xhrType = this._determineXhrType());
      var e3 = this.xhr = new XMLHttpRequest();
      e3.open("GET", this.url, true), e3.timeout = this.timeout, this.xhrType === t3.XHR_RESPONSE_TYPE.JSON || this.xhrType === t3.XHR_RESPONSE_TYPE.DOCUMENT ? e3.responseType = t3.XHR_RESPONSE_TYPE.TEXT : e3.responseType = this.xhrType, e3.addEventListener("error", this._boundXhrOnError, false), e3.addEventListener("timeout", this._boundXhrOnTimeout, false), e3.addEventListener("abort", this._boundXhrOnAbort, false), e3.addEventListener("progress", this._boundOnProgress, false), e3.addEventListener("load", this._boundXhrOnLoad, false), e3.send();
    }, t3.prototype._loadXdr = function() {
      typeof this.xhrType != "string" && (this.xhrType = this._determineXhrType());
      var t4 = this.xhr = new self.XDomainRequest();
      t4.timeout = this.timeout || 5e3, t4.onerror = this._boundXhrOnError, t4.ontimeout = this._boundXhrOnTimeout, t4.onprogress = this._boundOnProgress, t4.onload = this._boundXhrOnLoad, t4.open("GET", this.url, true), setTimeout(function() {
        return t4.send();
      }, 1);
    }, t3.prototype._createSource = function(t4, e3, n2) {
      n2 || (n2 = t4 + "/" + this._getExtension(e3));
      var i2 = document.createElement("source");
      return i2.src = e3, i2.type = n2, i2;
    }, t3.prototype._onError = function(t4) {
      this.abort("Failed to load element using: " + t4.target.nodeName);
    }, t3.prototype._onProgress = function(t4) {
      t4 && t4.lengthComputable && this.onProgress.dispatch(this, t4.loaded / t4.total);
    }, t3.prototype._onTimeout = function() {
      this.abort("Load timed out.");
    }, t3.prototype._xhrOnError = function() {
      var t4 = this.xhr;
      this.abort(Wb(t4) + " Request failed. Status: " + t4.status + ', text: "' + t4.statusText + '"');
    }, t3.prototype._xhrOnTimeout = function() {
      var t4 = this.xhr;
      this.abort(Wb(t4) + " Request timed out.");
    }, t3.prototype._xhrOnAbort = function() {
      var t4 = this.xhr;
      this.abort(Wb(t4) + " Request was aborted by the user.");
    }, t3.prototype._xhrOnLoad = function() {
      var e3 = this.xhr, n2 = "", i2 = e3.status === void 0 ? 200 : e3.status;
      if (e3.responseType !== "" && e3.responseType !== "text" && e3.responseType !== void 0 || (n2 = e3.responseText), i2 === 0 && (n2.length > 0 || e3.responseType === t3.XHR_RESPONSE_TYPE.BUFFER) ? i2 = 200 : i2 === 1223 && (i2 = 204), (i2 / 100 | 0) === 2) {
        if (this.xhrType === t3.XHR_RESPONSE_TYPE.TEXT)
          this.data = n2, this.type = t3.TYPE.TEXT;
        else if (this.xhrType === t3.XHR_RESPONSE_TYPE.JSON)
          try {
            this.data = JSON.parse(n2), this.type = t3.TYPE.JSON;
          } catch (t4) {
            return void this.abort("Error trying to parse loaded json: " + t4);
          }
        else if (this.xhrType === t3.XHR_RESPONSE_TYPE.DOCUMENT)
          try {
            if (self.DOMParser) {
              var r3 = new DOMParser();
              this.data = r3.parseFromString(n2, "text/xml");
            } else {
              var o3 = document.createElement("div");
              o3.innerHTML = n2, this.data = o3;
            }
            this.type = t3.TYPE.XML;
          } catch (t4) {
            return void this.abort("Error trying to parse loaded xml: " + t4);
          }
        else
          this.data = e3.response || n2;
        this.complete();
      } else
        this.abort("[" + e3.status + "] " + e3.statusText + ": " + e3.responseURL);
    }, t3.prototype._determineCrossOrigin = function(t4, e3) {
      if (t4.indexOf("data:") === 0)
        return "";
      if (self.origin !== self.location.origin)
        return "anonymous";
      e3 = e3 || self.location, zb || (zb = document.createElement("a")), zb.href = t4;
      var n2 = Gb(zb.href, { strictMode: true }), i2 = !n2.port && e3.port === "" || n2.port === e3.port, r3 = n2.protocol ? n2.protocol + ":" : "";
      return n2.host === e3.hostname && i2 && r3 === e3.protocol ? "" : "anonymous";
    }, t3.prototype._determineXhrType = function() {
      return t3._xhrTypeMap[this.extension] || t3.XHR_RESPONSE_TYPE.TEXT;
    }, t3.prototype._determineLoadType = function() {
      return t3._loadTypeMap[this.extension] || t3.LOAD_TYPE.XHR;
    }, t3.prototype._getExtension = function(t4) {
      t4 === void 0 && (t4 = this.url);
      var e3 = "";
      if (this.isDataUrl) {
        var n2 = t4.indexOf("/");
        e3 = t4.substring(n2 + 1, t4.indexOf(";", n2));
      } else {
        var i2 = t4.indexOf("?"), r3 = t4.indexOf("#"), o3 = Math.min(i2 > -1 ? i2 : t4.length, r3 > -1 ? r3 : t4.length);
        e3 = (t4 = t4.substring(0, o3)).substring(t4.lastIndexOf(".") + 1);
      }
      return e3.toLowerCase();
    }, t3.prototype._getMimeFromXhrType = function(e3) {
      switch (e3) {
        case t3.XHR_RESPONSE_TYPE.BUFFER:
          return "application/octet-binary";
        case t3.XHR_RESPONSE_TYPE.BLOB:
          return "application/blob";
        case t3.XHR_RESPONSE_TYPE.DOCUMENT:
          return "application/xml";
        case t3.XHR_RESPONSE_TYPE.JSON:
          return "application/json";
        case t3.XHR_RESPONSE_TYPE.DEFAULT:
        case t3.XHR_RESPONSE_TYPE.TEXT:
        default:
          return "text/plain";
      }
    }, t3;
  }();
  function qb() {
  }
  function Yb(t3) {
    return function() {
      for (var e3 = arguments, n2 = [], i2 = 0; i2 < arguments.length; i2++)
        n2[i2] = e3[i2];
      if (t3 === null)
        throw new Error("Callback was already called.");
      var r3 = t3;
      t3 = null, r3.apply(this, n2);
    };
  }
  !function(t3) {
    !function(t4) {
      t4[t4.NONE = 0] = "NONE", t4[t4.DATA_URL = 1] = "DATA_URL", t4[t4.COMPLETE = 2] = "COMPLETE", t4[t4.LOADING = 4] = "LOADING";
    }(t3.STATUS_FLAGS || (t3.STATUS_FLAGS = {})), function(t4) {
      t4[t4.UNKNOWN = 0] = "UNKNOWN", t4[t4.JSON = 1] = "JSON", t4[t4.XML = 2] = "XML", t4[t4.IMAGE = 3] = "IMAGE", t4[t4.AUDIO = 4] = "AUDIO", t4[t4.VIDEO = 5] = "VIDEO", t4[t4.TEXT = 6] = "TEXT";
    }(t3.TYPE || (t3.TYPE = {})), function(t4) {
      t4[t4.XHR = 1] = "XHR", t4[t4.IMAGE = 2] = "IMAGE", t4[t4.AUDIO = 3] = "AUDIO", t4[t4.VIDEO = 4] = "VIDEO";
    }(t3.LOAD_TYPE || (t3.LOAD_TYPE = {})), function(t4) {
      t4.DEFAULT = "text", t4.BUFFER = "arraybuffer", t4.BLOB = "blob", t4.DOCUMENT = "document", t4.JSON = "json", t4.TEXT = "text";
    }(t3.XHR_RESPONSE_TYPE || (t3.XHR_RESPONSE_TYPE = {})), t3._loadTypeMap = { gif: t3.LOAD_TYPE.IMAGE, png: t3.LOAD_TYPE.IMAGE, bmp: t3.LOAD_TYPE.IMAGE, jpg: t3.LOAD_TYPE.IMAGE, jpeg: t3.LOAD_TYPE.IMAGE, tif: t3.LOAD_TYPE.IMAGE, tiff: t3.LOAD_TYPE.IMAGE, webp: t3.LOAD_TYPE.IMAGE, tga: t3.LOAD_TYPE.IMAGE, svg: t3.LOAD_TYPE.IMAGE, "svg+xml": t3.LOAD_TYPE.IMAGE, mp3: t3.LOAD_TYPE.AUDIO, ogg: t3.LOAD_TYPE.AUDIO, wav: t3.LOAD_TYPE.AUDIO, mp4: t3.LOAD_TYPE.VIDEO, webm: t3.LOAD_TYPE.VIDEO }, t3._xhrTypeMap = { xhtml: t3.XHR_RESPONSE_TYPE.DOCUMENT, html: t3.XHR_RESPONSE_TYPE.DOCUMENT, htm: t3.XHR_RESPONSE_TYPE.DOCUMENT, xml: t3.XHR_RESPONSE_TYPE.DOCUMENT, tmx: t3.XHR_RESPONSE_TYPE.DOCUMENT, svg: t3.XHR_RESPONSE_TYPE.DOCUMENT, tsx: t3.XHR_RESPONSE_TYPE.DOCUMENT, gif: t3.XHR_RESPONSE_TYPE.BLOB, png: t3.XHR_RESPONSE_TYPE.BLOB, bmp: t3.XHR_RESPONSE_TYPE.BLOB, jpg: t3.XHR_RESPONSE_TYPE.BLOB, jpeg: t3.XHR_RESPONSE_TYPE.BLOB, tif: t3.XHR_RESPONSE_TYPE.BLOB, tiff: t3.XHR_RESPONSE_TYPE.BLOB, webp: t3.XHR_RESPONSE_TYPE.BLOB, tga: t3.XHR_RESPONSE_TYPE.BLOB, json: t3.XHR_RESPONSE_TYPE.JSON, text: t3.XHR_RESPONSE_TYPE.TEXT, txt: t3.XHR_RESPONSE_TYPE.TEXT, ttf: t3.XHR_RESPONSE_TYPE.BUFFER, otf: t3.XHR_RESPONSE_TYPE.BUFFER }, t3.EMPTY_GIF = "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==";
  }(Xb || (Xb = {}));
  var Zb = function(t3, e3) {
    this.data = t3, this.callback = e3;
  }, Jb = function() {
    function t3(t4, e3) {
      var n2 = this;
      if (e3 === void 0 && (e3 = 1), this.workers = 0, this.saturated = qb, this.unsaturated = qb, this.empty = qb, this.drain = qb, this.error = qb, this.started = false, this.paused = false, this._tasks = [], this._insert = function(t5, e4, i2) {
        if (i2 && typeof i2 != "function")
          throw new Error("task callback must be a function");
        if (n2.started = true, t5 == null && n2.idle())
          setTimeout(function() {
            return n2.drain();
          }, 1);
        else {
          var r3 = new Zb(t5, typeof i2 == "function" ? i2 : qb);
          e4 ? n2._tasks.unshift(r3) : n2._tasks.push(r3), setTimeout(n2.process, 1);
        }
      }, this.process = function() {
        for (; !n2.paused && n2.workers < n2.concurrency && n2._tasks.length; ) {
          var t5 = n2._tasks.shift();
          n2._tasks.length === 0 && n2.empty(), n2.workers += 1, n2.workers === n2.concurrency && n2.saturated(), n2._worker(t5.data, Yb(n2._next(t5)));
        }
      }, this._worker = t4, e3 === 0)
        throw new Error("Concurrency must not be zero");
      this.concurrency = e3, this.buffer = e3 / 4;
    }
    return t3.prototype._next = function(t4) {
      var e3 = this;
      return function() {
        for (var n2 = arguments, i2 = [], r3 = 0; r3 < arguments.length; r3++)
          i2[r3] = n2[r3];
        e3.workers -= 1, t4.callback.apply(t4, i2), i2[0] != null && e3.error(i2[0], t4.data), e3.workers <= e3.concurrency - e3.buffer && e3.unsaturated(), e3.idle() && e3.drain(), e3.process();
      };
    }, t3.prototype.push = function(t4, e3) {
      this._insert(t4, false, e3);
    }, t3.prototype.kill = function() {
      this.workers = 0, this.drain = qb, this.started = false, this._tasks = [];
    }, t3.prototype.unshift = function(t4, e3) {
      this._insert(t4, true, e3);
    }, t3.prototype.length = function() {
      return this._tasks.length;
    }, t3.prototype.running = function() {
      return this.workers;
    }, t3.prototype.idle = function() {
      return this._tasks.length + this.workers === 0;
    }, t3.prototype.pause = function() {
      this.paused !== true && (this.paused = true);
    }, t3.prototype.resume = function() {
      if (this.paused !== false) {
        this.paused = false;
        for (var t4 = 1; t4 <= this.concurrency; t4++)
          this.process();
      }
    }, t3.eachSeries = function(t4, e3, n2, i2) {
      var r3 = 0, o3 = t4.length;
      !function s3(a2) {
        a2 || r3 === o3 ? n2 && n2(a2) : i2 ? setTimeout(function() {
          e3(t4[r3++], s3);
        }, 1) : e3(t4[r3++], s3);
      }();
    }, t3.queue = function(e3, n2) {
      return new t3(e3, n2);
    }, t3;
  }(), $b = /(#[\w-]+)?$/, Kb = function() {
    function t3(e3, n2) {
      var i2 = this;
      e3 === void 0 && (e3 = ""), n2 === void 0 && (n2 = 10), this._beforeMiddleware = [], this._afterMiddleware = [], this._resourcesParsing = [], this._boundLoadResource = function(t4, e4) {
        return i2._loadResource(t4, e4);
      }, this.resources = {}, this.baseUrl = e3, this.progress = 0, this.loading = false, this.defaultQueryString = "", this._beforeMiddleware = [], this._afterMiddleware = [], this._resourcesParsing = [], this._boundLoadResource = function(t4, e4) {
        return i2._loadResource(t4, e4);
      }, this._queue = Jb.queue(this._boundLoadResource, n2), this._queue.pause(), this.resources = {}, this.onProgress = new kb(), this.onError = new kb(), this.onLoad = new kb(), this.onStart = new kb(), this.onComplete = new kb();
      for (var r3 = 0; r3 < t3._plugins.length; ++r3) {
        var o3 = t3._plugins[r3], s3 = o3.pre, a2 = o3.use;
        s3 && this.pre(s3), a2 && this.use(a2);
      }
      this._protected = false;
    }
    return t3.prototype._add = function(t4, e3, n2, i2) {
      if (this.loading && (!n2 || !n2.parentResource))
        throw new Error("Cannot add resources while the loader is running.");
      if (this.resources[t4])
        throw new Error('Resource named "' + t4 + '" already exists.');
      if (e3 = this._prepareUrl(e3), this.resources[t4] = new Xb(t4, e3, n2), typeof i2 == "function" && this.resources[t4].onAfterMiddleware.once(i2), this.loading) {
        for (var r3 = n2.parentResource, o3 = [], s3 = 0; s3 < r3.children.length; ++s3)
          r3.children[s3].isComplete || o3.push(r3.children[s3]);
        var a2 = r3.progressChunk * (o3.length + 1) / (o3.length + 2);
        r3.children.push(this.resources[t4]), r3.progressChunk = a2;
        for (s3 = 0; s3 < o3.length; ++s3)
          o3[s3].progressChunk = a2;
        this.resources[t4].progressChunk = a2;
      }
      return this._queue.push(this.resources[t4]), this;
    }, t3.prototype.pre = function(t4) {
      return this._beforeMiddleware.push(t4), this;
    }, t3.prototype.use = function(t4) {
      return this._afterMiddleware.push(t4), this;
    }, t3.prototype.reset = function() {
      for (var t4 in this.progress = 0, this.loading = false, this._queue.kill(), this._queue.pause(), this.resources) {
        var e3 = this.resources[t4];
        e3._onLoadBinding && e3._onLoadBinding.detach(), e3.isLoading && e3.abort("loader reset");
      }
      return this.resources = {}, this;
    }, t3.prototype.load = function(t4) {
      if (typeof t4 == "function" && this.onComplete.once(t4), this.loading)
        return this;
      if (this._queue.idle())
        this._onStart(), this._onComplete();
      else {
        for (var e3 = 100 / this._queue._tasks.length, n2 = 0; n2 < this._queue._tasks.length; ++n2)
          this._queue._tasks[n2].data.progressChunk = e3;
        this._onStart(), this._queue.resume();
      }
      return this;
    }, Object.defineProperty(t3.prototype, "concurrency", { get: function() {
      return this._queue.concurrency;
    }, set: function(t4) {
      this._queue.concurrency = t4;
    }, enumerable: false, configurable: true }), t3.prototype._prepareUrl = function(t4) {
      var e3, n2 = Gb(t4, { strictMode: true });
      if (e3 = n2.protocol || !n2.path || t4.indexOf("//") === 0 ? t4 : this.baseUrl.length && this.baseUrl.lastIndexOf("/") !== this.baseUrl.length - 1 && t4.charAt(0) !== "/" ? this.baseUrl + "/" + t4 : this.baseUrl + t4, this.defaultQueryString) {
        var i2 = $b.exec(e3)[0];
        (e3 = e3.substr(0, e3.length - i2.length)).indexOf("?") !== -1 ? e3 += "&" + this.defaultQueryString : e3 += "?" + this.defaultQueryString, e3 += i2;
      }
      return e3;
    }, t3.prototype._loadResource = function(t4, e3) {
      var n2 = this;
      t4._dequeue = e3, Jb.eachSeries(this._beforeMiddleware, function(e4, i2) {
        e4.call(n2, t4, function() {
          i2(t4.isComplete ? {} : null);
        });
      }, function() {
        t4.isComplete ? n2._onLoad(t4) : (t4._onLoadBinding = t4.onComplete.once(n2._onLoad, n2), t4.load());
      }, true);
    }, t3.prototype._onStart = function() {
      this.progress = 0, this.loading = true, this.onStart.dispatch(this);
    }, t3.prototype._onComplete = function() {
      this.progress = 100, this.loading = false, this.onComplete.dispatch(this, this.resources);
    }, t3.prototype._onLoad = function(t4) {
      var e3 = this;
      t4._onLoadBinding = null, this._resourcesParsing.push(t4), t4._dequeue(), Jb.eachSeries(this._afterMiddleware, function(n2, i2) {
        n2.call(e3, t4, i2);
      }, function() {
        t4.onAfterMiddleware.dispatch(t4), e3.progress = Math.min(100, e3.progress + t4.progressChunk), e3.onProgress.dispatch(e3, t4), t4.error ? e3.onError.dispatch(t4.error, e3, t4) : e3.onLoad.dispatch(e3, t4), e3._resourcesParsing.splice(e3._resourcesParsing.indexOf(t4), 1), e3._queue.idle() && e3._resourcesParsing.length === 0 && e3._onComplete();
      }, true);
    }, t3.prototype.destroy = function() {
      this._protected || this.reset();
    }, Object.defineProperty(t3, "shared", { get: function() {
      var e3 = t3._shared;
      return e3 || ((e3 = new t3())._protected = true, t3._shared = e3), e3;
    }, enumerable: false, configurable: true }), t3.registerPlugin = function(e3) {
      return t3._plugins.push(e3), e3.add && e3.add(), t3;
    }, t3._plugins = [], t3;
  }();
  Kb.prototype.add = function(t3, e3, n2, i2) {
    if (Array.isArray(t3)) {
      for (var r3 = 0; r3 < t3.length; ++r3)
        this.add(t3[r3]);
      return this;
    }
    if (typeof t3 == "object" && (n2 = t3, i2 = e3 || n2.callback || n2.onComplete, e3 = n2.url, t3 = n2.name || n2.key || n2.url), typeof e3 != "string" && (i2 = n2, n2 = e3, e3 = t3), typeof e3 != "string")
      throw new Error("No url passed to add resource to loader.");
    return typeof n2 == "function" && (i2 = n2, n2 = null), this._add(t3, e3, n2, i2);
  };
  var Qb = function() {
    function t3() {
    }
    return t3.init = function(t4) {
      t4 = Object.assign({ sharedLoader: false }, t4), this.loader = t4.sharedLoader ? Kb.shared : new Kb();
    }, t3.destroy = function() {
      this.loader && (this.loader.destroy(), this.loader = null);
    }, t3;
  }(), tT = function() {
    function t3() {
    }
    return t3.add = function() {
      Xb.setExtensionLoadType("svg", Xb.LOAD_TYPE.XHR), Xb.setExtensionXhrType("svg", Xb.XHR_RESPONSE_TYPE.TEXT);
    }, t3.use = function(t4, e3) {
      if (!t4.data || t4.type !== Xb.TYPE.IMAGE && t4.extension !== "svg")
        e3();
      else {
        var n2 = t4.data, i2 = t4.url, r3 = t4.name, o3 = t4.metadata;
        ky.fromLoader(n2, i2, r3, o3).then(function(n3) {
          t4.texture = n3, e3();
        }).catch(e3);
      }
    }, t3;
  }();
  var eT, nT, iT = self.URL || self.webkitURL;
  Kb.registerPlugin({ use: function(t3, e3) {
    if (t3.data) {
      if (t3.xhr && t3.xhrType === Xb.XHR_RESPONSE_TYPE.BLOB)
        if (self.Blob && typeof t3.data != "string") {
          if (t3.data.type.indexOf("image") === 0) {
            var n2 = iT.createObjectURL(t3.data);
            return t3.blob = t3.data, t3.data = new Image(), t3.data.src = n2, t3.type = Xb.TYPE.IMAGE, void (t3.data.onload = function() {
              iT.revokeObjectURL(n2), t3.data.onload = null, e3();
            });
          }
        } else {
          var i2 = t3.xhr.getResponseHeader("content-type");
          if (i2 && i2.indexOf("image") === 0)
            return t3.data = new Image(), t3.data.src = "data:" + i2 + ";base64," + function(t4) {
              for (var e4 = "", n3 = 0; n3 < t4.length; ) {
                for (var i3 = [0, 0, 0], r3 = [0, 0, 0, 0], o3 = 0; o3 < i3.length; ++o3)
                  n3 < t4.length ? i3[o3] = 255 & t4.charCodeAt(n3++) : i3[o3] = 0;
                switch (r3[0] = i3[0] >> 2, r3[1] = (3 & i3[0]) << 4 | i3[1] >> 4, r3[2] = (15 & i3[1]) << 2 | i3[2] >> 6, r3[3] = 63 & i3[2], n3 - (t4.length - 1)) {
                  case 2:
                    r3[3] = 64, r3[2] = 64;
                    break;
                  case 1:
                    r3[3] = 64;
                }
                for (o3 = 0; o3 < r3.length; ++o3)
                  e4 += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(r3[o3]);
              }
              return e4;
            }(t3.xhr.responseText), t3.type = Xb.TYPE.IMAGE, void (t3.data.onload = function() {
              t3.data.onload = null, e3();
            });
        }
      e3();
    } else
      e3();
  } }), Kb.registerPlugin(tT), function(t3) {
    t3[t3.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT", t3[t3.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT", t3[t3.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT", t3[t3.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT", t3[t3.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT", t3[t3.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT", t3[t3.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT", t3[t3.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT", t3[t3.COMPRESSED_R11_EAC = 37488] = "COMPRESSED_R11_EAC", t3[t3.COMPRESSED_SIGNED_R11_EAC = 37489] = "COMPRESSED_SIGNED_R11_EAC", t3[t3.COMPRESSED_RG11_EAC = 37490] = "COMPRESSED_RG11_EAC", t3[t3.COMPRESSED_SIGNED_RG11_EAC = 37491] = "COMPRESSED_SIGNED_RG11_EAC", t3[t3.COMPRESSED_RGB8_ETC2 = 37492] = "COMPRESSED_RGB8_ETC2", t3[t3.COMPRESSED_RGBA8_ETC2_EAC = 37496] = "COMPRESSED_RGBA8_ETC2_EAC", t3[t3.COMPRESSED_SRGB8_ETC2 = 37493] = "COMPRESSED_SRGB8_ETC2", t3[t3.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC", t3[t3.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", t3[t3.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2", t3[t3.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG", t3[t3.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", t3[t3.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG", t3[t3.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG", t3[t3.COMPRESSED_RGB_ETC1_WEBGL = 36196] = "COMPRESSED_RGB_ETC1_WEBGL", t3[t3.COMPRESSED_RGB_ATC_WEBGL = 35986] = "COMPRESSED_RGB_ATC_WEBGL", t3[t3.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL", t3[t3.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL";
  }(nT || (nT = {}));
  var rT = ((eT = {})[nT.COMPRESSED_RGB_S3TC_DXT1_EXT] = 0.5, eT[nT.COMPRESSED_RGBA_S3TC_DXT1_EXT] = 0.5, eT[nT.COMPRESSED_RGBA_S3TC_DXT3_EXT] = 1, eT[nT.COMPRESSED_RGBA_S3TC_DXT5_EXT] = 1, eT[nT.COMPRESSED_SRGB_S3TC_DXT1_EXT] = 0.5, eT[nT.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT] = 0.5, eT[nT.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT] = 1, eT[nT.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT] = 1, eT[nT.COMPRESSED_R11_EAC] = 0.5, eT[nT.COMPRESSED_SIGNED_R11_EAC] = 0.5, eT[nT.COMPRESSED_RG11_EAC] = 1, eT[nT.COMPRESSED_SIGNED_RG11_EAC] = 1, eT[nT.COMPRESSED_RGB8_ETC2] = 0.5, eT[nT.COMPRESSED_RGBA8_ETC2_EAC] = 1, eT[nT.COMPRESSED_SRGB8_ETC2] = 0.5, eT[nT.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC] = 1, eT[nT.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2] = 0.5, eT[nT.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2] = 0.5, eT[nT.COMPRESSED_RGB_PVRTC_4BPPV1_IMG] = 0.5, eT[nT.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG] = 0.5, eT[nT.COMPRESSED_RGB_PVRTC_2BPPV1_IMG] = 0.25, eT[nT.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG] = 0.25, eT[nT.COMPRESSED_RGB_ETC1_WEBGL] = 0.5, eT[nT.COMPRESSED_RGB_ATC_WEBGL] = 0.5, eT[nT.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL] = 1, eT[nT.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL] = 1, eT), oT = function(t3, e3) {
    return (oT = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e4) {
      t4.__proto__ = e4;
    } || function(t4, e4) {
      for (var n2 in e4)
        e4.hasOwnProperty(n2) && (t4[n2] = e4[n2]);
    })(t3, e3);
  };
  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */
  function sT(t3, e3) {
    function n2() {
      this.constructor = t3;
    }
    oT(t3, e3), t3.prototype = e3 === null ? Object.create(e3) : (n2.prototype = e3.prototype, new n2());
  }
  function aT(t3, e3) {
    var n2, i2, r3, o3, s3 = { label: 0, sent: function() {
      if (1 & r3[0])
        throw r3[1];
      return r3[1];
    }, trys: [], ops: [] };
    return o3 = { next: a2(0), throw: a2(1), return: a2(2) }, typeof Symbol == "function" && (o3[Symbol.iterator] = function() {
      return this;
    }), o3;
    function a2(o4) {
      return function(a3) {
        return function(o5) {
          if (n2)
            throw new TypeError("Generator is already executing.");
          for (; s3; )
            try {
              if (n2 = 1, i2 && (r3 = 2 & o5[0] ? i2.return : o5[0] ? i2.throw || ((r3 = i2.return) && r3.call(i2), 0) : i2.next) && !(r3 = r3.call(i2, o5[1])).done)
                return r3;
              switch (i2 = 0, r3 && (o5 = [2 & o5[0], r3.value]), o5[0]) {
                case 0:
                case 1:
                  r3 = o5;
                  break;
                case 4:
                  return s3.label++, { value: o5[1], done: false };
                case 5:
                  s3.label++, i2 = o5[1], o5 = [0];
                  continue;
                case 7:
                  o5 = s3.ops.pop(), s3.trys.pop();
                  continue;
                default:
                  if (!(r3 = s3.trys, (r3 = r3.length > 0 && r3[r3.length - 1]) || o5[0] !== 6 && o5[0] !== 2)) {
                    s3 = 0;
                    continue;
                  }
                  if (o5[0] === 3 && (!r3 || o5[1] > r3[0] && o5[1] < r3[3])) {
                    s3.label = o5[1];
                    break;
                  }
                  if (o5[0] === 6 && s3.label < r3[1]) {
                    s3.label = r3[1], r3 = o5;
                    break;
                  }
                  if (r3 && s3.label < r3[2]) {
                    s3.label = r3[2], s3.ops.push(o5);
                    break;
                  }
                  r3[2] && s3.ops.pop(), s3.trys.pop();
                  continue;
              }
              o5 = e3.call(t3, s3);
            } catch (t4) {
              o5 = [6, t4], i2 = 0;
            } finally {
              n2 = r3 = 0;
            }
          if (5 & o5[0])
            throw o5[1];
          return { value: o5[0] ? o5[1] : void 0, done: true };
        }([o4, a3]);
      };
    }
  }
  var lT, uT, hT = function(t3) {
    function e3(n2, i2) {
      var r3 = t3.call(this, n2, i2) || this;
      return r3.format = i2.format, r3.levels = i2.levels || 1, r3._width = i2.width, r3._height = i2.height, r3._extension = e3._formatToExtension(r3.format), (i2.levelBuffers || r3.buffer) && (r3._levelBuffers = i2.levelBuffers || e3._createLevelBuffers(n2 instanceof Uint8Array ? n2 : r3.buffer.uint8View, r3.format, r3.levels, 4, 4, r3.width, r3.height)), r3;
    }
    return sT(e3, t3), e3.prototype.upload = function(t4, e4, n2) {
      var i2 = t4.gl;
      if (!t4.context.extensions[this._extension])
        throw new Error(this._extension + " textures are not supported on the current machine");
      if (!this._levelBuffers)
        return false;
      for (var r3 = 0, o3 = this.levels; r3 < o3; r3++) {
        var s3 = this._levelBuffers[r3], a2 = s3.levelID, l2 = s3.levelWidth, u2 = s3.levelHeight, h2 = s3.levelBuffer;
        i2.compressedTexImage2D(i2.TEXTURE_2D, a2, this.format, l2, u2, 0, h2);
      }
      return true;
    }, e3.prototype.onBlobLoaded = function() {
      this._levelBuffers = e3._createLevelBuffers(this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height);
    }, e3._formatToExtension = function(t4) {
      if (t4 >= 33776 && t4 <= 33779)
        return "s3tc";
      if (t4 >= 37488 && t4 <= 37497)
        return "etc";
      if (t4 >= 35840 && t4 <= 35843)
        return "pvrtc";
      if (t4 >= 36196)
        return "etc1";
      if (t4 >= 35986 && t4 <= 34798)
        return "atc";
      throw new Error("Invalid (compressed) texture format given!");
    }, e3._createLevelBuffers = function(t4, e4, n2, i2, r3, o3, s3) {
      for (var a2 = new Array(n2), l2 = t4.byteOffset, u2 = o3, h2 = s3, c2 = u2 + i2 - 1 & ~(i2 - 1), d2 = h2 + r3 - 1 & ~(r3 - 1), p2 = c2 * d2 * rT[e4], f2 = 0; f2 < n2; f2++)
        a2[f2] = { levelID: f2, levelWidth: n2 > 1 ? u2 : c2, levelHeight: n2 > 1 ? h2 : d2, levelBuffer: new Uint8Array(t4.buffer, l2, p2) }, l2 += p2, p2 = (c2 = (u2 = u2 >> 1 || 1) + i2 - 1 & ~(i2 - 1)) * (d2 = (h2 = h2 >> 1 || 1) + r3 - 1 & ~(r3 - 1)) * rT[e4];
      return a2;
    }, e3;
  }(function(t3) {
    function e3(e4, n2) {
      n2 === void 0 && (n2 = { width: 1, height: 1, autoLoad: true });
      var i2, r3, o3 = this;
      return typeof e4 == "string" ? (i2 = e4, r3 = new Uint8Array()) : (i2 = null, r3 = e4), (o3 = t3.call(this, r3, n2) || this).origin = i2, o3.buffer = r3 ? new bb(r3) : null, o3.origin && n2.autoLoad !== false && o3.load(), r3 && r3.length && (o3.loaded = true, o3.onBlobLoaded(o3.buffer.rawBinaryData)), o3;
    }
    return sT(e3, t3), e3.prototype.onBlobLoaded = function(t4) {
    }, e3.prototype.load = function() {
      return t4 = this, e4 = void 0, i2 = function() {
        var t5;
        return aT(this, function(e5) {
          switch (e5.label) {
            case 0:
              return [4, fetch(this.origin)];
            case 1:
              return [4, e5.sent().blob()];
            case 2:
              return [4, e5.sent().arrayBuffer()];
            case 3:
              return t5 = e5.sent(), this.data = new Uint32Array(t5), this.buffer = new bb(t5), this.loaded = true, this.onBlobLoaded(t5), this.update(), [2, this];
          }
        });
      }, new ((n2 = Promise) || (n2 = Promise))(function(r3, o3) {
        function s3(t5) {
          try {
            l2(i2.next(t5));
          } catch (t6) {
            o3(t6);
          }
        }
        function a2(t5) {
          try {
            l2(i2.throw(t5));
          } catch (t6) {
            o3(t6);
          }
        }
        function l2(t5) {
          t5.done ? r3(t5.value) : new n2(function(e5) {
            e5(t5.value);
          }).then(s3, a2);
        }
        l2((i2 = i2.apply(t4, e4 || [])).next());
      });
      var t4, e4, n2, i2;
    }, e3;
  }(by)), cT = function() {
    function t3() {
    }
    return t3.use = function(e3, n2) {
      var i2 = e3.data;
      if (e3.type === Xb.TYPE.JSON && i2 && i2.cacheID && i2.textures) {
        for (var r3 = i2.textures, o3 = void 0, s3 = void 0, a2 = 0, l2 = r3.length; a2 < l2; a2++) {
          var u2 = r3[a2], h2 = u2.src, c2 = u2.format;
          if (c2 || (s3 = h2), t3.textureFormats[c2]) {
            o3 = h2;
            break;
          }
        }
        if (!(o3 = o3 || s3))
          return void n2(new Error("Cannot load compressed-textures in " + e3.url + ", make sure you provide a fallback"));
        if (o3 === e3.url)
          return void n2(new Error("URL of compressed texture cannot be the same as the manifest's URL"));
        var d2 = { crossOrigin: e3.crossOrigin, metadata: e3.metadata.imageMetadata, parentResource: e3 }, p2 = bv.resolve(e3.url.replace(this.baseUrl, ""), o3), f2 = i2.cacheID;
        this.add(f2, p2, d2, function(t4) {
          if (t4.error)
            n2(t4.error);
          else {
            var i3 = t4.texture, r4 = i3 === void 0 ? null : i3, o4 = t4.textures, s4 = o4 === void 0 ? {} : o4;
            Object.assign(e3, { texture: r4, textures: s4 }), n2();
          }
        });
      } else
        n2();
    }, t3.add = function() {
      var e3 = document.createElement("canvas").getContext("webgl");
      if (e3) {
        var n2 = { s3tc: e3.getExtension("WEBGL_compressed_texture_s3tc"), s3tc_sRGB: e3.getExtension("WEBGL_compressed_texture_s3tc_srgb"), etc: e3.getExtension("WEBGL_compressed_texture_etc"), etc1: e3.getExtension("WEBGL_compressed_texture_etc1"), pvrtc: e3.getExtension("WEBGL_compressed_texture_pvrtc") || e3.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"), atc: e3.getExtension("WEBGL_compressed_texture_atc"), astc: e3.getExtension("WEBGL_compressed_texture_astc") };
        for (var i2 in t3.textureExtensions = n2, t3.textureFormats = {}, n2) {
          var r3 = n2[i2];
          r3 && Object.assign(t3.textureFormats, Object.getPrototypeOf(r3));
        }
      } else
        console.warn("WebGL not available for compressed textures. Silently failing.");
    }, t3;
  }();
  function dT(t3, e3, n2) {
    var i2 = { textures: {}, texture: null };
    return e3 ? (e3.map(function(t4) {
      return new ky(new wy(t4, Object.assign({ mipmap: av.OFF, alphaMode: lv.NO_PREMULTIPLIED_ALPHA }, n2)));
    }).forEach(function(e4, n3) {
      var r3 = e4.baseTexture, o3 = t3 + "-" + (n3 + 1);
      wy.addToCache(r3, o3), ky.addToCache(e4, o3), n3 === 0 && (wy.addToCache(r3, t3), ky.addToCache(e4, t3), i2.texture = e4), i2.textures[o3] = e4;
    }), i2) : i2;
  }
  Xb.setExtensionXhrType("dds", Xb.XHR_RESPONSE_TYPE.BUFFER);
  var pT, fT, mT = 3, gT = 4, vT = 7, _T = 19, yT = 2, xT = 0, bT = 1, TT = 2, wT = 3;
  !function(t3) {
    t3[t3.DXGI_FORMAT_UNKNOWN = 0] = "DXGI_FORMAT_UNKNOWN", t3[t3.DXGI_FORMAT_R32G32B32A32_TYPELESS = 1] = "DXGI_FORMAT_R32G32B32A32_TYPELESS", t3[t3.DXGI_FORMAT_R32G32B32A32_FLOAT = 2] = "DXGI_FORMAT_R32G32B32A32_FLOAT", t3[t3.DXGI_FORMAT_R32G32B32A32_UINT = 3] = "DXGI_FORMAT_R32G32B32A32_UINT", t3[t3.DXGI_FORMAT_R32G32B32A32_SINT = 4] = "DXGI_FORMAT_R32G32B32A32_SINT", t3[t3.DXGI_FORMAT_R32G32B32_TYPELESS = 5] = "DXGI_FORMAT_R32G32B32_TYPELESS", t3[t3.DXGI_FORMAT_R32G32B32_FLOAT = 6] = "DXGI_FORMAT_R32G32B32_FLOAT", t3[t3.DXGI_FORMAT_R32G32B32_UINT = 7] = "DXGI_FORMAT_R32G32B32_UINT", t3[t3.DXGI_FORMAT_R32G32B32_SINT = 8] = "DXGI_FORMAT_R32G32B32_SINT", t3[t3.DXGI_FORMAT_R16G16B16A16_TYPELESS = 9] = "DXGI_FORMAT_R16G16B16A16_TYPELESS", t3[t3.DXGI_FORMAT_R16G16B16A16_FLOAT = 10] = "DXGI_FORMAT_R16G16B16A16_FLOAT", t3[t3.DXGI_FORMAT_R16G16B16A16_UNORM = 11] = "DXGI_FORMAT_R16G16B16A16_UNORM", t3[t3.DXGI_FORMAT_R16G16B16A16_UINT = 12] = "DXGI_FORMAT_R16G16B16A16_UINT", t3[t3.DXGI_FORMAT_R16G16B16A16_SNORM = 13] = "DXGI_FORMAT_R16G16B16A16_SNORM", t3[t3.DXGI_FORMAT_R16G16B16A16_SINT = 14] = "DXGI_FORMAT_R16G16B16A16_SINT", t3[t3.DXGI_FORMAT_R32G32_TYPELESS = 15] = "DXGI_FORMAT_R32G32_TYPELESS", t3[t3.DXGI_FORMAT_R32G32_FLOAT = 16] = "DXGI_FORMAT_R32G32_FLOAT", t3[t3.DXGI_FORMAT_R32G32_UINT = 17] = "DXGI_FORMAT_R32G32_UINT", t3[t3.DXGI_FORMAT_R32G32_SINT = 18] = "DXGI_FORMAT_R32G32_SINT", t3[t3.DXGI_FORMAT_R32G8X24_TYPELESS = 19] = "DXGI_FORMAT_R32G8X24_TYPELESS", t3[t3.DXGI_FORMAT_D32_FLOAT_S8X24_UINT = 20] = "DXGI_FORMAT_D32_FLOAT_S8X24_UINT", t3[t3.DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS = 21] = "DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS", t3[t3.DXGI_FORMAT_X32_TYPELESS_G8X24_UINT = 22] = "DXGI_FORMAT_X32_TYPELESS_G8X24_UINT", t3[t3.DXGI_FORMAT_R10G10B10A2_TYPELESS = 23] = "DXGI_FORMAT_R10G10B10A2_TYPELESS", t3[t3.DXGI_FORMAT_R10G10B10A2_UNORM = 24] = "DXGI_FORMAT_R10G10B10A2_UNORM", t3[t3.DXGI_FORMAT_R10G10B10A2_UINT = 25] = "DXGI_FORMAT_R10G10B10A2_UINT", t3[t3.DXGI_FORMAT_R11G11B10_FLOAT = 26] = "DXGI_FORMAT_R11G11B10_FLOAT", t3[t3.DXGI_FORMAT_R8G8B8A8_TYPELESS = 27] = "DXGI_FORMAT_R8G8B8A8_TYPELESS", t3[t3.DXGI_FORMAT_R8G8B8A8_UNORM = 28] = "DXGI_FORMAT_R8G8B8A8_UNORM", t3[t3.DXGI_FORMAT_R8G8B8A8_UNORM_SRGB = 29] = "DXGI_FORMAT_R8G8B8A8_UNORM_SRGB", t3[t3.DXGI_FORMAT_R8G8B8A8_UINT = 30] = "DXGI_FORMAT_R8G8B8A8_UINT", t3[t3.DXGI_FORMAT_R8G8B8A8_SNORM = 31] = "DXGI_FORMAT_R8G8B8A8_SNORM", t3[t3.DXGI_FORMAT_R8G8B8A8_SINT = 32] = "DXGI_FORMAT_R8G8B8A8_SINT", t3[t3.DXGI_FORMAT_R16G16_TYPELESS = 33] = "DXGI_FORMAT_R16G16_TYPELESS", t3[t3.DXGI_FORMAT_R16G16_FLOAT = 34] = "DXGI_FORMAT_R16G16_FLOAT", t3[t3.DXGI_FORMAT_R16G16_UNORM = 35] = "DXGI_FORMAT_R16G16_UNORM", t3[t3.DXGI_FORMAT_R16G16_UINT = 36] = "DXGI_FORMAT_R16G16_UINT", t3[t3.DXGI_FORMAT_R16G16_SNORM = 37] = "DXGI_FORMAT_R16G16_SNORM", t3[t3.DXGI_FORMAT_R16G16_SINT = 38] = "DXGI_FORMAT_R16G16_SINT", t3[t3.DXGI_FORMAT_R32_TYPELESS = 39] = "DXGI_FORMAT_R32_TYPELESS", t3[t3.DXGI_FORMAT_D32_FLOAT = 40] = "DXGI_FORMAT_D32_FLOAT", t3[t3.DXGI_FORMAT_R32_FLOAT = 41] = "DXGI_FORMAT_R32_FLOAT", t3[t3.DXGI_FORMAT_R32_UINT = 42] = "DXGI_FORMAT_R32_UINT", t3[t3.DXGI_FORMAT_R32_SINT = 43] = "DXGI_FORMAT_R32_SINT", t3[t3.DXGI_FORMAT_R24G8_TYPELESS = 44] = "DXGI_FORMAT_R24G8_TYPELESS", t3[t3.DXGI_FORMAT_D24_UNORM_S8_UINT = 45] = "DXGI_FORMAT_D24_UNORM_S8_UINT", t3[t3.DXGI_FORMAT_R24_UNORM_X8_TYPELESS = 46] = "DXGI_FORMAT_R24_UNORM_X8_TYPELESS", t3[t3.DXGI_FORMAT_X24_TYPELESS_G8_UINT = 47] = "DXGI_FORMAT_X24_TYPELESS_G8_UINT", t3[t3.DXGI_FORMAT_R8G8_TYPELESS = 48] = "DXGI_FORMAT_R8G8_TYPELESS", t3[t3.DXGI_FORMAT_R8G8_UNORM = 49] = "DXGI_FORMAT_R8G8_UNORM", t3[t3.DXGI_FORMAT_R8G8_UINT = 50] = "DXGI_FORMAT_R8G8_UINT", t3[t3.DXGI_FORMAT_R8G8_SNORM = 51] = "DXGI_FORMAT_R8G8_SNORM", t3[t3.DXGI_FORMAT_R8G8_SINT = 52] = "DXGI_FORMAT_R8G8_SINT", t3[t3.DXGI_FORMAT_R16_TYPELESS = 53] = "DXGI_FORMAT_R16_TYPELESS", t3[t3.DXGI_FORMAT_R16_FLOAT = 54] = "DXGI_FORMAT_R16_FLOAT", t3[t3.DXGI_FORMAT_D16_UNORM = 55] = "DXGI_FORMAT_D16_UNORM", t3[t3.DXGI_FORMAT_R16_UNORM = 56] = "DXGI_FORMAT_R16_UNORM", t3[t3.DXGI_FORMAT_R16_UINT = 57] = "DXGI_FORMAT_R16_UINT", t3[t3.DXGI_FORMAT_R16_SNORM = 58] = "DXGI_FORMAT_R16_SNORM", t3[t3.DXGI_FORMAT_R16_SINT = 59] = "DXGI_FORMAT_R16_SINT", t3[t3.DXGI_FORMAT_R8_TYPELESS = 60] = "DXGI_FORMAT_R8_TYPELESS", t3[t3.DXGI_FORMAT_R8_UNORM = 61] = "DXGI_FORMAT_R8_UNORM", t3[t3.DXGI_FORMAT_R8_UINT = 62] = "DXGI_FORMAT_R8_UINT", t3[t3.DXGI_FORMAT_R8_SNORM = 63] = "DXGI_FORMAT_R8_SNORM", t3[t3.DXGI_FORMAT_R8_SINT = 64] = "DXGI_FORMAT_R8_SINT", t3[t3.DXGI_FORMAT_A8_UNORM = 65] = "DXGI_FORMAT_A8_UNORM", t3[t3.DXGI_FORMAT_R1_UNORM = 66] = "DXGI_FORMAT_R1_UNORM", t3[t3.DXGI_FORMAT_R9G9B9E5_SHAREDEXP = 67] = "DXGI_FORMAT_R9G9B9E5_SHAREDEXP", t3[t3.DXGI_FORMAT_R8G8_B8G8_UNORM = 68] = "DXGI_FORMAT_R8G8_B8G8_UNORM", t3[t3.DXGI_FORMAT_G8R8_G8B8_UNORM = 69] = "DXGI_FORMAT_G8R8_G8B8_UNORM", t3[t3.DXGI_FORMAT_BC1_TYPELESS = 70] = "DXGI_FORMAT_BC1_TYPELESS", t3[t3.DXGI_FORMAT_BC1_UNORM = 71] = "DXGI_FORMAT_BC1_UNORM", t3[t3.DXGI_FORMAT_BC1_UNORM_SRGB = 72] = "DXGI_FORMAT_BC1_UNORM_SRGB", t3[t3.DXGI_FORMAT_BC2_TYPELESS = 73] = "DXGI_FORMAT_BC2_TYPELESS", t3[t3.DXGI_FORMAT_BC2_UNORM = 74] = "DXGI_FORMAT_BC2_UNORM", t3[t3.DXGI_FORMAT_BC2_UNORM_SRGB = 75] = "DXGI_FORMAT_BC2_UNORM_SRGB", t3[t3.DXGI_FORMAT_BC3_TYPELESS = 76] = "DXGI_FORMAT_BC3_TYPELESS", t3[t3.DXGI_FORMAT_BC3_UNORM = 77] = "DXGI_FORMAT_BC3_UNORM", t3[t3.DXGI_FORMAT_BC3_UNORM_SRGB = 78] = "DXGI_FORMAT_BC3_UNORM_SRGB", t3[t3.DXGI_FORMAT_BC4_TYPELESS = 79] = "DXGI_FORMAT_BC4_TYPELESS", t3[t3.DXGI_FORMAT_BC4_UNORM = 80] = "DXGI_FORMAT_BC4_UNORM", t3[t3.DXGI_FORMAT_BC4_SNORM = 81] = "DXGI_FORMAT_BC4_SNORM", t3[t3.DXGI_FORMAT_BC5_TYPELESS = 82] = "DXGI_FORMAT_BC5_TYPELESS", t3[t3.DXGI_FORMAT_BC5_UNORM = 83] = "DXGI_FORMAT_BC5_UNORM", t3[t3.DXGI_FORMAT_BC5_SNORM = 84] = "DXGI_FORMAT_BC5_SNORM", t3[t3.DXGI_FORMAT_B5G6R5_UNORM = 85] = "DXGI_FORMAT_B5G6R5_UNORM", t3[t3.DXGI_FORMAT_B5G5R5A1_UNORM = 86] = "DXGI_FORMAT_B5G5R5A1_UNORM", t3[t3.DXGI_FORMAT_B8G8R8A8_UNORM = 87] = "DXGI_FORMAT_B8G8R8A8_UNORM", t3[t3.DXGI_FORMAT_B8G8R8X8_UNORM = 88] = "DXGI_FORMAT_B8G8R8X8_UNORM", t3[t3.DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM = 89] = "DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM", t3[t3.DXGI_FORMAT_B8G8R8A8_TYPELESS = 90] = "DXGI_FORMAT_B8G8R8A8_TYPELESS", t3[t3.DXGI_FORMAT_B8G8R8A8_UNORM_SRGB = 91] = "DXGI_FORMAT_B8G8R8A8_UNORM_SRGB", t3[t3.DXGI_FORMAT_B8G8R8X8_TYPELESS = 92] = "DXGI_FORMAT_B8G8R8X8_TYPELESS", t3[t3.DXGI_FORMAT_B8G8R8X8_UNORM_SRGB = 93] = "DXGI_FORMAT_B8G8R8X8_UNORM_SRGB", t3[t3.DXGI_FORMAT_BC6H_TYPELESS = 94] = "DXGI_FORMAT_BC6H_TYPELESS", t3[t3.DXGI_FORMAT_BC6H_UF16 = 95] = "DXGI_FORMAT_BC6H_UF16", t3[t3.DXGI_FORMAT_BC6H_SF16 = 96] = "DXGI_FORMAT_BC6H_SF16", t3[t3.DXGI_FORMAT_BC7_TYPELESS = 97] = "DXGI_FORMAT_BC7_TYPELESS", t3[t3.DXGI_FORMAT_BC7_UNORM = 98] = "DXGI_FORMAT_BC7_UNORM", t3[t3.DXGI_FORMAT_BC7_UNORM_SRGB = 99] = "DXGI_FORMAT_BC7_UNORM_SRGB", t3[t3.DXGI_FORMAT_AYUV = 100] = "DXGI_FORMAT_AYUV", t3[t3.DXGI_FORMAT_Y410 = 101] = "DXGI_FORMAT_Y410", t3[t3.DXGI_FORMAT_Y416 = 102] = "DXGI_FORMAT_Y416", t3[t3.DXGI_FORMAT_NV12 = 103] = "DXGI_FORMAT_NV12", t3[t3.DXGI_FORMAT_P010 = 104] = "DXGI_FORMAT_P010", t3[t3.DXGI_FORMAT_P016 = 105] = "DXGI_FORMAT_P016", t3[t3.DXGI_FORMAT_420_OPAQUE = 106] = "DXGI_FORMAT_420_OPAQUE", t3[t3.DXGI_FORMAT_YUY2 = 107] = "DXGI_FORMAT_YUY2", t3[t3.DXGI_FORMAT_Y210 = 108] = "DXGI_FORMAT_Y210", t3[t3.DXGI_FORMAT_Y216 = 109] = "DXGI_FORMAT_Y216", t3[t3.DXGI_FORMAT_NV11 = 110] = "DXGI_FORMAT_NV11", t3[t3.DXGI_FORMAT_AI44 = 111] = "DXGI_FORMAT_AI44", t3[t3.DXGI_FORMAT_IA44 = 112] = "DXGI_FORMAT_IA44", t3[t3.DXGI_FORMAT_P8 = 113] = "DXGI_FORMAT_P8", t3[t3.DXGI_FORMAT_A8P8 = 114] = "DXGI_FORMAT_A8P8", t3[t3.DXGI_FORMAT_B4G4R4A4_UNORM = 115] = "DXGI_FORMAT_B4G4R4A4_UNORM", t3[t3.DXGI_FORMAT_P208 = 116] = "DXGI_FORMAT_P208", t3[t3.DXGI_FORMAT_V208 = 117] = "DXGI_FORMAT_V208", t3[t3.DXGI_FORMAT_V408 = 118] = "DXGI_FORMAT_V408", t3[t3.DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE = 119] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE", t3[t3.DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE = 120] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE", t3[t3.DXGI_FORMAT_FORCE_UINT = 121] = "DXGI_FORMAT_FORCE_UINT";
  }(pT || (pT = {})), function(t3) {
    t3[t3.DDS_DIMENSION_TEXTURE1D = 2] = "DDS_DIMENSION_TEXTURE1D", t3[t3.DDS_DIMENSION_TEXTURE2D = 3] = "DDS_DIMENSION_TEXTURE2D", t3[t3.DDS_DIMENSION_TEXTURE3D = 6] = "DDS_DIMENSION_TEXTURE3D";
  }(fT || (fT = {}));
  var ST, ET, MT, AT = ((lT = {})[827611204] = nT.COMPRESSED_RGBA_S3TC_DXT1_EXT, lT[861165636] = nT.COMPRESSED_RGBA_S3TC_DXT3_EXT, lT[894720068] = nT.COMPRESSED_RGBA_S3TC_DXT5_EXT, lT), RT = ((uT = {})[pT.DXGI_FORMAT_BC1_TYPELESS] = nT.COMPRESSED_RGBA_S3TC_DXT1_EXT, uT[pT.DXGI_FORMAT_BC1_UNORM] = nT.COMPRESSED_RGBA_S3TC_DXT1_EXT, uT[pT.DXGI_FORMAT_BC2_TYPELESS] = nT.COMPRESSED_RGBA_S3TC_DXT3_EXT, uT[pT.DXGI_FORMAT_BC2_UNORM] = nT.COMPRESSED_RGBA_S3TC_DXT3_EXT, uT[pT.DXGI_FORMAT_BC3_TYPELESS] = nT.COMPRESSED_RGBA_S3TC_DXT5_EXT, uT[pT.DXGI_FORMAT_BC3_UNORM] = nT.COMPRESSED_RGBA_S3TC_DXT5_EXT, uT[pT.DXGI_FORMAT_BC1_UNORM_SRGB] = nT.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT, uT[pT.DXGI_FORMAT_BC2_UNORM_SRGB] = nT.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT, uT[pT.DXGI_FORMAT_BC3_UNORM_SRGB] = nT.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT, uT), PT = function() {
    function t3() {
    }
    return t3.use = function(e3, n2) {
      if (e3.extension === "dds" && e3.data)
        try {
          Object.assign(e3, dT(e3.name || e3.url, t3.parse(e3.data), e3.metadata));
        } catch (t4) {
          return void n2(t4);
        }
      n2();
    }, t3.parse = function(t4) {
      var e3 = new Uint32Array(t4);
      if (e3[0] !== 542327876)
        throw new Error("Invalid DDS file magic word");
      var n2 = new Uint32Array(t4, 0, 124 / Uint32Array.BYTES_PER_ELEMENT), i2 = n2[mT], r3 = n2[gT], o3 = n2[vT], s3 = new Uint32Array(t4, _T * Uint32Array.BYTES_PER_ELEMENT, 32 / Uint32Array.BYTES_PER_ELEMENT), a2 = s3[1];
      if (4 & a2) {
        var l2 = s3[yT];
        if (l2 !== 808540228) {
          var u2 = AT[l2], h2 = new Uint8Array(t4, 128);
          return [new hT(h2, { format: u2, width: r3, height: i2, levels: o3 })];
        }
        var c2 = new Uint32Array(e3.buffer, 128, 20 / Uint32Array.BYTES_PER_ELEMENT), d2 = c2[xT], p2 = c2[bT], f2 = c2[TT], m2 = c2[wT], g2 = RT[d2];
        if (g2 === void 0)
          throw new Error("DDSLoader cannot parse texture data with DXGI format " + d2);
        if (f2 === 4)
          throw new Error("DDSLoader does not support cubemap textures");
        if (p2 === fT.DDS_DIMENSION_TEXTURE3D)
          throw new Error("DDSLoader does not supported 3D texture data");
        var v2 = new Array();
        if (m2 === 1)
          v2.push(new Uint8Array(t4, 148));
        else {
          for (var _2 = rT[g2], y2 = 0, x2 = r3, b2 = i2, T2 = 0; T2 < o3; T2++) {
            y2 += Math.max(1, x2 + 3 & -4) * Math.max(1, b2 + 3 & -4) * _2, x2 >>>= 1, b2 >>>= 1;
          }
          var w2 = 148;
          for (T2 = 0; T2 < m2; T2++)
            v2.push(new Uint8Array(t4, w2, y2)), w2 += y2;
        }
        return v2.map(function(t5) {
          return new hT(t5, { format: g2, width: r3, height: i2, levels: o3 });
        });
      }
      if (64 & a2)
        throw new Error("DDSLoader does not support uncompressed texture data.");
      if (512 & a2)
        throw new Error("DDSLoader does not supported YUV uncompressed texture data.");
      if (131072 & a2)
        throw new Error("DDSLoader does not support single-channel (lumninance) texture data!");
      if (2 & a2)
        throw new Error("DDSLoader does not support single-channel (alpha) texture data!");
      throw new Error("DDSLoader failed to load a texture file due to an unknown reason!");
    }, t3;
  }();
  Xb.setExtensionXhrType("ktx", Xb.XHR_RESPONSE_TYPE.BUFFER);
  var CT = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10], IT = 12, OT = 16, LT = 24, NT = 28, DT = 36, FT = 40, BT = 44, UT = 48, kT = 52, GT = 56, HT = 60, zT = ((ST = {})[iv.UNSIGNED_BYTE] = 1, ST[iv.UNSIGNED_SHORT] = 2, ST[iv.FLOAT] = 4, ST[iv.HALF_FLOAT] = 8, ST), jT = ((ET = {})[ev.RGBA] = 4, ET[ev.RGB] = 3, ET[ev.LUMINANCE] = 1, ET[ev.LUMINANCE_ALPHA] = 2, ET[ev.ALPHA] = 1, ET), VT = ((MT = {})[iv.UNSIGNED_SHORT_4_4_4_4] = 2, MT[iv.UNSIGNED_SHORT_5_5_5_1] = 2, MT[iv.UNSIGNED_SHORT_5_6_5] = 2, MT), WT = function() {
    function t3() {
    }
    return t3.use = function(e3, n2) {
      if (e3.extension === "ktx" && e3.data)
        try {
          var i2 = e3.name || e3.url;
          Object.assign(e3, dT(i2, t3.parse(i2, e3.data), e3.metadata));
        } catch (t4) {
          return void n2(t4);
        }
      n2();
    }, t3.parse = function(e3, n2) {
      var i2 = new DataView(n2);
      if (!t3.validate(e3, i2))
        return null;
      var r3 = i2.getUint32(IT, true) === 67305985, o3 = i2.getUint32(OT, r3), s3 = i2.getUint32(LT, r3), a2 = i2.getUint32(NT, r3), l2 = i2.getUint32(DT, r3), u2 = i2.getUint32(FT, r3) || 1, h2 = i2.getUint32(BT, r3) || 1, c2 = i2.getUint32(UT, r3) || 1, d2 = i2.getUint32(kT, r3), p2 = i2.getUint32(GT, r3), f2 = i2.getUint32(HT, r3);
      if (u2 === 0 || h2 !== 1)
        throw new Error("Only 2D textures are supported");
      if (d2 !== 1)
        throw new Error("CubeTextures are not supported by KTXLoader yet!");
      if (c2 !== 1)
        throw new Error("WebGL does not support array textures");
      var m2, g2 = l2 + 3 & -4, v2 = u2 + 3 & -4, _2 = new Array(c2), y2 = l2 * u2;
      if (o3 === 0 && (y2 = g2 * v2), (m2 = o3 !== 0 ? zT[o3] ? zT[o3] * jT[s3] : VT[o3] : rT[a2]) === void 0)
        throw new Error("Unable to resolve the pixel format stored in the *.ktx file!");
      for (var x2 = y2 * m2, b2 = l2, T2 = u2, w2 = g2, S2 = v2, E2 = 64 + f2, M2 = 0; M2 < p2; M2++) {
        for (var A2 = i2.getUint32(E2, r3), R2 = E2 + 4, P2 = 0; P2 < c2; P2++) {
          var C2 = _2[P2];
          C2 || (C2 = _2[P2] = new Array(p2)), C2[M2] = { levelID: M2, levelWidth: p2 > 1 ? b2 : w2, levelHeight: p2 > 1 ? T2 : S2, levelBuffer: new Uint8Array(n2, R2, x2) }, R2 += x2;
        }
        E2 = (E2 += A2 + 4) % 4 != 0 ? E2 + 4 - E2 % 4 : E2, x2 = (w2 = (b2 = b2 >> 1 || 1) + 4 - 1 & -4) * (S2 = (T2 = T2 >> 1 || 1) + 4 - 1 & -4) * m2;
      }
      if (o3 !== 0)
        throw new Error("TODO: Uncompressed");
      return _2.map(function(t4) {
        return new hT(null, { format: a2, width: l2, height: u2, levels: p2, levelBuffers: t4 });
      });
    }, t3.validate = function(t4, e3) {
      for (var n2 = 0; n2 < CT.length; n2++)
        if (e3.getUint8(n2) !== CT[n2])
          return console.error(t4 + " is not a valid *.ktx file!"), false;
      return true;
    }, t3;
  }(), XT = function(t3, e3) {
    return (XT = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e4) {
      t4.__proto__ = e4;
    } || function(t4, e4) {
      for (var n2 in e4)
        e4.hasOwnProperty(n2) && (t4[n2] = e4[n2]);
    })(t3, e3);
  };
  function qT(t3, e3) {
    function n2() {
      this.constructor = t3;
    }
    XT(t3, e3), t3.prototype = e3 === null ? Object.create(e3) : (n2.prototype = e3.prototype, new n2());
  }
  !function(t3) {
    function e3(e4, n2, i2, r3) {
      e4 === void 0 && (e4 = 1500), i2 === void 0 && (i2 = 16384), r3 === void 0 && (r3 = false);
      var o3 = t3.call(this) || this;
      return i2 > 16384 && (i2 = 16384), o3._properties = [false, true, false, false, false], o3._maxSize = e4, o3._batchSize = i2, o3._buffers = null, o3._bufferUpdateIDs = [], o3._updateID = 0, o3.interactiveChildren = false, o3.blendMode = Qg.NORMAL, o3.autoResize = r3, o3.roundPixels = true, o3.baseTexture = null, o3.setProperties(n2), o3._tint = 0, o3.tintRgb = new Float32Array(4), o3.tint = 16777215, o3;
    }
    qT(e3, t3), e3.prototype.setProperties = function(t4) {
      t4 && (this._properties[0] = "vertices" in t4 || "scale" in t4 ? !!t4.vertices || !!t4.scale : this._properties[0], this._properties[1] = "position" in t4 ? !!t4.position : this._properties[1], this._properties[2] = "rotation" in t4 ? !!t4.rotation : this._properties[2], this._properties[3] = "uvs" in t4 ? !!t4.uvs : this._properties[3], this._properties[4] = "tint" in t4 || "alpha" in t4 ? !!t4.tint || !!t4.alpha : this._properties[4]);
    }, e3.prototype.updateTransform = function() {
      this.displayObjectUpdateTransform();
    }, Object.defineProperty(e3.prototype, "tint", { get: function() {
      return this._tint;
    }, set: function(t4) {
      this._tint = t4, Rv(t4, this.tintRgb);
    }, enumerable: false, configurable: true }), e3.prototype.render = function(t4) {
      var e4 = this;
      this.visible && !(this.worldAlpha <= 0) && this.children.length && this.renderable && (this.baseTexture || (this.baseTexture = this.children[0]._texture.baseTexture, this.baseTexture.valid || this.baseTexture.once("update", function() {
        return e4.onChildrenChange(0);
      })), t4.batch.setObjectRenderer(t4.plugins.particle), t4.plugins.particle.render(this));
    }, e3.prototype.onChildrenChange = function(t4) {
      for (var e4 = Math.floor(t4 / this._batchSize); this._bufferUpdateIDs.length < e4; )
        this._bufferUpdateIDs.push(0);
      this._bufferUpdateIDs[e4] = ++this._updateID;
    }, e3.prototype.dispose = function() {
      if (this._buffers) {
        for (var t4 = 0; t4 < this._buffers.length; ++t4)
          this._buffers[t4].destroy();
        this._buffers = null;
      }
    }, e3.prototype.destroy = function(e4) {
      t3.prototype.destroy.call(this, e4), this.dispose(), this._properties = null, this._buffers = null, this._bufferUpdateIDs = null;
    };
  }(ty);
  var YT, ZT, JT = function() {
    function t3(t4, e3, n2) {
      this.geometry = new Jy(), this.indexBuffer = null, this.size = n2, this.dynamicProperties = [], this.staticProperties = [];
      for (var i2 = 0; i2 < t4.length; ++i2) {
        var r3 = t4[i2];
        r3 = { attributeName: r3.attributeName, size: r3.size, uploadFunction: r3.uploadFunction, type: r3.type || iv.FLOAT, offset: r3.offset }, e3[i2] ? this.dynamicProperties.push(r3) : this.staticProperties.push(r3);
      }
      this.staticStride = 0, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.dynamicStride = 0, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this._updateID = 0, this.initBuffers();
    }
    return t3.prototype.initBuffers = function() {
      var t4 = this.geometry, e3 = 0;
      this.indexBuffer = new Wy(Bv(this.size), true, true), t4.addIndex(this.indexBuffer), this.dynamicStride = 0;
      for (var n2 = 0; n2 < this.dynamicProperties.length; ++n2) {
        (s3 = this.dynamicProperties[n2]).offset = e3, e3 += s3.size, this.dynamicStride += s3.size;
      }
      var i2 = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);
      this.dynamicData = new Float32Array(i2), this.dynamicDataUint32 = new Uint32Array(i2), this.dynamicBuffer = new Wy(this.dynamicData, false, false);
      var r3 = 0;
      this.staticStride = 0;
      for (n2 = 0; n2 < this.staticProperties.length; ++n2) {
        (s3 = this.staticProperties[n2]).offset = r3, r3 += s3.size, this.staticStride += s3.size;
      }
      var o3 = new ArrayBuffer(this.size * this.staticStride * 4 * 4);
      this.staticData = new Float32Array(o3), this.staticDataUint32 = new Uint32Array(o3), this.staticBuffer = new Wy(this.staticData, true, false);
      for (n2 = 0; n2 < this.dynamicProperties.length; ++n2) {
        var s3 = this.dynamicProperties[n2];
        t4.addAttribute(s3.attributeName, this.dynamicBuffer, 0, s3.type === iv.UNSIGNED_BYTE, s3.type, 4 * this.dynamicStride, 4 * s3.offset);
      }
      for (n2 = 0; n2 < this.staticProperties.length; ++n2) {
        s3 = this.staticProperties[n2];
        t4.addAttribute(s3.attributeName, this.staticBuffer, 0, s3.type === iv.UNSIGNED_BYTE, s3.type, 4 * this.staticStride, 4 * s3.offset);
      }
    }, t3.prototype.uploadDynamic = function(t4, e3, n2) {
      for (var i2 = 0; i2 < this.dynamicProperties.length; i2++) {
        var r3 = this.dynamicProperties[i2];
        r3.uploadFunction(t4, e3, n2, r3.type === iv.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, r3.offset);
      }
      this.dynamicBuffer._updateID++;
    }, t3.prototype.uploadStatic = function(t4, e3, n2) {
      for (var i2 = 0; i2 < this.staticProperties.length; i2++) {
        var r3 = this.staticProperties[i2];
        r3.uploadFunction(t4, e3, n2, r3.type === iv.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, r3.offset);
      }
      this.staticBuffer._updateID++;
    }, t3.prototype.destroy = function() {
      this.indexBuffer = null, this.dynamicProperties = null, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this.staticProperties = null, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.geometry.destroy();
    }, t3;
  }(), $T = function(t3) {
    function e3(e4) {
      var n2 = t3.call(this, e4) || this;
      return n2.shader = null, n2.properties = null, n2.tempMatrix = new y_(), n2.properties = [{ attributeName: "aVertexPosition", size: 2, uploadFunction: n2.uploadVertices, offset: 0 }, { attributeName: "aPositionCoord", size: 2, uploadFunction: n2.uploadPosition, offset: 0 }, { attributeName: "aRotation", size: 1, uploadFunction: n2.uploadRotation, offset: 0 }, { attributeName: "aTextureCoord", size: 2, uploadFunction: n2.uploadUvs, offset: 0 }, { attributeName: "aColor", size: 1, type: iv.UNSIGNED_BYTE, uploadFunction: n2.uploadTint, offset: 0 }], n2.shader = Ux.from("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nattribute vec2 aPositionCoord;\nattribute float aRotation;\n\nuniform mat3 translationMatrix;\nuniform vec4 uColor;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvoid main(void){\n    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);\n    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);\n\n    vec2 v = vec2(x, y);\n    v = v + aPositionCoord;\n\n    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vColor = aColor * uColor;\n}\n", "varying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\n    gl_FragColor = color;\n}", {}), n2.state = kx.for2d(), n2;
    }
    return qT(e3, t3), e3.prototype.render = function(t4) {
      var e4 = t4.children, n2 = t4._maxSize, i2 = t4._batchSize, r3 = this.renderer, o3 = e4.length;
      if (o3 !== 0) {
        o3 > n2 && !t4.autoResize && (o3 = n2);
        var s3 = t4._buffers;
        s3 || (s3 = t4._buffers = this.generateBuffers(t4));
        var a2 = e4[0]._texture.baseTexture;
        this.state.blendMode = Lv(t4.blendMode, a2.alphaMode), r3.state.set(this.state);
        var l2 = r3.gl, u2 = t4.worldTransform.copyTo(this.tempMatrix);
        u2.prepend(r3.globalUniforms.uniforms.projectionMatrix), this.shader.uniforms.translationMatrix = u2.toArray(true), this.shader.uniforms.uColor = Nv(t4.tintRgb, t4.worldAlpha, this.shader.uniforms.uColor, a2.alphaMode), this.shader.uniforms.uSampler = a2, this.renderer.shader.bind(this.shader);
        for (var h2 = false, c2 = 0, d2 = 0; c2 < o3; c2 += i2, d2 += 1) {
          var p2 = o3 - c2;
          p2 > i2 && (p2 = i2), d2 >= s3.length && s3.push(this._generateOneMoreBuffer(t4));
          var f2 = s3[d2];
          f2.uploadDynamic(e4, c2, p2);
          var m2 = t4._bufferUpdateIDs[d2] || 0;
          (h2 = h2 || f2._updateID < m2) && (f2._updateID = t4._updateID, f2.uploadStatic(e4, c2, p2)), r3.geometry.bind(f2.geometry), l2.drawElements(l2.TRIANGLES, 6 * p2, l2.UNSIGNED_SHORT, 0);
        }
      }
    }, e3.prototype.generateBuffers = function(t4) {
      for (var e4 = [], n2 = t4._maxSize, i2 = t4._batchSize, r3 = t4._properties, o3 = 0; o3 < n2; o3 += i2)
        e4.push(new JT(this.properties, r3, i2));
      return e4;
    }, e3.prototype._generateOneMoreBuffer = function(t4) {
      var e4 = t4._batchSize, n2 = t4._properties;
      return new JT(this.properties, n2, e4);
    }, e3.prototype.uploadVertices = function(t4, e4, n2, i2, r3, o3) {
      for (var s3 = 0, a2 = 0, l2 = 0, u2 = 0, h2 = 0; h2 < n2; ++h2) {
        var c2 = t4[e4 + h2], d2 = c2._texture, p2 = c2.scale.x, f2 = c2.scale.y, m2 = d2.trim, g2 = d2.orig;
        m2 ? (s3 = (a2 = m2.x - c2.anchor.x * g2.width) + m2.width, l2 = (u2 = m2.y - c2.anchor.y * g2.height) + m2.height) : (s3 = g2.width * (1 - c2.anchor.x), a2 = g2.width * -c2.anchor.x, l2 = g2.height * (1 - c2.anchor.y), u2 = g2.height * -c2.anchor.y), i2[o3] = a2 * p2, i2[o3 + 1] = u2 * f2, i2[o3 + r3] = s3 * p2, i2[o3 + r3 + 1] = u2 * f2, i2[o3 + 2 * r3] = s3 * p2, i2[o3 + 2 * r3 + 1] = l2 * f2, i2[o3 + 3 * r3] = a2 * p2, i2[o3 + 3 * r3 + 1] = l2 * f2, o3 += 4 * r3;
      }
    }, e3.prototype.uploadPosition = function(t4, e4, n2, i2, r3, o3) {
      for (var s3 = 0; s3 < n2; s3++) {
        var a2 = t4[e4 + s3].position;
        i2[o3] = a2.x, i2[o3 + 1] = a2.y, i2[o3 + r3] = a2.x, i2[o3 + r3 + 1] = a2.y, i2[o3 + 2 * r3] = a2.x, i2[o3 + 2 * r3 + 1] = a2.y, i2[o3 + 3 * r3] = a2.x, i2[o3 + 3 * r3 + 1] = a2.y, o3 += 4 * r3;
      }
    }, e3.prototype.uploadRotation = function(t4, e4, n2, i2, r3, o3) {
      for (var s3 = 0; s3 < n2; s3++) {
        var a2 = t4[e4 + s3].rotation;
        i2[o3] = a2, i2[o3 + r3] = a2, i2[o3 + 2 * r3] = a2, i2[o3 + 3 * r3] = a2, o3 += 4 * r3;
      }
    }, e3.prototype.uploadUvs = function(t4, e4, n2, i2, r3, o3) {
      for (var s3 = 0; s3 < n2; ++s3) {
        var a2 = t4[e4 + s3]._texture._uvs;
        a2 ? (i2[o3] = a2.x0, i2[o3 + 1] = a2.y0, i2[o3 + r3] = a2.x1, i2[o3 + r3 + 1] = a2.y1, i2[o3 + 2 * r3] = a2.x2, i2[o3 + 2 * r3 + 1] = a2.y2, i2[o3 + 3 * r3] = a2.x3, i2[o3 + 3 * r3 + 1] = a2.y3, o3 += 4 * r3) : (i2[o3] = 0, i2[o3 + 1] = 0, i2[o3 + r3] = 0, i2[o3 + r3 + 1] = 0, i2[o3 + 2 * r3] = 0, i2[o3 + 2 * r3 + 1] = 0, i2[o3 + 3 * r3] = 0, i2[o3 + 3 * r3 + 1] = 0, o3 += 4 * r3);
      }
    }, e3.prototype.uploadTint = function(t4, e4, n2, i2, r3, o3) {
      for (var s3 = 0; s3 < n2; ++s3) {
        var a2 = t4[e4 + s3], l2 = a2._texture.baseTexture.alphaMode > 0, u2 = a2.alpha, h2 = u2 < 1 && l2 ? Dv(a2._tintRGB, u2) : a2._tintRGB + (255 * u2 << 24);
        i2[o3] = h2, i2[o3 + r3] = h2, i2[o3 + 2 * r3] = h2, i2[o3 + 3 * r3] = h2, o3 += 4 * r3;
      }
    }, e3.prototype.destroy = function() {
      t3.prototype.destroy.call(this), this.shader && (this.shader.destroy(), this.shader = null), this.tempMatrix = null;
    }, e3;
  }(ox);
  !function(t3) {
    t3.MITER = "miter", t3.BEVEL = "bevel", t3.ROUND = "round";
  }(YT || (YT = {})), function(t3) {
    t3.BUTT = "butt", t3.ROUND = "round", t3.SQUARE = "square";
  }(ZT || (ZT = {}));
  var KT = { adaptive: true, maxLength: 10, minSegments: 8, maxSegments: 2048, epsilon: 1e-4, _segmentsCount: function(t3, e3) {
    if (e3 === void 0 && (e3 = 20), !this.adaptive || !t3 || isNaN(t3))
      return e3;
    var n2 = Math.ceil(t3 / this.maxLength);
    return n2 < this.minSegments ? n2 = this.minSegments : n2 > this.maxSegments && (n2 = this.maxSegments), n2;
  } }, QT = function() {
    function t3() {
      this.color = 16777215, this.alpha = 1, this.texture = ky.WHITE, this.matrix = null, this.visible = false, this.reset();
    }
    return t3.prototype.clone = function() {
      var e3 = new t3();
      return e3.color = this.color, e3.alpha = this.alpha, e3.texture = this.texture, e3.matrix = this.matrix, e3.visible = this.visible, e3;
    }, t3.prototype.reset = function() {
      this.color = 16777215, this.alpha = 1, this.texture = ky.WHITE, this.matrix = null, this.visible = false;
    }, t3.prototype.destroy = function() {
      this.texture = null, this.matrix = null;
    }, t3;
  }(), tw = function(t3, e3) {
    return (tw = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e4) {
      t4.__proto__ = e4;
    } || function(t4, e4) {
      for (var n2 in e4)
        e4.hasOwnProperty(n2) && (t4[n2] = e4[n2]);
    })(t3, e3);
  };
  function ew(t3, e3) {
    function n2() {
      this.constructor = t3;
    }
    tw(t3, e3), t3.prototype = e3 === null ? Object.create(e3) : (n2.prototype = e3.prototype, new n2());
  }
  var nw = { build: function(t3) {
    t3.points = t3.shape.points.slice();
  }, triangulate: function(t3, e3) {
    var n2 = t3.points, i2 = t3.holes, r3 = e3.points, o3 = e3.indices;
    if (n2.length >= 6) {
      for (var s3 = [], a2 = 0; a2 < i2.length; a2++) {
        var l2 = i2[a2];
        s3.push(n2.length / 2), n2 = n2.concat(l2.points);
      }
      var u2 = yv()(n2, s3, 2);
      if (!u2)
        return;
      var h2 = r3.length / 2;
      for (a2 = 0; a2 < u2.length; a2 += 3)
        o3.push(u2[a2] + h2), o3.push(u2[a2 + 1] + h2), o3.push(u2[a2 + 2] + h2);
      for (a2 = 0; a2 < n2.length; a2++)
        r3.push(n2[a2]);
    }
  } }, iw = { build: function(t3) {
    var e3, n2, i2 = t3.shape, r3 = t3.points, o3 = i2.x, s3 = i2.y;
    if (r3.length = 0, t3.type === l_.CIRC)
      e3 = i2.radius, n2 = i2.radius;
    else {
      var a2 = t3.shape;
      e3 = a2.width, n2 = a2.height;
    }
    if (e3 !== 0 && n2 !== 0) {
      var l2 = Math.floor(30 * Math.sqrt(i2.radius)) || Math.floor(15 * Math.sqrt(e3 + n2));
      l2 /= 2.3;
      for (var u2 = 2 * Math.PI / l2, h2 = 0; h2 < l2 - 0.5; h2++)
        r3.push(o3 + Math.sin(-u2 * h2) * e3, s3 + Math.cos(-u2 * h2) * n2);
      r3.push(r3[0], r3[1]);
    }
  }, triangulate: function(t3, e3) {
    var n2 = t3.points, i2 = e3.points, r3 = e3.indices, o3 = i2.length / 2, s3 = o3, a2 = t3.shape, l2 = t3.matrix, u2 = a2.x, h2 = a2.y;
    i2.push(t3.matrix ? l2.a * u2 + l2.c * h2 + l2.tx : u2, t3.matrix ? l2.b * u2 + l2.d * h2 + l2.ty : h2);
    for (var c2 = 0; c2 < n2.length; c2 += 2)
      i2.push(n2[c2], n2[c2 + 1]), r3.push(o3++, s3, o3);
  } }, rw = { build: function(t3) {
    var e3 = t3.shape, n2 = e3.x, i2 = e3.y, r3 = e3.width, o3 = e3.height, s3 = t3.points;
    s3.length = 0, s3.push(n2, i2, n2 + r3, i2, n2 + r3, i2 + o3, n2, i2 + o3);
  }, triangulate: function(t3, e3) {
    var n2 = t3.points, i2 = e3.points, r3 = i2.length / 2;
    i2.push(n2[0], n2[1], n2[2], n2[3], n2[6], n2[7], n2[4], n2[5]), e3.indices.push(r3, r3 + 1, r3 + 2, r3 + 1, r3 + 2, r3 + 3);
  } };
  function ow(t3, e3, n2) {
    return t3 + (e3 - t3) * n2;
  }
  function sw(t3, e3, n2, i2, r3, o3, s3) {
    s3 === void 0 && (s3 = []);
    for (var a2 = s3, l2 = 0, u2 = 0, h2 = 0, c2 = 0, d2 = 0, p2 = 0, f2 = 0, m2 = 0; f2 <= 20; ++f2)
      l2 = ow(t3, n2, m2 = f2 / 20), u2 = ow(e3, i2, m2), h2 = ow(n2, r3, m2), c2 = ow(i2, o3, m2), d2 = ow(l2, h2, m2), p2 = ow(u2, c2, m2), f2 === 0 && a2[a2.length - 2] === d2 && a2[a2.length - 1] === p2 || a2.push(d2, p2);
    return a2;
  }
  var aw = { build: function(t3) {
    var e3 = t3.shape, n2 = t3.points, i2 = e3.x, r3 = e3.y, o3 = e3.width, s3 = e3.height, a2 = Math.max(0, Math.min(e3.radius, Math.min(o3, s3) / 2));
    n2.length = 0, a2 ? (sw(i2, r3 + a2, i2, r3, i2 + a2, r3, n2), sw(i2 + o3 - a2, r3, i2 + o3, r3, i2 + o3, r3 + a2, n2), sw(i2 + o3, r3 + s3 - a2, i2 + o3, r3 + s3, i2 + o3 - a2, r3 + s3, n2), sw(i2 + a2, r3 + s3, i2, r3 + s3, i2, r3 + s3 - a2, n2)) : n2.push(i2, r3, i2 + o3, r3, i2 + o3, r3 + s3, i2, r3 + s3);
  }, triangulate: function(t3, e3) {
    for (var n2 = t3.points, i2 = e3.points, r3 = e3.indices, o3 = i2.length / 2, s3 = yv()(n2, null, 2), a2 = 0, l2 = s3.length; a2 < l2; a2 += 3)
      r3.push(s3[a2] + o3), r3.push(s3[a2 + 1] + o3), r3.push(s3[a2 + 2] + o3);
    for (a2 = 0, l2 = n2.length; a2 < l2; a2++)
      i2.push(n2[a2], n2[++a2]);
  } };
  function lw(t3, e3, n2, i2, r3, o3, s3, a2) {
    var l2, u2;
    s3 ? (l2 = i2, u2 = -n2) : (l2 = -i2, u2 = n2);
    var h2 = t3 - n2 * r3 + l2, c2 = e3 - i2 * r3 + u2, d2 = t3 + n2 * o3 + l2, p2 = e3 + i2 * o3 + u2;
    return a2.push(h2, c2), a2.push(d2, p2), 2;
  }
  function uw(t3, e3, n2, i2, r3, o3, s3, a2) {
    var l2 = n2 - t3, u2 = i2 - e3, h2 = Math.atan2(l2, u2), c2 = Math.atan2(r3 - t3, o3 - e3);
    a2 && h2 < c2 ? h2 += 2 * Math.PI : !a2 && h2 > c2 && (c2 += 2 * Math.PI);
    var d2 = h2, p2 = c2 - h2, f2 = Math.abs(p2), m2 = Math.sqrt(l2 * l2 + u2 * u2), g2 = 1 + (15 * f2 * Math.sqrt(m2) / Math.PI >> 0), v2 = p2 / g2;
    if (d2 += v2, a2) {
      s3.push(t3, e3), s3.push(n2, i2);
      for (var _2 = 1, y2 = d2; _2 < g2; _2++, y2 += v2)
        s3.push(t3, e3), s3.push(t3 + Math.sin(y2) * m2, e3 + Math.cos(y2) * m2);
      s3.push(t3, e3), s3.push(r3, o3);
    } else {
      s3.push(n2, i2), s3.push(t3, e3);
      for (_2 = 1, y2 = d2; _2 < g2; _2++, y2 += v2)
        s3.push(t3 + Math.sin(y2) * m2, e3 + Math.cos(y2) * m2), s3.push(t3, e3);
      s3.push(r3, o3), s3.push(t3, e3);
    }
    return 2 * g2;
  }
  function hw(t3, e3) {
    t3.lineStyle.native ? function(t4, e4) {
      var n2 = 0, i2 = t4.shape, r3 = t4.points || i2.points, o3 = i2.type !== l_.POLY || i2.closeStroke;
      if (r3.length !== 0) {
        var s3 = e4.points, a2 = e4.indices, l2 = r3.length / 2, u2 = s3.length / 2, h2 = u2;
        for (s3.push(r3[0], r3[1]), n2 = 1; n2 < l2; n2++)
          s3.push(r3[2 * n2], r3[2 * n2 + 1]), a2.push(h2, h2 + 1), h2++;
        o3 && a2.push(h2, u2);
      }
    }(t3, e3) : function(t4, e4) {
      var n2 = t4.shape, i2 = t4.points || n2.points.slice(), r3 = e4.closePointEps;
      if (i2.length !== 0) {
        var o3 = t4.lineStyle, s3 = new v_(i2[0], i2[1]), a2 = new v_(i2[i2.length - 2], i2[i2.length - 1]), l2 = n2.type !== l_.POLY || n2.closeStroke, u2 = Math.abs(s3.x - a2.x) < r3 && Math.abs(s3.y - a2.y) < r3;
        if (l2) {
          i2 = i2.slice(), u2 && (i2.pop(), i2.pop(), a2.set(i2[i2.length - 2], i2[i2.length - 1]));
          var h2 = 0.5 * (s3.x + a2.x), c2 = 0.5 * (a2.y + s3.y);
          i2.unshift(h2, c2), i2.push(h2, c2);
        }
        var d2 = e4.points, p2 = i2.length / 2, f2 = i2.length, m2 = d2.length / 2, g2 = o3.width / 2, v2 = g2 * g2, _2 = o3.miterLimit * o3.miterLimit, y2 = i2[0], x2 = i2[1], b2 = i2[2], T2 = i2[3], w2 = 0, S2 = 0, E2 = -(x2 - T2), M2 = y2 - b2, A2 = 0, R2 = 0, P2 = Math.sqrt(E2 * E2 + M2 * M2);
        E2 /= P2, M2 /= P2, E2 *= g2, M2 *= g2;
        var C2 = o3.alignment, I2 = 2 * (1 - C2), O2 = 2 * C2;
        l2 || (o3.cap === ZT.ROUND ? f2 += uw(y2 - E2 * (I2 - O2) * 0.5, x2 - M2 * (I2 - O2) * 0.5, y2 - E2 * I2, x2 - M2 * I2, y2 + E2 * O2, x2 + M2 * O2, d2, true) + 2 : o3.cap === ZT.SQUARE && (f2 += lw(y2, x2, E2, M2, I2, O2, true, d2))), d2.push(y2 - E2 * I2, x2 - M2 * I2), d2.push(y2 + E2 * O2, x2 + M2 * O2);
        for (var L2 = 1; L2 < p2 - 1; ++L2) {
          y2 = i2[2 * (L2 - 1)], x2 = i2[2 * (L2 - 1) + 1], b2 = i2[2 * L2], T2 = i2[2 * L2 + 1], w2 = i2[2 * (L2 + 1)], S2 = i2[2 * (L2 + 1) + 1], E2 = -(x2 - T2), M2 = y2 - b2, E2 /= P2 = Math.sqrt(E2 * E2 + M2 * M2), M2 /= P2, E2 *= g2, M2 *= g2, A2 = -(T2 - S2), R2 = b2 - w2, A2 /= P2 = Math.sqrt(A2 * A2 + R2 * R2), R2 /= P2, A2 *= g2, R2 *= g2;
          var N2 = b2 - y2, D2 = x2 - T2, F2 = b2 - w2, B2 = S2 - T2, U2 = D2 * F2 - B2 * N2, k2 = U2 < 0;
          if (Math.abs(U2) < 0.1)
            d2.push(b2 - E2 * I2, T2 - M2 * I2), d2.push(b2 + E2 * O2, T2 + M2 * O2);
          else {
            var G2 = (-E2 + y2) * (-M2 + T2) - (-E2 + b2) * (-M2 + x2), H2 = (-A2 + w2) * (-R2 + T2) - (-A2 + b2) * (-R2 + S2), z2 = (N2 * H2 - F2 * G2) / U2, j2 = (B2 * G2 - D2 * H2) / U2, V2 = (z2 - b2) * (z2 - b2) + (j2 - T2) * (j2 - T2), W2 = b2 + (z2 - b2) * I2, X2 = T2 + (j2 - T2) * I2, q2 = b2 - (z2 - b2) * O2, Y2 = T2 - (j2 - T2) * O2, Z2 = k2 ? I2 : O2;
            V2 <= Math.min(N2 * N2 + D2 * D2, F2 * F2 + B2 * B2) + Z2 * Z2 * v2 ? o3.join === YT.BEVEL || V2 / v2 > _2 ? (k2 ? (d2.push(W2, X2), d2.push(b2 + E2 * O2, T2 + M2 * O2), d2.push(W2, X2), d2.push(b2 + A2 * O2, T2 + R2 * O2)) : (d2.push(b2 - E2 * I2, T2 - M2 * I2), d2.push(q2, Y2), d2.push(b2 - A2 * I2, T2 - R2 * I2), d2.push(q2, Y2)), f2 += 2) : o3.join === YT.ROUND ? k2 ? (d2.push(W2, X2), d2.push(b2 + E2 * O2, T2 + M2 * O2), f2 += uw(b2, T2, b2 + E2 * O2, T2 + M2 * O2, b2 + A2 * O2, T2 + R2 * O2, d2, true) + 4, d2.push(W2, X2), d2.push(b2 + A2 * O2, T2 + R2 * O2)) : (d2.push(b2 - E2 * I2, T2 - M2 * I2), d2.push(q2, Y2), f2 += uw(b2, T2, b2 - E2 * I2, T2 - M2 * I2, b2 - A2 * I2, T2 - R2 * I2, d2, false) + 4, d2.push(b2 - A2 * I2, T2 - R2 * I2), d2.push(q2, Y2)) : (d2.push(W2, X2), d2.push(q2, Y2)) : (d2.push(b2 - E2 * I2, T2 - M2 * I2), d2.push(b2 + E2 * O2, T2 + M2 * O2), o3.join === YT.BEVEL || V2 / v2 > _2 || (o3.join === YT.ROUND ? f2 += k2 ? uw(b2, T2, b2 + E2 * O2, T2 + M2 * O2, b2 + A2 * O2, T2 + R2 * O2, d2, true) + 2 : uw(b2, T2, b2 - E2 * I2, T2 - M2 * I2, b2 - A2 * I2, T2 - R2 * I2, d2, false) + 2 : (k2 ? (d2.push(q2, Y2), d2.push(q2, Y2)) : (d2.push(W2, X2), d2.push(W2, X2)), f2 += 2)), d2.push(b2 - A2 * I2, T2 - R2 * I2), d2.push(b2 + A2 * O2, T2 + R2 * O2), f2 += 2);
          }
        }
        y2 = i2[2 * (p2 - 2)], x2 = i2[2 * (p2 - 2) + 1], b2 = i2[2 * (p2 - 1)], E2 = -(x2 - (T2 = i2[2 * (p2 - 1) + 1])), M2 = y2 - b2, E2 /= P2 = Math.sqrt(E2 * E2 + M2 * M2), M2 /= P2, E2 *= g2, M2 *= g2, d2.push(b2 - E2 * I2, T2 - M2 * I2), d2.push(b2 + E2 * O2, T2 + M2 * O2), l2 || (o3.cap === ZT.ROUND ? f2 += uw(b2 - E2 * (I2 - O2) * 0.5, T2 - M2 * (I2 - O2) * 0.5, b2 - E2 * I2, T2 - M2 * I2, b2 + E2 * O2, T2 + M2 * O2, d2, false) + 2 : o3.cap === ZT.SQUARE && (f2 += lw(b2, T2, E2, M2, I2, O2, false, d2)));
        var J2 = e4.indices, $2 = KT.epsilon * KT.epsilon;
        for (L2 = m2; L2 < f2 + m2 - 2; ++L2)
          y2 = d2[2 * L2], x2 = d2[2 * L2 + 1], b2 = d2[2 * (L2 + 1)], T2 = d2[2 * (L2 + 1) + 1], w2 = d2[2 * (L2 + 2)], S2 = d2[2 * (L2 + 2) + 1], Math.abs(y2 * (T2 - S2) + b2 * (S2 - x2) + w2 * (x2 - T2)) < $2 || J2.push(L2, L2 + 1, L2 + 2);
      }
    }(t3, e3);
  }
  var cw, dw = function() {
    function t3() {
    }
    return t3.curveTo = function(t4, e3, n2, i2, r3, o3) {
      var s3 = o3[o3.length - 2], a2 = o3[o3.length - 1] - e3, l2 = s3 - t4, u2 = i2 - e3, h2 = n2 - t4, c2 = Math.abs(a2 * h2 - l2 * u2);
      if (c2 < 1e-8 || r3 === 0)
        return o3[o3.length - 2] === t4 && o3[o3.length - 1] === e3 || o3.push(t4, e3), null;
      var d2 = a2 * a2 + l2 * l2, p2 = u2 * u2 + h2 * h2, f2 = a2 * u2 + l2 * h2, m2 = r3 * Math.sqrt(d2) / c2, g2 = r3 * Math.sqrt(p2) / c2, v2 = m2 * f2 / d2, _2 = g2 * f2 / p2, y2 = m2 * h2 + g2 * l2, x2 = m2 * u2 + g2 * a2, b2 = l2 * (g2 + v2), T2 = a2 * (g2 + v2), w2 = h2 * (m2 + _2), S2 = u2 * (m2 + _2);
      return { cx: y2 + t4, cy: x2 + e3, radius: r3, startAngle: Math.atan2(T2 - x2, b2 - y2), endAngle: Math.atan2(S2 - x2, w2 - y2), anticlockwise: l2 * u2 > h2 * a2 };
    }, t3.arc = function(t4, e3, n2, i2, r3, o3, s3, a2, l2) {
      for (var u2 = s3 - o3, h2 = KT._segmentsCount(Math.abs(u2) * r3, 40 * Math.ceil(Math.abs(u2) / u_)), c2 = u2 / (2 * h2), d2 = 2 * c2, p2 = Math.cos(c2), f2 = Math.sin(c2), m2 = h2 - 1, g2 = m2 % 1 / m2, v2 = 0; v2 <= m2; ++v2) {
        var _2 = c2 + o3 + d2 * (v2 + g2 * v2), y2 = Math.cos(_2), x2 = -Math.sin(_2);
        l2.push((p2 * y2 + f2 * x2) * r3 + n2, (p2 * -x2 + f2 * y2) * r3 + i2);
      }
    }, t3;
  }(), pw = function() {
    function t3() {
    }
    return t3.curveLength = function(t4, e3, n2, i2, r3, o3, s3, a2) {
      for (var l2 = 0, u2 = 0, h2 = 0, c2 = 0, d2 = 0, p2 = 0, f2 = 0, m2 = 0, g2 = 0, v2 = 0, _2 = 0, y2 = t4, x2 = e3, b2 = 1; b2 <= 10; ++b2)
        v2 = y2 - (m2 = (f2 = (p2 = (d2 = 1 - (u2 = b2 / 10)) * d2) * d2) * t4 + 3 * p2 * u2 * n2 + 3 * d2 * (h2 = u2 * u2) * r3 + (c2 = h2 * u2) * s3), _2 = x2 - (g2 = f2 * e3 + 3 * p2 * u2 * i2 + 3 * d2 * h2 * o3 + c2 * a2), y2 = m2, x2 = g2, l2 += Math.sqrt(v2 * v2 + _2 * _2);
      return l2;
    }, t3.curveTo = function(e3, n2, i2, r3, o3, s3, a2) {
      var l2 = a2[a2.length - 2], u2 = a2[a2.length - 1];
      a2.length -= 2;
      var h2 = KT._segmentsCount(t3.curveLength(l2, u2, e3, n2, i2, r3, o3, s3)), c2 = 0, d2 = 0, p2 = 0, f2 = 0, m2 = 0;
      a2.push(l2, u2);
      for (var g2 = 1, v2 = 0; g2 <= h2; ++g2)
        p2 = (d2 = (c2 = 1 - (v2 = g2 / h2)) * c2) * c2, m2 = (f2 = v2 * v2) * v2, a2.push(p2 * l2 + 3 * d2 * v2 * e3 + 3 * c2 * f2 * i2 + m2 * o3, p2 * u2 + 3 * d2 * v2 * n2 + 3 * c2 * f2 * r3 + m2 * s3);
    }, t3;
  }(), fw = function() {
    function t3() {
    }
    return t3.curveLength = function(t4, e3, n2, i2, r3, o3) {
      var s3 = t4 - 2 * n2 + r3, a2 = e3 - 2 * i2 + o3, l2 = 2 * n2 - 2 * t4, u2 = 2 * i2 - 2 * e3, h2 = 4 * (s3 * s3 + a2 * a2), c2 = 4 * (s3 * l2 + a2 * u2), d2 = l2 * l2 + u2 * u2, p2 = 2 * Math.sqrt(h2 + c2 + d2), f2 = Math.sqrt(h2), m2 = 2 * h2 * f2, g2 = 2 * Math.sqrt(d2), v2 = c2 / f2;
      return (m2 * p2 + f2 * c2 * (p2 - g2) + (4 * d2 * h2 - c2 * c2) * Math.log((2 * f2 + v2 + p2) / (v2 + g2))) / (4 * m2);
    }, t3.curveTo = function(e3, n2, i2, r3, o3) {
      for (var s3 = o3[o3.length - 2], a2 = o3[o3.length - 1], l2 = KT._segmentsCount(t3.curveLength(s3, a2, e3, n2, i2, r3)), u2 = 0, h2 = 0, c2 = 1; c2 <= l2; ++c2) {
        var d2 = c2 / l2;
        u2 = s3 + (e3 - s3) * d2, h2 = a2 + (n2 - a2) * d2, o3.push(u2 + (e3 + (i2 - e3) * d2 - u2) * d2, h2 + (n2 + (r3 - n2) * d2 - h2) * d2);
      }
    }, t3;
  }(), mw = function() {
    function t3() {
      this.reset();
    }
    return t3.prototype.begin = function(t4, e3, n2) {
      this.reset(), this.style = t4, this.start = e3, this.attribStart = n2;
    }, t3.prototype.end = function(t4, e3) {
      this.attribSize = e3 - this.attribStart, this.size = t4 - this.start;
    }, t3.prototype.reset = function() {
      this.style = null, this.size = 0, this.start = 0, this.attribStart = 0, this.attribSize = 0;
    }, t3;
  }(), gw = ((cw = {})[l_.POLY] = nw, cw[l_.CIRC] = iw, cw[l_.ELIP] = iw, cw[l_.RECT] = rw, cw[l_.RREC] = aw, cw), vw = [], _w = [];
  function yw(t3) {
    for (var e3 = t3.points, n2 = 0, i2 = 0; i2 < e3.length - 2; i2 += 2)
      n2 += (e3[i2 + 2] - e3[i2]) * (e3[i2 + 3] + e3[i2 + 1]);
    return n2 > 0;
  }
  var xw = function() {
    function t3(t4, e3, n2, i2) {
      e3 === void 0 && (e3 = null), n2 === void 0 && (n2 = null), i2 === void 0 && (i2 = null), this.points = [], this.holes = [], this.shape = t4, this.lineStyle = n2, this.fillStyle = e3, this.matrix = i2, this.type = t4.type;
    }
    return t3.prototype.clone = function() {
      return new t3(this.shape, this.fillStyle, this.lineStyle, this.matrix);
    }, t3.prototype.destroy = function() {
      this.shape = null, this.holes.length = 0, this.holes = null, this.points.length = 0, this.points = null, this.lineStyle = null, this.fillStyle = null;
    }, t3;
  }(), bw = new v_(), Tw = new P_(), ww = function(t3) {
    function e3() {
      var e4 = t3.call(this) || this;
      return e4.closePointEps = 1e-4, e4.boundsPadding = 0, e4.uvsFloat32 = null, e4.indicesUint16 = null, e4.batchable = false, e4.points = [], e4.colors = [], e4.uvs = [], e4.indices = [], e4.textureIds = [], e4.graphicsData = [], e4.drawCalls = [], e4.batchDirty = -1, e4.batches = [], e4.dirty = 0, e4.cacheDirty = -1, e4.clearDirty = 0, e4.shapeIndex = 0, e4._bounds = new P_(), e4.boundsDirty = -1, e4;
    }
    return ew(e3, t3), Object.defineProperty(e3.prototype, "bounds", { get: function() {
      return this.boundsDirty !== this.dirty && (this.boundsDirty = this.dirty, this.calculateBounds()), this._bounds;
    }, enumerable: false, configurable: true }), e3.prototype.invalidate = function() {
      this.boundsDirty = -1, this.dirty++, this.batchDirty++, this.shapeIndex = 0, this.points.length = 0, this.colors.length = 0, this.uvs.length = 0, this.indices.length = 0, this.textureIds.length = 0;
      for (var t4 = 0; t4 < this.drawCalls.length; t4++)
        this.drawCalls[t4].texArray.clear(), _w.push(this.drawCalls[t4]);
      this.drawCalls.length = 0;
      for (t4 = 0; t4 < this.batches.length; t4++) {
        var e4 = this.batches[t4];
        e4.reset(), vw.push(e4);
      }
      this.batches.length = 0;
    }, e3.prototype.clear = function() {
      return this.graphicsData.length > 0 && (this.invalidate(), this.clearDirty++, this.graphicsData.length = 0), this;
    }, e3.prototype.drawShape = function(t4, e4, n2, i2) {
      e4 === void 0 && (e4 = null), n2 === void 0 && (n2 = null), i2 === void 0 && (i2 = null);
      var r3 = new xw(t4, e4, n2, i2);
      return this.graphicsData.push(r3), this.dirty++, this;
    }, e3.prototype.drawHole = function(t4, e4) {
      if (e4 === void 0 && (e4 = null), !this.graphicsData.length)
        return null;
      var n2 = new xw(t4, null, null, e4), i2 = this.graphicsData[this.graphicsData.length - 1];
      return n2.lineStyle = i2.lineStyle, i2.holes.push(n2), this.dirty++, this;
    }, e3.prototype.destroy = function() {
      t3.prototype.destroy.call(this);
      for (var e4 = 0; e4 < this.graphicsData.length; ++e4)
        this.graphicsData[e4].destroy();
      this.points.length = 0, this.points = null, this.colors.length = 0, this.colors = null, this.uvs.length = 0, this.uvs = null, this.indices.length = 0, this.indices = null, this.indexBuffer.destroy(), this.indexBuffer = null, this.graphicsData.length = 0, this.graphicsData = null, this.drawCalls.length = 0, this.drawCalls = null, this.batches.length = 0, this.batches = null, this._bounds = null;
    }, e3.prototype.containsPoint = function(t4) {
      for (var e4 = this.graphicsData, n2 = 0; n2 < e4.length; ++n2) {
        var i2 = e4[n2];
        if (i2.fillStyle.visible && (i2.shape && (i2.matrix ? i2.matrix.applyInverse(t4, bw) : bw.copyFrom(t4), i2.shape.contains(bw.x, bw.y)))) {
          var r3 = false;
          if (i2.holes)
            for (var o3 = 0; o3 < i2.holes.length; o3++) {
              if (i2.holes[o3].shape.contains(bw.x, bw.y)) {
                r3 = true;
                break;
              }
            }
          if (!r3)
            return true;
        }
      }
      return false;
    }, e3.prototype.updateBatches = function(t4) {
      if (this.graphicsData.length) {
        if (this.validateBatching()) {
          this.cacheDirty = this.dirty;
          var e4 = this.uvs, n2 = this.graphicsData, i2 = null, r3 = null;
          this.batches.length > 0 && (r3 = (i2 = this.batches[this.batches.length - 1]).style);
          for (var o3 = this.shapeIndex; o3 < n2.length; o3++) {
            this.shapeIndex++;
            var s3 = n2[o3], a2 = s3.fillStyle, l2 = s3.lineStyle;
            gw[s3.type].build(s3), s3.matrix && this.transformPoints(s3.points, s3.matrix);
            for (var u2 = 0; u2 < 2; u2++) {
              var h2 = u2 === 0 ? a2 : l2;
              if (h2.visible) {
                var c2 = h2.texture.baseTexture, d2 = this.indices.length, p2 = this.points.length / 2;
                c2.wrapMode = sv.REPEAT, u2 === 0 ? this.processFill(s3) : this.processLine(s3);
                var f2 = this.points.length / 2 - p2;
                f2 !== 0 && (i2 && !this._compareStyles(r3, h2) && (i2.end(d2, p2), i2 = null), i2 || ((i2 = vw.pop() || new mw()).begin(h2, d2, p2), this.batches.push(i2), r3 = h2), this.addUvs(this.points, e4, h2.texture, p2, f2, h2.matrix));
              }
            }
          }
          var m2 = this.indices.length, g2 = this.points.length / 2;
          if (i2 && i2.end(m2, g2), this.batches.length !== 0) {
            if (this.indicesUint16 && this.indices.length === this.indicesUint16.length)
              this.indicesUint16.set(this.indices);
            else {
              var v2 = g2 > 65535 && t4;
              this.indicesUint16 = v2 ? new Uint32Array(this.indices) : new Uint16Array(this.indices);
            }
            this.batchable = this.isBatchable(), this.batchable ? this.packBatches() : this.buildDrawCalls();
          } else
            this.batchable = true;
        }
      } else
        this.batchable = true;
    }, e3.prototype._compareStyles = function(t4, e4) {
      return !(!t4 || !e4) && (t4.texture.baseTexture === e4.texture.baseTexture && (t4.color + t4.alpha === e4.color + e4.alpha && !!t4.native == !!e4.native));
    }, e3.prototype.validateBatching = function() {
      if (this.dirty === this.cacheDirty || !this.graphicsData.length)
        return false;
      for (var t4 = 0, e4 = this.graphicsData.length; t4 < e4; t4++) {
        var n2 = this.graphicsData[t4], i2 = n2.fillStyle, r3 = n2.lineStyle;
        if (i2 && !i2.texture.baseTexture.valid)
          return false;
        if (r3 && !r3.texture.baseTexture.valid)
          return false;
      }
      return true;
    }, e3.prototype.packBatches = function() {
      this.batchDirty++, this.uvsFloat32 = new Float32Array(this.uvs);
      for (var t4 = this.batches, e4 = 0, n2 = t4.length; e4 < n2; e4++)
        for (var i2 = t4[e4], r3 = 0; r3 < i2.size; r3++) {
          var o3 = i2.start + r3;
          this.indicesUint16[o3] = this.indicesUint16[o3] - i2.attribStart;
        }
    }, e3.prototype.isBatchable = function() {
      if (this.points.length > 131070)
        return false;
      for (var t4 = this.batches, n2 = 0; n2 < t4.length; n2++)
        if (t4[n2].style.native)
          return false;
      return this.points.length < 2 * e3.BATCHABLE_SIZE;
    }, e3.prototype.buildDrawCalls = function() {
      for (var t4 = ++wy._globalBatch, e4 = 0; e4 < this.drawCalls.length; e4++)
        this.drawCalls[e4].texArray.clear(), _w.push(this.drawCalls[e4]);
      this.drawCalls.length = 0;
      var n2 = this.colors, i2 = this.textureIds, r3 = _w.pop();
      r3 || ((r3 = new yb()).texArray = new xb()), r3.texArray.count = 0, r3.start = 0, r3.size = 0, r3.type = tv.TRIANGLES;
      var o3 = 0, s3 = null, a2 = 0, l2 = false, u2 = tv.TRIANGLES, h2 = 0;
      this.drawCalls.push(r3);
      for (e4 = 0; e4 < this.batches.length; e4++) {
        var c2 = this.batches[e4], d2 = c2.style, p2 = d2.texture.baseTexture;
        l2 !== !!d2.native && (u2 = (l2 = !!d2.native) ? tv.LINES : tv.TRIANGLES, s3 = null, o3 = 8, t4++), s3 !== p2 && (s3 = p2, p2._batchEnabled !== t4 && (o3 === 8 && (t4++, o3 = 0, r3.size > 0 && ((r3 = _w.pop()) || ((r3 = new yb()).texArray = new xb()), this.drawCalls.push(r3)), r3.start = h2, r3.size = 0, r3.texArray.count = 0, r3.type = u2), p2.touched = 1, p2._batchEnabled = t4, p2._batchLocation = o3, p2.wrapMode = sv.REPEAT, r3.texArray.elements[r3.texArray.count++] = p2, o3++)), r3.size += c2.size, h2 += c2.size, a2 = p2._batchLocation, this.addColors(n2, d2.color, d2.alpha, c2.attribSize, c2.attribStart), this.addTextureIds(i2, a2, c2.attribSize, c2.attribStart);
      }
      wy._globalBatch = t4, this.packAttributes();
    }, e3.prototype.packAttributes = function() {
      for (var t4 = this.points, e4 = this.uvs, n2 = this.colors, i2 = this.textureIds, r3 = new ArrayBuffer(3 * t4.length * 4), o3 = new Float32Array(r3), s3 = new Uint32Array(r3), a2 = 0, l2 = 0; l2 < t4.length / 2; l2++)
        o3[a2++] = t4[2 * l2], o3[a2++] = t4[2 * l2 + 1], o3[a2++] = e4[2 * l2], o3[a2++] = e4[2 * l2 + 1], s3[a2++] = n2[l2], o3[a2++] = i2[l2];
      this._buffer.update(r3), this._indexBuffer.update(this.indicesUint16);
    }, e3.prototype.processFill = function(t4) {
      t4.holes.length ? (this.processHoles(t4.holes), nw.triangulate(t4, this)) : gw[t4.type].triangulate(t4, this);
    }, e3.prototype.processLine = function(t4) {
      hw(t4, this);
      for (var e4 = 0; e4 < t4.holes.length; e4++)
        hw(t4.holes[e4], this);
    }, e3.prototype.processHoles = function(t4) {
      for (var e4 = 0; e4 < t4.length; e4++) {
        var n2 = t4[e4];
        gw[n2.type].build(n2), n2.matrix && this.transformPoints(n2.points, n2.matrix);
      }
    }, e3.prototype.calculateBounds = function() {
      var t4 = this._bounds, e4 = Tw, n2 = y_.IDENTITY;
      this._bounds.clear(), e4.clear();
      for (var i2 = 0; i2 < this.graphicsData.length; i2++) {
        var r3 = this.graphicsData[i2], o3 = r3.shape, s3 = r3.type, a2 = r3.lineStyle, l2 = r3.matrix || y_.IDENTITY, u2 = 0;
        if (a2 && a2.visible) {
          var h2 = a2.alignment;
          u2 = a2.width, s3 === l_.POLY ? yw(o3) ? u2 *= 1 - h2 : u2 *= h2 : u2 *= Math.max(0, h2);
        }
        if (n2 !== l2 && (e4.isEmpty() || (t4.addBoundsMatrix(e4, n2), e4.clear()), n2 = l2), s3 === l_.RECT || s3 === l_.RREC) {
          var c2 = o3;
          e4.addFramePad(c2.x, c2.y, c2.x + c2.width, c2.y + c2.height, u2, u2);
        } else if (s3 === l_.CIRC) {
          var d2 = o3;
          e4.addFramePad(d2.x, d2.y, d2.x, d2.y, d2.radius + u2, d2.radius + u2);
        } else if (s3 === l_.ELIP) {
          var p2 = o3;
          e4.addFramePad(p2.x, p2.y, p2.x, p2.y, p2.width + u2, p2.height + u2);
        } else {
          var f2 = o3;
          t4.addVerticesMatrix(n2, f2.points, 0, f2.points.length, u2, u2);
        }
      }
      e4.isEmpty() || t4.addBoundsMatrix(e4, n2), t4.pad(this.boundsPadding, this.boundsPadding);
    }, e3.prototype.transformPoints = function(t4, e4) {
      for (var n2 = 0; n2 < t4.length / 2; n2++) {
        var i2 = t4[2 * n2], r3 = t4[2 * n2 + 1];
        t4[2 * n2] = e4.a * i2 + e4.c * r3 + e4.tx, t4[2 * n2 + 1] = e4.b * i2 + e4.d * r3 + e4.ty;
      }
    }, e3.prototype.addColors = function(t4, e4, n2, i2, r3) {
      r3 === void 0 && (r3 = 0);
      var o3 = Dv((e4 >> 16) + (65280 & e4) + ((255 & e4) << 16), n2);
      t4.length = Math.max(t4.length, r3 + i2);
      for (var s3 = 0; s3 < i2; s3++)
        t4[r3 + s3] = o3;
    }, e3.prototype.addTextureIds = function(t4, e4, n2, i2) {
      i2 === void 0 && (i2 = 0), t4.length = Math.max(t4.length, i2 + n2);
      for (var r3 = 0; r3 < n2; r3++)
        t4[i2 + r3] = e4;
    }, e3.prototype.addUvs = function(t4, e4, n2, i2, r3, o3) {
      o3 === void 0 && (o3 = null);
      for (var s3 = 0, a2 = e4.length, l2 = n2.frame; s3 < r3; ) {
        var u2 = t4[2 * (i2 + s3)], h2 = t4[2 * (i2 + s3) + 1];
        if (o3) {
          var c2 = o3.a * u2 + o3.c * h2 + o3.tx;
          h2 = o3.b * u2 + o3.d * h2 + o3.ty, u2 = c2;
        }
        s3++, e4.push(u2 / l2.width, h2 / l2.height);
      }
      var d2 = n2.baseTexture;
      (l2.width < d2.width || l2.height < d2.height) && this.adjustUvs(e4, n2, a2, r3);
    }, e3.prototype.adjustUvs = function(t4, e4, n2, i2) {
      for (var r3 = e4.baseTexture, o3 = 1e-6, s3 = n2 + 2 * i2, a2 = e4.frame, l2 = a2.width / r3.width, u2 = a2.height / r3.height, h2 = a2.x / a2.width, c2 = a2.y / a2.height, d2 = Math.floor(t4[n2] + o3), p2 = Math.floor(t4[n2 + 1] + o3), f2 = n2 + 2; f2 < s3; f2 += 2)
        d2 = Math.min(d2, Math.floor(t4[f2] + o3)), p2 = Math.min(p2, Math.floor(t4[f2 + 1] + o3));
      h2 -= d2, c2 -= p2;
      for (f2 = n2; f2 < s3; f2 += 2)
        t4[f2] = (t4[f2] + h2) * l2, t4[f2 + 1] = (t4[f2 + 1] + c2) * u2;
    }, e3.BATCHABLE_SIZE = 100, e3;
  }(Sb), Sw = function(t3) {
    function e3() {
      var e4 = t3 !== null && t3.apply(this, arguments) || this;
      return e4.width = 0, e4.alignment = 0.5, e4.native = false, e4.cap = ZT.BUTT, e4.join = YT.MITER, e4.miterLimit = 10, e4;
    }
    return ew(e3, t3), e3.prototype.clone = function() {
      var t4 = new e3();
      return t4.color = this.color, t4.alpha = this.alpha, t4.texture = this.texture, t4.matrix = this.matrix, t4.visible = this.visible, t4.width = this.width, t4.alignment = this.alignment, t4.native = this.native, t4.cap = this.cap, t4.join = this.join, t4.miterLimit = this.miterLimit, t4;
    }, e3.prototype.reset = function() {
      t3.prototype.reset.call(this), this.color = 0, this.alignment = 0.5, this.width = 0, this.native = false;
    }, e3;
  }(QT), Ew = new Float32Array(3), Mw = {}, Aw = function(t3) {
    function e3(e4) {
      e4 === void 0 && (e4 = null);
      var n2 = t3.call(this) || this;
      return n2.shader = null, n2.pluginName = "batch", n2.currentPath = null, n2.batches = [], n2.batchTint = -1, n2.batchDirty = -1, n2.vertexData = null, n2._fillStyle = new QT(), n2._lineStyle = new Sw(), n2._matrix = null, n2._holeMode = false, n2.state = kx.for2d(), n2._geometry = e4 || new ww(), n2._geometry.refCount++, n2._transformID = -1, n2.tint = 16777215, n2.blendMode = Qg.NORMAL, n2;
    }
    return ew(e3, t3), Object.defineProperty(e3.prototype, "geometry", { get: function() {
      return this._geometry;
    }, enumerable: false, configurable: true }), e3.prototype.clone = function() {
      return this.finishPoly(), new e3(this._geometry);
    }, Object.defineProperty(e3.prototype, "blendMode", { get: function() {
      return this.state.blendMode;
    }, set: function(t4) {
      this.state.blendMode = t4;
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "tint", { get: function() {
      return this._tint;
    }, set: function(t4) {
      this._tint = t4;
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "fill", { get: function() {
      return this._fillStyle;
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "line", { get: function() {
      return this._lineStyle;
    }, enumerable: false, configurable: true }), e3.prototype.lineStyle = function(t4, e4, n2, i2, r3) {
      return t4 === void 0 && (t4 = null), e4 === void 0 && (e4 = 0), n2 === void 0 && (n2 = 1), i2 === void 0 && (i2 = 0.5), r3 === void 0 && (r3 = false), typeof t4 == "number" && (t4 = { width: t4, color: e4, alpha: n2, alignment: i2, native: r3 }), this.lineTextureStyle(t4);
    }, e3.prototype.lineTextureStyle = function(t4) {
      t4 = Object.assign({ width: 0, texture: ky.WHITE, color: t4 && t4.texture ? 16777215 : 0, alpha: 1, matrix: null, alignment: 0.5, native: false, cap: ZT.BUTT, join: YT.MITER, miterLimit: 10 }, t4), this.currentPath && this.startPoly();
      var e4 = t4.width > 0 && t4.alpha > 0;
      return e4 ? (t4.matrix && (t4.matrix = t4.matrix.clone(), t4.matrix.invert()), Object.assign(this._lineStyle, { visible: e4 }, t4)) : this._lineStyle.reset(), this;
    }, e3.prototype.startPoly = function() {
      if (this.currentPath) {
        var t4 = this.currentPath.points, e4 = this.currentPath.points.length;
        e4 > 2 && (this.drawShape(this.currentPath), this.currentPath = new m_(), this.currentPath.closeStroke = false, this.currentPath.points.push(t4[e4 - 2], t4[e4 - 1]));
      } else
        this.currentPath = new m_(), this.currentPath.closeStroke = false;
    }, e3.prototype.finishPoly = function() {
      this.currentPath && (this.currentPath.points.length > 2 ? (this.drawShape(this.currentPath), this.currentPath = null) : this.currentPath.points.length = 0);
    }, e3.prototype.moveTo = function(t4, e4) {
      return this.startPoly(), this.currentPath.points[0] = t4, this.currentPath.points[1] = e4, this;
    }, e3.prototype.lineTo = function(t4, e4) {
      this.currentPath || this.moveTo(0, 0);
      var n2 = this.currentPath.points, i2 = n2[n2.length - 2], r3 = n2[n2.length - 1];
      return i2 === t4 && r3 === e4 || n2.push(t4, e4), this;
    }, e3.prototype._initCurve = function(t4, e4) {
      t4 === void 0 && (t4 = 0), e4 === void 0 && (e4 = 0), this.currentPath ? this.currentPath.points.length === 0 && (this.currentPath.points = [t4, e4]) : this.moveTo(t4, e4);
    }, e3.prototype.quadraticCurveTo = function(t4, e4, n2, i2) {
      this._initCurve();
      var r3 = this.currentPath.points;
      return r3.length === 0 && this.moveTo(0, 0), fw.curveTo(t4, e4, n2, i2, r3), this;
    }, e3.prototype.bezierCurveTo = function(t4, e4, n2, i2, r3, o3) {
      return this._initCurve(), pw.curveTo(t4, e4, n2, i2, r3, o3, this.currentPath.points), this;
    }, e3.prototype.arcTo = function(t4, e4, n2, i2, r3) {
      this._initCurve(t4, e4);
      var o3 = this.currentPath.points, s3 = dw.curveTo(t4, e4, n2, i2, r3, o3);
      if (s3) {
        var a2 = s3.cx, l2 = s3.cy, u2 = s3.radius, h2 = s3.startAngle, c2 = s3.endAngle, d2 = s3.anticlockwise;
        this.arc(a2, l2, u2, h2, c2, d2);
      }
      return this;
    }, e3.prototype.arc = function(t4, e4, n2, i2, r3, o3) {
      if (o3 === void 0 && (o3 = false), i2 === r3)
        return this;
      if (!o3 && r3 <= i2 ? r3 += u_ : o3 && i2 <= r3 && (i2 += u_), r3 - i2 === 0)
        return this;
      var s3 = t4 + Math.cos(i2) * n2, a2 = e4 + Math.sin(i2) * n2, l2 = this._geometry.closePointEps, u2 = this.currentPath ? this.currentPath.points : null;
      if (u2) {
        var h2 = Math.abs(u2[u2.length - 2] - s3), c2 = Math.abs(u2[u2.length - 1] - a2);
        h2 < l2 && c2 < l2 || u2.push(s3, a2);
      } else
        this.moveTo(s3, a2), u2 = this.currentPath.points;
      return dw.arc(s3, a2, t4, e4, n2, i2, r3, o3, u2), this;
    }, e3.prototype.beginFill = function(t4, e4) {
      return t4 === void 0 && (t4 = 0), e4 === void 0 && (e4 = 1), this.beginTextureFill({ texture: ky.WHITE, color: t4, alpha: e4 });
    }, e3.prototype.beginTextureFill = function(t4) {
      t4 = Object.assign({ texture: ky.WHITE, color: 16777215, alpha: 1, matrix: null }, t4), this.currentPath && this.startPoly();
      var e4 = t4.alpha > 0;
      return e4 ? (t4.matrix && (t4.matrix = t4.matrix.clone(), t4.matrix.invert()), Object.assign(this._fillStyle, { visible: e4 }, t4)) : this._fillStyle.reset(), this;
    }, e3.prototype.endFill = function() {
      return this.finishPoly(), this._fillStyle.reset(), this;
    }, e3.prototype.drawRect = function(t4, e4, n2, i2) {
      return this.drawShape(new d_(t4, e4, n2, i2));
    }, e3.prototype.drawRoundedRect = function(t4, e4, n2, i2, r3) {
      return this.drawShape(new g_(t4, e4, n2, i2, r3));
    }, e3.prototype.drawCircle = function(t4, e4, n2) {
      return this.drawShape(new p_(t4, e4, n2));
    }, e3.prototype.drawEllipse = function(t4, e4, n2, i2) {
      return this.drawShape(new f_(t4, e4, n2, i2));
    }, e3.prototype.drawPolygon = function() {
      for (var t4, e4 = arguments, n2 = [], i2 = 0; i2 < arguments.length; i2++)
        n2[i2] = e4[i2];
      var r3 = true, o3 = n2[0];
      o3.points ? (r3 = o3.closeStroke, t4 = o3.points) : t4 = Array.isArray(n2[0]) ? n2[0] : n2;
      var s3 = new m_(t4);
      return s3.closeStroke = r3, this.drawShape(s3), this;
    }, e3.prototype.drawShape = function(t4) {
      return this._holeMode ? this._geometry.drawHole(t4, this._matrix) : this._geometry.drawShape(t4, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix), this;
    }, e3.prototype.clear = function() {
      return this._geometry.clear(), this._lineStyle.reset(), this._fillStyle.reset(), this._boundsID++, this._matrix = null, this._holeMode = false, this.currentPath = null, this;
    }, e3.prototype.isFastRect = function() {
      var t4 = this._geometry.graphicsData;
      return !(t4.length !== 1 || t4[0].shape.type !== l_.RECT || t4[0].holes.length || t4[0].lineStyle.visible && t4[0].lineStyle.width);
    }, e3.prototype._render = function(t4) {
      this.finishPoly();
      var e4 = this._geometry, n2 = t4.context.supports.uint32Indices;
      e4.updateBatches(n2), e4.batchable ? (this.batchDirty !== e4.batchDirty && this._populateBatches(), this._renderBatched(t4)) : (t4.batch.flush(), this._renderDirect(t4));
    }, e3.prototype._populateBatches = function() {
      var t4 = this._geometry, e4 = this.blendMode, n2 = t4.batches.length;
      this.batchTint = -1, this._transformID = -1, this.batchDirty = t4.batchDirty, this.batches.length = n2, this.vertexData = new Float32Array(t4.points);
      for (var i2 = 0; i2 < n2; i2++) {
        var r3 = t4.batches[i2], o3 = r3.style.color, s3 = new Float32Array(this.vertexData.buffer, 4 * r3.attribStart * 2, 2 * r3.attribSize), a2 = new Float32Array(t4.uvsFloat32.buffer, 4 * r3.attribStart * 2, 2 * r3.attribSize), l2 = { vertexData: s3, blendMode: e4, indices: new Uint16Array(t4.indicesUint16.buffer, 2 * r3.start, r3.size), uvs: a2, _batchRGB: Rv(o3), _tintRGB: o3, _texture: r3.style.texture, alpha: r3.style.alpha, worldAlpha: 1 };
        this.batches[i2] = l2;
      }
    }, e3.prototype._renderBatched = function(t4) {
      if (this.batches.length) {
        t4.batch.setObjectRenderer(t4.plugins[this.pluginName]), this.calculateVertices(), this.calculateTints();
        for (var e4 = 0, n2 = this.batches.length; e4 < n2; e4++) {
          var i2 = this.batches[e4];
          i2.worldAlpha = this.worldAlpha * i2.alpha, t4.plugins[this.pluginName].render(i2);
        }
      }
    }, e3.prototype._renderDirect = function(t4) {
      var e4 = this._resolveDirectShader(t4), n2 = this._geometry, i2 = this.tint, r3 = this.worldAlpha, o3 = e4.uniforms, s3 = n2.drawCalls;
      o3.translationMatrix = this.transform.worldTransform, o3.tint[0] = (i2 >> 16 & 255) / 255 * r3, o3.tint[1] = (i2 >> 8 & 255) / 255 * r3, o3.tint[2] = (255 & i2) / 255 * r3, o3.tint[3] = r3, t4.shader.bind(e4), t4.geometry.bind(n2, e4), t4.state.set(this.state);
      for (var a2 = 0, l2 = s3.length; a2 < l2; a2++)
        this._renderDrawCallDirect(t4, n2.drawCalls[a2]);
    }, e3.prototype._renderDrawCallDirect = function(t4, e4) {
      for (var n2 = e4.texArray, i2 = e4.type, r3 = e4.size, o3 = e4.start, s3 = n2.count, a2 = 0; a2 < s3; a2++)
        t4.texture.bind(n2.elements[a2], a2);
      t4.geometry.draw(i2, r3, o3);
    }, e3.prototype._resolveDirectShader = function(t4) {
      var e4 = this.shader, n2 = this.pluginName;
      if (!e4) {
        if (!Mw[n2]) {
          for (var i2 = t4.plugins.batch.MAX_TEXTURES, r3 = new Int32Array(i2), o3 = 0; o3 < i2; o3++)
            r3[o3] = o3;
          var s3 = { tint: new Float32Array([1, 1, 1, 1]), translationMatrix: new y_(), default: tx.from({ uSamplers: r3 }, true) }, a2 = t4.plugins[n2]._shader.program;
          Mw[n2] = new Ux(a2, s3);
        }
        e4 = Mw[n2];
      }
      return e4;
    }, e3.prototype._calculateBounds = function() {
      this.finishPoly();
      var t4 = this._geometry;
      if (t4.graphicsData.length) {
        var e4 = t4.bounds, n2 = e4.minX, i2 = e4.minY, r3 = e4.maxX, o3 = e4.maxY;
        this._bounds.addFrame(this.transform, n2, i2, r3, o3);
      }
    }, e3.prototype.containsPoint = function(t4) {
      return this.worldTransform.applyInverse(t4, e3._TEMP_POINT), this._geometry.containsPoint(e3._TEMP_POINT);
    }, e3.prototype.calculateTints = function() {
      if (this.batchTint !== this.tint) {
        this.batchTint = this.tint;
        for (var t4 = Rv(this.tint, Ew), e4 = 0; e4 < this.batches.length; e4++) {
          var n2 = this.batches[e4], i2 = n2._batchRGB, r3 = (t4[0] * i2[0] * 255 << 16) + (t4[1] * i2[1] * 255 << 8) + (0 | t4[2] * i2[2] * 255);
          n2._tintRGB = (r3 >> 16) + (65280 & r3) + ((255 & r3) << 16);
        }
      }
    }, e3.prototype.calculateVertices = function() {
      var t4 = this.transform._worldID;
      if (this._transformID !== t4) {
        this._transformID = t4;
        for (var e4 = this.transform.worldTransform, n2 = e4.a, i2 = e4.b, r3 = e4.c, o3 = e4.d, s3 = e4.tx, a2 = e4.ty, l2 = this._geometry.points, u2 = this.vertexData, h2 = 0, c2 = 0; c2 < l2.length; c2 += 2) {
          var d2 = l2[c2], p2 = l2[c2 + 1];
          u2[h2++] = n2 * d2 + r3 * p2 + s3, u2[h2++] = o3 * p2 + i2 * d2 + a2;
        }
      }
    }, e3.prototype.closePath = function() {
      var t4 = this.currentPath;
      return t4 && (t4.closeStroke = true, this.finishPoly()), this;
    }, e3.prototype.setMatrix = function(t4) {
      return this._matrix = t4, this;
    }, e3.prototype.beginHole = function() {
      return this.finishPoly(), this._holeMode = true, this;
    }, e3.prototype.endHole = function() {
      return this.finishPoly(), this._holeMode = false, this;
    }, e3.prototype.destroy = function(e4) {
      this._geometry.refCount--, this._geometry.refCount === 0 && this._geometry.dispose(), this._matrix = null, this.currentPath = null, this._lineStyle.destroy(), this._lineStyle = null, this._fillStyle.destroy(), this._fillStyle = null, this._geometry = null, this.shader = null, this.vertexData = null, this.batches.length = 0, this.batches = null, t3.prototype.destroy.call(this, e4);
    }, e3._TEMP_POINT = new v_(), e3;
  }(ty), Rw = function(t3, e3) {
    return (Rw = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e4) {
      t4.__proto__ = e4;
    } || function(t4, e4) {
      for (var n2 in e4)
        e4.hasOwnProperty(n2) && (t4[n2] = e4[n2]);
    })(t3, e3);
  };
  var Pw, Cw = new v_(), Iw = new Uint16Array([0, 1, 2, 0, 2, 3]), Ow = function(t3) {
    function e3(e4) {
      var n2 = t3.call(this) || this;
      return n2._anchor = new __(n2._onAnchorUpdate, n2, e4 ? e4.defaultAnchor.x : 0, e4 ? e4.defaultAnchor.y : 0), n2._texture = null, n2._width = 0, n2._height = 0, n2._tint = null, n2._tintRGB = null, n2.tint = 16777215, n2.blendMode = Qg.NORMAL, n2._cachedTint = 16777215, n2.uvs = null, n2.texture = e4 || ky.EMPTY, n2.vertexData = new Float32Array(8), n2.vertexTrimmedData = null, n2._transformID = -1, n2._textureID = -1, n2._transformTrimmedID = -1, n2._textureTrimmedID = -1, n2.indices = Iw, n2.pluginName = "batch", n2.isSprite = true, n2._roundPixels = mv.ROUND_PIXELS, n2;
    }
    return function(t4, e4) {
      function n2() {
        this.constructor = t4;
      }
      Rw(t4, e4), t4.prototype = e4 === null ? Object.create(e4) : (n2.prototype = e4.prototype, new n2());
    }(e3, t3), e3.prototype._onTextureUpdate = function() {
      this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this._width && (this.scale.x = Wv(this.scale.x) * this._width / this._texture.orig.width), this._height && (this.scale.y = Wv(this.scale.y) * this._height / this._texture.orig.height);
    }, e3.prototype._onAnchorUpdate = function() {
      this._transformID = -1, this._transformTrimmedID = -1;
    }, e3.prototype.calculateVertices = function() {
      var t4 = this._texture;
      if (this._transformID !== this.transform._worldID || this._textureID !== t4._updateID) {
        this._textureID !== t4._updateID && (this.uvs = this._texture._uvs.uvsFloat32), this._transformID = this.transform._worldID, this._textureID = t4._updateID;
        var e4 = this.transform.worldTransform, n2 = e4.a, i2 = e4.b, r3 = e4.c, o3 = e4.d, s3 = e4.tx, a2 = e4.ty, l2 = this.vertexData, u2 = t4.trim, h2 = t4.orig, c2 = this._anchor, d2 = 0, p2 = 0, f2 = 0, m2 = 0;
        if (u2 ? (d2 = (p2 = u2.x - c2._x * h2.width) + u2.width, f2 = (m2 = u2.y - c2._y * h2.height) + u2.height) : (d2 = (p2 = -c2._x * h2.width) + h2.width, f2 = (m2 = -c2._y * h2.height) + h2.height), l2[0] = n2 * p2 + r3 * m2 + s3, l2[1] = o3 * m2 + i2 * p2 + a2, l2[2] = n2 * d2 + r3 * m2 + s3, l2[3] = o3 * m2 + i2 * d2 + a2, l2[4] = n2 * d2 + r3 * f2 + s3, l2[5] = o3 * f2 + i2 * d2 + a2, l2[6] = n2 * p2 + r3 * f2 + s3, l2[7] = o3 * f2 + i2 * p2 + a2, this._roundPixels)
          for (var g2 = mv.RESOLUTION, v2 = 0; v2 < l2.length; ++v2)
            l2[v2] = Math.round((l2[v2] * g2 | 0) / g2);
      }
    }, e3.prototype.calculateTrimmedVertices = function() {
      if (this.vertexTrimmedData) {
        if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID)
          return;
      } else
        this.vertexTrimmedData = new Float32Array(8);
      this._transformTrimmedID = this.transform._worldID, this._textureTrimmedID = this._texture._updateID;
      var t4 = this._texture, e4 = this.vertexTrimmedData, n2 = t4.orig, i2 = this._anchor, r3 = this.transform.worldTransform, o3 = r3.a, s3 = r3.b, a2 = r3.c, l2 = r3.d, u2 = r3.tx, h2 = r3.ty, c2 = -i2._x * n2.width, d2 = c2 + n2.width, p2 = -i2._y * n2.height, f2 = p2 + n2.height;
      e4[0] = o3 * c2 + a2 * p2 + u2, e4[1] = l2 * p2 + s3 * c2 + h2, e4[2] = o3 * d2 + a2 * p2 + u2, e4[3] = l2 * p2 + s3 * d2 + h2, e4[4] = o3 * d2 + a2 * f2 + u2, e4[5] = l2 * f2 + s3 * d2 + h2, e4[6] = o3 * c2 + a2 * f2 + u2, e4[7] = l2 * f2 + s3 * c2 + h2;
    }, e3.prototype._render = function(t4) {
      this.calculateVertices(), t4.batch.setObjectRenderer(t4.plugins[this.pluginName]), t4.plugins[this.pluginName].render(this);
    }, e3.prototype._calculateBounds = function() {
      var t4 = this._texture.trim, e4 = this._texture.orig;
      !t4 || t4.width === e4.width && t4.height === e4.height ? (this.calculateVertices(), this._bounds.addQuad(this.vertexData)) : (this.calculateTrimmedVertices(), this._bounds.addQuad(this.vertexTrimmedData));
    }, e3.prototype.getLocalBounds = function(e4) {
      return this.children.length === 0 ? (this._bounds.minX = this._texture.orig.width * -this._anchor._x, this._bounds.minY = this._texture.orig.height * -this._anchor._y, this._bounds.maxX = this._texture.orig.width * (1 - this._anchor._x), this._bounds.maxY = this._texture.orig.height * (1 - this._anchor._y), e4 || (this._localBoundsRect || (this._localBoundsRect = new d_()), e4 = this._localBoundsRect), this._bounds.getRectangle(e4)) : t3.prototype.getLocalBounds.call(this, e4);
    }, e3.prototype.containsPoint = function(t4) {
      this.worldTransform.applyInverse(t4, Cw);
      var e4 = this._texture.orig.width, n2 = this._texture.orig.height, i2 = -e4 * this.anchor.x, r3 = 0;
      return Cw.x >= i2 && Cw.x < i2 + e4 && (r3 = -n2 * this.anchor.y, Cw.y >= r3 && Cw.y < r3 + n2);
    }, e3.prototype.destroy = function(e4) {
      if (t3.prototype.destroy.call(this, e4), this._texture.off("update", this._onTextureUpdate, this), this._anchor = null, typeof e4 == "boolean" ? e4 : e4 && e4.texture) {
        var n2 = typeof e4 == "boolean" ? e4 : e4 && e4.baseTexture;
        this._texture.destroy(!!n2);
      }
      this._texture = null;
    }, e3.from = function(t4, n2) {
      return new e3(t4 instanceof ky ? t4 : ky.from(t4, n2));
    }, Object.defineProperty(e3.prototype, "roundPixels", { get: function() {
      return this._roundPixels;
    }, set: function(t4) {
      this._roundPixels !== t4 && (this._transformID = -1), this._roundPixels = t4;
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "width", { get: function() {
      return Math.abs(this.scale.x) * this._texture.orig.width;
    }, set: function(t4) {
      var e4 = Wv(this.scale.x) || 1;
      this.scale.x = e4 * t4 / this._texture.orig.width, this._width = t4;
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "height", { get: function() {
      return Math.abs(this.scale.y) * this._texture.orig.height;
    }, set: function(t4) {
      var e4 = Wv(this.scale.y) || 1;
      this.scale.y = e4 * t4 / this._texture.orig.height, this._height = t4;
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "anchor", { get: function() {
      return this._anchor;
    }, set: function(t4) {
      this._anchor.copyFrom(t4);
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "tint", { get: function() {
      return this._tint;
    }, set: function(t4) {
      this._tint = t4, this._tintRGB = (t4 >> 16) + (65280 & t4) + ((255 & t4) << 16);
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "texture", { get: function() {
      return this._texture;
    }, set: function(t4) {
      this._texture !== t4 && (this._texture && this._texture.off("update", this._onTextureUpdate, this), this._texture = t4 || ky.EMPTY, this._cachedTint = 16777215, this._textureID = -1, this._textureTrimmedID = -1, t4 && (t4.baseTexture.valid ? this._onTextureUpdate() : t4.once("update", this._onTextureUpdate, this)));
    }, enumerable: false, configurable: true }), e3;
  }(ty), Lw = function(t3, e3) {
    return (Lw = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e4) {
      t4.__proto__ = e4;
    } || function(t4, e4) {
      for (var n2 in e4)
        e4.hasOwnProperty(n2) && (t4[n2] = e4[n2]);
    })(t3, e3);
  };
  !function(t3) {
    t3[t3.LINEAR_VERTICAL = 0] = "LINEAR_VERTICAL", t3[t3.LINEAR_HORIZONTAL = 1] = "LINEAR_HORIZONTAL";
  }(Pw || (Pw = {}));
  var Nw = { align: "left", breakWords: false, dropShadow: false, dropShadowAlpha: 1, dropShadowAngle: Math.PI / 6, dropShadowBlur: 0, dropShadowColor: "black", dropShadowDistance: 5, fill: "black", fillGradientType: Pw.LINEAR_VERTICAL, fillGradientStops: [], fontFamily: "Arial", fontSize: 26, fontStyle: "normal", fontVariant: "normal", fontWeight: "normal", letterSpacing: 0, lineHeight: 0, lineJoin: "miter", miterLimit: 10, padding: 0, stroke: "black", strokeThickness: 0, textBaseline: "alphabetic", trim: false, whiteSpace: "pre", wordWrap: false, wordWrapWidth: 100, leading: 0 }, Dw = ["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui"], Fw = function() {
    function t3(t4) {
      this.styleID = 0, this.reset(), kw(this, t4, t4);
    }
    return t3.prototype.clone = function() {
      var e3 = {};
      return kw(e3, this, Nw), new t3(e3);
    }, t3.prototype.reset = function() {
      kw(this, Nw, Nw);
    }, Object.defineProperty(t3.prototype, "align", { get: function() {
      return this._align;
    }, set: function(t4) {
      this._align !== t4 && (this._align = t4, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "breakWords", { get: function() {
      return this._breakWords;
    }, set: function(t4) {
      this._breakWords !== t4 && (this._breakWords = t4, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "dropShadow", { get: function() {
      return this._dropShadow;
    }, set: function(t4) {
      this._dropShadow !== t4 && (this._dropShadow = t4, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "dropShadowAlpha", { get: function() {
      return this._dropShadowAlpha;
    }, set: function(t4) {
      this._dropShadowAlpha !== t4 && (this._dropShadowAlpha = t4, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "dropShadowAngle", { get: function() {
      return this._dropShadowAngle;
    }, set: function(t4) {
      this._dropShadowAngle !== t4 && (this._dropShadowAngle = t4, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "dropShadowBlur", { get: function() {
      return this._dropShadowBlur;
    }, set: function(t4) {
      this._dropShadowBlur !== t4 && (this._dropShadowBlur = t4, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "dropShadowColor", { get: function() {
      return this._dropShadowColor;
    }, set: function(t4) {
      var e3 = Uw(t4);
      this._dropShadowColor !== e3 && (this._dropShadowColor = e3, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "dropShadowDistance", { get: function() {
      return this._dropShadowDistance;
    }, set: function(t4) {
      this._dropShadowDistance !== t4 && (this._dropShadowDistance = t4, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "fill", { get: function() {
      return this._fill;
    }, set: function(t4) {
      var e3 = Uw(t4);
      this._fill !== e3 && (this._fill = e3, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "fillGradientType", { get: function() {
      return this._fillGradientType;
    }, set: function(t4) {
      this._fillGradientType !== t4 && (this._fillGradientType = t4, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "fillGradientStops", { get: function() {
      return this._fillGradientStops;
    }, set: function(t4) {
      (function(t5, e3) {
        if (!Array.isArray(t5) || !Array.isArray(e3))
          return false;
        if (t5.length !== e3.length)
          return false;
        for (var n2 = 0; n2 < t5.length; ++n2)
          if (t5[n2] !== e3[n2])
            return false;
        return true;
      })(this._fillGradientStops, t4) || (this._fillGradientStops = t4, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "fontFamily", { get: function() {
      return this._fontFamily;
    }, set: function(t4) {
      this.fontFamily !== t4 && (this._fontFamily = t4, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "fontSize", { get: function() {
      return this._fontSize;
    }, set: function(t4) {
      this._fontSize !== t4 && (this._fontSize = t4, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "fontStyle", { get: function() {
      return this._fontStyle;
    }, set: function(t4) {
      this._fontStyle !== t4 && (this._fontStyle = t4, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "fontVariant", { get: function() {
      return this._fontVariant;
    }, set: function(t4) {
      this._fontVariant !== t4 && (this._fontVariant = t4, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "fontWeight", { get: function() {
      return this._fontWeight;
    }, set: function(t4) {
      this._fontWeight !== t4 && (this._fontWeight = t4, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "letterSpacing", { get: function() {
      return this._letterSpacing;
    }, set: function(t4) {
      this._letterSpacing !== t4 && (this._letterSpacing = t4, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "lineHeight", { get: function() {
      return this._lineHeight;
    }, set: function(t4) {
      this._lineHeight !== t4 && (this._lineHeight = t4, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "leading", { get: function() {
      return this._leading;
    }, set: function(t4) {
      this._leading !== t4 && (this._leading = t4, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "lineJoin", { get: function() {
      return this._lineJoin;
    }, set: function(t4) {
      this._lineJoin !== t4 && (this._lineJoin = t4, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "miterLimit", { get: function() {
      return this._miterLimit;
    }, set: function(t4) {
      this._miterLimit !== t4 && (this._miterLimit = t4, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "padding", { get: function() {
      return this._padding;
    }, set: function(t4) {
      this._padding !== t4 && (this._padding = t4, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "stroke", { get: function() {
      return this._stroke;
    }, set: function(t4) {
      var e3 = Uw(t4);
      this._stroke !== e3 && (this._stroke = e3, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "strokeThickness", { get: function() {
      return this._strokeThickness;
    }, set: function(t4) {
      this._strokeThickness !== t4 && (this._strokeThickness = t4, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "textBaseline", { get: function() {
      return this._textBaseline;
    }, set: function(t4) {
      this._textBaseline !== t4 && (this._textBaseline = t4, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "trim", { get: function() {
      return this._trim;
    }, set: function(t4) {
      this._trim !== t4 && (this._trim = t4, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "whiteSpace", { get: function() {
      return this._whiteSpace;
    }, set: function(t4) {
      this._whiteSpace !== t4 && (this._whiteSpace = t4, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "wordWrap", { get: function() {
      return this._wordWrap;
    }, set: function(t4) {
      this._wordWrap !== t4 && (this._wordWrap = t4, this.styleID++);
    }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "wordWrapWidth", { get: function() {
      return this._wordWrapWidth;
    }, set: function(t4) {
      this._wordWrapWidth !== t4 && (this._wordWrapWidth = t4, this.styleID++);
    }, enumerable: false, configurable: true }), t3.prototype.toFontString = function() {
      var t4 = typeof this.fontSize == "number" ? this.fontSize + "px" : this.fontSize, e3 = this.fontFamily;
      Array.isArray(this.fontFamily) || (e3 = this.fontFamily.split(","));
      for (var n2 = e3.length - 1; n2 >= 0; n2--) {
        var i2 = e3[n2].trim();
        !/([\"\'])[^\'\"]+\1/.test(i2) && Dw.indexOf(i2) < 0 && (i2 = '"' + i2 + '"'), e3[n2] = i2;
      }
      return this.fontStyle + " " + this.fontVariant + " " + this.fontWeight + " " + t4 + " " + e3.join(",");
    }, t3;
  }();
  function Bw(t3) {
    return typeof t3 == "number" ? Pv(t3) : (typeof t3 == "string" && t3.indexOf("0x") === 0 && (t3 = t3.replace("0x", "#")), t3);
  }
  function Uw(t3) {
    if (Array.isArray(t3)) {
      for (var e3 = 0; e3 < t3.length; ++e3)
        t3[e3] = Bw(t3[e3]);
      return t3;
    }
    return Bw(t3);
  }
  function kw(t3, e3, n2) {
    for (var i2 in n2)
      Array.isArray(e3[i2]) ? t3[i2] = e3[i2].slice() : t3[i2] = e3[i2];
  }
  var Gw = function() {
    function t3(t4, e3, n2, i2, r3, o3, s3, a2, l2) {
      this.text = t4, this.style = e3, this.width = n2, this.height = i2, this.lines = r3, this.lineWidths = o3, this.lineHeight = s3, this.maxLineWidth = a2, this.fontProperties = l2;
    }
    return t3.measureText = function(e3, n2, i2, r3) {
      r3 === void 0 && (r3 = t3._canvas), i2 = i2 == null ? n2.wordWrap : i2;
      var o3 = n2.toFontString(), s3 = t3.measureFont(o3);
      s3.fontSize === 0 && (s3.fontSize = n2.fontSize, s3.ascent = n2.fontSize);
      var a2 = r3.getContext("2d");
      a2.font = o3;
      for (var l2 = (i2 ? t3.wordWrap(e3, n2, r3) : e3).split(/(?:\r\n|\r|\n)/), u2 = new Array(l2.length), h2 = 0, c2 = 0; c2 < l2.length; c2++) {
        var d2 = a2.measureText(l2[c2]).width + (l2[c2].length - 1) * n2.letterSpacing;
        u2[c2] = d2, h2 = Math.max(h2, d2);
      }
      var p2 = h2 + n2.strokeThickness;
      n2.dropShadow && (p2 += n2.dropShadowDistance);
      var f2 = n2.lineHeight || s3.fontSize + n2.strokeThickness, m2 = Math.max(f2, s3.fontSize + n2.strokeThickness) + (l2.length - 1) * (f2 + n2.leading);
      return n2.dropShadow && (m2 += n2.dropShadowDistance), new t3(e3, n2, p2, m2, l2, u2, f2 + n2.leading, h2, s3);
    }, t3.wordWrap = function(e3, n2, i2) {
      i2 === void 0 && (i2 = t3._canvas);
      for (var r3 = i2.getContext("2d"), o3 = 0, s3 = "", a2 = "", l2 = Object.create(null), u2 = n2.letterSpacing, h2 = n2.whiteSpace, c2 = t3.collapseSpaces(h2), d2 = t3.collapseNewlines(h2), p2 = !c2, f2 = n2.wordWrapWidth + u2, m2 = t3.tokenize(e3), g2 = 0; g2 < m2.length; g2++) {
        var v2 = m2[g2];
        if (t3.isNewline(v2)) {
          if (!d2) {
            a2 += t3.addLine(s3), p2 = !c2, s3 = "", o3 = 0;
            continue;
          }
          v2 = " ";
        }
        if (c2) {
          var _2 = t3.isBreakingSpace(v2), y2 = t3.isBreakingSpace(s3[s3.length - 1]);
          if (_2 && y2)
            continue;
        }
        var x2 = t3.getFromCache(v2, u2, l2, r3);
        if (x2 > f2)
          if (s3 !== "" && (a2 += t3.addLine(s3), s3 = "", o3 = 0), t3.canBreakWords(v2, n2.breakWords))
            for (var b2 = t3.wordWrapSplit(v2), T2 = 0; T2 < b2.length; T2++) {
              for (var w2 = b2[T2], S2 = 1; b2[T2 + S2]; ) {
                var E2 = b2[T2 + S2], M2 = w2[w2.length - 1];
                if (t3.canBreakChars(M2, E2, v2, T2, n2.breakWords))
                  break;
                w2 += E2, S2++;
              }
              T2 += w2.length - 1;
              var A2 = t3.getFromCache(w2, u2, l2, r3);
              A2 + o3 > f2 && (a2 += t3.addLine(s3), p2 = false, s3 = "", o3 = 0), s3 += w2, o3 += A2;
            }
          else {
            s3.length > 0 && (a2 += t3.addLine(s3), s3 = "", o3 = 0);
            var R2 = g2 === m2.length - 1;
            a2 += t3.addLine(v2, !R2), p2 = false, s3 = "", o3 = 0;
          }
        else
          x2 + o3 > f2 && (p2 = false, a2 += t3.addLine(s3), s3 = "", o3 = 0), (s3.length > 0 || !t3.isBreakingSpace(v2) || p2) && (s3 += v2, o3 += x2);
      }
      return a2 += t3.addLine(s3, false);
    }, t3.addLine = function(e3, n2) {
      return n2 === void 0 && (n2 = true), e3 = t3.trimRight(e3), e3 = n2 ? e3 + "\n" : e3;
    }, t3.getFromCache = function(t4, e3, n2, i2) {
      var r3 = n2[t4];
      if (typeof r3 != "number") {
        var o3 = t4.length * e3;
        r3 = i2.measureText(t4).width + o3, n2[t4] = r3;
      }
      return r3;
    }, t3.collapseSpaces = function(t4) {
      return t4 === "normal" || t4 === "pre-line";
    }, t3.collapseNewlines = function(t4) {
      return t4 === "normal";
    }, t3.trimRight = function(e3) {
      if (typeof e3 != "string")
        return "";
      for (var n2 = e3.length - 1; n2 >= 0; n2--) {
        var i2 = e3[n2];
        if (!t3.isBreakingSpace(i2))
          break;
        e3 = e3.slice(0, -1);
      }
      return e3;
    }, t3.isNewline = function(e3) {
      return typeof e3 == "string" && t3._newlines.indexOf(e3.charCodeAt(0)) >= 0;
    }, t3.isBreakingSpace = function(e3, n2) {
      return typeof e3 == "string" && t3._breakingSpaces.indexOf(e3.charCodeAt(0)) >= 0;
    }, t3.tokenize = function(e3) {
      var n2 = [], i2 = "";
      if (typeof e3 != "string")
        return n2;
      for (var r3 = 0; r3 < e3.length; r3++) {
        var o3 = e3[r3], s3 = e3[r3 + 1];
        t3.isBreakingSpace(o3, s3) || t3.isNewline(o3) ? (i2 !== "" && (n2.push(i2), i2 = ""), n2.push(o3)) : i2 += o3;
      }
      return i2 !== "" && n2.push(i2), n2;
    }, t3.canBreakWords = function(t4, e3) {
      return e3;
    }, t3.canBreakChars = function(t4, e3, n2, i2, r3) {
      return true;
    }, t3.wordWrapSplit = function(t4) {
      return t4.split("");
    }, t3.measureFont = function(e3) {
      if (t3._fonts[e3])
        return t3._fonts[e3];
      var n2 = { ascent: 0, descent: 0, fontSize: 0 }, i2 = t3._canvas, r3 = t3._context;
      r3.font = e3;
      var o3 = t3.METRICS_STRING + t3.BASELINE_SYMBOL, s3 = Math.ceil(r3.measureText(o3).width), a2 = Math.ceil(r3.measureText(t3.BASELINE_SYMBOL).width), l2 = Math.ceil(t3.HEIGHT_MULTIPLIER * a2);
      a2 = a2 * t3.BASELINE_MULTIPLIER | 0, i2.width = s3, i2.height = l2, r3.fillStyle = "#f00", r3.fillRect(0, 0, s3, l2), r3.font = e3, r3.textBaseline = "alphabetic", r3.fillStyle = "#000", r3.fillText(o3, 0, a2);
      var u2 = r3.getImageData(0, 0, s3, l2).data, h2 = u2.length, c2 = 4 * s3, d2 = 0, p2 = 0, f2 = false;
      for (d2 = 0; d2 < a2; ++d2) {
        for (var m2 = 0; m2 < c2; m2 += 4)
          if (u2[p2 + m2] !== 255) {
            f2 = true;
            break;
          }
        if (f2)
          break;
        p2 += c2;
      }
      for (n2.ascent = a2 - d2, p2 = h2 - c2, f2 = false, d2 = l2; d2 > a2; --d2) {
        for (m2 = 0; m2 < c2; m2 += 4)
          if (u2[p2 + m2] !== 255) {
            f2 = true;
            break;
          }
        if (f2)
          break;
        p2 -= c2;
      }
      return n2.descent = d2 - a2, n2.fontSize = n2.ascent + n2.descent, t3._fonts[e3] = n2, n2;
    }, t3.clearMetrics = function(e3) {
      e3 === void 0 && (e3 = ""), e3 ? delete t3._fonts[e3] : t3._fonts = {};
    }, t3;
  }(), Hw = function() {
    try {
      var t3 = new OffscreenCanvas(0, 0), e3 = t3.getContext("2d");
      return e3 && e3.measureText ? t3 : document.createElement("canvas");
    } catch (t4) {
      return document.createElement("canvas");
    }
  }();
  Hw.width = Hw.height = 10, Gw._canvas = Hw, Gw._context = Hw.getContext("2d"), Gw._fonts = {}, Gw.METRICS_STRING = "|\xC9q\xC5", Gw.BASELINE_SYMBOL = "M", Gw.BASELINE_MULTIPLIER = 1.4, Gw.HEIGHT_MULTIPLIER = 2, Gw._newlines = [10, 13], Gw._breakingSpaces = [9, 32, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8200, 8201, 8202, 8287, 12288];
  var zw = { texture: true, children: false, baseTexture: true }, jw = "letterSpacing" in CanvasRenderingContext2D.prototype || "textLetterSpacing" in CanvasRenderingContext2D.prototype, Vw = function(t3) {
    function e3(e4, n2, i2) {
      var r3 = this, o3 = false;
      i2 || (i2 = document.createElement("canvas"), o3 = true), i2.width = 3, i2.height = 3;
      var s3 = ky.from(i2);
      return s3.orig = new d_(), s3.trim = new d_(), (r3 = t3.call(this, s3) || this)._ownCanvas = o3, r3.canvas = i2, r3.context = r3.canvas.getContext("2d"), r3._resolution = mv.RESOLUTION, r3._autoResolution = true, r3._text = null, r3._style = null, r3._styleListener = null, r3._font = "", r3.text = e4, r3.style = n2, r3.localStyleID = -1, r3;
    }
    return function(t4, e4) {
      function n2() {
        this.constructor = t4;
      }
      Lw(t4, e4), t4.prototype = e4 === null ? Object.create(e4) : (n2.prototype = e4.prototype, new n2());
    }(e3, t3), e3.prototype.updateText = function(t4) {
      var n2 = this._style;
      if (this.localStyleID !== n2.styleID && (this.dirty = true, this.localStyleID = n2.styleID), this.dirty || !t4) {
        this._font = this._style.toFontString();
        var i2, r3, o3 = this.context, s3 = Gw.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas), a2 = s3.width, l2 = s3.height, u2 = s3.lines, h2 = s3.lineHeight, c2 = s3.lineWidths, d2 = s3.maxLineWidth, p2 = s3.fontProperties;
        this.canvas.width = Math.ceil(Math.ceil(Math.max(1, a2) + 2 * n2.padding) * this._resolution), this.canvas.height = Math.ceil(Math.ceil(Math.max(1, l2) + 2 * n2.padding) * this._resolution), o3.scale(this._resolution, this._resolution), o3.clearRect(0, 0, this.canvas.width, this.canvas.height), o3.font = this._font, o3.lineWidth = n2.strokeThickness, o3.textBaseline = n2.textBaseline, o3.lineJoin = n2.lineJoin, o3.miterLimit = n2.miterLimit;
        for (var f2 = n2.dropShadow ? 2 : 1, m2 = 0; m2 < f2; ++m2) {
          var g2 = n2.dropShadow && m2 === 0, v2 = g2 ? Math.ceil(Math.max(1, l2) + 2 * n2.padding) : 0, _2 = v2 * this._resolution;
          if (g2) {
            o3.fillStyle = "black", o3.strokeStyle = "black";
            var y2 = n2.dropShadowColor, x2 = Rv(typeof y2 == "number" ? y2 : Cv(y2));
            o3.shadowColor = "rgba(" + 255 * x2[0] + "," + 255 * x2[1] + "," + 255 * x2[2] + "," + n2.dropShadowAlpha + ")", o3.shadowBlur = n2.dropShadowBlur, o3.shadowOffsetX = Math.cos(n2.dropShadowAngle) * n2.dropShadowDistance, o3.shadowOffsetY = Math.sin(n2.dropShadowAngle) * n2.dropShadowDistance + _2;
          } else
            o3.fillStyle = this._generateFillStyle(n2, u2, s3), o3.strokeStyle = n2.stroke, o3.shadowColor = "black", o3.shadowBlur = 0, o3.shadowOffsetX = 0, o3.shadowOffsetY = 0;
          var b2 = (h2 - p2.fontSize) / 2;
          (!e3.nextLineHeightBehavior || h2 - p2.fontSize < 0) && (b2 = 0);
          for (var T2 = 0; T2 < u2.length; T2++)
            i2 = n2.strokeThickness / 2, r3 = n2.strokeThickness / 2 + T2 * h2 + p2.ascent + b2, n2.align === "right" ? i2 += d2 - c2[T2] : n2.align === "center" && (i2 += (d2 - c2[T2]) / 2), n2.stroke && n2.strokeThickness && this.drawLetterSpacing(u2[T2], i2 + n2.padding, r3 + n2.padding - v2, true), n2.fill && this.drawLetterSpacing(u2[T2], i2 + n2.padding, r3 + n2.padding - v2);
        }
        this.updateTexture();
      }
    }, e3.prototype.drawLetterSpacing = function(t4, e4, n2, i2) {
      i2 === void 0 && (i2 = false);
      var r3 = this._style.letterSpacing;
      if (r3 === 0 || jw)
        return jw && (this.context.letterSpacing = r3, this.context.textLetterSpacing = r3), void (i2 ? this.context.strokeText(t4, e4, n2) : this.context.fillText(t4, e4, n2));
      for (var o3 = e4, s3 = Array.from ? Array.from(t4) : t4.split(""), a2 = this.context.measureText(t4).width, l2 = 0, u2 = 0; u2 < s3.length; ++u2) {
        var h2 = s3[u2];
        i2 ? this.context.strokeText(h2, o3, n2) : this.context.fillText(h2, o3, n2), o3 += a2 - (l2 = this.context.measureText(t4.substring(u2 + 1)).width) + r3, a2 = l2;
      }
    }, e3.prototype.updateTexture = function() {
      var t4 = this.canvas;
      if (this._style.trim) {
        var e4 = n_(t4);
        e4.data && (t4.width = e4.width, t4.height = e4.height, this.context.putImageData(e4.data, 0, 0));
      }
      var n2 = this._texture, i2 = this._style, r3 = i2.trim ? 0 : i2.padding, o3 = n2.baseTexture;
      n2.trim.width = n2._frame.width = t4.width / this._resolution, n2.trim.height = n2._frame.height = t4.height / this._resolution, n2.trim.x = -r3, n2.trim.y = -r3, n2.orig.width = n2._frame.width - 2 * r3, n2.orig.height = n2._frame.height - 2 * r3, this._onTextureUpdate(), o3.setRealSize(t4.width, t4.height, this._resolution), n2.updateUvs(), this._recursivePostUpdateTransform(), this.dirty = false;
    }, e3.prototype._render = function(e4) {
      this._autoResolution && this._resolution !== e4.resolution && (this._resolution = e4.resolution, this.dirty = true), this.updateText(true), t3.prototype._render.call(this, e4);
    }, e3.prototype.getLocalBounds = function(e4) {
      return this.updateText(true), t3.prototype.getLocalBounds.call(this, e4);
    }, e3.prototype._calculateBounds = function() {
      this.updateText(true), this.calculateVertices(), this._bounds.addQuad(this.vertexData);
    }, e3.prototype._generateFillStyle = function(t4, e4, n2) {
      var i2, r3 = t4.fill;
      if (!Array.isArray(r3))
        return r3;
      if (r3.length === 1)
        return r3[0];
      var o3 = t4.dropShadow ? t4.dropShadowDistance : 0, s3 = t4.padding || 0, a2 = this.canvas.width / this._resolution - o3 - 2 * s3, l2 = this.canvas.height / this._resolution - o3 - 2 * s3, u2 = r3.slice(), h2 = t4.fillGradientStops.slice();
      if (!h2.length)
        for (var c2 = u2.length + 1, d2 = 1; d2 < c2; ++d2)
          h2.push(d2 / c2);
      if (u2.unshift(r3[0]), h2.unshift(0), u2.push(r3[r3.length - 1]), h2.push(1), t4.fillGradientType === Pw.LINEAR_VERTICAL) {
        i2 = this.context.createLinearGradient(a2 / 2, s3, a2 / 2, l2 + s3);
        var p2 = n2.fontProperties.fontSize + t4.strokeThickness;
        for (d2 = 0; d2 < e4.length; d2++) {
          var f2 = n2.lineHeight * (d2 - 1) + p2, m2 = n2.lineHeight * d2, g2 = m2;
          d2 > 0 && f2 > m2 && (g2 = (m2 + f2) / 2);
          var v2 = m2 + p2, _2 = n2.lineHeight * (d2 + 1), y2 = v2;
          d2 + 1 < e4.length && _2 < v2 && (y2 = (v2 + _2) / 2);
          for (var x2 = (y2 - g2) / l2, b2 = 0; b2 < u2.length; b2++) {
            var T2 = 0;
            T2 = typeof h2[b2] == "number" ? h2[b2] : b2 / u2.length;
            var w2 = Math.min(1, Math.max(0, g2 / l2 + T2 * x2));
            w2 = Number(w2.toFixed(5)), i2.addColorStop(w2, u2[b2]);
          }
        }
      } else {
        i2 = this.context.createLinearGradient(s3, l2 / 2, a2 + s3, l2 / 2);
        var S2 = u2.length + 1, E2 = 1;
        for (d2 = 0; d2 < u2.length; d2++) {
          var M2 = void 0;
          M2 = typeof h2[d2] == "number" ? h2[d2] : E2 / S2, i2.addColorStop(M2, u2[d2]), E2++;
        }
      }
      return i2;
    }, e3.prototype.destroy = function(e4) {
      typeof e4 == "boolean" && (e4 = { children: e4 }), e4 = Object.assign({}, zw, e4), t3.prototype.destroy.call(this, e4), this._ownCanvas && (this.canvas.height = this.canvas.width = 0), this.context = null, this.canvas = null, this._style = null;
    }, Object.defineProperty(e3.prototype, "width", { get: function() {
      return this.updateText(true), Math.abs(this.scale.x) * this._texture.orig.width;
    }, set: function(t4) {
      this.updateText(true);
      var e4 = Wv(this.scale.x) || 1;
      this.scale.x = e4 * t4 / this._texture.orig.width, this._width = t4;
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "height", { get: function() {
      return this.updateText(true), Math.abs(this.scale.y) * this._texture.orig.height;
    }, set: function(t4) {
      this.updateText(true);
      var e4 = Wv(this.scale.y) || 1;
      this.scale.y = e4 * t4 / this._texture.orig.height, this._height = t4;
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "style", { get: function() {
      return this._style;
    }, set: function(t4) {
      t4 = t4 || {}, this._style = t4 instanceof Fw ? t4 : new Fw(t4), this.localStyleID = -1, this.dirty = true;
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "text", { get: function() {
      return this._text;
    }, set: function(t4) {
      t4 = String(t4 == null ? "" : t4), this._text !== t4 && (this._text = t4, this.dirty = true);
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "resolution", { get: function() {
      return this._resolution;
    }, set: function(t4) {
      this._autoResolution = false, this._resolution !== t4 && (this._resolution = t4, this.dirty = true);
    }, enumerable: false, configurable: true }), e3.nextLineHeightBehavior = false, e3;
  }(Ow);
  /*!
   * @pixi/prepare - v6.2.0
   * Compiled Mon, 01 Nov 2021 16:52:10 UTC
   *
   * @pixi/prepare is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   */
  mv.UPLOADS_PER_FRAME = 4;
  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */
  var Ww = function(t3, e3) {
    return (Ww = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e4) {
      t4.__proto__ = e4;
    } || function(t4, e4) {
      for (var n2 in e4)
        e4.hasOwnProperty(n2) && (t4[n2] = e4[n2]);
    })(t3, e3);
  };
  var Xw = function() {
    function t3(t4) {
      this.maxItemsPerFrame = t4, this.itemsLeft = 0;
    }
    return t3.prototype.beginFrame = function() {
      this.itemsLeft = this.maxItemsPerFrame;
    }, t3.prototype.allowedToUpload = function() {
      return this.itemsLeft-- > 0;
    }, t3;
  }();
  function qw(t3, e3) {
    var n2 = false;
    if (t3 && t3._textures && t3._textures.length) {
      for (var i2 = 0; i2 < t3._textures.length; i2++)
        if (t3._textures[i2] instanceof ky) {
          var r3 = t3._textures[i2].baseTexture;
          e3.indexOf(r3) === -1 && (e3.push(r3), n2 = true);
        }
    }
    return n2;
  }
  function Yw(t3, e3) {
    if (t3.baseTexture instanceof wy) {
      var n2 = t3.baseTexture;
      return e3.indexOf(n2) === -1 && e3.push(n2), true;
    }
    return false;
  }
  function Zw(t3, e3) {
    if (t3._texture && t3._texture instanceof ky) {
      var n2 = t3._texture.baseTexture;
      return e3.indexOf(n2) === -1 && e3.push(n2), true;
    }
    return false;
  }
  function Jw(t3, e3) {
    return e3 instanceof Vw && (e3.updateText(true), true);
  }
  function $w(t3, e3) {
    if (e3 instanceof Fw) {
      var n2 = e3.toFontString();
      return Gw.measureFont(n2), true;
    }
    return false;
  }
  function Kw(t3, e3) {
    if (t3 instanceof Vw) {
      e3.indexOf(t3.style) === -1 && e3.push(t3.style), e3.indexOf(t3) === -1 && e3.push(t3);
      var n2 = t3._texture.baseTexture;
      return e3.indexOf(n2) === -1 && e3.push(n2), true;
    }
    return false;
  }
  function Qw(t3, e3) {
    return t3 instanceof Fw && (e3.indexOf(t3) === -1 && e3.push(t3), true);
  }
  function tS(t3, e3) {
    return e3 instanceof wy && (e3._glTextures[t3.CONTEXT_UID] || t3.texture.bind(e3), true);
  }
  function eS(t3, e3) {
    if (!(e3 instanceof Aw))
      return false;
    var n2 = e3.geometry;
    e3.finishPoly(), n2.updateBatches();
    for (var i2 = n2.batches, r3 = 0; r3 < i2.length; r3++) {
      var o3 = i2[r3].style.texture;
      o3 && tS(t3, o3.baseTexture);
    }
    return n2.batchable || t3.geometry.bind(n2, e3._resolveDirectShader(t3)), true;
  }
  function nS(t3, e3) {
    return t3 instanceof Aw && (e3.push(t3), true);
  }
  var iS = function(t3) {
    function e3(e4) {
      var n2 = t3.call(this, e4) || this;
      return n2.uploadHookHelper = n2.renderer, n2.registerFindHook(nS), n2.registerUploadHook(tS), n2.registerUploadHook(eS), n2;
    }
    return function(t4, e4) {
      function n2() {
        this.constructor = t4;
      }
      Ww(t4, e4), t4.prototype = e4 === null ? Object.create(e4) : (n2.prototype = e4.prototype, new n2());
    }(e3, t3), e3;
  }(function() {
    function t3(t4) {
      var e3 = this;
      this.limiter = new Xw(mv.UPLOADS_PER_FRAME), this.renderer = t4, this.uploadHookHelper = null, this.queue = [], this.addHooks = [], this.uploadHooks = [], this.completes = [], this.ticking = false, this.delayedTick = function() {
        e3.queue && e3.prepareItems();
      }, this.registerFindHook(Kw), this.registerFindHook(Qw), this.registerFindHook(qw), this.registerFindHook(Yw), this.registerFindHook(Zw), this.registerUploadHook(Jw), this.registerUploadHook($w);
    }
    return t3.prototype.upload = function(t4, e3) {
      typeof t4 == "function" && (e3 = t4, t4 = null), t4 && this.add(t4), this.queue.length ? (e3 && this.completes.push(e3), this.ticking || (this.ticking = true, ry.system.addOnce(this.tick, this, ey.UTILITY))) : e3 && e3();
    }, t3.prototype.tick = function() {
      setTimeout(this.delayedTick, 0);
    }, t3.prototype.prepareItems = function() {
      for (this.limiter.beginFrame(); this.queue.length && this.limiter.allowedToUpload(); ) {
        var t4 = this.queue[0], e3 = false;
        if (t4 && !t4._destroyed) {
          for (var n2 = 0, i2 = this.uploadHooks.length; n2 < i2; n2++)
            if (this.uploadHooks[n2](this.uploadHookHelper, t4)) {
              this.queue.shift(), e3 = true;
              break;
            }
        }
        e3 || this.queue.shift();
      }
      if (this.queue.length)
        ry.system.addOnce(this.tick, this, ey.UTILITY);
      else {
        this.ticking = false;
        var r3 = this.completes.slice(0);
        this.completes.length = 0;
        for (n2 = 0, i2 = r3.length; n2 < i2; n2++)
          r3[n2]();
      }
    }, t3.prototype.registerFindHook = function(t4) {
      return t4 && this.addHooks.push(t4), this;
    }, t3.prototype.registerUploadHook = function(t4) {
      return t4 && this.uploadHooks.push(t4), this;
    }, t3.prototype.add = function(t4) {
      for (var e3 = 0, n2 = this.addHooks.length; e3 < n2 && !this.addHooks[e3](t4, this.queue); e3++)
        ;
      if (t4 instanceof ty)
        for (e3 = t4.children.length - 1; e3 >= 0; e3--)
          this.add(t4.children[e3]);
      return this;
    }, t3.prototype.destroy = function() {
      this.ticking && ry.system.remove(this.tick, this), this.ticking = false, this.addHooks = null, this.uploadHooks = null, this.renderer = null, this.completes = null, this.queue = null, this.limiter = null, this.uploadHookHelper = null;
    }, t3;
  }()), rS = function() {
    function t3(t4, e3, n2) {
      n2 === void 0 && (n2 = null), this._texture = t4 instanceof ky ? t4 : null, this.baseTexture = t4 instanceof wy ? t4 : this._texture.baseTexture, this.textures = {}, this.animations = {}, this.data = e3;
      var i2 = this.baseTexture.resource;
      this.resolution = this._updateResolution(n2 || (i2 ? i2.url : null)), this._frames = this.data.frames, this._frameKeys = Object.keys(this._frames), this._batchIndex = 0, this._callback = null;
    }
    return t3.prototype._updateResolution = function(t4) {
      t4 === void 0 && (t4 = null);
      var e3 = this.data.meta.scale, n2 = a_(t4, null);
      return n2 === null && (n2 = e3 !== void 0 ? parseFloat(e3) : 1), n2 !== 1 && this.baseTexture.setResolution(n2), n2;
    }, t3.prototype.parse = function(e3) {
      this._batchIndex = 0, this._callback = e3, this._frameKeys.length <= t3.BATCH_SIZE ? (this._processFrames(0), this._processAnimations(), this._parseComplete()) : this._nextBatch();
    }, t3.prototype._processFrames = function(e3) {
      for (var n2 = e3, i2 = t3.BATCH_SIZE; n2 - e3 < i2 && n2 < this._frameKeys.length; ) {
        var r3 = this._frameKeys[n2], o3 = this._frames[r3], s3 = o3.frame;
        if (s3) {
          var a2 = null, l2 = null, u2 = o3.trimmed !== false && o3.sourceSize ? o3.sourceSize : o3.frame, h2 = new d_(0, 0, Math.floor(u2.w) / this.resolution, Math.floor(u2.h) / this.resolution);
          a2 = o3.rotated ? new d_(Math.floor(s3.x) / this.resolution, Math.floor(s3.y) / this.resolution, Math.floor(s3.h) / this.resolution, Math.floor(s3.w) / this.resolution) : new d_(Math.floor(s3.x) / this.resolution, Math.floor(s3.y) / this.resolution, Math.floor(s3.w) / this.resolution, Math.floor(s3.h) / this.resolution), o3.trimmed !== false && o3.spriteSourceSize && (l2 = new d_(Math.floor(o3.spriteSourceSize.x) / this.resolution, Math.floor(o3.spriteSourceSize.y) / this.resolution, Math.floor(s3.w) / this.resolution, Math.floor(s3.h) / this.resolution)), this.textures[r3] = new ky(this.baseTexture, a2, h2, l2, o3.rotated ? 2 : 0, o3.anchor), ky.addToCache(this.textures[r3], r3);
        }
        n2++;
      }
    }, t3.prototype._processAnimations = function() {
      var t4 = this.data.animations || {};
      for (var e3 in t4) {
        this.animations[e3] = [];
        for (var n2 = 0; n2 < t4[e3].length; n2++) {
          var i2 = t4[e3][n2];
          this.animations[e3].push(this.textures[i2]);
        }
      }
    }, t3.prototype._parseComplete = function() {
      var t4 = this._callback;
      this._callback = null, this._batchIndex = 0, t4.call(this, this.textures);
    }, t3.prototype._nextBatch = function() {
      var e3 = this;
      this._processFrames(this._batchIndex * t3.BATCH_SIZE), this._batchIndex++, setTimeout(function() {
        e3._batchIndex * t3.BATCH_SIZE < e3._frameKeys.length ? e3._nextBatch() : (e3._processAnimations(), e3._parseComplete());
      }, 0);
    }, t3.prototype.destroy = function(t4) {
      var e3;
      for (var n2 in t4 === void 0 && (t4 = false), this.textures)
        this.textures[n2].destroy();
      this._frames = null, this._frameKeys = null, this.data = null, this.textures = null, t4 && ((e3 = this._texture) === null || e3 === void 0 || e3.destroy(), this.baseTexture.destroy()), this._texture = null, this.baseTexture = null;
    }, t3.BATCH_SIZE = 1e3, t3;
  }(), oS = function() {
    function t3() {
    }
    return t3.use = function(e3, n2) {
      var i2, r3, o3 = this, s3 = e3.name + "_image";
      if (e3.data && e3.type === Xb.TYPE.JSON && e3.data.frames && !o3.resources[s3]) {
        var a2 = (r3 = (i2 = e3.data) === null || i2 === void 0 ? void 0 : i2.meta) === null || r3 === void 0 ? void 0 : r3.related_multi_packs;
        if (Array.isArray(a2))
          for (var l2 = function(t4) {
            if (typeof t4 != "string")
              return "continue";
            var n3 = t4.replace(".json", ""), i3 = bv.resolve(e3.url.replace(o3.baseUrl, ""), t4);
            if (o3.resources[n3] || Object.values(o3.resources).some(function(t5) {
              return bv.format(bv.parse(t5.url)) === i3;
            }))
              return "continue";
            var r4 = { crossOrigin: e3.crossOrigin, loadType: Xb.LOAD_TYPE.XHR, xhrType: Xb.XHR_RESPONSE_TYPE.JSON, parentResource: e3, metadata: e3.metadata };
            o3.add(n3, i3, r4);
          }, u2 = 0, h2 = a2; u2 < h2.length; u2++) {
            l2(h2[u2]);
          }
        var c2 = { crossOrigin: e3.crossOrigin, metadata: e3.metadata.imageMetadata, parentResource: e3 }, d2 = t3.getResourcePath(e3, o3.baseUrl);
        o3.add(s3, d2, c2, function(t4) {
          if (t4.error)
            n2(t4.error);
          else {
            var i3 = new rS(t4.texture, e3.data, e3.url);
            i3.parse(function() {
              e3.spritesheet = i3, e3.textures = i3.textures, n2();
            });
          }
        });
      } else
        n2();
    }, t3.getResourcePath = function(t4, e3) {
      return t4.isDataUrl ? t4.data.meta.image : bv.resolve(t4.url.replace(e3, ""), t4.data.meta.image);
    }, t3;
  }(), sS = function(t3, e3) {
    return (sS = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e4) {
      t4.__proto__ = e4;
    } || function(t4, e4) {
      for (var n2 in e4)
        e4.hasOwnProperty(n2) && (t4[n2] = e4[n2]);
    })(t3, e3);
  };
  function aS(t3, e3) {
    function n2() {
      this.constructor = t3;
    }
    sS(t3, e3), t3.prototype = e3 === null ? Object.create(e3) : (n2.prototype = e3.prototype, new n2());
  }
  var lS = new v_(), uS = (function(t3) {
    function e3(e4, n2, i2) {
      n2 === void 0 && (n2 = 100), i2 === void 0 && (i2 = 100);
      var r3 = t3.call(this, e4) || this;
      return r3.tileTransform = new R_(), r3._width = n2, r3._height = i2, r3.uvMatrix = r3.texture.uvMatrix || new zx(e4), r3.pluginName = "tilingSprite", r3.uvRespectAnchor = false, r3;
    }
    aS(e3, t3), Object.defineProperty(e3.prototype, "clampMargin", { get: function() {
      return this.uvMatrix.clampMargin;
    }, set: function(t4) {
      this.uvMatrix.clampMargin = t4, this.uvMatrix.update(true);
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "tileScale", { get: function() {
      return this.tileTransform.scale;
    }, set: function(t4) {
      this.tileTransform.scale.copyFrom(t4);
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "tilePosition", { get: function() {
      return this.tileTransform.position;
    }, set: function(t4) {
      this.tileTransform.position.copyFrom(t4);
    }, enumerable: false, configurable: true }), e3.prototype._onTextureUpdate = function() {
      this.uvMatrix && (this.uvMatrix.texture = this._texture), this._cachedTint = 16777215;
    }, e3.prototype._render = function(t4) {
      var e4 = this._texture;
      e4 && e4.valid && (this.tileTransform.updateLocalTransform(), this.uvMatrix.update(), t4.batch.setObjectRenderer(t4.plugins[this.pluginName]), t4.plugins[this.pluginName].render(this));
    }, e3.prototype._calculateBounds = function() {
      var t4 = this._width * -this._anchor._x, e4 = this._height * -this._anchor._y, n2 = this._width * (1 - this._anchor._x), i2 = this._height * (1 - this._anchor._y);
      this._bounds.addFrame(this.transform, t4, e4, n2, i2);
    }, e3.prototype.getLocalBounds = function(e4) {
      return this.children.length === 0 ? (this._bounds.minX = this._width * -this._anchor._x, this._bounds.minY = this._height * -this._anchor._y, this._bounds.maxX = this._width * (1 - this._anchor._x), this._bounds.maxY = this._height * (1 - this._anchor._y), e4 || (this._localBoundsRect || (this._localBoundsRect = new d_()), e4 = this._localBoundsRect), this._bounds.getRectangle(e4)) : t3.prototype.getLocalBounds.call(this, e4);
    }, e3.prototype.containsPoint = function(t4) {
      this.worldTransform.applyInverse(t4, lS);
      var e4 = this._width, n2 = this._height, i2 = -e4 * this.anchor._x;
      if (lS.x >= i2 && lS.x < i2 + e4) {
        var r3 = -n2 * this.anchor._y;
        if (lS.y >= r3 && lS.y < r3 + n2)
          return true;
      }
      return false;
    }, e3.prototype.destroy = function(e4) {
      t3.prototype.destroy.call(this, e4), this.tileTransform = null, this.uvMatrix = null;
    }, e3.from = function(t4, n2) {
      return new e3(t4 instanceof ky ? t4 : ky.from(t4, n2), n2.width, n2.height);
    }, Object.defineProperty(e3.prototype, "width", { get: function() {
      return this._width;
    }, set: function(t4) {
      this._width = t4;
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "height", { get: function() {
      return this._height;
    }, set: function(t4) {
      this._height = t4;
    }, enumerable: false, configurable: true });
  }(Ow), "#version 100\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n"), hS = new y_(), cS = function(t3) {
    function e3(e4) {
      var n2 = t3.call(this, e4) || this;
      return e4.runners.contextChange.add(n2), n2.quad = new Ky(), n2.state = kx.for2d(), n2;
    }
    return aS(e3, t3), e3.prototype.contextChange = function() {
      var t4 = this.renderer, e4 = { globals: t4.globalUniforms };
      this.simpleShader = Ux.from(uS, "#version 100\n#define SHADER_NAME Tiling-Sprite-Simple-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\n\nvoid main(void)\n{\n    vec4 texSample = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = texSample * uColor;\n}\n", e4), this.shader = t4.context.webGLVersion > 1 ? Ux.from("#version 300 es\n#define SHADER_NAME Tiling-Sprite-300\n\nprecision lowp float;\n\nin vec2 aVertexPosition;\nin vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nout vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n", "#version 300 es\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nin vec2 vTextureCoord;\n\nout vec4 fragmentColor;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0\n\n    fragmentColor = texSample * uColor;\n}\n", e4) : Ux.from(uS, "#version 100\n#ifdef GL_EXT_shader_texture_lod\n    #extension GL_EXT_shader_texture_lod : enable\n#endif\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    #ifdef GL_EXT_shader_texture_lod\n        vec4 texSample = unclamped == coord\n            ? texture2D(uSampler, coord) \n            : texture2DLodEXT(uSampler, coord, 0);\n    #else\n        vec4 texSample = texture2D(uSampler, coord);\n    #endif\n\n    gl_FragColor = texSample * uColor;\n}\n", e4);
    }, e3.prototype.render = function(t4) {
      var e4 = this.renderer, n2 = this.quad, i2 = n2.vertices;
      i2[0] = i2[6] = t4._width * -t4.anchor.x, i2[1] = i2[3] = t4._height * -t4.anchor.y, i2[2] = i2[4] = t4._width * (1 - t4.anchor.x), i2[5] = i2[7] = t4._height * (1 - t4.anchor.y);
      var r3 = t4.uvRespectAnchor ? t4.anchor.x : 0, o3 = t4.uvRespectAnchor ? t4.anchor.y : 0;
      (i2 = n2.uvs)[0] = i2[6] = -r3, i2[1] = i2[3] = -o3, i2[2] = i2[4] = 1 - r3, i2[5] = i2[7] = 1 - o3, n2.invalidate();
      var s3 = t4._texture, a2 = s3.baseTexture, l2 = t4.tileTransform.localTransform, u2 = t4.uvMatrix, h2 = a2.isPowerOfTwo && s3.frame.width === a2.width && s3.frame.height === a2.height;
      h2 && (a2._glTextures[e4.CONTEXT_UID] ? h2 = a2.wrapMode !== sv.CLAMP : a2.wrapMode === sv.CLAMP && (a2.wrapMode = sv.REPEAT));
      var c2 = h2 ? this.simpleShader : this.shader, d2 = s3.width, p2 = s3.height, f2 = t4._width, m2 = t4._height;
      hS.set(l2.a * d2 / f2, l2.b * d2 / m2, l2.c * p2 / f2, l2.d * p2 / m2, l2.tx / f2, l2.ty / m2), hS.invert(), h2 ? hS.prepend(u2.mapCoord) : (c2.uniforms.uMapCoord = u2.mapCoord.toArray(true), c2.uniforms.uClampFrame = u2.uClampFrame, c2.uniforms.uClampOffset = u2.uClampOffset), c2.uniforms.uTransform = hS.toArray(true), c2.uniforms.uColor = Fv(t4.tint, t4.worldAlpha, c2.uniforms.uColor, a2.alphaMode), c2.uniforms.translationMatrix = t4.transform.worldTransform.toArray(true), c2.uniforms.uSampler = s3, e4.shader.bind(c2), e4.geometry.bind(n2), this.state.blendMode = Lv(t4.blendMode, a2.alphaMode), e4.state.set(this.state), e4.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);
    }, e3;
  }(ox), dS = function(t3, e3) {
    return (dS = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e4) {
      t4.__proto__ = e4;
    } || function(t4, e4) {
      for (var n2 in e4)
        e4.hasOwnProperty(n2) && (t4[n2] = e4[n2]);
    })(t3, e3);
  };
  function pS(t3, e3) {
    function n2() {
      this.constructor = t3;
    }
    dS(t3, e3), t3.prototype = e3 === null ? Object.create(e3) : (n2.prototype = e3.prototype, new n2());
  }
  var fS = function() {
    function t3(t4, e3) {
      this.uvBuffer = t4, this.uvMatrix = e3, this.data = null, this._bufferUpdateId = -1, this._textureUpdateId = -1, this._updateID = 0;
    }
    return t3.prototype.update = function(t4) {
      if (t4 || this._bufferUpdateId !== this.uvBuffer._updateID || this._textureUpdateId !== this.uvMatrix._updateID) {
        this._bufferUpdateId = this.uvBuffer._updateID, this._textureUpdateId = this.uvMatrix._updateID;
        var e3 = this.uvBuffer.data;
        this.data && this.data.length === e3.length || (this.data = new Float32Array(e3.length)), this.uvMatrix.multiplyUvs(e3, this.data), this._updateID++;
      }
    }, t3;
  }(), mS = new v_(), gS = new m_(), vS = function(t3) {
    function e3(e4, n2, i2, r3) {
      r3 === void 0 && (r3 = tv.TRIANGLES);
      var o3 = t3.call(this) || this;
      return o3.geometry = e4, o3.shader = n2, o3.state = i2 || kx.for2d(), o3.drawMode = r3, o3.start = 0, o3.size = 0, o3.uvs = null, o3.indices = null, o3.vertexData = new Float32Array(1), o3.vertexDirty = -1, o3._transformID = -1, o3._roundPixels = mv.ROUND_PIXELS, o3.batchUvs = null, o3;
    }
    return pS(e3, t3), Object.defineProperty(e3.prototype, "geometry", { get: function() {
      return this._geometry;
    }, set: function(t4) {
      this._geometry !== t4 && (this._geometry && (this._geometry.refCount--, this._geometry.refCount === 0 && this._geometry.dispose()), this._geometry = t4, this._geometry && this._geometry.refCount++, this.vertexDirty = -1);
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "uvBuffer", { get: function() {
      return this.geometry.buffers[1];
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "verticesBuffer", { get: function() {
      return this.geometry.buffers[0];
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "material", { get: function() {
      return this.shader;
    }, set: function(t4) {
      this.shader = t4;
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "blendMode", { get: function() {
      return this.state.blendMode;
    }, set: function(t4) {
      this.state.blendMode = t4;
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "roundPixels", { get: function() {
      return this._roundPixels;
    }, set: function(t4) {
      this._roundPixels !== t4 && (this._transformID = -1), this._roundPixels = t4;
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "tint", { get: function() {
      return "tint" in this.shader ? this.shader.tint : null;
    }, set: function(t4) {
      this.shader.tint = t4;
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "texture", { get: function() {
      return "texture" in this.shader ? this.shader.texture : null;
    }, set: function(t4) {
      this.shader.texture = t4;
    }, enumerable: false, configurable: true }), e3.prototype._render = function(t4) {
      var n2 = this.geometry.buffers[0].data;
      this.shader.batchable && this.drawMode === tv.TRIANGLES && n2.length < 2 * e3.BATCHABLE_SIZE ? this._renderToBatch(t4) : this._renderDefault(t4);
    }, e3.prototype._renderDefault = function(t4) {
      var e4 = this.shader;
      e4.alpha = this.worldAlpha, e4.update && e4.update(), t4.batch.flush(), e4.uniforms.translationMatrix = this.transform.worldTransform.toArray(true), t4.shader.bind(e4), t4.state.set(this.state), t4.geometry.bind(this.geometry, e4), t4.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);
    }, e3.prototype._renderToBatch = function(t4) {
      var e4 = this.geometry, n2 = this.shader;
      n2.uvMatrix && (n2.uvMatrix.update(), this.calculateUvs()), this.calculateVertices(), this.indices = e4.indexBuffer.data, this._tintRGB = n2._tintRGB, this._texture = n2.texture;
      var i2 = this.material.pluginName;
      t4.batch.setObjectRenderer(t4.plugins[i2]), t4.plugins[i2].render(this);
    }, e3.prototype.calculateVertices = function() {
      var t4 = this.geometry.buffers[0], e4 = t4.data, n2 = t4._updateID;
      if (n2 !== this.vertexDirty || this._transformID !== this.transform._worldID) {
        this._transformID = this.transform._worldID, this.vertexData.length !== e4.length && (this.vertexData = new Float32Array(e4.length));
        for (var i2 = this.transform.worldTransform, r3 = i2.a, o3 = i2.b, s3 = i2.c, a2 = i2.d, l2 = i2.tx, u2 = i2.ty, h2 = this.vertexData, c2 = 0; c2 < h2.length / 2; c2++) {
          var d2 = e4[2 * c2], p2 = e4[2 * c2 + 1];
          h2[2 * c2] = r3 * d2 + s3 * p2 + l2, h2[2 * c2 + 1] = o3 * d2 + a2 * p2 + u2;
        }
        if (this._roundPixels) {
          var f2 = mv.RESOLUTION;
          for (c2 = 0; c2 < h2.length; ++c2)
            h2[c2] = Math.round((h2[c2] * f2 | 0) / f2);
        }
        this.vertexDirty = n2;
      }
    }, e3.prototype.calculateUvs = function() {
      var t4 = this.geometry.buffers[1], e4 = this.shader;
      e4.uvMatrix.isSimple ? this.uvs = t4.data : (this.batchUvs || (this.batchUvs = new fS(t4, e4.uvMatrix)), this.batchUvs.update(), this.uvs = this.batchUvs.data);
    }, e3.prototype._calculateBounds = function() {
      this.calculateVertices(), this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);
    }, e3.prototype.containsPoint = function(t4) {
      if (!this.getBounds().contains(t4.x, t4.y))
        return false;
      this.worldTransform.applyInverse(t4, mS);
      for (var e4 = this.geometry.getBuffer("aVertexPosition").data, n2 = gS.points, i2 = this.geometry.getIndex().data, r3 = i2.length, o3 = this.drawMode === 4 ? 3 : 1, s3 = 0; s3 + 2 < r3; s3 += o3) {
        var a2 = 2 * i2[s3], l2 = 2 * i2[s3 + 1], u2 = 2 * i2[s3 + 2];
        if (n2[0] = e4[a2], n2[1] = e4[a2 + 1], n2[2] = e4[l2], n2[3] = e4[l2 + 1], n2[4] = e4[u2], n2[5] = e4[u2 + 1], gS.contains(mS.x, mS.y))
          return true;
      }
      return false;
    }, e3.prototype.destroy = function(e4) {
      t3.prototype.destroy.call(this, e4), this._cachedTexture && (this._cachedTexture.destroy(), this._cachedTexture = null), this.geometry = null, this.shader = null, this.state = null, this.uvs = null, this.indices = null, this.vertexData = null;
    }, e3.BATCHABLE_SIZE = 100, e3;
  }(ty), _S = function(t3) {
    function e3(e4, n2) {
      var i2 = this, r3 = { uSampler: e4, alpha: 1, uTextureMatrix: y_.IDENTITY, uColor: new Float32Array([1, 1, 1, 1]) };
      return (n2 = Object.assign({ tint: 16777215, alpha: 1, pluginName: "batch" }, n2)).uniforms && Object.assign(r3, n2.uniforms), (i2 = t3.call(this, n2.program || Bx.from("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTextureMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\n}\n", "varying vec2 vTextureCoord;\nuniform vec4 uColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\n}\n"), r3) || this)._colorDirty = false, i2.uvMatrix = new zx(e4), i2.batchable = n2.program === void 0, i2.pluginName = n2.pluginName, i2.tint = n2.tint, i2.alpha = n2.alpha, i2;
    }
    return pS(e3, t3), Object.defineProperty(e3.prototype, "texture", { get: function() {
      return this.uniforms.uSampler;
    }, set: function(t4) {
      this.uniforms.uSampler !== t4 && (this.uniforms.uSampler = t4, this.uvMatrix.texture = t4);
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "alpha", { get: function() {
      return this._alpha;
    }, set: function(t4) {
      t4 !== this._alpha && (this._alpha = t4, this._colorDirty = true);
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "tint", { get: function() {
      return this._tint;
    }, set: function(t4) {
      t4 !== this._tint && (this._tint = t4, this._tintRGB = (t4 >> 16) + (65280 & t4) + ((255 & t4) << 16), this._colorDirty = true);
    }, enumerable: false, configurable: true }), e3.prototype.update = function() {
      if (this._colorDirty) {
        this._colorDirty = false;
        var t4 = this.texture.baseTexture;
        Fv(this._tint, this._alpha, this.uniforms.uColor, t4.alphaMode);
      }
      this.uvMatrix.update() && (this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord);
    }, e3;
  }(Ux), yS = function(t3) {
    function e3(e4, n2, i2) {
      var r3 = t3.call(this) || this, o3 = new Wy(e4), s3 = new Wy(n2, true), a2 = new Wy(i2, true, true);
      return r3.addAttribute("aVertexPosition", o3, 2, false, iv.FLOAT).addAttribute("aTextureCoord", s3, 2, false, iv.FLOAT).addIndex(a2), r3._updateId = -1, r3;
    }
    return pS(e3, t3), Object.defineProperty(e3.prototype, "vertexDirtyId", { get: function() {
      return this.buffers[0]._updateID;
    }, enumerable: false, configurable: true }), e3;
  }(Jy), xS = function(t3, e3) {
    return (xS = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e4) {
      t4.__proto__ = e4;
    } || function(t4, e4) {
      for (var n2 in e4)
        e4.hasOwnProperty(n2) && (t4[n2] = e4[n2]);
    })(t3, e3);
  };
  var bS = function() {
    this.info = [], this.common = [], this.page = [], this.char = [], this.kerning = [], this.distanceField = [];
  }, TS = function() {
    function t3() {
    }
    return t3.test = function(t4) {
      return typeof t4 == "string" && t4.indexOf("info face=") === 0;
    }, t3.parse = function(t4) {
      var e3 = t4.match(/^[a-z]+\s+.+$/gm), n2 = { info: [], common: [], page: [], char: [], chars: [], kerning: [], kernings: [], distanceField: [] };
      for (var i2 in e3) {
        var r3 = e3[i2].match(/^[a-z]+/gm)[0], o3 = e3[i2].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm), s3 = {};
        for (var a2 in o3) {
          var l2 = o3[a2].split("="), u2 = l2[0], h2 = l2[1].replace(/"/gm, ""), c2 = parseFloat(h2), d2 = isNaN(c2) ? h2 : c2;
          s3[u2] = d2;
        }
        n2[r3].push(s3);
      }
      var p2 = new bS();
      return n2.info.forEach(function(t5) {
        return p2.info.push({ face: t5.face, size: parseInt(t5.size, 10) });
      }), n2.common.forEach(function(t5) {
        return p2.common.push({ lineHeight: parseInt(t5.lineHeight, 10) });
      }), n2.page.forEach(function(t5) {
        return p2.page.push({ id: parseInt(t5.id, 10), file: t5.file });
      }), n2.char.forEach(function(t5) {
        return p2.char.push({ id: parseInt(t5.id, 10), page: parseInt(t5.page, 10), x: parseInt(t5.x, 10), y: parseInt(t5.y, 10), width: parseInt(t5.width, 10), height: parseInt(t5.height, 10), xoffset: parseInt(t5.xoffset, 10), yoffset: parseInt(t5.yoffset, 10), xadvance: parseInt(t5.xadvance, 10) });
      }), n2.kerning.forEach(function(t5) {
        return p2.kerning.push({ first: parseInt(t5.first, 10), second: parseInt(t5.second, 10), amount: parseInt(t5.amount, 10) });
      }), n2.distanceField.forEach(function(t5) {
        return p2.distanceField.push({ distanceRange: parseInt(t5.distanceRange, 10), fieldType: t5.fieldType });
      }), p2;
    }, t3;
  }(), wS = function() {
    function t3() {
    }
    return t3.test = function(t4) {
      return t4 instanceof XMLDocument && t4.getElementsByTagName("page").length && t4.getElementsByTagName("info")[0].getAttribute("face") !== null;
    }, t3.parse = function(t4) {
      for (var e3 = new bS(), n2 = t4.getElementsByTagName("info"), i2 = t4.getElementsByTagName("common"), r3 = t4.getElementsByTagName("page"), o3 = t4.getElementsByTagName("char"), s3 = t4.getElementsByTagName("kerning"), a2 = t4.getElementsByTagName("distanceField"), l2 = 0; l2 < n2.length; l2++)
        e3.info.push({ face: n2[l2].getAttribute("face"), size: parseInt(n2[l2].getAttribute("size"), 10) });
      for (l2 = 0; l2 < i2.length; l2++)
        e3.common.push({ lineHeight: parseInt(i2[l2].getAttribute("lineHeight"), 10) });
      for (l2 = 0; l2 < r3.length; l2++)
        e3.page.push({ id: parseInt(r3[l2].getAttribute("id"), 10) || 0, file: r3[l2].getAttribute("file") });
      for (l2 = 0; l2 < o3.length; l2++) {
        var u2 = o3[l2];
        e3.char.push({ id: parseInt(u2.getAttribute("id"), 10), page: parseInt(u2.getAttribute("page"), 10) || 0, x: parseInt(u2.getAttribute("x"), 10), y: parseInt(u2.getAttribute("y"), 10), width: parseInt(u2.getAttribute("width"), 10), height: parseInt(u2.getAttribute("height"), 10), xoffset: parseInt(u2.getAttribute("xoffset"), 10), yoffset: parseInt(u2.getAttribute("yoffset"), 10), xadvance: parseInt(u2.getAttribute("xadvance"), 10) });
      }
      for (l2 = 0; l2 < s3.length; l2++)
        e3.kerning.push({ first: parseInt(s3[l2].getAttribute("first"), 10), second: parseInt(s3[l2].getAttribute("second"), 10), amount: parseInt(s3[l2].getAttribute("amount"), 10) });
      for (l2 = 0; l2 < a2.length; l2++)
        e3.distanceField.push({ fieldType: a2[l2].getAttribute("fieldType"), distanceRange: parseInt(a2[l2].getAttribute("distanceRange"), 10) });
      return e3;
    }, t3;
  }(), SS = function() {
    function t3() {
    }
    return t3.test = function(t4) {
      if (typeof t4 == "string" && t4.indexOf("<font>") > -1) {
        var e3 = new self.DOMParser().parseFromString(t4, "text/xml");
        return wS.test(e3);
      }
      return false;
    }, t3.parse = function(t4) {
      var e3 = new self.DOMParser().parseFromString(t4, "text/xml");
      return wS.parse(e3);
    }, t3;
  }(), ES = [TS, wS, SS];
  function MS(t3) {
    for (var e3 = 0; e3 < ES.length; e3++)
      if (ES[e3].test(t3))
        return ES[e3];
    return null;
  }
  function AS(t3, e3, n2, i2, r3, o3, s3) {
    var a2 = n2.text, l2 = n2.fontProperties;
    e3.translate(i2, r3), e3.scale(o3, o3);
    var u2 = s3.strokeThickness / 2, h2 = -s3.strokeThickness / 2;
    e3.font = s3.toFontString(), e3.lineWidth = s3.strokeThickness, e3.textBaseline = s3.textBaseline, e3.lineJoin = s3.lineJoin, e3.miterLimit = s3.miterLimit, e3.fillStyle = function(t4, e4, n3, i3, r4, o4) {
      var s4, a3 = n3.fill;
      if (!Array.isArray(a3))
        return a3;
      if (a3.length === 1)
        return a3[0];
      var l3 = n3.dropShadow ? n3.dropShadowDistance : 0, u3 = n3.padding || 0, h3 = t4.width / i3 - l3 - 2 * u3, c3 = t4.height / i3 - l3 - 2 * u3, d3 = a3.slice(), p2 = n3.fillGradientStops.slice();
      if (!p2.length)
        for (var f2 = d3.length + 1, m2 = 1; m2 < f2; ++m2)
          p2.push(m2 / f2);
      if (d3.unshift(a3[0]), p2.unshift(0), d3.push(a3[a3.length - 1]), p2.push(1), n3.fillGradientType === Pw.LINEAR_VERTICAL) {
        s4 = e4.createLinearGradient(h3 / 2, u3, h3 / 2, c3 + u3);
        var g2 = 0, v2 = (o4.fontProperties.fontSize + n3.strokeThickness) / c3;
        for (m2 = 0; m2 < r4.length; m2++)
          for (var _2 = o4.lineHeight * m2, y2 = 0; y2 < d3.length; y2++) {
            var x2 = _2 / c3 + (typeof p2[y2] == "number" ? p2[y2] : y2 / d3.length) * v2, b2 = Math.max(g2, x2);
            b2 = Math.min(b2, 1), s4.addColorStop(b2, d3[y2]), g2 = b2;
          }
      } else {
        s4 = e4.createLinearGradient(u3, c3 / 2, h3 + u3, c3 / 2);
        var T2 = d3.length + 1, w2 = 1;
        for (m2 = 0; m2 < d3.length; m2++) {
          var S2 = void 0;
          S2 = typeof p2[m2] == "number" ? p2[m2] : w2 / T2, s4.addColorStop(S2, d3[m2]), w2++;
        }
      }
      return s4;
    }(t3, e3, s3, o3, [a2], n2), e3.strokeStyle = s3.stroke;
    var c2 = s3.dropShadowColor, d2 = Rv(typeof c2 == "number" ? c2 : Cv(c2));
    s3.dropShadow ? (e3.shadowColor = "rgba(" + 255 * d2[0] + "," + 255 * d2[1] + "," + 255 * d2[2] + "," + s3.dropShadowAlpha + ")", e3.shadowBlur = s3.dropShadowBlur, e3.shadowOffsetX = Math.cos(s3.dropShadowAngle) * s3.dropShadowDistance, e3.shadowOffsetY = Math.sin(s3.dropShadowAngle) * s3.dropShadowDistance) : (e3.shadowColor = "black", e3.shadowBlur = 0, e3.shadowOffsetX = 0, e3.shadowOffsetY = 0), s3.stroke && s3.strokeThickness && e3.strokeText(a2, u2, h2 + n2.lineHeight - l2.descent), s3.fill && e3.fillText(a2, u2, h2 + n2.lineHeight - l2.descent), e3.setTransform(1, 0, 0, 1, 0, 0), e3.fillStyle = "rgba(0, 0, 0, 0)";
  }
  function RS(t3) {
    return Array.from ? Array.from(t3) : t3.split("");
  }
  function PS(t3) {
    return t3.codePointAt ? t3.codePointAt(0) : t3.charCodeAt(0);
  }
  var CS = function() {
    function t3(t4, e3, n2) {
      var i2, r3, o3 = t4.info[0], s3 = t4.common[0], a2 = t4.page[0], l2 = t4.distanceField[0], u2 = a_(a2.file), h2 = {};
      this._ownsTextures = n2, this.font = o3.face, this.size = o3.size, this.lineHeight = s3.lineHeight / u2, this.chars = {}, this.pageTextures = h2;
      for (var c2 = 0; c2 < t4.page.length; c2++) {
        var d2 = t4.page[c2], p2 = d2.id, f2 = d2.file;
        h2[p2] = e3 instanceof Array ? e3[c2] : e3[f2], (l2 == null ? void 0 : l2.fieldType) && l2.fieldType !== "none" && (h2[p2].baseTexture.alphaMode = lv.NO_PREMULTIPLIED_ALPHA);
      }
      for (c2 = 0; c2 < t4.char.length; c2++) {
        var m2 = t4.char[c2], g2 = (p2 = m2.id, m2.page), v2 = t4.char[c2], _2 = v2.x, y2 = v2.y, x2 = v2.width, b2 = v2.height, T2 = v2.xoffset, w2 = v2.yoffset, S2 = v2.xadvance;
        y2 /= u2, x2 /= u2, b2 /= u2, T2 /= u2, w2 /= u2, S2 /= u2;
        var E2 = new d_((_2 /= u2) + h2[g2].frame.x / u2, y2 + h2[g2].frame.y / u2, x2, b2);
        this.chars[p2] = { xOffset: T2, yOffset: w2, xAdvance: S2, kerning: {}, texture: new ky(h2[g2].baseTexture, E2), page: g2 };
      }
      for (c2 = 0; c2 < t4.kerning.length; c2++) {
        var M2 = t4.kerning[c2], A2 = M2.first, R2 = M2.second, P2 = M2.amount;
        A2 /= u2, R2 /= u2, P2 /= u2, this.chars[R2] && (this.chars[R2].kerning[A2] = P2);
      }
      this.distanceFieldRange = l2 == null ? void 0 : l2.distanceRange, this.distanceFieldType = (r3 = (i2 = l2 == null ? void 0 : l2.fieldType) === null || i2 === void 0 ? void 0 : i2.toLowerCase()) !== null && r3 !== void 0 ? r3 : "none";
    }
    return t3.prototype.destroy = function() {
      for (var t4 in this.chars)
        this.chars[t4].texture.destroy(), this.chars[t4].texture = null;
      for (var t4 in this.pageTextures)
        this._ownsTextures && this.pageTextures[t4].destroy(true), this.pageTextures[t4] = null;
      this.chars = null, this.pageTextures = null;
    }, t3.install = function(e3, n2, i2) {
      var r3;
      if (e3 instanceof bS)
        r3 = e3;
      else {
        var o3 = MS(e3);
        if (!o3)
          throw new Error("Unrecognized data format for font.");
        r3 = o3.parse(e3);
      }
      n2 instanceof ky && (n2 = [n2]);
      var s3 = new t3(r3, n2, i2);
      return t3.available[s3.font] = s3, s3;
    }, t3.uninstall = function(e3) {
      var n2 = t3.available[e3];
      if (!n2)
        throw new Error("No font found named '" + e3 + "'");
      n2.destroy(), delete t3.available[e3];
    }, t3.from = function(e3, n2, i2) {
      if (!e3)
        throw new Error("[BitmapFont] Property `name` is required.");
      var r3 = Object.assign({}, t3.defaultOptions, i2), o3 = r3.chars, s3 = r3.padding, a2 = r3.resolution, l2 = r3.textureWidth, u2 = r3.textureHeight, h2 = function(t4) {
        typeof t4 == "string" && (t4 = [t4]);
        for (var e4 = [], n3 = 0, i3 = t4.length; n3 < i3; n3++) {
          var r4 = t4[n3];
          if (Array.isArray(r4)) {
            if (r4.length !== 2)
              throw new Error("[BitmapFont]: Invalid character range length, expecting 2 got " + r4.length + ".");
            var o4 = r4[0].charCodeAt(0), s4 = r4[1].charCodeAt(0);
            if (s4 < o4)
              throw new Error("[BitmapFont]: Invalid character range.");
            for (var a3 = o4, l3 = s4; a3 <= l3; a3++)
              e4.push(String.fromCharCode(a3));
          } else
            e4.push.apply(e4, RS(r4));
        }
        if (e4.length === 0)
          throw new Error("[BitmapFont]: Empty set when resolving characters.");
        return e4;
      }(o3), c2 = n2 instanceof Fw ? n2 : new Fw(n2), d2 = l2, p2 = new bS();
      p2.info[0] = { face: c2.fontFamily, size: c2.fontSize }, p2.common[0] = { lineHeight: c2.fontSize };
      for (var f2, m2, g2, v2 = 0, _2 = 0, y2 = 0, x2 = [], b2 = 0; b2 < h2.length; b2++) {
        f2 || ((f2 = document.createElement("canvas")).width = l2, f2.height = u2, m2 = f2.getContext("2d"), g2 = new wy(f2, { resolution: a2 }), x2.push(new ky(g2)), p2.page.push({ id: x2.length - 1, file: "" }));
        var T2 = Gw.measureText(h2[b2], c2, false, f2), w2 = T2.width, S2 = Math.ceil(T2.height), E2 = Math.ceil((c2.fontStyle === "italic" ? 2 : 1) * w2);
        if (_2 >= u2 - S2 * a2) {
          if (_2 === 0)
            throw new Error("[BitmapFont] textureHeight " + u2 + "px is too small for " + c2.fontSize + "px fonts");
          --b2, f2 = null, m2 = null, g2 = null, _2 = 0, v2 = 0, y2 = 0;
        } else if (y2 = Math.max(S2 + T2.fontProperties.descent, y2), E2 * a2 + v2 >= d2)
          --b2, _2 += y2 * a2, _2 = Math.ceil(_2), v2 = 0, y2 = 0;
        else {
          AS(f2, m2, T2, v2, _2, a2, c2);
          var M2 = PS(T2.text);
          p2.char.push({ id: M2, page: x2.length - 1, x: v2 / a2, y: _2 / a2, width: E2, height: S2, xoffset: 0, yoffset: 0, xadvance: Math.ceil(w2 - (c2.dropShadow ? c2.dropShadowDistance : 0) - (c2.stroke ? c2.strokeThickness : 0)) }), v2 += (E2 + 2 * s3) * a2, v2 = Math.ceil(v2);
        }
      }
      b2 = 0;
      for (var A2 = h2.length; b2 < A2; b2++)
        for (var R2 = h2[b2], P2 = 0; P2 < A2; P2++) {
          var C2 = h2[P2], I2 = m2.measureText(R2).width, O2 = m2.measureText(C2).width, L2 = m2.measureText(R2 + C2).width - (I2 + O2);
          L2 && p2.kerning.push({ first: PS(R2), second: PS(C2), amount: L2 });
        }
      var N2 = new t3(p2, x2, true);
      return t3.available[e3] !== void 0 && t3.uninstall(e3), t3.available[e3] = N2, N2;
    }, t3.ALPHA = [["a", "z"], ["A", "Z"], " "], t3.NUMERIC = [["0", "9"]], t3.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "], t3.ASCII = [[" ", "~"]], t3.defaultOptions = { resolution: 1, textureWidth: 512, textureHeight: 512, padding: 4, chars: t3.ALPHANUMERIC }, t3.available = {}, t3;
  }(), IS = [], OS = [], LS = [], NS = (function(t3) {
    function e3(n2, i2) {
      i2 === void 0 && (i2 = {});
      var r3 = t3.call(this) || this;
      r3._tint = 16777215;
      var o3 = Object.assign({}, e3.styleDefaults, i2), s3 = o3.align, a2 = o3.tint, l2 = o3.maxWidth, u2 = o3.letterSpacing, h2 = o3.fontName, c2 = o3.fontSize;
      if (!CS.available[h2])
        throw new Error('Missing BitmapFont "' + h2 + '"');
      return r3._activePagesMeshData = [], r3._textWidth = 0, r3._textHeight = 0, r3._align = s3, r3._tint = a2, r3._fontName = h2, r3._fontSize = c2 || CS.available[h2].size, r3._text = n2, r3._maxWidth = l2, r3._maxLineHeight = 0, r3._letterSpacing = u2, r3._anchor = new __(function() {
        r3.dirty = true;
      }, r3, 0, 0), r3._roundPixels = mv.ROUND_PIXELS, r3.dirty = true, r3._textureCache = {}, r3;
    }
    (function(t4, e4) {
      function n2() {
        this.constructor = t4;
      }
      xS(t4, e4), t4.prototype = e4 === null ? Object.create(e4) : (n2.prototype = e4.prototype, new n2());
    })(e3, t3), e3.prototype.updateText = function() {
      for (var t4, e4 = CS.available[this._fontName], n2 = this._fontSize / e4.size, i2 = new v_(), r3 = [], o3 = [], s3 = [], a2 = RS(this._text.replace(/(?:\r\n|\r)/g, "\n") || " "), l2 = this._maxWidth * e4.size / this._fontSize, u2 = e4.distanceFieldType === "none" ? IS : OS, h2 = null, c2 = 0, d2 = 0, p2 = 0, f2 = -1, m2 = 0, g2 = 0, v2 = 0, _2 = 0, y2 = 0; y2 < a2.length; y2++) {
        var x2 = PS(G2 = a2[y2]);
        if (/(?:\s)/.test(G2) && (f2 = y2, m2 = c2, _2++), G2 !== "\r" && G2 !== "\n") {
          var b2 = e4.chars[x2];
          if (b2) {
            h2 && b2.kerning[h2] && (i2.x += b2.kerning[h2]);
            var T2 = LS.pop() || { texture: ky.EMPTY, line: 0, charCode: 0, prevSpaces: 0, position: new v_() };
            T2.texture = b2.texture, T2.line = p2, T2.charCode = x2, T2.position.x = i2.x + b2.xOffset + this._letterSpacing / 2, T2.position.y = i2.y + b2.yOffset, T2.prevSpaces = _2, r3.push(T2), c2 = T2.position.x + b2.texture.orig.width, i2.x += b2.xAdvance + this._letterSpacing, v2 = Math.max(v2, b2.yOffset + b2.texture.height), h2 = x2, f2 !== -1 && l2 > 0 && i2.x > l2 && (Vv(r3, 1 + f2 - ++g2, 1 + y2 - f2), y2 = f2, f2 = -1, o3.push(m2), s3.push(r3.length > 0 ? r3[r3.length - 1].prevSpaces : 0), d2 = Math.max(d2, m2), p2++, i2.x = 0, i2.y += e4.lineHeight, h2 = null, _2 = 0);
          }
        } else
          o3.push(c2), s3.push(-1), d2 = Math.max(d2, c2), ++p2, ++g2, i2.x = 0, i2.y += e4.lineHeight, h2 = null, _2 = 0;
      }
      var w2 = a2[a2.length - 1];
      w2 !== "\r" && w2 !== "\n" && (/(?:\s)/.test(w2) && (c2 = m2), o3.push(c2), d2 = Math.max(d2, c2), s3.push(-1));
      var S2 = [];
      for (y2 = 0; y2 <= p2; y2++) {
        var E2 = 0;
        this._align === "right" ? E2 = d2 - o3[y2] : this._align === "center" ? E2 = (d2 - o3[y2]) / 2 : this._align === "justify" && (E2 = s3[y2] < 0 ? 0 : (d2 - o3[y2]) / s3[y2]), S2.push(E2);
      }
      var M2 = r3.length, A2 = {}, R2 = [], P2 = this._activePagesMeshData;
      for (y2 = 0; y2 < P2.length; y2++)
        u2.push(P2[y2]);
      for (y2 = 0; y2 < M2; y2++) {
        var C2 = (z2 = r3[y2].texture).baseTexture.uid;
        if (!A2[C2]) {
          if (!(Z2 = u2.pop())) {
            var I2 = new yS(), O2 = void 0, L2 = void 0;
            e4.distanceFieldType === "none" ? (O2 = new _S(ky.EMPTY), L2 = Qg.NORMAL) : (O2 = new _S(ky.EMPTY, { program: Bx.from("// Mesh material default fragment\r\nattribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 translationMatrix;\r\nuniform mat3 uTextureMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n\r\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r\n}\r\n", "// Pixi texture info\r\nvarying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\n\r\n// Tint\r\nuniform vec4 uColor;\r\n\r\n// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\r\nuniform float uFWidth;\r\n\r\nvoid main(void) {\r\n\r\n  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\r\n  vec4 texColor = texture2D(uSampler, vTextureCoord);\r\n\r\n  // MSDF\r\n  float median = texColor.r + texColor.g + texColor.b -\r\n                  min(texColor.r, min(texColor.g, texColor.b)) -\r\n                  max(texColor.r, max(texColor.g, texColor.b));\r\n  // SDF\r\n  median = min(median, texColor.a);\r\n\r\n  float screenPxDistance = uFWidth * (median - 0.5);\r\n  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\r\n\r\n  // NPM Textures, NPM outputs\r\n  gl_FragColor = vec4(uColor.rgb, uColor.a * alpha);\r\n\r\n}\r\n"), uniforms: { uFWidth: 0 } }), L2 = Qg.NORMAL_NPM);
            var N2 = new vS(I2, O2);
            N2.blendMode = L2, Z2 = { index: 0, indexCount: 0, vertexCount: 0, uvsCount: 0, total: 0, mesh: N2, vertices: null, uvs: null, indices: null };
          }
          Z2.index = 0, Z2.indexCount = 0, Z2.vertexCount = 0, Z2.uvsCount = 0, Z2.total = 0;
          var D2 = this._textureCache;
          D2[C2] = D2[C2] || new ky(z2.baseTexture), Z2.mesh.texture = D2[C2], Z2.mesh.tint = this._tint, R2.push(Z2), A2[C2] = Z2;
        }
        A2[C2].total++;
      }
      for (y2 = 0; y2 < P2.length; y2++)
        R2.indexOf(P2[y2]) === -1 && this.removeChild(P2[y2].mesh);
      for (y2 = 0; y2 < R2.length; y2++)
        R2[y2].mesh.parent !== this && this.addChild(R2[y2].mesh);
      for (var y2 in this._activePagesMeshData = R2, A2) {
        var F2 = (Z2 = A2[y2]).total;
        if (!(((t4 = Z2.indices) === null || t4 === void 0 ? void 0 : t4.length) > 6 * F2) || Z2.vertices.length < 2 * vS.BATCHABLE_SIZE)
          Z2.vertices = new Float32Array(8 * F2), Z2.uvs = new Float32Array(8 * F2), Z2.indices = new Uint16Array(6 * F2);
        else
          for (var B2 = Z2.total, U2 = Z2.vertices, k2 = 4 * B2 * 2; k2 < U2.length; k2++)
            U2[k2] = 0;
        Z2.mesh.size = 6 * F2;
      }
      for (y2 = 0; y2 < M2; y2++) {
        var G2, H2 = (G2 = r3[y2]).position.x + S2[G2.line] * (this._align === "justify" ? G2.prevSpaces : 1);
        this._roundPixels && (H2 = Math.round(H2));
        var z2, j2 = H2 * n2, V2 = G2.position.y * n2, W2 = A2[(z2 = G2.texture).baseTexture.uid], X2 = z2.frame, q2 = z2._uvs, Y2 = W2.index++;
        W2.indices[6 * Y2 + 0] = 0 + 4 * Y2, W2.indices[6 * Y2 + 1] = 1 + 4 * Y2, W2.indices[6 * Y2 + 2] = 2 + 4 * Y2, W2.indices[6 * Y2 + 3] = 0 + 4 * Y2, W2.indices[6 * Y2 + 4] = 2 + 4 * Y2, W2.indices[6 * Y2 + 5] = 3 + 4 * Y2, W2.vertices[8 * Y2 + 0] = j2, W2.vertices[8 * Y2 + 1] = V2, W2.vertices[8 * Y2 + 2] = j2 + X2.width * n2, W2.vertices[8 * Y2 + 3] = V2, W2.vertices[8 * Y2 + 4] = j2 + X2.width * n2, W2.vertices[8 * Y2 + 5] = V2 + X2.height * n2, W2.vertices[8 * Y2 + 6] = j2, W2.vertices[8 * Y2 + 7] = V2 + X2.height * n2, W2.uvs[8 * Y2 + 0] = q2.x0, W2.uvs[8 * Y2 + 1] = q2.y0, W2.uvs[8 * Y2 + 2] = q2.x1, W2.uvs[8 * Y2 + 3] = q2.y1, W2.uvs[8 * Y2 + 4] = q2.x2, W2.uvs[8 * Y2 + 5] = q2.y2, W2.uvs[8 * Y2 + 6] = q2.x3, W2.uvs[8 * Y2 + 7] = q2.y3;
      }
      for (var y2 in this._textWidth = d2 * n2, this._textHeight = (i2.y + e4.lineHeight) * n2, A2) {
        var Z2 = A2[y2];
        if (this.anchor.x !== 0 || this.anchor.y !== 0)
          for (var J2 = 0, $2 = this._textWidth * this.anchor.x, K2 = this._textHeight * this.anchor.y, Q2 = 0; Q2 < Z2.total; Q2++)
            Z2.vertices[J2++] -= $2, Z2.vertices[J2++] -= K2, Z2.vertices[J2++] -= $2, Z2.vertices[J2++] -= K2, Z2.vertices[J2++] -= $2, Z2.vertices[J2++] -= K2, Z2.vertices[J2++] -= $2, Z2.vertices[J2++] -= K2;
        this._maxLineHeight = v2 * n2;
        var tt2 = Z2.mesh.geometry.getBuffer("aVertexPosition"), et2 = Z2.mesh.geometry.getBuffer("aTextureCoord"), nt2 = Z2.mesh.geometry.getIndex();
        tt2.data = Z2.vertices, et2.data = Z2.uvs, nt2.data = Z2.indices, tt2.update(), et2.update(), nt2.update();
      }
      for (y2 = 0; y2 < r3.length; y2++)
        LS.push(r3[y2]);
    }, e3.prototype.updateTransform = function() {
      this.validate(), this.containerUpdateTransform();
    }, e3.prototype._render = function(e4) {
      var n2 = CS.available[this._fontName], i2 = n2.distanceFieldRange, r3 = n2.distanceFieldType, o3 = n2.size;
      if (r3 !== "none")
        for (var s3 = this.worldTransform, a2 = s3.a, l2 = s3.b, u2 = s3.c, h2 = s3.d, c2 = Math.sqrt(a2 * a2 + l2 * l2), d2 = Math.sqrt(u2 * u2 + h2 * h2), p2 = (Math.abs(c2) + Math.abs(d2)) / 2, f2 = this._fontSize / o3, m2 = 0, g2 = this._activePagesMeshData; m2 < g2.length; m2++) {
          g2[m2].mesh.shader.uniforms.uFWidth = p2 * i2 * f2 * e4.resolution;
        }
      t3.prototype._render.call(this, e4);
    }, e3.prototype.getLocalBounds = function() {
      return this.validate(), t3.prototype.getLocalBounds.call(this);
    }, e3.prototype.validate = function() {
      this.dirty && (this.updateText(), this.dirty = false);
    }, Object.defineProperty(e3.prototype, "tint", { get: function() {
      return this._tint;
    }, set: function(t4) {
      if (this._tint !== t4) {
        this._tint = t4;
        for (var e4 = 0; e4 < this._activePagesMeshData.length; e4++)
          this._activePagesMeshData[e4].mesh.tint = t4;
      }
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "align", { get: function() {
      return this._align;
    }, set: function(t4) {
      this._align !== t4 && (this._align = t4, this.dirty = true);
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "fontName", { get: function() {
      return this._fontName;
    }, set: function(t4) {
      if (!CS.available[t4])
        throw new Error('Missing BitmapFont "' + t4 + '"');
      this._fontName !== t4 && (this._fontName = t4, this.dirty = true);
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "fontSize", { get: function() {
      return this._fontSize;
    }, set: function(t4) {
      this._fontSize !== t4 && (this._fontSize = t4, this.dirty = true);
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "anchor", { get: function() {
      return this._anchor;
    }, set: function(t4) {
      typeof t4 == "number" ? this._anchor.set(t4) : this._anchor.copyFrom(t4);
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "text", { get: function() {
      return this._text;
    }, set: function(t4) {
      t4 = String(t4 == null ? "" : t4), this._text !== t4 && (this._text = t4, this.dirty = true);
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "maxWidth", { get: function() {
      return this._maxWidth;
    }, set: function(t4) {
      this._maxWidth !== t4 && (this._maxWidth = t4, this.dirty = true);
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "maxLineHeight", { get: function() {
      return this.validate(), this._maxLineHeight;
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "textWidth", { get: function() {
      return this.validate(), this._textWidth;
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "letterSpacing", { get: function() {
      return this._letterSpacing;
    }, set: function(t4) {
      this._letterSpacing !== t4 && (this._letterSpacing = t4, this.dirty = true);
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "roundPixels", { get: function() {
      return this._roundPixels;
    }, set: function(t4) {
      t4 !== this._roundPixels && (this._roundPixels = t4, this.dirty = true);
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "textHeight", { get: function() {
      return this.validate(), this._textHeight;
    }, enumerable: false, configurable: true }), e3.prototype.destroy = function(e4) {
      var n2 = this._textureCache;
      for (var i2 in n2) {
        n2[i2].destroy(), delete n2[i2];
      }
      this._textureCache = null, t3.prototype.destroy.call(this, e4);
    }, e3.styleDefaults = { align: "left", tint: 16777215, maxWidth: 0, letterSpacing: 0 };
  }(ty), function() {
    function t3() {
    }
    return t3.add = function() {
      Xb.setExtensionXhrType("fnt", Xb.XHR_RESPONSE_TYPE.TEXT);
    }, t3.use = function(e3, n2) {
      var i2 = MS(e3.data);
      if (i2)
        for (var r3 = t3.getBaseUrl(this, e3), o3 = i2.parse(e3.data), s3 = {}, a2 = function(t4) {
          s3[t4.metadata.pageFile] = t4.texture, Object.keys(s3).length === o3.page.length && (e3.bitmapFont = CS.install(o3, s3, true), n2());
        }, l2 = 0; l2 < o3.page.length; ++l2) {
          var u2 = o3.page[l2].file, h2 = r3 + u2, c2 = false;
          for (var d2 in this.resources) {
            var p2 = this.resources[d2];
            if (p2.url === h2) {
              p2.metadata.pageFile = u2, p2.texture ? a2(p2) : p2.onAfterMiddleware.add(a2), c2 = true;
              break;
            }
          }
          if (!c2) {
            var f2 = { crossOrigin: e3.crossOrigin, loadType: Xb.LOAD_TYPE.IMAGE, metadata: Object.assign({ pageFile: u2 }, e3.metadata.imageMetadata), parentResource: e3 };
            this.add(h2, f2, a2);
          }
        }
      else
        n2();
    }, t3.getBaseUrl = function(e3, n2) {
      var i2 = n2.isDataUrl ? "" : t3.dirname(n2.url);
      return n2.isDataUrl && (i2 === "." && (i2 = ""), e3.baseUrl && i2 && e3.baseUrl.charAt(e3.baseUrl.length - 1) === "/" && (i2 += "/")), (i2 = i2.replace(e3.baseUrl, "")) && i2.charAt(i2.length - 1) !== "/" && (i2 += "/"), i2;
    }, t3.dirname = function(t4) {
      var e3 = t4.replace(/\\/g, "/").replace(/\/$/, "").replace(/\/[^\/]*$/, "");
      return e3 === t4 ? "." : e3 === "" ? "/" : e3;
    }, t3;
  }()), DS = function(t3, e3) {
    return (DS = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e4) {
      t4.__proto__ = e4;
    } || function(t4, e4) {
      for (var n2 in e4)
        e4.hasOwnProperty(n2) && (t4[n2] = e4[n2]);
    })(t3, e3);
  };
  var FS = function(t3) {
    function e3(e4) {
      e4 === void 0 && (e4 = 1);
      var n2 = t3.call(this, "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}", "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float uAlpha;\n\nvoid main(void)\n{\n   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;\n}\n", { uAlpha: 1 }) || this;
      return n2.alpha = e4, n2;
    }
    return function(t4, e4) {
      function n2() {
        this.constructor = t4;
      }
      DS(t4, e4), t4.prototype = e4 === null ? Object.create(e4) : (n2.prototype = e4.prototype, new n2());
    }(e3, t3), Object.defineProperty(e3.prototype, "alpha", { get: function() {
      return this.uniforms.uAlpha;
    }, set: function(t4) {
      this.uniforms.uAlpha = t4;
    }, enumerable: false, configurable: true }), e3;
  }(Gx), BS = function(t3, e3) {
    return (BS = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e4) {
      t4.__proto__ = e4;
    } || function(t4, e4) {
      for (var n2 in e4)
        e4.hasOwnProperty(n2) && (t4[n2] = e4[n2]);
    })(t3, e3);
  };
  function US(t3, e3) {
    function n2() {
      this.constructor = t3;
    }
    BS(t3, e3), t3.prototype = e3 === null ? Object.create(e3) : (n2.prototype = e3.prototype, new n2());
  }
  var kS, GS, HS, zS, jS, VS, WS, XS, qS, YS, ZS, JS, $S, KS, QS, tE, eE, nE, iE, rE = { 5: [0.153388, 0.221461, 0.250301], 7: [0.071303, 0.131514, 0.189879, 0.214607], 9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236], 11: [93e-4, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596], 13: [2406e-6, 9255e-6, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641], 15: [489e-6, 2403e-6, 9246e-6, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448] }, oE = ["varying vec2 vBlurTexCoords[%size%];", "uniform sampler2D uSampler;", "void main(void)", "{", "    gl_FragColor = vec4(0.0);", "    %blur%", "}"].join("\n");
  !function(t3) {
    t3[t3.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", t3[t3.WEBGL = 1] = "WEBGL", t3[t3.WEBGL2 = 2] = "WEBGL2";
  }(kS || (kS = {})), function(t3) {
    t3[t3.UNKNOWN = 0] = "UNKNOWN", t3[t3.WEBGL = 1] = "WEBGL", t3[t3.CANVAS = 2] = "CANVAS";
  }(GS || (GS = {})), function(t3) {
    t3[t3.COLOR = 16384] = "COLOR", t3[t3.DEPTH = 256] = "DEPTH", t3[t3.STENCIL = 1024] = "STENCIL";
  }(HS || (HS = {})), function(t3) {
    t3[t3.NORMAL = 0] = "NORMAL", t3[t3.ADD = 1] = "ADD", t3[t3.MULTIPLY = 2] = "MULTIPLY", t3[t3.SCREEN = 3] = "SCREEN", t3[t3.OVERLAY = 4] = "OVERLAY", t3[t3.DARKEN = 5] = "DARKEN", t3[t3.LIGHTEN = 6] = "LIGHTEN", t3[t3.COLOR_DODGE = 7] = "COLOR_DODGE", t3[t3.COLOR_BURN = 8] = "COLOR_BURN", t3[t3.HARD_LIGHT = 9] = "HARD_LIGHT", t3[t3.SOFT_LIGHT = 10] = "SOFT_LIGHT", t3[t3.DIFFERENCE = 11] = "DIFFERENCE", t3[t3.EXCLUSION = 12] = "EXCLUSION", t3[t3.HUE = 13] = "HUE", t3[t3.SATURATION = 14] = "SATURATION", t3[t3.COLOR = 15] = "COLOR", t3[t3.LUMINOSITY = 16] = "LUMINOSITY", t3[t3.NORMAL_NPM = 17] = "NORMAL_NPM", t3[t3.ADD_NPM = 18] = "ADD_NPM", t3[t3.SCREEN_NPM = 19] = "SCREEN_NPM", t3[t3.NONE = 20] = "NONE", t3[t3.SRC_OVER = 0] = "SRC_OVER", t3[t3.SRC_IN = 21] = "SRC_IN", t3[t3.SRC_OUT = 22] = "SRC_OUT", t3[t3.SRC_ATOP = 23] = "SRC_ATOP", t3[t3.DST_OVER = 24] = "DST_OVER", t3[t3.DST_IN = 25] = "DST_IN", t3[t3.DST_OUT = 26] = "DST_OUT", t3[t3.DST_ATOP = 27] = "DST_ATOP", t3[t3.ERASE = 26] = "ERASE", t3[t3.SUBTRACT = 28] = "SUBTRACT", t3[t3.XOR = 29] = "XOR";
  }(zS || (zS = {})), function(t3) {
    t3[t3.POINTS = 0] = "POINTS", t3[t3.LINES = 1] = "LINES", t3[t3.LINE_LOOP = 2] = "LINE_LOOP", t3[t3.LINE_STRIP = 3] = "LINE_STRIP", t3[t3.TRIANGLES = 4] = "TRIANGLES", t3[t3.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", t3[t3.TRIANGLE_FAN = 6] = "TRIANGLE_FAN";
  }(jS || (jS = {})), function(t3) {
    t3[t3.RGBA = 6408] = "RGBA", t3[t3.RGB = 6407] = "RGB", t3[t3.RG = 33319] = "RG", t3[t3.RED = 6403] = "RED", t3[t3.RGBA_INTEGER = 36249] = "RGBA_INTEGER", t3[t3.RGB_INTEGER = 36248] = "RGB_INTEGER", t3[t3.RG_INTEGER = 33320] = "RG_INTEGER", t3[t3.RED_INTEGER = 36244] = "RED_INTEGER", t3[t3.ALPHA = 6406] = "ALPHA", t3[t3.LUMINANCE = 6409] = "LUMINANCE", t3[t3.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", t3[t3.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", t3[t3.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL";
  }(VS || (VS = {})), function(t3) {
    t3[t3.TEXTURE_2D = 3553] = "TEXTURE_2D", t3[t3.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", t3[t3.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", t3[t3.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", t3[t3.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", t3[t3.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", t3[t3.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", t3[t3.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", t3[t3.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
  }(WS || (WS = {})), function(t3) {
    t3[t3.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", t3[t3.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", t3[t3.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", t3[t3.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", t3[t3.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", t3[t3.UNSIGNED_INT = 5125] = "UNSIGNED_INT", t3[t3.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", t3[t3.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", t3[t3.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", t3[t3.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", t3[t3.BYTE = 5120] = "BYTE", t3[t3.SHORT = 5122] = "SHORT", t3[t3.INT = 5124] = "INT", t3[t3.FLOAT = 5126] = "FLOAT", t3[t3.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", t3[t3.HALF_FLOAT = 36193] = "HALF_FLOAT";
  }(XS || (XS = {})), function(t3) {
    t3[t3.FLOAT = 0] = "FLOAT", t3[t3.INT = 1] = "INT", t3[t3.UINT = 2] = "UINT";
  }(qS || (qS = {})), function(t3) {
    t3[t3.NEAREST = 0] = "NEAREST", t3[t3.LINEAR = 1] = "LINEAR";
  }(YS || (YS = {})), function(t3) {
    t3[t3.CLAMP = 33071] = "CLAMP", t3[t3.REPEAT = 10497] = "REPEAT", t3[t3.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT";
  }(ZS || (ZS = {})), function(t3) {
    t3[t3.OFF = 0] = "OFF", t3[t3.POW2 = 1] = "POW2", t3[t3.ON = 2] = "ON", t3[t3.ON_MANUAL = 3] = "ON_MANUAL";
  }(JS || (JS = {})), function(t3) {
    t3[t3.NPM = 0] = "NPM", t3[t3.UNPACK = 1] = "UNPACK", t3[t3.PMA = 2] = "PMA", t3[t3.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", t3[t3.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", t3[t3.PREMULTIPLY_ALPHA = 2] = "PREMULTIPLY_ALPHA", t3[t3.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA";
  }($S || ($S = {})), function(t3) {
    t3[t3.NO = 0] = "NO", t3[t3.YES = 1] = "YES", t3[t3.AUTO = 2] = "AUTO", t3[t3.BLEND = 0] = "BLEND", t3[t3.CLEAR = 1] = "CLEAR", t3[t3.BLIT = 2] = "BLIT";
  }(KS || (KS = {})), function(t3) {
    t3[t3.AUTO = 0] = "AUTO", t3[t3.MANUAL = 1] = "MANUAL";
  }(QS || (QS = {})), function(t3) {
    t3.LOW = "lowp", t3.MEDIUM = "mediump", t3.HIGH = "highp";
  }(tE || (tE = {})), function(t3) {
    t3[t3.NONE = 0] = "NONE", t3[t3.SCISSOR = 1] = "SCISSOR", t3[t3.STENCIL = 2] = "STENCIL", t3[t3.SPRITE = 3] = "SPRITE";
  }(eE || (eE = {})), function(t3) {
    t3[t3.NONE = 0] = "NONE", t3[t3.LOW = 2] = "LOW", t3[t3.MEDIUM = 4] = "MEDIUM", t3[t3.HIGH = 8] = "HIGH";
  }(nE || (nE = {})), function(t3) {
    t3[t3.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", t3[t3.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", t3[t3.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER";
  }(iE || (iE = {}));
  var sE = function(t3) {
    function e3(e4, n2, i2, r3, o3) {
      n2 === void 0 && (n2 = 8), i2 === void 0 && (i2 = 4), r3 === void 0 && (r3 = mv.FILTER_RESOLUTION), o3 === void 0 && (o3 = 5);
      var s3 = this, a2 = function(t4, e5) {
        var n3, i3 = Math.ceil(t4 / 2), r4 = "\n    attribute vec2 aVertexPosition;\n\n    uniform mat3 projectionMatrix;\n\n    uniform float strength;\n\n    varying vec2 vBlurTexCoords[%size%];\n\n    uniform vec4 inputSize;\n    uniform vec4 outputFrame;\n\n    vec4 filterVertexPosition( void )\n    {\n        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n    }\n\n    vec2 filterTextureCoord( void )\n    {\n        return aVertexPosition * (outputFrame.zw * inputSize.zw);\n    }\n\n    void main(void)\n    {\n        gl_Position = filterVertexPosition();\n\n        vec2 textureCoord = filterTextureCoord();\n        %blur%\n    }", o4 = "";
        n3 = e5 ? "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);" : "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);";
        for (var s4 = 0; s4 < t4; s4++) {
          var a3 = n3.replace("%index%", s4.toString());
          o4 += a3 = a3.replace("%sampleIndex%", s4 - (i3 - 1) + ".0"), o4 += "\n";
        }
        return r4 = (r4 = r4.replace("%blur%", o4)).replace("%size%", t4.toString());
      }(o3, e4), l2 = function(t4) {
        for (var e5, n3 = rE[t4], i3 = n3.length, r4 = oE, o4 = "", s4 = 0; s4 < t4; s4++) {
          var a3 = "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;".replace("%index%", s4.toString());
          e5 = s4, s4 >= i3 && (e5 = t4 - s4 - 1), o4 += a3 = a3.replace("%value%", n3[e5].toString()), o4 += "\n";
        }
        return r4 = (r4 = r4.replace("%blur%", o4)).replace("%size%", t4.toString());
      }(o3);
      return (s3 = t3.call(this, a2, l2) || this).horizontal = e4, s3.resolution = r3, s3._quality = 0, s3.quality = i2, s3.blur = n2, s3;
    }
    return US(e3, t3), e3.prototype.apply = function(t4, e4, n2, i2) {
      if (n2 ? this.horizontal ? this.uniforms.strength = 1 / n2.width * (n2.width / e4.width) : this.uniforms.strength = 1 / n2.height * (n2.height / e4.height) : this.horizontal ? this.uniforms.strength = 1 / t4.renderer.width * (t4.renderer.width / e4.width) : this.uniforms.strength = 1 / t4.renderer.height * (t4.renderer.height / e4.height), this.uniforms.strength *= this.strength, this.uniforms.strength /= this.passes, this.passes === 1)
        t4.applyFilter(this, e4, n2, i2);
      else {
        var r3 = t4.getFilterTexture(), o3 = t4.renderer, s3 = e4, a2 = r3;
        this.state.blend = false, t4.applyFilter(this, s3, a2, KS.CLEAR);
        for (var l2 = 1; l2 < this.passes - 1; l2++) {
          t4.bindAndClear(s3, KS.BLIT), this.uniforms.uSampler = a2;
          var u2 = a2;
          a2 = s3, s3 = u2, o3.shader.bind(this), o3.geometry.draw(5);
        }
        this.state.blend = true, t4.applyFilter(this, a2, n2, i2), t4.returnFilterTexture(r3);
      }
    }, Object.defineProperty(e3.prototype, "blur", { get: function() {
      return this.strength;
    }, set: function(t4) {
      this.padding = 1 + 2 * Math.abs(t4), this.strength = t4;
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "quality", { get: function() {
      return this._quality;
    }, set: function(t4) {
      this._quality = t4, this.passes = t4;
    }, enumerable: false, configurable: true }), e3;
  }(Gx), aE = function(t3) {
    function e3(e4, n2, i2, r3) {
      e4 === void 0 && (e4 = 8), n2 === void 0 && (n2 = 4), i2 === void 0 && (i2 = mv.FILTER_RESOLUTION), r3 === void 0 && (r3 = 5);
      var o3 = t3.call(this) || this;
      return o3.blurXFilter = new sE(true, e4, n2, i2, r3), o3.blurYFilter = new sE(false, e4, n2, i2, r3), o3.resolution = i2, o3.quality = n2, o3.blur = e4, o3.repeatEdgePixels = false, o3;
    }
    return US(e3, t3), e3.prototype.apply = function(t4, e4, n2, i2) {
      var r3 = Math.abs(this.blurXFilter.strength), o3 = Math.abs(this.blurYFilter.strength);
      if (r3 && o3) {
        var s3 = t4.getFilterTexture();
        this.blurXFilter.apply(t4, e4, s3, KS.CLEAR), this.blurYFilter.apply(t4, s3, n2, i2), t4.returnFilterTexture(s3);
      } else
        o3 ? this.blurYFilter.apply(t4, e4, n2, i2) : this.blurXFilter.apply(t4, e4, n2, i2);
    }, e3.prototype.updatePadding = function() {
      this._repeatEdgePixels ? this.padding = 0 : this.padding = 2 * Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength));
    }, Object.defineProperty(e3.prototype, "blur", { get: function() {
      return this.blurXFilter.blur;
    }, set: function(t4) {
      this.blurXFilter.blur = this.blurYFilter.blur = t4, this.updatePadding();
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "quality", { get: function() {
      return this.blurXFilter.quality;
    }, set: function(t4) {
      this.blurXFilter.quality = this.blurYFilter.quality = t4;
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "blurX", { get: function() {
      return this.blurXFilter.blur;
    }, set: function(t4) {
      this.blurXFilter.blur = t4, this.updatePadding();
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "blurY", { get: function() {
      return this.blurYFilter.blur;
    }, set: function(t4) {
      this.blurYFilter.blur = t4, this.updatePadding();
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "blendMode", { get: function() {
      return this.blurYFilter.blendMode;
    }, set: function(t4) {
      this.blurYFilter.blendMode = t4;
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "repeatEdgePixels", { get: function() {
      return this._repeatEdgePixels;
    }, set: function(t4) {
      this._repeatEdgePixels = t4, this.updatePadding();
    }, enumerable: false, configurable: true }), e3;
  }(Gx), lE = function(t3, e3) {
    return (lE = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e4) {
      t4.__proto__ = e4;
    } || function(t4, e4) {
      for (var n2 in e4)
        e4.hasOwnProperty(n2) && (t4[n2] = e4[n2]);
    })(t3, e3);
  };
  var uE = function(t3) {
    function e3() {
      var e4 = this, n2 = { m: new Float32Array([1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]), uAlpha: 1 };
      return (e4 = t3.call(this, _b, "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float m[20];\nuniform float uAlpha;\n\nvoid main(void)\n{\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    if (uAlpha == 0.0) {\n        gl_FragColor = c;\n        return;\n    }\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (c.a > 0.0) {\n      c.rgb /= c.a;\n    }\n\n    vec4 result;\n\n    result.r = (m[0] * c.r);\n        result.r += (m[1] * c.g);\n        result.r += (m[2] * c.b);\n        result.r += (m[3] * c.a);\n        result.r += m[4];\n\n    result.g = (m[5] * c.r);\n        result.g += (m[6] * c.g);\n        result.g += (m[7] * c.b);\n        result.g += (m[8] * c.a);\n        result.g += m[9];\n\n    result.b = (m[10] * c.r);\n       result.b += (m[11] * c.g);\n       result.b += (m[12] * c.b);\n       result.b += (m[13] * c.a);\n       result.b += m[14];\n\n    result.a = (m[15] * c.r);\n       result.a += (m[16] * c.g);\n       result.a += (m[17] * c.b);\n       result.a += (m[18] * c.a);\n       result.a += m[19];\n\n    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);\n\n    // Premultiply alpha again.\n    rgb *= result.a;\n\n    gl_FragColor = vec4(rgb, result.a);\n}\n", n2) || this).alpha = 1, e4;
    }
    return function(t4, e4) {
      function n2() {
        this.constructor = t4;
      }
      lE(t4, e4), t4.prototype = e4 === null ? Object.create(e4) : (n2.prototype = e4.prototype, new n2());
    }(e3, t3), e3.prototype._loadMatrix = function(t4, e4) {
      e4 === void 0 && (e4 = false);
      var n2 = t4;
      e4 && (this._multiply(n2, this.uniforms.m, t4), n2 = this._colorMatrix(n2)), this.uniforms.m = n2;
    }, e3.prototype._multiply = function(t4, e4, n2) {
      return t4[0] = e4[0] * n2[0] + e4[1] * n2[5] + e4[2] * n2[10] + e4[3] * n2[15], t4[1] = e4[0] * n2[1] + e4[1] * n2[6] + e4[2] * n2[11] + e4[3] * n2[16], t4[2] = e4[0] * n2[2] + e4[1] * n2[7] + e4[2] * n2[12] + e4[3] * n2[17], t4[3] = e4[0] * n2[3] + e4[1] * n2[8] + e4[2] * n2[13] + e4[3] * n2[18], t4[4] = e4[0] * n2[4] + e4[1] * n2[9] + e4[2] * n2[14] + e4[3] * n2[19] + e4[4], t4[5] = e4[5] * n2[0] + e4[6] * n2[5] + e4[7] * n2[10] + e4[8] * n2[15], t4[6] = e4[5] * n2[1] + e4[6] * n2[6] + e4[7] * n2[11] + e4[8] * n2[16], t4[7] = e4[5] * n2[2] + e4[6] * n2[7] + e4[7] * n2[12] + e4[8] * n2[17], t4[8] = e4[5] * n2[3] + e4[6] * n2[8] + e4[7] * n2[13] + e4[8] * n2[18], t4[9] = e4[5] * n2[4] + e4[6] * n2[9] + e4[7] * n2[14] + e4[8] * n2[19] + e4[9], t4[10] = e4[10] * n2[0] + e4[11] * n2[5] + e4[12] * n2[10] + e4[13] * n2[15], t4[11] = e4[10] * n2[1] + e4[11] * n2[6] + e4[12] * n2[11] + e4[13] * n2[16], t4[12] = e4[10] * n2[2] + e4[11] * n2[7] + e4[12] * n2[12] + e4[13] * n2[17], t4[13] = e4[10] * n2[3] + e4[11] * n2[8] + e4[12] * n2[13] + e4[13] * n2[18], t4[14] = e4[10] * n2[4] + e4[11] * n2[9] + e4[12] * n2[14] + e4[13] * n2[19] + e4[14], t4[15] = e4[15] * n2[0] + e4[16] * n2[5] + e4[17] * n2[10] + e4[18] * n2[15], t4[16] = e4[15] * n2[1] + e4[16] * n2[6] + e4[17] * n2[11] + e4[18] * n2[16], t4[17] = e4[15] * n2[2] + e4[16] * n2[7] + e4[17] * n2[12] + e4[18] * n2[17], t4[18] = e4[15] * n2[3] + e4[16] * n2[8] + e4[17] * n2[13] + e4[18] * n2[18], t4[19] = e4[15] * n2[4] + e4[16] * n2[9] + e4[17] * n2[14] + e4[18] * n2[19] + e4[19], t4;
    }, e3.prototype._colorMatrix = function(t4) {
      var e4 = new Float32Array(t4);
      return e4[4] /= 255, e4[9] /= 255, e4[14] /= 255, e4[19] /= 255, e4;
    }, e3.prototype.brightness = function(t4, e4) {
      var n2 = [t4, 0, 0, 0, 0, 0, t4, 0, 0, 0, 0, 0, t4, 0, 0, 0, 0, 0, 1, 0];
      this._loadMatrix(n2, e4);
    }, e3.prototype.tint = function(t4, e4) {
      var n2 = [(t4 >> 16 & 255) / 255, 0, 0, 0, 0, 0, (t4 >> 8 & 255) / 255, 0, 0, 0, 0, 0, (255 & t4) / 255, 0, 0, 0, 0, 0, 1, 0];
      this._loadMatrix(n2, e4);
    }, e3.prototype.greyscale = function(t4, e4) {
      var n2 = [t4, t4, t4, 0, 0, t4, t4, t4, 0, 0, t4, t4, t4, 0, 0, 0, 0, 0, 1, 0];
      this._loadMatrix(n2, e4);
    }, e3.prototype.blackAndWhite = function(t4) {
      this._loadMatrix([0.3, 0.6, 0.1, 0, 0, 0.3, 0.6, 0.1, 0, 0, 0.3, 0.6, 0.1, 0, 0, 0, 0, 0, 1, 0], t4);
    }, e3.prototype.hue = function(t4, e4) {
      t4 = (t4 || 0) / 180 * Math.PI;
      var n2 = Math.cos(t4), i2 = Math.sin(t4), r3 = 1 / 3, o3 = (0, Math.sqrt)(r3), s3 = [n2 + (1 - n2) * r3, r3 * (1 - n2) - o3 * i2, r3 * (1 - n2) + o3 * i2, 0, 0, r3 * (1 - n2) + o3 * i2, n2 + r3 * (1 - n2), r3 * (1 - n2) - o3 * i2, 0, 0, r3 * (1 - n2) - o3 * i2, r3 * (1 - n2) + o3 * i2, n2 + r3 * (1 - n2), 0, 0, 0, 0, 0, 1, 0];
      this._loadMatrix(s3, e4);
    }, e3.prototype.contrast = function(t4, e4) {
      var n2 = (t4 || 0) + 1, i2 = -0.5 * (n2 - 1), r3 = [n2, 0, 0, 0, i2, 0, n2, 0, 0, i2, 0, 0, n2, 0, i2, 0, 0, 0, 1, 0];
      this._loadMatrix(r3, e4);
    }, e3.prototype.saturate = function(t4, e4) {
      t4 === void 0 && (t4 = 0);
      var n2 = 2 * t4 / 3 + 1, i2 = -0.5 * (n2 - 1), r3 = [n2, i2, i2, 0, 0, i2, n2, i2, 0, 0, i2, i2, n2, 0, 0, 0, 0, 0, 1, 0];
      this._loadMatrix(r3, e4);
    }, e3.prototype.desaturate = function() {
      this.saturate(-1);
    }, e3.prototype.negative = function(t4) {
      this._loadMatrix([-1, 0, 0, 1, 0, 0, -1, 0, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0], t4);
    }, e3.prototype.sepia = function(t4) {
      this._loadMatrix([0.393, 0.7689999, 0.18899999, 0, 0, 0.349, 0.6859999, 0.16799999, 0, 0, 0.272, 0.5339999, 0.13099999, 0, 0, 0, 0, 0, 1, 0], t4);
    }, e3.prototype.technicolor = function(t4) {
      this._loadMatrix([1.9125277891456083, -0.8545344976951645, -0.09155508482755585, 0, 11.793603434377337, -0.3087833385928097, 1.7658908555458428, -0.10601743074722245, 0, -70.35205161461398, -0.231103377548616, -0.7501899197440212, 1.847597816108189, 0, 30.950940869491138, 0, 0, 0, 1, 0], t4);
    }, e3.prototype.polaroid = function(t4) {
      this._loadMatrix([1.438, -0.062, -0.062, 0, 0, -0.122, 1.378, -0.122, 0, 0, -0.016, -0.016, 1.483, 0, 0, 0, 0, 0, 1, 0], t4);
    }, e3.prototype.toBGR = function(t4) {
      this._loadMatrix([0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0], t4);
    }, e3.prototype.kodachrome = function(t4) {
      this._loadMatrix([1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0, 63.72958762196502, -0.16404339962244616, 1.0835251566291304, -0.05498805115633132, 0, 24.732407896706203, -0.16786010706155763, -0.5603416277695248, 1.6014850761964943, 0, 35.62982807460946, 0, 0, 0, 1, 0], t4);
    }, e3.prototype.browni = function(t4) {
      this._loadMatrix([0.5997023498159715, 0.34553243048391263, -0.2708298674538042, 0, 47.43192855600873, -0.037703249837783157, 0.8609577587992641, 0.15059552388459913, 0, -36.96841498319127, 0.24113635128153335, -0.07441037908422492, 0.44972182064877153, 0, -7.562075277591283, 0, 0, 0, 1, 0], t4);
    }, e3.prototype.vintage = function(t4) {
      this._loadMatrix([0.6279345635605994, 0.3202183420819367, -0.03965408211312453, 0, 9.651285835294123, 0.02578397704808868, 0.6441188644374771, 0.03259127616149294, 0, 7.462829176470591, 0.0466055556782719, -0.0851232987247891, 0.5241648018700465, 0, 5.159190588235296, 0, 0, 0, 1, 0], t4);
    }, e3.prototype.colorTone = function(t4, e4, n2, i2, r3) {
      var o3 = ((n2 = n2 || 16770432) >> 16 & 255) / 255, s3 = (n2 >> 8 & 255) / 255, a2 = (255 & n2) / 255, l2 = ((i2 = i2 || 3375104) >> 16 & 255) / 255, u2 = (i2 >> 8 & 255) / 255, h2 = (255 & i2) / 255, c2 = [0.3, 0.59, 0.11, 0, 0, o3, s3, a2, t4 = t4 || 0.2, 0, l2, u2, h2, e4 = e4 || 0.15, 0, o3 - l2, s3 - u2, a2 - h2, 0, 0];
      this._loadMatrix(c2, r3);
    }, e3.prototype.night = function(t4, e4) {
      var n2 = [-2 * (t4 = t4 || 0.1), -t4, 0, 0, 0, -t4, 0, t4, 0, 0, 0, t4, 2 * t4, 0, 0, 0, 0, 0, 1, 0];
      this._loadMatrix(n2, e4);
    }, e3.prototype.predator = function(t4, e4) {
      var n2 = [11.224130630493164 * t4, -4.794486999511719 * t4, -2.8746118545532227 * t4, 0 * t4, 0.40342438220977783 * t4, -3.6330697536468506 * t4, 9.193157196044922 * t4, -2.951810836791992 * t4, 0 * t4, -1.316135048866272 * t4, -3.2184197902679443 * t4, -4.2375030517578125 * t4, 7.476448059082031 * t4, 0 * t4, 0.8044459223747253 * t4, 0, 0, 0, 1, 0];
      this._loadMatrix(n2, e4);
    }, e3.prototype.lsd = function(t4) {
      this._loadMatrix([2, -0.4, 0.5, 0, 0, -0.5, 2, -0.4, 0, 0, -0.4, -0.5, 3, 0, 0, 0, 0, 0, 1, 0], t4);
    }, e3.prototype.reset = function() {
      this._loadMatrix([1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], false);
    }, Object.defineProperty(e3.prototype, "matrix", { get: function() {
      return this.uniforms.m;
    }, set: function(t4) {
      this.uniforms.m = t4;
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "alpha", { get: function() {
      return this.uniforms.uAlpha;
    }, set: function(t4) {
      this.uniforms.uAlpha = t4;
    }, enumerable: false, configurable: true }), e3;
  }(Gx);
  uE.prototype.grayscale = uE.prototype.greyscale;
  /*!
   * @pixi/filter-displacement - v6.2.0
   * Compiled Mon, 01 Nov 2021 16:52:10 UTC
   *
   * @pixi/filter-displacement is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   */
  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */
  var hE = function(t3, e3) {
    return (hE = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e4) {
      t4.__proto__ = e4;
    } || function(t4, e4) {
      for (var n2 in e4)
        e4.hasOwnProperty(n2) && (t4[n2] = e4[n2]);
    })(t3, e3);
  };
  var cE = function(t3) {
    function e3(e4, n2) {
      var i2 = this, r3 = new y_();
      return e4.renderable = false, (i2 = t3.call(this, "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\nuniform mat3 filterMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vFilterCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n	gl_Position = filterVertexPosition();\n	vTextureCoord = filterTextureCoord();\n	vFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;\n}\n", "varying vec2 vFilterCoord;\nvarying vec2 vTextureCoord;\n\nuniform vec2 scale;\nuniform mat2 rotation;\nuniform sampler2D uSampler;\nuniform sampler2D mapSampler;\n\nuniform highp vec4 inputSize;\nuniform vec4 inputClamp;\n\nvoid main(void)\n{\n  vec4 map =  texture2D(mapSampler, vFilterCoord);\n\n  map -= 0.5;\n  map.xy = scale * inputSize.zw * (rotation * map.xy);\n\n  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));\n}\n", { mapSampler: e4._texture, filterMatrix: r3, scale: { x: 1, y: 1 }, rotation: new Float32Array([1, 0, 0, 1]) }) || this).maskSprite = e4, i2.maskMatrix = r3, n2 == null && (n2 = 20), i2.scale = new v_(n2, n2), i2;
    }
    return function(t4, e4) {
      function n2() {
        this.constructor = t4;
      }
      hE(t4, e4), t4.prototype = e4 === null ? Object.create(e4) : (n2.prototype = e4.prototype, new n2());
    }(e3, t3), e3.prototype.apply = function(t4, e4, n2, i2) {
      this.uniforms.filterMatrix = t4.calculateSpriteMatrix(this.maskMatrix, this.maskSprite), this.uniforms.scale.x = this.scale.x, this.uniforms.scale.y = this.scale.y;
      var r3 = this.maskSprite.worldTransform, o3 = Math.sqrt(r3.a * r3.a + r3.b * r3.b), s3 = Math.sqrt(r3.c * r3.c + r3.d * r3.d);
      o3 !== 0 && s3 !== 0 && (this.uniforms.rotation[0] = r3.a / o3, this.uniforms.rotation[1] = r3.b / o3, this.uniforms.rotation[2] = r3.c / s3, this.uniforms.rotation[3] = r3.d / s3), t4.applyFilter(this, e4, n2, i2);
    }, Object.defineProperty(e3.prototype, "map", { get: function() {
      return this.uniforms.mapSampler;
    }, set: function(t4) {
      this.uniforms.mapSampler = t4;
    }, enumerable: false, configurable: true }), e3;
  }(Gx), dE = function(t3, e3) {
    return (dE = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e4) {
      t4.__proto__ = e4;
    } || function(t4, e4) {
      for (var n2 in e4)
        e4.hasOwnProperty(n2) && (t4[n2] = e4[n2]);
    })(t3, e3);
  };
  var pE = function(t3) {
    function e3() {
      return t3.call(this, "\nattribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvoid texcoords(vec2 fragCoord, vec2 inverseVP,\n               out vec2 v_rgbNW, out vec2 v_rgbNE,\n               out vec2 v_rgbSW, out vec2 v_rgbSE,\n               out vec2 v_rgbM) {\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n    v_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvoid main(void) {\n\n   gl_Position = filterVertexPosition();\n\n   vFragCoord = aVertexPosition * outputFrame.zw;\n\n   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}\n", `varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;
uniform sampler2D uSampler;
uniform highp vec4 inputSize;


/**
 Basic FXAA implementation based on the code on geeks3d.com with the
 modification that the texture2DLod stuff was removed since it's
 unsupported by WebGL.

 --

 From:
 https://github.com/mitsuhiko/webgl-meincraft

 Copyright (c) 2011 by Armin Ronacher.

 Some rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are
 met:

 * Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above
 copyright notice, this list of conditions and the following
 disclaimer in the documentation and/or other materials provided
 with the distribution.

 * The names of the contributors may not be used to endorse or
 promote products derived from this software without specific
 prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef FXAA_REDUCE_MIN
#define FXAA_REDUCE_MIN   (1.0/ 128.0)
#endif
#ifndef FXAA_REDUCE_MUL
#define FXAA_REDUCE_MUL   (1.0 / 8.0)
#endif
#ifndef FXAA_SPAN_MAX
#define FXAA_SPAN_MAX     8.0
#endif

//optimized version for mobile, where dependent
//texture reads can be a bottleneck
vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,
          vec2 v_rgbNW, vec2 v_rgbNE,
          vec2 v_rgbSW, vec2 v_rgbSE,
          vec2 v_rgbM) {
    vec4 color;
    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;
    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;
    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;
    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;
    vec4 texColor = texture2D(tex, v_rgbM);
    vec3 rgbM  = texColor.xyz;
    vec3 luma = vec3(0.299, 0.587, 0.114);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM  = dot(rgbM,  luma);
    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

    mediump vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *
                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);

    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),
              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
                  dir * rcpDirMin)) * inverseVP;

    vec3 rgbA = 0.5 * (
                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +
                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);
    vec3 rgbB = rgbA * 0.5 + 0.25 * (
                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +
                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);

    float lumaB = dot(rgbB, luma);
    if ((lumaB < lumaMin) || (lumaB > lumaMax))
        color = vec4(rgbA, texColor.a);
    else
        color = vec4(rgbB, texColor.a);
    return color;
}

void main() {

      vec4 color;

      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);

      gl_FragColor = color;
}
`) || this;
    }
    return function(t4, e4) {
      function n2() {
        this.constructor = t4;
      }
      dE(t4, e4), t4.prototype = e4 === null ? Object.create(e4) : (n2.prototype = e4.prototype, new n2());
    }(e3, t3), e3;
  }(Gx), fE = function(t3, e3) {
    return (fE = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e4) {
      t4.__proto__ = e4;
    } || function(t4, e4) {
      for (var n2 in e4)
        e4.hasOwnProperty(n2) && (t4[n2] = e4[n2]);
    })(t3, e3);
  };
  var mE, gE, vE, _E, yE, xE, bE, TE, wE, SE, EE, ME, AE, RE, PE, CE, IE, OE, LE, NE = function(t3) {
    function e3(e4, n2) {
      e4 === void 0 && (e4 = 0.5), n2 === void 0 && (n2 = Math.random());
      var i2 = t3.call(this, _b, "precision highp float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform float uNoise;\nuniform float uSeed;\nuniform sampler2D uSampler;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * uSeed);\n    float diff = (randomValue - 0.5) * uNoise;\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    color.r += diff;\n    color.g += diff;\n    color.b += diff;\n\n    // Premultiply alpha again.\n    color.rgb *= color.a;\n\n    gl_FragColor = color;\n}\n", { uNoise: 0, uSeed: 0 }) || this;
      return i2.noise = e4, i2.seed = n2, i2;
    }
    return function(t4, e4) {
      function n2() {
        this.constructor = t4;
      }
      fE(t4, e4), t4.prototype = e4 === null ? Object.create(e4) : (n2.prototype = e4.prototype, new n2());
    }(e3, t3), Object.defineProperty(e3.prototype, "noise", { get: function() {
      return this.uniforms.uNoise;
    }, set: function(t4) {
      this.uniforms.uNoise = t4;
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "seed", { get: function() {
      return this.uniforms.uSeed;
    }, set: function(t4) {
      this.uniforms.uSeed = t4;
    }, enumerable: false, configurable: true }), e3;
  }(Gx);
  !function(t3) {
    t3[t3.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", t3[t3.WEBGL = 1] = "WEBGL", t3[t3.WEBGL2 = 2] = "WEBGL2";
  }(mE || (mE = {})), function(t3) {
    t3[t3.UNKNOWN = 0] = "UNKNOWN", t3[t3.WEBGL = 1] = "WEBGL", t3[t3.CANVAS = 2] = "CANVAS";
  }(gE || (gE = {})), function(t3) {
    t3[t3.COLOR = 16384] = "COLOR", t3[t3.DEPTH = 256] = "DEPTH", t3[t3.STENCIL = 1024] = "STENCIL";
  }(vE || (vE = {})), function(t3) {
    t3[t3.NORMAL = 0] = "NORMAL", t3[t3.ADD = 1] = "ADD", t3[t3.MULTIPLY = 2] = "MULTIPLY", t3[t3.SCREEN = 3] = "SCREEN", t3[t3.OVERLAY = 4] = "OVERLAY", t3[t3.DARKEN = 5] = "DARKEN", t3[t3.LIGHTEN = 6] = "LIGHTEN", t3[t3.COLOR_DODGE = 7] = "COLOR_DODGE", t3[t3.COLOR_BURN = 8] = "COLOR_BURN", t3[t3.HARD_LIGHT = 9] = "HARD_LIGHT", t3[t3.SOFT_LIGHT = 10] = "SOFT_LIGHT", t3[t3.DIFFERENCE = 11] = "DIFFERENCE", t3[t3.EXCLUSION = 12] = "EXCLUSION", t3[t3.HUE = 13] = "HUE", t3[t3.SATURATION = 14] = "SATURATION", t3[t3.COLOR = 15] = "COLOR", t3[t3.LUMINOSITY = 16] = "LUMINOSITY", t3[t3.NORMAL_NPM = 17] = "NORMAL_NPM", t3[t3.ADD_NPM = 18] = "ADD_NPM", t3[t3.SCREEN_NPM = 19] = "SCREEN_NPM", t3[t3.NONE = 20] = "NONE", t3[t3.SRC_OVER = 0] = "SRC_OVER", t3[t3.SRC_IN = 21] = "SRC_IN", t3[t3.SRC_OUT = 22] = "SRC_OUT", t3[t3.SRC_ATOP = 23] = "SRC_ATOP", t3[t3.DST_OVER = 24] = "DST_OVER", t3[t3.DST_IN = 25] = "DST_IN", t3[t3.DST_OUT = 26] = "DST_OUT", t3[t3.DST_ATOP = 27] = "DST_ATOP", t3[t3.ERASE = 26] = "ERASE", t3[t3.SUBTRACT = 28] = "SUBTRACT", t3[t3.XOR = 29] = "XOR";
  }(_E || (_E = {})), function(t3) {
    t3[t3.POINTS = 0] = "POINTS", t3[t3.LINES = 1] = "LINES", t3[t3.LINE_LOOP = 2] = "LINE_LOOP", t3[t3.LINE_STRIP = 3] = "LINE_STRIP", t3[t3.TRIANGLES = 4] = "TRIANGLES", t3[t3.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", t3[t3.TRIANGLE_FAN = 6] = "TRIANGLE_FAN";
  }(yE || (yE = {})), function(t3) {
    t3[t3.RGBA = 6408] = "RGBA", t3[t3.RGB = 6407] = "RGB", t3[t3.RG = 33319] = "RG", t3[t3.RED = 6403] = "RED", t3[t3.RGBA_INTEGER = 36249] = "RGBA_INTEGER", t3[t3.RGB_INTEGER = 36248] = "RGB_INTEGER", t3[t3.RG_INTEGER = 33320] = "RG_INTEGER", t3[t3.RED_INTEGER = 36244] = "RED_INTEGER", t3[t3.ALPHA = 6406] = "ALPHA", t3[t3.LUMINANCE = 6409] = "LUMINANCE", t3[t3.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", t3[t3.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", t3[t3.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL";
  }(xE || (xE = {})), function(t3) {
    t3[t3.TEXTURE_2D = 3553] = "TEXTURE_2D", t3[t3.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", t3[t3.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", t3[t3.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", t3[t3.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", t3[t3.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", t3[t3.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", t3[t3.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", t3[t3.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
  }(bE || (bE = {})), function(t3) {
    t3[t3.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", t3[t3.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", t3[t3.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", t3[t3.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", t3[t3.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", t3[t3.UNSIGNED_INT = 5125] = "UNSIGNED_INT", t3[t3.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", t3[t3.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", t3[t3.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", t3[t3.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", t3[t3.BYTE = 5120] = "BYTE", t3[t3.SHORT = 5122] = "SHORT", t3[t3.INT = 5124] = "INT", t3[t3.FLOAT = 5126] = "FLOAT", t3[t3.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", t3[t3.HALF_FLOAT = 36193] = "HALF_FLOAT";
  }(TE || (TE = {})), function(t3) {
    t3[t3.FLOAT = 0] = "FLOAT", t3[t3.INT = 1] = "INT", t3[t3.UINT = 2] = "UINT";
  }(wE || (wE = {})), function(t3) {
    t3[t3.NEAREST = 0] = "NEAREST", t3[t3.LINEAR = 1] = "LINEAR";
  }(SE || (SE = {})), function(t3) {
    t3[t3.CLAMP = 33071] = "CLAMP", t3[t3.REPEAT = 10497] = "REPEAT", t3[t3.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT";
  }(EE || (EE = {})), function(t3) {
    t3[t3.OFF = 0] = "OFF", t3[t3.POW2 = 1] = "POW2", t3[t3.ON = 2] = "ON", t3[t3.ON_MANUAL = 3] = "ON_MANUAL";
  }(ME || (ME = {})), function(t3) {
    t3[t3.NPM = 0] = "NPM", t3[t3.UNPACK = 1] = "UNPACK", t3[t3.PMA = 2] = "PMA", t3[t3.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", t3[t3.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", t3[t3.PREMULTIPLY_ALPHA = 2] = "PREMULTIPLY_ALPHA", t3[t3.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA";
  }(AE || (AE = {})), function(t3) {
    t3[t3.NO = 0] = "NO", t3[t3.YES = 1] = "YES", t3[t3.AUTO = 2] = "AUTO", t3[t3.BLEND = 0] = "BLEND", t3[t3.CLEAR = 1] = "CLEAR", t3[t3.BLIT = 2] = "BLIT";
  }(RE || (RE = {})), function(t3) {
    t3[t3.AUTO = 0] = "AUTO", t3[t3.MANUAL = 1] = "MANUAL";
  }(PE || (PE = {})), function(t3) {
    t3.LOW = "lowp", t3.MEDIUM = "mediump", t3.HIGH = "highp";
  }(CE || (CE = {})), function(t3) {
    t3[t3.NONE = 0] = "NONE", t3[t3.SCISSOR = 1] = "SCISSOR", t3[t3.STENCIL = 2] = "STENCIL", t3[t3.SPRITE = 3] = "SPRITE";
  }(IE || (IE = {})), function(t3) {
    t3[t3.NONE = 0] = "NONE", t3[t3.LOW = 2] = "LOW", t3[t3.MEDIUM = 4] = "MEDIUM", t3[t3.HIGH = 8] = "HIGH";
  }(OE || (OE = {})), function(t3) {
    t3[t3.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", t3[t3.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", t3[t3.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER";
  }(LE || (LE = {}));
  var DE = new y_();
  $_.prototype._cacheAsBitmap = false, $_.prototype._cacheData = null, $_.prototype._cacheAsBitmapResolution = null, $_.prototype._cacheAsBitmapMultisample = OE.NONE;
  var FE = function() {
    this.textureCacheId = null, this.originalRender = null, this.originalRenderCanvas = null, this.originalCalculateBounds = null, this.originalGetLocalBounds = null, this.originalUpdateTransform = null, this.originalDestroy = null, this.originalMask = null, this.originalFilterArea = null, this.originalContainsPoint = null, this.sprite = null;
  };
  Object.defineProperties($_.prototype, { cacheAsBitmapResolution: { get: function() {
    return this._cacheAsBitmapResolution;
  }, set: function(t3) {
    t3 !== this._cacheAsBitmapResolution && (this._cacheAsBitmapResolution = t3, this.cacheAsBitmap && (this.cacheAsBitmap = false, this.cacheAsBitmap = true));
  } }, cacheAsBitmapMultisample: { get: function() {
    return this._cacheAsBitmapMultisample;
  }, set: function(t3) {
    t3 !== this._cacheAsBitmapMultisample && (this._cacheAsBitmapMultisample = t3, this.cacheAsBitmap && (this.cacheAsBitmap = false, this.cacheAsBitmap = true));
  } }, cacheAsBitmap: { get: function() {
    return this._cacheAsBitmap;
  }, set: function(t3) {
    var e3;
    this._cacheAsBitmap !== t3 && (this._cacheAsBitmap = t3, t3 ? (this._cacheData || (this._cacheData = new FE()), (e3 = this._cacheData).originalRender = this.render, e3.originalRenderCanvas = this.renderCanvas, e3.originalUpdateTransform = this.updateTransform, e3.originalCalculateBounds = this.calculateBounds, e3.originalGetLocalBounds = this.getLocalBounds, e3.originalDestroy = this.destroy, e3.originalContainsPoint = this.containsPoint, e3.originalMask = this._mask, e3.originalFilterArea = this.filterArea, this.render = this._renderCached, this.renderCanvas = this._renderCachedCanvas, this.destroy = this._cacheAsBitmapDestroy) : ((e3 = this._cacheData).sprite && this._destroyCachedDisplayObject(), this.render = e3.originalRender, this.renderCanvas = e3.originalRenderCanvas, this.calculateBounds = e3.originalCalculateBounds, this.getLocalBounds = e3.originalGetLocalBounds, this.destroy = e3.originalDestroy, this.updateTransform = e3.originalUpdateTransform, this.containsPoint = e3.originalContainsPoint, this._mask = e3.originalMask, this.filterArea = e3.originalFilterArea));
  } } }), $_.prototype._renderCached = function(t3) {
    !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObject(t3), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._render(t3));
  }, $_.prototype._initCachedDisplayObject = function(t3) {
    var e3;
    if (!this._cacheData || !this._cacheData.sprite) {
      var n2 = this.alpha;
      this.alpha = 1, t3.batch.flush();
      var i2 = this.getLocalBounds(null, true).clone();
      if (this.filters) {
        var r3 = this.filters[0].padding;
        i2.pad(r3);
      }
      i2.ceil(mv.RESOLUTION);
      var o3 = t3.renderTexture.current, s3 = t3.renderTexture.sourceFrame.clone(), a2 = t3.renderTexture.destinationFrame.clone(), l2 = t3.projection.transform, u2 = Hy.create({ width: i2.width, height: i2.height, resolution: this.cacheAsBitmapResolution || t3.resolution, multisample: (e3 = this.cacheAsBitmapMultisample) !== null && e3 !== void 0 ? e3 : t3.multisample }), h2 = "cacheAsBitmap_" + qv();
      this._cacheData.textureCacheId = h2, wy.addToCache(u2.baseTexture, h2), ky.addToCache(u2, h2);
      var c2 = this.transform.localTransform.copyTo(DE).invert().translate(-i2.x, -i2.y);
      this.render = this._cacheData.originalRender, t3.render(this, { renderTexture: u2, clear: true, transform: c2, skipUpdateTransform: false }), t3.framebuffer.blit(), t3.projection.transform = l2, t3.renderTexture.bind(o3, s3, a2), this.render = this._renderCached, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = n2;
      var d2 = new Ow(u2);
      d2.transform.worldTransform = this.transform.worldTransform, d2.anchor.x = -i2.x / i2.width, d2.anchor.y = -i2.y / i2.height, d2.alpha = n2, d2._bounds = this._bounds, this._cacheData.sprite = d2, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.enableTempParent(), this.updateTransform(), this.disableTempParent(null)), this.containsPoint = d2.containsPoint.bind(d2);
    }
  }, $_.prototype._renderCachedCanvas = function(t3) {
    !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObjectCanvas(t3), this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._renderCanvas(t3));
  }, $_.prototype._initCachedDisplayObjectCanvas = function(t3) {
    if (!this._cacheData || !this._cacheData.sprite) {
      var e3 = this.getLocalBounds(null, true), n2 = this.alpha;
      this.alpha = 1;
      var i2 = t3.context, r3 = t3._projTransform;
      e3.ceil(mv.RESOLUTION);
      var o3 = Hy.create({ width: e3.width, height: e3.height }), s3 = "cacheAsBitmap_" + qv();
      this._cacheData.textureCacheId = s3, wy.addToCache(o3.baseTexture, s3), ky.addToCache(o3, s3);
      var a2 = DE;
      this.transform.localTransform.copyTo(a2), a2.invert(), a2.tx -= e3.x, a2.ty -= e3.y, this.renderCanvas = this._cacheData.originalRenderCanvas, t3.render(this, { renderTexture: o3, clear: true, transform: a2, skipUpdateTransform: false }), t3.context = i2, t3._projTransform = r3, this.renderCanvas = this._renderCachedCanvas, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = n2;
      var l2 = new Ow(o3);
      l2.transform.worldTransform = this.transform.worldTransform, l2.anchor.x = -e3.x / e3.width, l2.anchor.y = -e3.y / e3.height, l2.alpha = n2, l2._bounds = this._bounds, this._cacheData.sprite = l2, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.parent = t3._tempDisplayObjectParent, this.updateTransform(), this.parent = null), this.containsPoint = l2.containsPoint.bind(l2);
    }
  }, $_.prototype._calculateCachedBounds = function() {
    this._bounds.clear(), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite._calculateBounds(), this._bounds.updateID = this._boundsID;
  }, $_.prototype._getCachedLocalBounds = function() {
    return this._cacheData.sprite.getLocalBounds(null);
  }, $_.prototype._destroyCachedDisplayObject = function() {
    this._cacheData.sprite._texture.destroy(true), this._cacheData.sprite = null, wy.removeFromCache(this._cacheData.textureCacheId), ky.removeFromCache(this._cacheData.textureCacheId), this._cacheData.textureCacheId = null;
  }, $_.prototype._cacheAsBitmapDestroy = function(t3) {
    this.cacheAsBitmap = false, this.destroy(t3);
  }, $_.prototype.name = null, ty.prototype.getChildByName = function(t3, e3) {
    for (var n2 = 0, i2 = this.children.length; n2 < i2; n2++)
      if (this.children[n2].name === t3)
        return this.children[n2];
    if (e3)
      for (n2 = 0, i2 = this.children.length; n2 < i2; n2++) {
        if (this.children[n2].getChildByName) {
          var r3 = this.children[n2].getChildByName(t3, true);
          if (r3)
            return r3;
        }
      }
    return null;
  }, $_.prototype.getGlobalPosition = function(t3, e3) {
    return t3 === void 0 && (t3 = new v_()), e3 === void 0 && (e3 = false), this.parent ? this.parent.toGlobal(this.position, t3, e3) : (t3.x = this.position.x, t3.y = this.position.y), t3;
  };
  /*!
   * @pixi/mesh-extras - v6.2.0
   * Compiled Mon, 01 Nov 2021 16:52:10 UTC
   *
   * @pixi/mesh-extras is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   */
  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */
  var BE = function(t3, e3) {
    return (BE = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e4) {
      t4.__proto__ = e4;
    } || function(t4, e4) {
      for (var n2 in e4)
        e4.hasOwnProperty(n2) && (t4[n2] = e4[n2]);
    })(t3, e3);
  };
  function UE(t3, e3) {
    function n2() {
      this.constructor = t3;
    }
    BE(t3, e3), t3.prototype = e3 === null ? Object.create(e3) : (n2.prototype = e3.prototype, new n2());
  }
  var kE = function(t3) {
    function e3(e4, n2, i2, r3) {
      e4 === void 0 && (e4 = 100), n2 === void 0 && (n2 = 100), i2 === void 0 && (i2 = 10), r3 === void 0 && (r3 = 10);
      var o3 = t3.call(this) || this;
      return o3.segWidth = i2, o3.segHeight = r3, o3.width = e4, o3.height = n2, o3.build(), o3;
    }
    return UE(e3, t3), e3.prototype.build = function() {
      for (var t4 = this.segWidth * this.segHeight, e4 = [], n2 = [], i2 = [], r3 = this.segWidth - 1, o3 = this.segHeight - 1, s3 = this.width / r3, a2 = this.height / o3, l2 = 0; l2 < t4; l2++) {
        var u2 = l2 % this.segWidth, h2 = l2 / this.segWidth | 0;
        e4.push(u2 * s3, h2 * a2), n2.push(u2 / r3, h2 / o3);
      }
      var c2 = r3 * o3;
      for (l2 = 0; l2 < c2; l2++) {
        var d2 = l2 % r3, p2 = l2 / r3 | 0, f2 = p2 * this.segWidth + d2, m2 = p2 * this.segWidth + d2 + 1, g2 = (p2 + 1) * this.segWidth + d2, v2 = (p2 + 1) * this.segWidth + d2 + 1;
        i2.push(f2, m2, g2, m2, v2, g2);
      }
      this.buffers[0].data = new Float32Array(e4), this.buffers[1].data = new Float32Array(n2), this.indexBuffer.data = new Uint16Array(i2), this.buffers[0].update(), this.buffers[1].update(), this.indexBuffer.update();
    }, e3;
  }(yS), GE = function(t3) {
    function e3(e4, n2, i2) {
      e4 === void 0 && (e4 = 200), i2 === void 0 && (i2 = 0);
      var r3 = t3.call(this, new Float32Array(4 * n2.length), new Float32Array(4 * n2.length), new Uint16Array(6 * (n2.length - 1))) || this;
      return r3.points = n2, r3._width = e4, r3.textureScale = i2, r3.build(), r3;
    }
    return UE(e3, t3), Object.defineProperty(e3.prototype, "width", { get: function() {
      return this._width;
    }, enumerable: false, configurable: true }), e3.prototype.build = function() {
      var t4 = this.points;
      if (t4) {
        var e4 = this.getBuffer("aVertexPosition"), n2 = this.getBuffer("aTextureCoord"), i2 = this.getIndex();
        if (!(t4.length < 1)) {
          e4.data.length / 4 !== t4.length && (e4.data = new Float32Array(4 * t4.length), n2.data = new Float32Array(4 * t4.length), i2.data = new Uint16Array(6 * (t4.length - 1)));
          var r3 = n2.data, o3 = i2.data;
          r3[0] = 0, r3[1] = 0, r3[2] = 0, r3[3] = 1;
          for (var s3 = 0, a2 = t4[0], l2 = this._width * this.textureScale, u2 = t4.length, h2 = 0; h2 < u2; h2++) {
            var c2 = 4 * h2;
            if (this.textureScale > 0) {
              var d2 = a2.x - t4[h2].x, p2 = a2.y - t4[h2].y, f2 = Math.sqrt(d2 * d2 + p2 * p2);
              a2 = t4[h2], s3 += f2 / l2;
            } else
              s3 = h2 / (u2 - 1);
            r3[c2] = s3, r3[c2 + 1] = 0, r3[c2 + 2] = s3, r3[c2 + 3] = 1;
          }
          var m2 = 0;
          for (h2 = 0; h2 < u2 - 1; h2++) {
            c2 = 2 * h2;
            o3[m2++] = c2, o3[m2++] = c2 + 1, o3[m2++] = c2 + 2, o3[m2++] = c2 + 2, o3[m2++] = c2 + 1, o3[m2++] = c2 + 3;
          }
          n2.update(), i2.update(), this.updateVertices();
        }
      }
    }, e3.prototype.updateVertices = function() {
      var t4 = this.points;
      if (!(t4.length < 1)) {
        for (var e4, n2 = t4[0], i2 = 0, r3 = 0, o3 = this.buffers[0].data, s3 = t4.length, a2 = 0; a2 < s3; a2++) {
          var l2 = t4[a2], u2 = 4 * a2;
          r3 = -((e4 = a2 < t4.length - 1 ? t4[a2 + 1] : l2).x - n2.x), i2 = e4.y - n2.y;
          var h2 = Math.sqrt(i2 * i2 + r3 * r3), c2 = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;
          i2 /= h2, r3 /= h2, i2 *= c2, r3 *= c2, o3[u2] = l2.x + i2, o3[u2 + 1] = l2.y + r3, o3[u2 + 2] = l2.x - i2, o3[u2 + 3] = l2.y - r3, n2 = l2;
        }
        this.buffers[0].update();
      }
    }, e3.prototype.update = function() {
      this.textureScale > 0 ? this.build() : this.updateVertices();
    }, e3;
  }(yS), HE = (function(t3) {
    function e3(e4, n2, i2) {
      i2 === void 0 && (i2 = 0);
      var r3 = this, o3 = new GE(e4.height, n2, i2), s3 = new _S(e4);
      return i2 > 0 && (e4.baseTexture.wrapMode = sv.REPEAT), (r3 = t3.call(this, o3, s3) || this).autoUpdate = true, r3;
    }
    UE(e3, t3), e3.prototype._render = function(e4) {
      var n2 = this.geometry;
      (this.autoUpdate || n2._width !== this.shader.texture.height) && (n2._width = this.shader.texture.height, n2.update()), t3.prototype._render.call(this, e4);
    };
  }(vS), function(t3) {
    function e3(e4, n2, i2) {
      var r3 = this, o3 = new kE(e4.width, e4.height, n2, i2), s3 = new _S(ky.WHITE);
      return (r3 = t3.call(this, o3, s3) || this).texture = e4, r3.autoResize = true, r3;
    }
    return UE(e3, t3), e3.prototype.textureUpdated = function() {
      this._textureID = this.shader.texture._updateID;
      var t4 = this.geometry, e4 = this.shader.texture, n2 = e4.width, i2 = e4.height;
      !this.autoResize || t4.width === n2 && t4.height === i2 || (t4.width = this.shader.texture.width, t4.height = this.shader.texture.height, t4.build());
    }, Object.defineProperty(e3.prototype, "texture", { get: function() {
      return this.shader.texture;
    }, set: function(t4) {
      this.shader.texture !== t4 && (this.shader.texture = t4, this._textureID = -1, t4.baseTexture.valid ? this.textureUpdated() : t4.once("update", this.textureUpdated, this));
    }, enumerable: false, configurable: true }), e3.prototype._render = function(e4) {
      this._textureID !== this.shader.texture._updateID && this.textureUpdated(), t3.prototype._render.call(this, e4);
    }, e3.prototype.destroy = function(e4) {
      this.shader.texture.off("update", this.textureUpdated, this), t3.prototype.destroy.call(this, e4);
    }, e3;
  }(vS)), zE = (function(t3) {
    function e3(e4, n2, i2, r3, o3) {
      e4 === void 0 && (e4 = ky.EMPTY);
      var s3 = this, a2 = new yS(n2, i2, r3);
      a2.getBuffer("aVertexPosition").static = false;
      var l2 = new _S(e4);
      return (s3 = t3.call(this, a2, l2, null, o3) || this).autoUpdate = true, s3;
    }
    UE(e3, t3), Object.defineProperty(e3.prototype, "vertices", { get: function() {
      return this.geometry.getBuffer("aVertexPosition").data;
    }, set: function(t4) {
      this.geometry.getBuffer("aVertexPosition").data = t4;
    }, enumerable: false, configurable: true }), e3.prototype._render = function(e4) {
      this.autoUpdate && this.geometry.getBuffer("aVertexPosition").update(), t3.prototype._render.call(this, e4);
    };
  }(vS), function(t3) {
    function e3(e4, n2, i2, r3, o3) {
      n2 === void 0 && (n2 = 10), i2 === void 0 && (i2 = 10), r3 === void 0 && (r3 = 10), o3 === void 0 && (o3 = 10);
      var s3 = t3.call(this, ky.WHITE, 4, 4) || this;
      return s3._origWidth = e4.orig.width, s3._origHeight = e4.orig.height, s3._width = s3._origWidth, s3._height = s3._origHeight, s3._leftWidth = n2, s3._rightWidth = r3, s3._topHeight = i2, s3._bottomHeight = o3, s3.texture = e4, s3;
    }
    UE(e3, t3), e3.prototype.textureUpdated = function() {
      this._textureID = this.shader.texture._updateID, this._refresh();
    }, Object.defineProperty(e3.prototype, "vertices", { get: function() {
      return this.geometry.getBuffer("aVertexPosition").data;
    }, set: function(t4) {
      this.geometry.getBuffer("aVertexPosition").data = t4;
    }, enumerable: false, configurable: true }), e3.prototype.updateHorizontalVertices = function() {
      var t4 = this.vertices, e4 = this._getMinScale();
      t4[9] = t4[11] = t4[13] = t4[15] = this._topHeight * e4, t4[17] = t4[19] = t4[21] = t4[23] = this._height - this._bottomHeight * e4, t4[25] = t4[27] = t4[29] = t4[31] = this._height;
    }, e3.prototype.updateVerticalVertices = function() {
      var t4 = this.vertices, e4 = this._getMinScale();
      t4[2] = t4[10] = t4[18] = t4[26] = this._leftWidth * e4, t4[4] = t4[12] = t4[20] = t4[28] = this._width - this._rightWidth * e4, t4[6] = t4[14] = t4[22] = t4[30] = this._width;
    }, e3.prototype._getMinScale = function() {
      var t4 = this._leftWidth + this._rightWidth, e4 = this._width > t4 ? 1 : this._width / t4, n2 = this._topHeight + this._bottomHeight, i2 = this._height > n2 ? 1 : this._height / n2;
      return Math.min(e4, i2);
    }, Object.defineProperty(e3.prototype, "width", { get: function() {
      return this._width;
    }, set: function(t4) {
      this._width = t4, this._refresh();
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "height", { get: function() {
      return this._height;
    }, set: function(t4) {
      this._height = t4, this._refresh();
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "leftWidth", { get: function() {
      return this._leftWidth;
    }, set: function(t4) {
      this._leftWidth = t4, this._refresh();
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "rightWidth", { get: function() {
      return this._rightWidth;
    }, set: function(t4) {
      this._rightWidth = t4, this._refresh();
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "topHeight", { get: function() {
      return this._topHeight;
    }, set: function(t4) {
      this._topHeight = t4, this._refresh();
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "bottomHeight", { get: function() {
      return this._bottomHeight;
    }, set: function(t4) {
      this._bottomHeight = t4, this._refresh();
    }, enumerable: false, configurable: true }), e3.prototype._refresh = function() {
      var t4 = this.texture, e4 = this.geometry.buffers[1].data;
      this._origWidth = t4.orig.width, this._origHeight = t4.orig.height;
      var n2 = 1 / this._origWidth, i2 = 1 / this._origHeight;
      e4[0] = e4[8] = e4[16] = e4[24] = 0, e4[1] = e4[3] = e4[5] = e4[7] = 0, e4[6] = e4[14] = e4[22] = e4[30] = 1, e4[25] = e4[27] = e4[29] = e4[31] = 1, e4[2] = e4[10] = e4[18] = e4[26] = n2 * this._leftWidth, e4[4] = e4[12] = e4[20] = e4[28] = 1 - n2 * this._rightWidth, e4[9] = e4[11] = e4[13] = e4[15] = i2 * this._topHeight, e4[17] = e4[19] = e4[21] = e4[23] = 1 - i2 * this._bottomHeight, this.updateHorizontalVertices(), this.updateVerticalVertices(), this.geometry.buffers[0].update(), this.geometry.buffers[1].update();
    };
  }(HE), function(t3, e3) {
    return (zE = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e4) {
      t4.__proto__ = e4;
    } || function(t4, e4) {
      for (var n2 in e4)
        e4.hasOwnProperty(n2) && (t4[n2] = e4[n2]);
    })(t3, e3);
  });
  var jE = function(t3) {
    function e3(e4, n2) {
      n2 === void 0 && (n2 = true);
      var i2 = t3.call(this, e4[0] instanceof ky ? e4[0] : e4[0].texture) || this;
      return i2._textures = null, i2._durations = null, i2._autoUpdate = n2, i2._isConnectedToTicker = false, i2.animationSpeed = 1, i2.loop = true, i2.updateAnchor = false, i2.onComplete = null, i2.onFrameChange = null, i2.onLoop = null, i2._currentTime = 0, i2._playing = false, i2._previousFrame = null, i2.textures = e4, i2;
    }
    return function(t4, e4) {
      function n2() {
        this.constructor = t4;
      }
      zE(t4, e4), t4.prototype = e4 === null ? Object.create(e4) : (n2.prototype = e4.prototype, new n2());
    }(e3, t3), e3.prototype.stop = function() {
      this._playing && (this._playing = false, this._autoUpdate && this._isConnectedToTicker && (ry.shared.remove(this.update, this), this._isConnectedToTicker = false));
    }, e3.prototype.play = function() {
      this._playing || (this._playing = true, this._autoUpdate && !this._isConnectedToTicker && (ry.shared.add(this.update, this, ey.HIGH), this._isConnectedToTicker = true));
    }, e3.prototype.gotoAndStop = function(t4) {
      this.stop();
      var e4 = this.currentFrame;
      this._currentTime = t4, e4 !== this.currentFrame && this.updateTexture();
    }, e3.prototype.gotoAndPlay = function(t4) {
      var e4 = this.currentFrame;
      this._currentTime = t4, e4 !== this.currentFrame && this.updateTexture(), this.play();
    }, e3.prototype.update = function(t4) {
      if (this._playing) {
        var e4 = this.animationSpeed * t4, n2 = this.currentFrame;
        if (this._durations !== null) {
          var i2 = this._currentTime % 1 * this._durations[this.currentFrame];
          for (i2 += e4 / 60 * 1e3; i2 < 0; )
            this._currentTime--, i2 += this._durations[this.currentFrame];
          var r3 = Math.sign(this.animationSpeed * t4);
          for (this._currentTime = Math.floor(this._currentTime); i2 >= this._durations[this.currentFrame]; )
            i2 -= this._durations[this.currentFrame] * r3, this._currentTime += r3;
          this._currentTime += i2 / this._durations[this.currentFrame];
        } else
          this._currentTime += e4;
        this._currentTime < 0 && !this.loop ? (this.gotoAndStop(0), this.onComplete && this.onComplete()) : this._currentTime >= this._textures.length && !this.loop ? (this.gotoAndStop(this._textures.length - 1), this.onComplete && this.onComplete()) : n2 !== this.currentFrame && (this.loop && this.onLoop && (this.animationSpeed > 0 && this.currentFrame < n2 || this.animationSpeed < 0 && this.currentFrame > n2) && this.onLoop(), this.updateTexture());
      }
    }, e3.prototype.updateTexture = function() {
      var t4 = this.currentFrame;
      this._previousFrame !== t4 && (this._previousFrame = t4, this._texture = this._textures[t4], this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this.uvs = this._texture._uvs.uvsFloat32, this.updateAnchor && this._anchor.copyFrom(this._texture.defaultAnchor), this.onFrameChange && this.onFrameChange(this.currentFrame));
    }, e3.prototype.destroy = function(e4) {
      this.stop(), t3.prototype.destroy.call(this, e4), this.onComplete = null, this.onFrameChange = null, this.onLoop = null;
    }, e3.fromFrames = function(t4) {
      for (var n2 = [], i2 = 0; i2 < t4.length; ++i2)
        n2.push(ky.from(t4[i2]));
      return new e3(n2);
    }, e3.fromImages = function(t4) {
      for (var n2 = [], i2 = 0; i2 < t4.length; ++i2)
        n2.push(ky.from(t4[i2]));
      return new e3(n2);
    }, Object.defineProperty(e3.prototype, "totalFrames", { get: function() {
      return this._textures.length;
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "textures", { get: function() {
      return this._textures;
    }, set: function(t4) {
      if (t4[0] instanceof ky)
        this._textures = t4, this._durations = null;
      else {
        this._textures = [], this._durations = [];
        for (var e4 = 0; e4 < t4.length; e4++)
          this._textures.push(t4[e4].texture), this._durations.push(t4[e4].time);
      }
      this._previousFrame = null, this.gotoAndStop(0), this.updateTexture();
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "currentFrame", { get: function() {
      var t4 = Math.floor(this._currentTime) % this._textures.length;
      return t4 < 0 && (t4 += this._textures.length), t4;
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "playing", { get: function() {
      return this._playing;
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "autoUpdate", { get: function() {
      return this._autoUpdate;
    }, set: function(t4) {
      t4 !== this._autoUpdate && (this._autoUpdate = t4, !this._autoUpdate && this._isConnectedToTicker ? (ry.shared.remove(this.update, this), this._isConnectedToTicker = false) : this._autoUpdate && !this._isConnectedToTicker && this._playing && (ry.shared.add(this.update, this), this._isConnectedToTicker = true));
    }, enumerable: false, configurable: true }), e3;
  }(Ow);
  /*!
   * pixi.js - v6.2.0
   * Compiled Mon, 01 Nov 2021 16:52:10 UTC
   *
   * pixi.js is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   */
  vb.registerPlugin("accessibility", ny), vb.registerPlugin("extract", Fb), vb.registerPlugin("interaction", py), vb.registerPlugin("particle", $T), vb.registerPlugin("prepare", iS), vb.registerPlugin("batch", Ab), vb.registerPlugin("tilingSprite", cS), Kb.registerPlugin(NS), Kb.registerPlugin(cT), Kb.registerPlugin(PT), Kb.registerPlugin(WT), Kb.registerPlugin(oS), Lb.registerPlugin(oy), Lb.registerPlugin(Qb);
  var VE = { AlphaFilter: FS, BlurFilter: aE, BlurFilterPass: sE, ColorMatrixFilter: uE, DisplacementFilter: cE, FXAAFilter: pE, NoiseFilter: NE }, WE = n(2), XE = n.n(WE);
  class qE extends a.a {
    constructor() {
      super(), this.prevTime = -1, this.times = 0, this.valueTotal = 0, this.destroyed = false, this.value = 0, this.calcFps();
    }
    calcFps() {
      requestAnimationFrame((t3) => {
        const e3 = t3 - this.prevTime;
        this.valueTotal += e3, this.times += 1, this.times > 20 && (this.value = Math.floor(800 * this.times / this.valueTotal), this.valueTotal = 0, this.times = 0, this.destroyed || this.emit("update", this.value)), this.prevTime = t3, this.destroyed || this.calcFps();
      });
    }
    destroy() {
      this.destroyed = true;
    }
  }
  var YE = function(t3, e3, n2, i2) {
    return new (n2 || (n2 = Promise))(function(r3, o3) {
      function s3(t4) {
        try {
          l2(i2.next(t4));
        } catch (t5) {
          o3(t5);
        }
      }
      function a2(t4) {
        try {
          l2(i2.throw(t4));
        } catch (t5) {
          o3(t5);
        }
      }
      function l2(t4) {
        var e4;
        t4.done ? r3(t4.value) : (e4 = t4.value, e4 instanceof n2 ? e4 : new n2(function(t5) {
          t5(e4);
        })).then(s3, a2);
      }
      l2((i2 = i2.apply(t3, e3 || [])).next());
    });
  };
  const ZE = new class {
    constructor() {
      this.life = 144e5, this.cache = XE.a.createInstance({ name: "_slide_cache_life_", storeName: "_slide_cache_life_", driver: XE.a.INDEXEDDB, version: 1 }), this.clear().catch(() => {
      });
    }
    clear() {
      return YE(this, void 0, void 0, function* () {
        const t3 = yield this.cache.keys();
        for (const e3 of t3) {
          const t4 = (yield this.cache.getItem(e3)) || 0;
          if (Date.now() - t4 > this.life) {
            const [t5, n2] = e3.split("@");
            yield XE.a.createInstance({ name: t5, storeName: n2, driver: XE.a.INDEXEDDB, version: 1 }).dropInstance().then(() => {
              this.cache.removeItem(e3).catch(() => {
              });
            }).catch(() => {
            });
          }
        }
      });
    }
    updateActiveTime(t3, e3) {
      return this.cache.setItem(`${t3}@${e3}`, Date.now());
    }
    dispose() {
      return YE(this, void 0, void 0, function* () {
        const t3 = yield this.cache.keys();
        for (const e3 of t3) {
          const [t4, n2] = e3.split("@");
          yield XE.a.createInstance({ name: t4, storeName: n2, driver: XE.a.INDEXEDDB, version: 1 }).dropInstance().then(() => {
            this.cache.removeItem(e3).catch(() => {
            });
          }).catch(() => {
          });
        }
      });
    }
  }();
  var JE = function(t3, e3, n2, i2) {
    return new (n2 || (n2 = Promise))(function(r3, o3) {
      function s3(t4) {
        try {
          l2(i2.next(t4));
        } catch (t5) {
          o3(t5);
        }
      }
      function a2(t4) {
        try {
          l2(i2.throw(t4));
        } catch (t5) {
          o3(t5);
        }
      }
      function l2(t4) {
        var e4;
        t4.done ? r3(t4.value) : (e4 = t4.value, e4 instanceof n2 ? e4 : new n2(function(t5) {
          t5(e4);
        })).then(s3, a2);
      }
      l2((i2 = i2.apply(t3, e3 || [])).next());
    });
  };
  class $E {
    constructor(t3) {
      this.useCache = false, this.useCache = t3;
    }
    bindTask(t3) {
      if (this.taskId = t3, this.useCache) {
        const t4 = "_slide_local_cache_", e3 = this.taskId;
        this.cache = WE.createInstance({ name: t4, storeName: e3, driver: WE.INDEXEDDB, version: 1 }), ZE.updateActiveTime(t4, e3).catch(() => {
        });
      }
    }
    fetchJson(t3) {
      var e3, n2;
      return JE(this, void 0, void 0, function* () {
        let i2 = yield (e3 = this.cache) === null || e3 === void 0 ? void 0 : e3.getItem(t3);
        return i2 && this.useCache || (i2 = yield (yield fetch(t3)).json(), this.useCache && (yield (n2 = this.cache) === null || n2 === void 0 ? void 0 : n2.setItem(t3, i2))), i2;
      });
    }
    fetchPng(t3) {
      var e3, n2;
      return JE(this, void 0, void 0, function* () {
        let i2 = yield (e3 = this.cache) === null || e3 === void 0 ? void 0 : e3.getItem(t3);
        if (i2 && this.useCache)
          return i2;
        if (i2 = yield fetch(t3).then((t4) => t4.blob()).then((e4) => new Promise((n3, i3) => {
          const r3 = new FileReader();
          r3.onload = () => {
            n3(r3.result);
          }, r3.onerror = () => {
            i3(new Error(`fetch ${t3} failed`));
          }, r3.readAsDataURL(e4);
        })), this.useCache && (yield (n2 = this.cache) === null || n2 === void 0 ? void 0 : n2.setItem(t3, i2)), !i2)
          throw new Error(`fetch ${t3} failed`);
        return i2;
      });
    }
    destroy() {
    }
  }
  var KE = n(7), QE = n.n(KE);
  function tM(t3, e3, n2 = 5) {
    return Math.abs(t3 - e3) <= Math.pow(10, -n2);
  }
  function eM(t3) {
    return Math.floor(1e6 * t3) / 1e6;
  }
  class nM {
    constructor() {
      this.point = { x: 0, y: 0 }, this.slope = Math.PI / 4;
    }
    static fromPointSlope(t3, e3) {
      const n2 = new nM();
      return n2.point = t3, n2.slope = e3, n2;
    }
    resolveY(t3) {
      return Math.tan(this.slope) * (t3 - this.point.x) + this.point.y;
    }
    distanceToLinearEquation(t3) {
      return tM(this.slope, t3.slope) ? this.distanceToPoint(t3.point) : -1;
    }
    distanceToPoint(t3) {
      let e3 = 0;
      if (Math.tan(this.slope) * (t3.x - this.point.x) + this.point.y === t3.y)
        return 0;
      e3 = this.slope >= Math.PI / 2 ? this.slope - Math.PI / 2 : Math.PI / 2 + this.slope;
      const n2 = nM.fromPointSlope(t3, e3), i2 = this.crossPoint(n2);
      return i2 ? Math.ceil(Math.sqrt(Math.pow(i2.x - t3.x, 2) + Math.pow(i2.y - t3.y, 2))) : 0;
    }
    crossPoint(t3) {
      if (tM(t3.slope, this.slope))
        return null;
      let e3 = 0, n2 = 0;
      const i2 = Math.tan(t3.slope), r3 = Math.tan(this.slope), { x: o3, y: s3 } = this.point, { x: a2, y: l2 } = t3.point;
      return tM(this.slope, Math.PI / 2) ? (e3 = this.point.x, n2 = i2 * (e3 - a2) + l2) : tM(t3.slope, Math.PI / 2) ? (e3 = t3.point.x, n2 = r3 * (e3 - o3) + s3) : tM(this.slope, Math.PI) || tM(this.slope, 0) ? (n2 = this.point.y, e3 = (n2 - l2) / i2 + a2) : tM(t3.slope, Math.PI) || tM(t3.slope, 0) ? (n2 = t3.point.y, e3 = (n2 - s3) / r3 + o3) : (e3 = (i2 * a2 - l2 + s3 - r3 * o3) / (i2 - r3), n2 = r3 * (e3 - o3) + s3), { x: e3, y: n2 };
    }
  }
  function iM() {
    return Date.now().toString(32) + Math.random().toString(32).substring(2);
  }
  function rM(t3) {
    const e3 = [], n2 = t3.filter((t4) => {
      const n3 = t4.width < 2048 && t4.height < 2048;
      return n3 || e3.push(t4), n3;
    }).sort((t4, e4) => t4.width * t4.height - e4.width * e4.height);
    let i2 = n2.length + 1, r3 = 2050, o3 = 2050;
    const s3 = [];
    let a2 = null;
    for (; (r3 > 2048 || o3 > 2048) && n2.length > 0; )
      i2 -= 1, a2 = QE()(n2.slice(0, i2)), r3 = a2.width, o3 = a2.height;
    return a2 && s3.push(a2), e3.forEach((t4) => {
      const e4 = QE()([t4]);
      s3.push(e4);
    }), i2 < n2.length ? s3.concat(rM(n2.slice(i2))) : s3;
  }
  var oM = function(t3, e3, n2, i2) {
    return new (n2 || (n2 = Promise))(function(r3, o3) {
      function s3(t4) {
        try {
          l2(i2.next(t4));
        } catch (t5) {
          o3(t5);
        }
      }
      function a2(t4) {
        try {
          l2(i2.throw(t4));
        } catch (t5) {
          o3(t5);
        }
      }
      function l2(t4) {
        var e4;
        t4.done ? r3(t4.value) : (e4 = t4.value, e4 instanceof n2 ? e4 : new n2(function(t5) {
          t5(e4);
        })).then(s3, a2);
      }
      l2((i2 = i2.apply(t3, e3 || [])).next());
    });
  };
  class sM {
    constructor(t3) {
      this.isPaused = false, this.timestamp = 0, this.callbackList = [], this.onTimeUpdate = (t4) => {
        const e3 = t4 / (mv.TARGET_FPMS || 0.06);
        if (!this.isPaused) {
          this.timestamp += e3, this.callbackList = this.callbackList.filter((t6) => t6 && !t6.applied);
          let { length: t5 } = this.callbackList;
          for (let e4 = 0; e4 < t5; e4++) {
            const n2 = this.callbackList[e4];
            if (n2 && !n2.applied) {
              if (!(n2.triggerTime <= this.timestamp))
                break;
              n2.fn(), n2.applied = true, t5 = this.callbackList.length;
            }
          }
        }
      }, this.ticker = t3, this.ticker.add(this.onTimeUpdate);
    }
    setTimeout(t3, e3) {
      const n2 = iM(), i2 = this.timestamp + Math.max(e3 || 16, 16);
      return this.callbackList.push({ fn: t3, triggerTime: i2, id: n2, applied: false }), this.callbackList.sort((t4, e4) => t4.triggerTime - e4.triggerTime), n2;
    }
    clearTimeout(t3) {
      const e3 = this.callbackList.findIndex((e4) => e4.id === t3);
      e3 >= 0 && this.callbackList.splice(e3, 1);
    }
    delay(t3) {
      return new Promise((e3) => {
        this.setTimeout(e3, t3);
      });
    }
    waitUntil(t3, e3) {
      return oM(this, void 0, void 0, function* () {
        const n2 = this.timestamp;
        for (; !t3() && this.timestamp - n2 < e3; )
          yield this.delay(50);
      });
    }
    pause() {
      this.isPaused = true;
    }
    resume() {
      this.isPaused = false;
    }
  }
  var aM = function(t3, e3, n2, i2) {
    return new (n2 || (n2 = Promise))(function(r3, o3) {
      function s3(t4) {
        try {
          l2(i2.next(t4));
        } catch (t5) {
          o3(t5);
        }
      }
      function a2(t4) {
        try {
          l2(i2.throw(t4));
        } catch (t5) {
          o3(t5);
        }
      }
      function l2(t4) {
        var e4;
        t4.done ? r3(t4.value) : (e4 = t4.value, e4 instanceof n2 ? e4 : new n2(function(t5) {
          t5(e4);
        })).then(s3, a2);
      }
      l2((i2 = i2.apply(t3, e3 || [])).next());
    });
  };
  class lM {
    constructor(t3) {
      this.gifs = Object.create(null), this.textures = Object.create(null), this.frames = Object.create(null), this.spriteSheets = [], this.loader = t3;
    }
    getTexture(t3) {
      return this.textures[t3] || null;
    }
    getFrameData(t3) {
      return this.frames[t3];
    }
    getGifFrames(t3) {
      return this.gifs[t3] ? this.gifs[t3].filter((t4) => !!t4) : [];
    }
    loadSpriteSheetItem(t3, e3, n2) {
      return aM(this, void 0, void 0, function* () {
        const i2 = yield this.loader.fetchJson(`${t3}/${e3}/jsonOutput/${n2}.json`), r3 = yield this.loader.fetchPng(`${t3}/${e3}/jsonOutput/${n2}.png`), o3 = document.createElement("img");
        o3.src = r3, yield new Promise((t4, e4) => {
          o3.onload = () => t4(""), o3.onerror = () => e4();
        });
        const s3 = new wy(o3), a2 = new rS(s3, i2);
        KR.textureCacheSize += s3.width * s3.height, yield new Promise((t4) => {
          a2.parse(() => t4(""));
        }), this.spriteSheets.push(a2), Object.keys(a2.textures).forEach((t4) => {
          const e4 = t4.match(/^(.+)_gif_(\d+)$/);
          if (e4 && e4[1] && e4[2]) {
            const n3 = e4[1];
            this.gifs[n3] || (this.gifs[n3] = []);
            const i3 = parseInt(e4[2], 10);
            this.gifs[n3][i3] = a2.textures[t4];
          } else
            this.frames[t4] = i2.frames[t4], this.textures[t4] = a2.textures[t4];
        });
      });
    }
    destroy() {
      this.spriteSheets.forEach((t3) => t3.destroy(true)), this.spriteSheets = [], this.gifs = Object.create(null), this.textures = Object.create(null), this.frames = Object.create(null);
    }
  }
  var uM = n(3), hM = n.n(uM);
  function cM(t3, e3, n2) {
    let i2, r3;
    const o3 = t3 % 360;
    if (o3 % 180 == 0)
      i2 = Math.cos(o3 * (Math.PI / 180)) * e3, r3 = 0;
    else if (o3 % 90 == 0)
      i2 = 0, r3 = Math.sin(o3 * (Math.PI / 180)) * n2;
    else {
      const t4 = function(t5) {
        const e4 = t5 * Math.PI / 180;
        return Math.tan(e4);
      }(o3);
      i2 = e3 * n2 / Math.sqrt(Math.pow(n2, 2) + Math.pow(e3 * t4, 2)), (o3 > 90 && o3 < 270 || o3 < -90 && o3 > -270) && (i2 = -i2), r3 = t4 * i2;
    }
    return { x: i2, y: r3 };
  }
  function dM(t3, e3, n2, i2, r3, o3) {
    const s3 = t3, a2 = e3;
    let l2, u2, h2, c2, d2;
    if (i2 === 0)
      l2 = r3, u2 = o3, d2 = 0;
    else if (i2 >= 360)
      l2 = r3, u2 = o3, h2 = r3 + 2 * t3 * Math.abs(Math.cos(-n2 / 180 * Math.PI)), c2 = o3 + 2 * e3 * Math.sin(-n2 / 180 * Math.PI), d2 = 1;
    else {
      const t4 = -n2, e4 = -(n2 + i2), { x: h3, y: c3 } = cM(t4, s3, a2), p2 = r3 - h3, f2 = o3 + c3, { x: m2, y: g2 } = cM(e4, s3, a2);
      l2 = m2 + p2, u2 = f2 - g2, d2 = i2 >= -360 && i2 < -180 ? 1 : i2 >= -180 && i2 < 0 || i2 > 0 && i2 < 180 ? 0 : 1;
    }
    return { radiusX: s3, radiusY: a2, xAxisRotation: 0, largeArcFlag: d2, sweepFlag: i2 > 0 ? 1 : 0, endX: l2, endY: u2, middleX: h2, middleY: c2 };
  }
  class pM {
    constructor() {
      this.pool = [];
    }
    getObject(t3) {
      const e3 = this.pool.find((t4) => !t4.isUsed);
      if (e3)
        return e3.isUsed = true, e3.obj;
      {
        const e4 = { obj: this.createObject(), isUsed: true, group: t3 };
        return this.pool.push(e4), e4.obj;
      }
    }
    collectObject(t3) {
      const e3 = this.pool.find((e4) => e4.obj === t3);
      e3 && (e3.isUsed = false, this.resetObject(e3.obj));
    }
    collectObjectByGroup(t3) {
      this.pool.filter((e3) => e3.group === t3).forEach((t4) => this.collectObject(t4.obj));
    }
  }
  const fM = new class extends pM {
    createObject() {
      const t3 = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      return t3.setAttribute("xmlns", "http://www.w3.org/2000/svg"), t3.setAttribute("version", "1.1"), t3;
    }
    resetObject(t3) {
      t3.removeAttribute("viewBox"), t3.removeAttribute("width"), t3.removeAttribute("height"), t3.innerHTML = "";
    }
  }();
  const mM = new class extends pM {
    createObject() {
      return document.createElement("img");
    }
    resetObject(t3) {
      t3.removeAttribute("src");
    }
  }();
  var gM = function(t3, e3, n2, i2) {
    return new (n2 || (n2 = Promise))(function(r3, o3) {
      function s3(t4) {
        try {
          l2(i2.next(t4));
        } catch (t5) {
          o3(t5);
        }
      }
      function a2(t4) {
        try {
          l2(i2.throw(t4));
        } catch (t5) {
          o3(t5);
        }
      }
      function l2(t4) {
        var e4;
        t4.done ? r3(t4.value) : (e4 = t4.value, e4 instanceof n2 ? e4 : new n2(function(t5) {
          t5(e4);
        })).then(s3, a2);
      }
      l2((i2 = i2.apply(t3, e3 || [])).next());
    });
  };
  const vM = (t3) => new Promise((e3) => setTimeout(e3, t3));
  class _M extends a.a {
    constructor() {
      super(...arguments), this.isCancel = false, this.tasks = [];
    }
    addMTask(t3) {
      this.tasks.push({ fn: t3, state: "wait" });
    }
    addSubMTask(t3) {
      const e3 = Math.min(this.tasks.findIndex((t4) => t4.state === "running"), 0);
      this.tasks.splice(e3, 0, ...t3.map((t4) => ({ fn: t4, state: "wait" })));
    }
    cancel() {
      this.tasks = [], this.isCancel = true;
    }
    applyNext() {
      if (this.tasks.some((t4) => t4.state === "running"))
        return;
      if (this.tasks.every((t4) => t4.state === "finish"))
        return void (this.isCancel || this.emit("task-finish"));
      const t3 = this.tasks.find((t4) => t4.state === "wait");
      t3 && (t3.state = "running", t3.fn.apply(null).then(() => {
        t3.state = "finish";
      }).catch((t4) => {
        console.log(t4);
      }));
    }
    applyAll() {
      return gM(this, void 0, void 0, function* () {
        for (; !this.tasks.every((t3) => t3.state === "finish"); )
          if (this.tasks.some((t3) => t3.state === "running"))
            yield vM(16);
          else {
            const t3 = this.tasks.find((t4) => t4.state === "wait");
            t3 && (t3.state = "running", yield t3.fn.apply(null).then(() => {
              t3.state = "finish";
            }).catch((t4) => {
              console.log(t4);
            }));
          }
        this.isCancel || this.emit("task-finish");
      });
    }
  }
  var yM = function(t3, e3, n2, i2) {
    return new (n2 || (n2 = Promise))(function(r3, o3) {
      function s3(t4) {
        try {
          l2(i2.next(t4));
        } catch (t5) {
          o3(t5);
        }
      }
      function a2(t4) {
        try {
          l2(i2.throw(t4));
        } catch (t5) {
          o3(t5);
        }
      }
      function l2(t4) {
        var e4;
        t4.done ? r3(t4.value) : (e4 = t4.value, e4 instanceof n2 ? e4 : new n2(function(t5) {
          t5(e4);
        })).then(s3, a2);
      }
      l2((i2 = i2.apply(t3, e3 || [])).next());
    });
  };
  class xM {
    constructor(t3, e3, n2, i2, r3) {
      this.taskId = t3, this.slideIndex = e3, this.microTaskManager = n2, this.renderer = i2, this.cache = r3, this.imgElements = [], this.svgElements = [], this.idToHashMap = Object.create(null), this.textures = Object.create(null), this.graphics = [], this.hashToIdMap = Object.create(null);
    }
    setCacheLength(t3) {
      return this.cache ? this.cache.setItem(this.slideIndex + "-length", t3) : Promise.resolve(0);
    }
    render(t3, e3, n2) {
      return yM(this, void 0, void 0, function* () {
        const { items: i2, width: r3, height: o3 } = t3, s3 = mM.getObject(n2), a2 = new wy(s3, { width: r3, height: o3, resolution: 1 }), u2 = fM.getObject(n2);
        this.imgElements.push(s3), this.svgElements.push(u2), u2.setAttribute("viewBox", `0 0 ${r3} ${o3}`), u2.setAttribute("width", "" + r3), u2.setAttribute("height", "" + o3);
        const h2 = {}, c2 = {};
        i2.forEach((t4) => {
          const { item: e4, x: n3, y: i3 } = t4, r4 = n3 + 2, o4 = i3 + 2;
          e4.pathsData.forEach((t5) => {
            let e5 = "";
            t5.cmds.forEach(([n4, i4]) => {
              e5 += n4 + " ", e5 += i4.map((e6) => (Object(l.isNumber)(e6) || (e6.x = Math.round(e6.x + t5.offset.x + r4), e6.y = Math.round(e6.y + t5.offset.y + o4)), e6)).reduce((t6, e6) => (Object(l.isNumber)(e6) ? t6 += e6 + " " : t6 += `${e6.x} ${e6.y} `, t6), ""), e5 += " ";
            }), t5.pathElement.setAttribute("d", e5), u2.appendChild(t5.pathElement);
          });
          const s4 = e4.width - 4 - 2 * e4.padding, d3 = e4.height - 4 - 2 * e4.padding;
          this.textures[e4.hash] = { texture: new ky(a2, new d_(r4 + 2, o4 + 2, s4, d3)), pivot: e4.pivot }, h2[e4.hash] = { x: r4 + 2, y: o4 + 2, w: s4, h: d3, pivot: e4.pivot }, c2[e4.hash] = this.hashToIdMap[e4.hash];
        });
        const d2 = (p2 = '<?xml version="1.0" encoding="utf-8"?>' + u2.outerHTML, "data:image/svg+xml," + encodeURIComponent(p2).replace(/'/g, "%27").replace(/"/g, "%22"));
        var p2;
        if (s3.src = d2, yield new Promise((t4, e4) => {
          s3.onload = () => t4(""), s3.onerror = () => e4();
        }), KR.textureCacheSize += a2.width * a2.height, this.cache) {
          const t4 = new _M();
          t4.addMTask(() => yM(this, void 0, void 0, function* () {
            var t5, n3, i3;
            this.graphics.length > 0 && (yield (t5 = this.cache) === null || t5 === void 0 ? void 0 : t5.setItem(`${this.slideIndex}-texture-${e3}`, d2), yield (n3 = this.cache) === null || n3 === void 0 ? void 0 : n3.setItem(`${this.slideIndex}-json-${e3}`, h2), yield (i3 = this.cache) === null || i3 === void 0 ? void 0 : i3.setItem(`${this.slideIndex}-map-${e3}`, c2));
          })), this.microTaskManager.addTask(t4);
        }
      });
    }
    getGraphicsData(t3) {
      const e3 = this.idToHashMap[t3] || "";
      return this.textures[e3] || null;
    }
    addGraphics(t3, e3, n2, i2, r3, o3, s3, a2, l2) {
      var u2, h2;
      const c2 = hM()(n2 + ((h2 = (u2 = s3 == null ? void 0 : s3.width) === null || u2 === void 0 ? void 0 : u2.toString()) !== null && h2 !== void 0 ? h2 : 0) + l2);
      if (this.hashToIdMap[c2] || (this.hashToIdMap[c2] = []), this.hashToIdMap[c2].push(t3), this.idToHashMap[t3] = c2, this.graphics.findIndex((t4) => t4.hash === c2) < 0) {
        const { graphicsWidth: t4, graphicsHeight: n3, pathsData: a3, pivot: u3, padding: h3 } = function(t5, e4, n4, i3, r4, o4, s4 = true) {
          var a4;
          const l3 = [], u4 = { x: Math.abs(r4.x), y: Math.abs(r4.y) };
          let h4 = 0, c3 = 0, d2 = 0, p2 = 0, f2 = 0, m2 = "none", g2 = "none";
          const v2 = (a4 = i3 == null ? void 0 : i3.width) !== null && a4 !== void 0 ? a4 : 0;
          return s4 ? (h4 = e4, c3 = n4, f2 = 0, g2 = "#ff0000") : (m2 = "#ff0000", f2 = v2, d2 = 0.5 * v2, p2 = 0.5 * v2, h4 = e4 + v2, c3 = n4 + v2, u4.x += 0.5 * v2, u4.y += 0.5 * v2), h4 += Math.abs(r4.x), c3 += Math.abs(r4.y), d2 += Math.abs(r4.x), p2 += Math.abs(r4.y), h4 += 4, c3 += 4, d2 += 2, p2 += 2, h4 = Math.ceil(h4), c3 = Math.ceil(c3), t5.forEach((t6) => {
            const e5 = document.createElementNS("http://www.w3.org/2000/svg", "path");
            t6.fill !== "none" ? e5.setAttribute("fill", g2) : e5.setAttribute("fill", "none"), t6.hasStroke && (e5.setAttribute("stroke-linecap", (i3 == null ? void 0 : i3.cap) || "butt"), e5.setAttribute("stroke-linejoin", (i3 == null ? void 0 : i3.join) || "miter"), e5.setAttribute("stroke-width", f2.toString()), e5.setAttribute("stroke", m2), (i3 == null ? void 0 : i3.dash) && e5.setAttribute("stroke-dasharray", i3.dash));
            const { scale: n5 } = t6, r5 = t6.path.trim().split(" ");
            let o5 = { x: 0, y: 0 };
            const s5 = { offset: { x: d2, y: p2 }, cmds: [], pathElement: e5 };
            for (let t7 = 0; t7 < r5.length; t7 += 2) {
              const e6 = r5[t7], i4 = r5[t7 + 1];
              if (e6 === "M") {
                let [t8, e7] = i4.split(",").map((t9) => Number(t9));
                o5 = { x: t8, y: e7 }, t8 = t8 / 9525 * n5.x, e7 = e7 / 9525 * n5.y, s5.cmds.push(["M", [{ x: t8, y: e7 }]]);
              } else if (e6 === "A") {
                const [t8, e7, r6, a5] = i4.split(",").map((t9) => Number(t9)), l4 = Math.round(r6 / Math.PI * 180), u5 = Math.round(a5 / Math.PI * 180), h5 = dM(t8, e7, l4, u5, o5.x, o5.y);
                u5 >= 360 ? (o5 = { x: h5.endX, y: h5.endY }, s5.cmds.push(["A", [h5.radiusX / 9525 * n5.x, h5.radiusY / 9525 * n5.y, h5.xAxisRotation, h5.largeArcFlag, h5.sweepFlag, { x: h5.middleX / 9525 * n5.x, y: h5.middleY / 9525 * n5.y }]]), s5.cmds.push(["A", [h5.radiusX / 9525 * n5.x, h5.radiusY / 9525 * n5.y, h5.xAxisRotation, h5.largeArcFlag, h5.sweepFlag, { x: h5.endX / 9525 * n5.x, y: h5.endY / 9525 * n5.y }]])) : (o5 = { x: h5.endX, y: h5.endY }, s5.cmds.push(["A", [h5.radiusX / 9525 * n5.x, h5.radiusY / 9525 * n5.y, h5.xAxisRotation, h5.largeArcFlag, h5.sweepFlag, { x: h5.endX / 9525 * n5.x, y: h5.endY / 9525 * n5.y }]]));
              } else if (e6 === "L") {
                let [t8, e7] = i4.split(",").map((t9) => Number(t9));
                o5 = { x: t8, y: e7 }, t8 = t8 / 9525 * n5.x, e7 = e7 / 9525 * n5.y, s5.cmds.push(["L", [{ x: t8, y: e7 }]]);
              } else if (e6 === "QB") {
                let [t8, e7, r6, a5] = i4.split(",").map((t9) => Number(t9));
                o5 = { x: r6, y: a5 }, t8 = t8 / 9525 * n5.x, e7 = e7 / 9525 * n5.y, r6 = r6 / 9525 * n5.x, a5 = a5 / 9525 * n5.y, s5.cmds.push(["Q", [{ x: t8, y: e7 }, { x: r6, y: a5 }]]);
              } else if (e6 === "CB") {
                let [t8, e7, r6, a5, l4, u5] = i4.split(",").map((t9) => Number(t9));
                o5 = { x: l4, y: u5 }, t8 = t8 / 9525 * n5.x, e7 = e7 / 9525 * n5.y, r6 = r6 / 9525 * n5.x, a5 = a5 / 9525 * n5.y, l4 = l4 / 9525 * n5.x, u5 = u5 / 9525 * n5.y, s5.cmds.push(["C", [{ x: t8, y: e7 }, { x: r6, y: a5 }, { x: l4, y: u5 }]]);
              } else
                e6 === "C" && s5.cmds.push(["Z", []]);
            }
            l3.push(s5);
          }), { graphicsWidth: h4, graphicsHeight: c3, pivot: u4, padding: 2, pathsData: l3 };
        }(e3, r3, o3, s3, i2, 0, l2);
        this.graphics.push({ hash: c2, pathsData: a3, pivot: u3, width: t4, height: n3, padding: h3 });
      }
      return t3;
    }
    pack() {
      this.graphics.forEach((t3) => {
        t3.width += 4, t3.height += 4;
      });
      return rM(this.graphics);
    }
    getTextureKeys() {
      var t3;
      return yM(this, void 0, void 0, function* () {
        const e3 = (yield (t3 = this.cache) === null || t3 === void 0 ? void 0 : t3.keys()) || [], n2 = new RegExp(`^${this.slideIndex}-texture`);
        return e3.filter((t4) => n2.test(t4));
      });
    }
    hasLocalCache() {
      return yM(this, void 0, void 0, function* () {
        if (!this.cache)
          return false;
        try {
          const t3 = yield this.cache.getItem(this.slideIndex + "-length");
          if (t3) {
            const e3 = yield this.cache.keys(), n2 = new RegExp(`^${this.slideIndex}-texture`);
            return e3.filter((t4) => n2.test(t4)).length === t3;
          }
          return false;
        } catch (t3) {
          return false;
        }
      });
    }
    loadFromCache(t3) {
      return yM(this, void 0, void 0, function* () {
        if (!this.cache)
          return;
        const e3 = yield this.cache.getItem(t3);
        if (!e3)
          return;
        const n2 = new wy(e3), i2 = yield this.cache.getItem(t3.replace("texture", "json")), r3 = yield this.cache.getItem(t3.replace("texture", "map"));
        i2 && r3 && (Object.keys(r3).forEach((t4) => {
          this.hashToIdMap[t4] = r3[t4], r3[t4].forEach((e4) => {
            this.idToHashMap[e4] = t4;
          });
        }), Object.keys(i2).forEach((t4) => {
          const e4 = i2[t4], r4 = new ky(n2, new d_(e4.x, e4.y, e4.w, e4.h));
          this.textures[t4] = { texture: r4, pivot: e4.pivot };
        }));
      });
    }
    destroy() {
      Object.keys(this.textures).forEach((t3) => {
        var e3;
        (e3 = this.textures[t3]) === null || e3 === void 0 || e3.texture.destroy(true);
      }), this.textures = Object.create(null), this.imgElements.forEach((t3) => mM.collectObject(t3)), this.svgElements.forEach((t3) => fM.collectObject(t3)), this.graphics = [];
    }
  }
  const bM = 134217729;
  function TM(t3, e3, n2, i2, r3) {
    let o3, s3, a2, l2, u2 = e3[0], h2 = i2[0], c2 = 0, d2 = 0;
    h2 > u2 == h2 > -u2 ? (o3 = u2, u2 = e3[++c2]) : (o3 = h2, h2 = i2[++d2]);
    let p2 = 0;
    if (c2 < t3 && d2 < n2)
      for (h2 > u2 == h2 > -u2 ? (s3 = u2 + o3, a2 = o3 - (s3 - u2), u2 = e3[++c2]) : (s3 = h2 + o3, a2 = o3 - (s3 - h2), h2 = i2[++d2]), o3 = s3, a2 !== 0 && (r3[p2++] = a2); c2 < t3 && d2 < n2; )
        h2 > u2 == h2 > -u2 ? (s3 = o3 + u2, l2 = s3 - o3, a2 = o3 - (s3 - l2) + (u2 - l2), u2 = e3[++c2]) : (s3 = o3 + h2, l2 = s3 - o3, a2 = o3 - (s3 - l2) + (h2 - l2), h2 = i2[++d2]), o3 = s3, a2 !== 0 && (r3[p2++] = a2);
    for (; c2 < t3; )
      s3 = o3 + u2, l2 = s3 - o3, a2 = o3 - (s3 - l2) + (u2 - l2), u2 = e3[++c2], o3 = s3, a2 !== 0 && (r3[p2++] = a2);
    for (; d2 < n2; )
      s3 = o3 + h2, l2 = s3 - o3, a2 = o3 - (s3 - l2) + (h2 - l2), h2 = i2[++d2], o3 = s3, a2 !== 0 && (r3[p2++] = a2);
    return o3 === 0 && p2 !== 0 || (r3[p2++] = o3), p2;
  }
  function wM(t3, e3) {
    let n2 = e3[0];
    for (let i2 = 1; i2 < t3; i2++)
      n2 += e3[i2];
    return n2;
  }
  function SM(t3) {
    return new Float64Array(t3);
  }
  const EM = SM(4), MM = SM(8), AM = SM(12), RM = SM(16), PM = SM(4);
  function CM(t3, e3, n2, i2, r3, o3) {
    const s3 = (e3 - o3) * (n2 - r3), a2 = (t3 - r3) * (i2 - o3), l2 = s3 - a2;
    if (s3 === 0 || a2 === 0 || s3 > 0 != a2 > 0)
      return l2;
    const u2 = Math.abs(s3 + a2);
    return Math.abs(l2) >= 33306690738754716e-32 * u2 ? l2 : -function(t4, e4, n3, i3, r4, o4, s4) {
      let a3, l3, u3, h2, c2, d2, p2, f2, m2, g2, v2, _2, y2, x2, b2, T2, w2, S2;
      const E2 = t4 - r4, M2 = n3 - r4, A2 = e4 - o4, R2 = i3 - o4;
      x2 = E2 * R2, d2 = bM * E2, p2 = d2 - (d2 - E2), f2 = E2 - p2, d2 = bM * R2, m2 = d2 - (d2 - R2), g2 = R2 - m2, b2 = f2 * g2 - (x2 - p2 * m2 - f2 * m2 - p2 * g2), T2 = A2 * M2, d2 = bM * A2, p2 = d2 - (d2 - A2), f2 = A2 - p2, d2 = bM * M2, m2 = d2 - (d2 - M2), g2 = M2 - m2, w2 = f2 * g2 - (T2 - p2 * m2 - f2 * m2 - p2 * g2), v2 = b2 - w2, c2 = b2 - v2, EM[0] = b2 - (v2 + c2) + (c2 - w2), _2 = x2 + v2, c2 = _2 - x2, y2 = x2 - (_2 - c2) + (v2 - c2), v2 = y2 - T2, c2 = y2 - v2, EM[1] = y2 - (v2 + c2) + (c2 - T2), S2 = _2 + v2, c2 = S2 - _2, EM[2] = _2 - (S2 - c2) + (v2 - c2), EM[3] = S2;
      let P2 = wM(4, EM), C2 = 22204460492503146e-32 * s4;
      if (P2 >= C2 || -P2 >= C2)
        return P2;
      if (c2 = t4 - E2, a3 = t4 - (E2 + c2) + (c2 - r4), c2 = n3 - M2, u3 = n3 - (M2 + c2) + (c2 - r4), c2 = e4 - A2, l3 = e4 - (A2 + c2) + (c2 - o4), c2 = i3 - R2, h2 = i3 - (R2 + c2) + (c2 - o4), a3 === 0 && l3 === 0 && u3 === 0 && h2 === 0)
        return P2;
      if (C2 = 11093356479670487e-47 * s4 + 33306690738754706e-32 * Math.abs(P2), P2 += E2 * h2 + R2 * a3 - (A2 * u3 + M2 * l3), P2 >= C2 || -P2 >= C2)
        return P2;
      x2 = a3 * R2, d2 = bM * a3, p2 = d2 - (d2 - a3), f2 = a3 - p2, d2 = bM * R2, m2 = d2 - (d2 - R2), g2 = R2 - m2, b2 = f2 * g2 - (x2 - p2 * m2 - f2 * m2 - p2 * g2), T2 = l3 * M2, d2 = bM * l3, p2 = d2 - (d2 - l3), f2 = l3 - p2, d2 = bM * M2, m2 = d2 - (d2 - M2), g2 = M2 - m2, w2 = f2 * g2 - (T2 - p2 * m2 - f2 * m2 - p2 * g2), v2 = b2 - w2, c2 = b2 - v2, PM[0] = b2 - (v2 + c2) + (c2 - w2), _2 = x2 + v2, c2 = _2 - x2, y2 = x2 - (_2 - c2) + (v2 - c2), v2 = y2 - T2, c2 = y2 - v2, PM[1] = y2 - (v2 + c2) + (c2 - T2), S2 = _2 + v2, c2 = S2 - _2, PM[2] = _2 - (S2 - c2) + (v2 - c2), PM[3] = S2;
      const I2 = TM(4, EM, 4, PM, MM);
      x2 = E2 * h2, d2 = bM * E2, p2 = d2 - (d2 - E2), f2 = E2 - p2, d2 = bM * h2, m2 = d2 - (d2 - h2), g2 = h2 - m2, b2 = f2 * g2 - (x2 - p2 * m2 - f2 * m2 - p2 * g2), T2 = A2 * u3, d2 = bM * A2, p2 = d2 - (d2 - A2), f2 = A2 - p2, d2 = bM * u3, m2 = d2 - (d2 - u3), g2 = u3 - m2, w2 = f2 * g2 - (T2 - p2 * m2 - f2 * m2 - p2 * g2), v2 = b2 - w2, c2 = b2 - v2, PM[0] = b2 - (v2 + c2) + (c2 - w2), _2 = x2 + v2, c2 = _2 - x2, y2 = x2 - (_2 - c2) + (v2 - c2), v2 = y2 - T2, c2 = y2 - v2, PM[1] = y2 - (v2 + c2) + (c2 - T2), S2 = _2 + v2, c2 = S2 - _2, PM[2] = _2 - (S2 - c2) + (v2 - c2), PM[3] = S2;
      const O2 = TM(I2, MM, 4, PM, AM);
      x2 = a3 * h2, d2 = bM * a3, p2 = d2 - (d2 - a3), f2 = a3 - p2, d2 = bM * h2, m2 = d2 - (d2 - h2), g2 = h2 - m2, b2 = f2 * g2 - (x2 - p2 * m2 - f2 * m2 - p2 * g2), T2 = l3 * u3, d2 = bM * l3, p2 = d2 - (d2 - l3), f2 = l3 - p2, d2 = bM * u3, m2 = d2 - (d2 - u3), g2 = u3 - m2, w2 = f2 * g2 - (T2 - p2 * m2 - f2 * m2 - p2 * g2), v2 = b2 - w2, c2 = b2 - v2, PM[0] = b2 - (v2 + c2) + (c2 - w2), _2 = x2 + v2, c2 = _2 - x2, y2 = x2 - (_2 - c2) + (v2 - c2), v2 = y2 - T2, c2 = y2 - v2, PM[1] = y2 - (v2 + c2) + (c2 - T2), S2 = _2 + v2, c2 = S2 - _2, PM[2] = _2 - (S2 - c2) + (v2 - c2), PM[3] = S2;
      const L2 = TM(O2, AM, 4, PM, RM);
      return RM[L2 - 1];
    }(t3, e3, n2, i2, r3, o3, u2);
  }
  const IM = Math.pow(2, -52), OM = new Uint32Array(512);
  class LM {
    static from(t3, e3 = kM, n2 = GM) {
      const i2 = t3.length, r3 = new Float64Array(2 * i2);
      for (let o3 = 0; o3 < i2; o3++) {
        const i3 = t3[o3];
        r3[2 * o3] = e3(i3), r3[2 * o3 + 1] = n2(i3);
      }
      return new LM(r3);
    }
    constructor(t3) {
      const e3 = t3.length >> 1;
      if (e3 > 0 && typeof t3[0] != "number")
        throw new Error("Expected coords to contain numbers.");
      this.coords = t3;
      const n2 = Math.max(2 * e3 - 5, 0);
      this._triangles = new Uint32Array(3 * n2), this._halfedges = new Int32Array(3 * n2), this._hashSize = Math.ceil(Math.sqrt(e3)), this._hullPrev = new Uint32Array(e3), this._hullNext = new Uint32Array(e3), this._hullTri = new Uint32Array(e3), this._hullHash = new Int32Array(this._hashSize).fill(-1), this._ids = new Uint32Array(e3), this._dists = new Float64Array(e3), this.update();
    }
    update() {
      const { coords: t3, _hullPrev: e3, _hullNext: n2, _hullTri: i2, _hullHash: r3 } = this, o3 = t3.length >> 1;
      let s3 = 1 / 0, a2 = 1 / 0, l2 = -1 / 0, u2 = -1 / 0;
      for (let e4 = 0; e4 < o3; e4++) {
        const n3 = t3[2 * e4], i3 = t3[2 * e4 + 1];
        n3 < s3 && (s3 = n3), i3 < a2 && (a2 = i3), n3 > l2 && (l2 = n3), i3 > u2 && (u2 = i3), this._ids[e4] = e4;
      }
      const h2 = (s3 + l2) / 2, c2 = (a2 + u2) / 2;
      let d2, p2, f2, m2 = 1 / 0;
      for (let e4 = 0; e4 < o3; e4++) {
        const n3 = NM(h2, c2, t3[2 * e4], t3[2 * e4 + 1]);
        n3 < m2 && (d2 = e4, m2 = n3);
      }
      const g2 = t3[2 * d2], v2 = t3[2 * d2 + 1];
      m2 = 1 / 0;
      for (let e4 = 0; e4 < o3; e4++) {
        if (e4 === d2)
          continue;
        const n3 = NM(g2, v2, t3[2 * e4], t3[2 * e4 + 1]);
        n3 < m2 && n3 > 0 && (p2 = e4, m2 = n3);
      }
      let _2 = t3[2 * p2], y2 = t3[2 * p2 + 1], x2 = 1 / 0;
      for (let e4 = 0; e4 < o3; e4++) {
        if (e4 === d2 || e4 === p2)
          continue;
        const n3 = FM(g2, v2, _2, y2, t3[2 * e4], t3[2 * e4 + 1]);
        n3 < x2 && (f2 = e4, x2 = n3);
      }
      let b2 = t3[2 * f2], T2 = t3[2 * f2 + 1];
      if (x2 === 1 / 0) {
        for (let e5 = 0; e5 < o3; e5++)
          this._dists[e5] = t3[2 * e5] - t3[0] || t3[2 * e5 + 1] - t3[1];
        BM(this._ids, this._dists, 0, o3 - 1);
        const e4 = new Uint32Array(o3);
        let n3 = 0;
        for (let t4 = 0, i3 = -1 / 0; t4 < o3; t4++) {
          const r4 = this._ids[t4];
          this._dists[r4] > i3 && (e4[n3++] = r4, i3 = this._dists[r4]);
        }
        return this.hull = e4.subarray(0, n3), this.triangles = new Uint32Array(0), void (this.halfedges = new Uint32Array(0));
      }
      if (CM(g2, v2, _2, y2, b2, T2) < 0) {
        const t4 = p2, e4 = _2, n3 = y2;
        p2 = f2, _2 = b2, y2 = T2, f2 = t4, b2 = e4, T2 = n3;
      }
      const w2 = function(t4, e4, n3, i3, r4, o4) {
        const s4 = n3 - t4, a3 = i3 - e4, l3 = r4 - t4, u3 = o4 - e4, h3 = s4 * s4 + a3 * a3, c3 = l3 * l3 + u3 * u3, d3 = 0.5 / (s4 * u3 - a3 * l3);
        return { x: t4 + (u3 * h3 - a3 * c3) * d3, y: e4 + (s4 * c3 - l3 * h3) * d3 };
      }(g2, v2, _2, y2, b2, T2);
      this._cx = w2.x, this._cy = w2.y;
      for (let e4 = 0; e4 < o3; e4++)
        this._dists[e4] = NM(t3[2 * e4], t3[2 * e4 + 1], w2.x, w2.y);
      BM(this._ids, this._dists, 0, o3 - 1), this._hullStart = d2;
      let S2 = 3;
      n2[d2] = e3[f2] = p2, n2[p2] = e3[d2] = f2, n2[f2] = e3[p2] = d2, i2[d2] = 0, i2[p2] = 1, i2[f2] = 2, r3.fill(-1), r3[this._hashKey(g2, v2)] = d2, r3[this._hashKey(_2, y2)] = p2, r3[this._hashKey(b2, T2)] = f2, this.trianglesLen = 0, this._addTriangle(d2, p2, f2, -1, -1, -1);
      for (let o4, s4, a3 = 0; a3 < this._ids.length; a3++) {
        const l3 = this._ids[a3], u3 = t3[2 * l3], h3 = t3[2 * l3 + 1];
        if (a3 > 0 && Math.abs(u3 - o4) <= IM && Math.abs(h3 - s4) <= IM)
          continue;
        if (o4 = u3, s4 = h3, l3 === d2 || l3 === p2 || l3 === f2)
          continue;
        let c3 = 0;
        for (let t4 = 0, e4 = this._hashKey(u3, h3); t4 < this._hashSize && (c3 = r3[(e4 + t4) % this._hashSize], c3 === -1 || c3 === n2[c3]); t4++)
          ;
        c3 = e3[c3];
        let m3, g3 = c3;
        for (; m3 = n2[g3], CM(u3, h3, t3[2 * g3], t3[2 * g3 + 1], t3[2 * m3], t3[2 * m3 + 1]) >= 0; )
          if (g3 = m3, g3 === c3) {
            g3 = -1;
            break;
          }
        if (g3 === -1)
          continue;
        let v3 = this._addTriangle(g3, l3, n2[g3], -1, -1, i2[g3]);
        i2[l3] = this._legalize(v3 + 2), i2[g3] = v3, S2++;
        let _3 = n2[g3];
        for (; m3 = n2[_3], CM(u3, h3, t3[2 * _3], t3[2 * _3 + 1], t3[2 * m3], t3[2 * m3 + 1]) < 0; )
          v3 = this._addTriangle(_3, l3, m3, i2[l3], -1, i2[_3]), i2[l3] = this._legalize(v3 + 2), n2[_3] = _3, S2--, _3 = m3;
        if (g3 === c3)
          for (; m3 = e3[g3], CM(u3, h3, t3[2 * m3], t3[2 * m3 + 1], t3[2 * g3], t3[2 * g3 + 1]) < 0; )
            v3 = this._addTriangle(m3, l3, g3, -1, i2[g3], i2[m3]), this._legalize(v3 + 2), i2[m3] = v3, n2[g3] = g3, S2--, g3 = m3;
        this._hullStart = e3[l3] = g3, n2[g3] = e3[_3] = l3, n2[l3] = _3, r3[this._hashKey(u3, h3)] = l3, r3[this._hashKey(t3[2 * g3], t3[2 * g3 + 1])] = g3;
      }
      this.hull = new Uint32Array(S2);
      for (let t4 = 0, e4 = this._hullStart; t4 < S2; t4++)
        this.hull[t4] = e4, e4 = n2[e4];
      this.triangles = this._triangles.subarray(0, this.trianglesLen), this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
    }
    _hashKey(t3, e3) {
      return Math.floor(function(t4, e4) {
        const n2 = t4 / (Math.abs(t4) + Math.abs(e4));
        return (e4 > 0 ? 3 - n2 : 1 + n2) / 4;
      }(t3 - this._cx, e3 - this._cy) * this._hashSize) % this._hashSize;
    }
    _legalize(t3) {
      const { _triangles: e3, _halfedges: n2, coords: i2 } = this;
      let r3 = 0, o3 = 0;
      for (; ; ) {
        const s3 = n2[t3], a2 = t3 - t3 % 3;
        if (o3 = a2 + (t3 + 2) % 3, s3 === -1) {
          if (r3 === 0)
            break;
          t3 = OM[--r3];
          continue;
        }
        const l2 = s3 - s3 % 3, u2 = a2 + (t3 + 1) % 3, h2 = l2 + (s3 + 2) % 3, c2 = e3[o3], d2 = e3[t3], p2 = e3[u2], f2 = e3[h2];
        if (DM(i2[2 * c2], i2[2 * c2 + 1], i2[2 * d2], i2[2 * d2 + 1], i2[2 * p2], i2[2 * p2 + 1], i2[2 * f2], i2[2 * f2 + 1])) {
          e3[t3] = f2, e3[s3] = c2;
          const i3 = n2[h2];
          if (i3 === -1) {
            let e4 = this._hullStart;
            do {
              if (this._hullTri[e4] === h2) {
                this._hullTri[e4] = t3;
                break;
              }
              e4 = this._hullPrev[e4];
            } while (e4 !== this._hullStart);
          }
          this._link(t3, i3), this._link(s3, n2[o3]), this._link(o3, h2);
          const a3 = l2 + (s3 + 1) % 3;
          r3 < OM.length && (OM[r3++] = a3);
        } else {
          if (r3 === 0)
            break;
          t3 = OM[--r3];
        }
      }
      return o3;
    }
    _link(t3, e3) {
      this._halfedges[t3] = e3, e3 !== -1 && (this._halfedges[e3] = t3);
    }
    _addTriangle(t3, e3, n2, i2, r3, o3) {
      const s3 = this.trianglesLen;
      return this._triangles[s3] = t3, this._triangles[s3 + 1] = e3, this._triangles[s3 + 2] = n2, this._link(s3, i2), this._link(s3 + 1, r3), this._link(s3 + 2, o3), this.trianglesLen += 3, s3;
    }
  }
  function NM(t3, e3, n2, i2) {
    const r3 = t3 - n2, o3 = e3 - i2;
    return r3 * r3 + o3 * o3;
  }
  function DM(t3, e3, n2, i2, r3, o3, s3, a2) {
    const l2 = t3 - s3, u2 = e3 - a2, h2 = n2 - s3, c2 = i2 - a2, d2 = r3 - s3, p2 = o3 - a2, f2 = h2 * h2 + c2 * c2, m2 = d2 * d2 + p2 * p2;
    return l2 * (c2 * m2 - f2 * p2) - u2 * (h2 * m2 - f2 * d2) + (l2 * l2 + u2 * u2) * (h2 * p2 - c2 * d2) < 0;
  }
  function FM(t3, e3, n2, i2, r3, o3) {
    const s3 = n2 - t3, a2 = i2 - e3, l2 = r3 - t3, u2 = o3 - e3, h2 = s3 * s3 + a2 * a2, c2 = l2 * l2 + u2 * u2, d2 = 0.5 / (s3 * u2 - a2 * l2), p2 = (u2 * h2 - a2 * c2) * d2, f2 = (s3 * c2 - l2 * h2) * d2;
    return p2 * p2 + f2 * f2;
  }
  function BM(t3, e3, n2, i2) {
    if (i2 - n2 <= 20)
      for (let r3 = n2 + 1; r3 <= i2; r3++) {
        const i3 = t3[r3], o3 = e3[i3];
        let s3 = r3 - 1;
        for (; s3 >= n2 && e3[t3[s3]] > o3; )
          t3[s3 + 1] = t3[s3--];
        t3[s3 + 1] = i3;
      }
    else {
      let r3 = n2 + 1, o3 = i2;
      UM(t3, n2 + i2 >> 1, r3), e3[t3[n2]] > e3[t3[i2]] && UM(t3, n2, i2), e3[t3[r3]] > e3[t3[i2]] && UM(t3, r3, i2), e3[t3[n2]] > e3[t3[r3]] && UM(t3, n2, r3);
      const s3 = t3[r3], a2 = e3[s3];
      for (; ; ) {
        do {
          r3++;
        } while (e3[t3[r3]] < a2);
        do {
          o3--;
        } while (e3[t3[o3]] > a2);
        if (o3 < r3)
          break;
        UM(t3, r3, o3);
      }
      t3[n2 + 1] = t3[o3], t3[o3] = s3, i2 - r3 + 1 >= o3 - n2 ? (BM(t3, e3, r3, i2), BM(t3, e3, n2, o3 - 1)) : (BM(t3, e3, n2, o3 - 1), BM(t3, e3, r3, i2));
    }
  }
  function UM(t3, e3, n2) {
    const i2 = t3[e3];
    t3[e3] = t3[n2], t3[n2] = i2;
  }
  function kM(t3) {
    return t3[0];
  }
  function GM(t3) {
    return t3[1];
  }
  class HM {
    constructor(t3) {
      if (this._isInit = false, this.h = 0, this.s = 0, this.l = 0, this.a = 1, t3) {
        this._isInit = true;
        const e3 = t3.match(/-?[0-9]+/g);
        e3 && (this.h = parseInt(e3[0], 10), this.s = parseInt(e3[1], 10) / 100, this.l = parseInt(e3[2], 10) / 100);
      }
    }
    isInit() {
      return this._isInit;
    }
    by(t3, e3) {
      e3.h = Math.max(Math.min(this.h + t3.h, 359), 0), e3.s = Math.max(Math.min(this.s + t3.s, 1), 0), e3.l = Math.max(Math.min(this.l + t3.l, 1), 0), e3.a = Math.max(Math.min(this.a + t3.a, 1), 0);
    }
    fromHexString(t3) {
      const [e3, n2, i2, r3] = VM(t3);
      let o3 = 0, s3 = 0, a2 = 0;
      const l2 = Math.max(e3, n2, i2), u2 = Math.min(e3, n2, i2), h2 = l2 - u2;
      a2 = (l2 + u2) / 2, h2 === 0 ? o3 = 0 : l2 === e3 ? o3 = (n2 - i2) / h2 % 6 * 60 : l2 === n2 ? o3 = 60 * ((i2 - e3) / h2 + 2) : l2 === i2 && (o3 = 60 * ((e3 - n2) / h2 + 4)), s3 = h2 === 0 ? 0 : h2 / (1 - Math.abs(2 * a2 - 1)), this.h = o3, this.s = s3, this.l = a2, this.a = r3;
    }
    interpolationFrom(t3, e3, n2) {
      const i2 = t3.h + (this.h - t3.h) * e3, r3 = t3.s + (this.s - t3.s) * e3, o3 = t3.l + (this.l - t3.l) * e3, s3 = t3.a + (this.a - t3.a) * e3;
      n2.h = Math.max(Math.min(i2, 359), 0), n2.s = Math.max(Math.min(r3, 1), 0), n2.l = Math.max(Math.min(o3, 1), 0), n2.a = Math.max(Math.min(s3, 1), 0);
    }
    toHexString() {
      let t3 = [0, 0, 0, 0];
      const { h: e3, s: n2, l: i2 } = this;
      if (e3 < 360 && e3 >= 0 && n2 <= 1 && n2 >= 0 && i2 <= 1 && i2 >= 0) {
        let r3, o3, s3;
        const a2 = (1 - Math.abs(2 * i2 - 1)) * n2, l2 = a2 * (1 - Math.abs(e3 / 60 % 2 - 1)), u2 = i2 - a2 / 2;
        [r3, o3, s3] = e3 >= 0 && e3 < 60 ? [a2, l2, 0] : e3 >= 60 && e3 < 120 ? [l2, a2, 0] : e3 >= 120 && e3 < 180 ? [0, a2, l2] : e3 >= 180 && e3 < 240 ? [0, l2, a2] : e3 >= 240 && e3 < 300 ? [l2, 0, a2] : [a2, 0, l2], t3 = [r3 + u2, o3 + u2, s3 + u2, this.a];
      }
      return WM(t3);
    }
  }
  class zM {
    constructor(t3) {
      this._isInit = false, this.r = 0, this.g = 0, this.b = 0, this.a = 0, t3 && (this._isInit = true, this.fromHexString(t3));
    }
    fromHexString(t3) {
      const [e3, n2, i2, r3] = VM(t3);
      this.r = e3, this.g = n2, this.b = i2, this.a = r3;
    }
    isInit() {
      return this._isInit;
    }
    interpolationFrom(t3, e3, n2) {
      n2.r = t3.r + (this.r - t3.r) * e3, n2.g = t3.g + (this.g - t3.g) * e3, n2.b = t3.b + (this.b - t3.b) * e3, n2.a = t3.a + (this.a - t3.a) * e3;
    }
    by(t3, e3) {
      e3.r = Math.min(Math.max(this.r + t3.r, 0), 255), e3.g = Math.min(Math.max(this.g + t3.g, 0), 255), e3.b = Math.min(Math.max(this.b + t3.b, 0), 255), e3.a = Math.min(Math.max(this.a + t3.a, 0), 1);
    }
    toHexString() {
      return WM([this.r, this.g, this.b, this.a]);
    }
  }
  function jM(t3) {
    const e3 = t3.substring(1);
    return [parseInt(e3.substring(0, 6), 16), parseInt(e3.substring(6, 8), 16) / 255];
  }
  function VM(t3) {
    return (t3 = t3.replace(/^#/, "")).substring(6, 8).length === 0 && (t3 += "FF"), [parseInt(t3.substring(0, 2).padStart(8, "0"), 16) / 255, parseInt(t3.substring(2, 4).padStart(8, "0"), 16) / 255, parseInt(t3.substring(4, 6).padStart(8, "0"), 16) / 255, parseInt(t3.substring(6, 8).padStart(8, "0"), 16) / 255];
  }
  function WM(t3) {
    return "#" + Math.round(255 * t3[0]).toString(16).padStart(2, "0") + Math.round(255 * t3[1]).toString(16).padStart(2, "0") + Math.round(255 * t3[2]).toString(16).padStart(2, "0") + Math.round(255 * t3[3]).toString(16).padStart(2, "0");
  }
  function XM(t3, e3, n2) {
    const i2 = VM(t3), r3 = VM(e3), o3 = Math.round(255 * (i2[0] + (r3[0] - i2[0]) * n2)), s3 = Math.round(255 * (i2[1] + (r3[1] - i2[1]) * n2)), a2 = Math.round(255 * (i2[2] + (r3[2] - i2[2]) * n2)), l2 = Math.round(255 * (i2[3] + (r3[3] - i2[3]) * n2));
    return "#" + o3.toString(16).padStart(2, "0") + s3.toString(16).padStart(2, "0") + a2.toString(16).padStart(2, "0") + l2.toString(16).padStart(2, "0");
  }
  function qM(t3, e3, n2) {
    return t3.fillType === "solidFill" ? function(t4, e4, n3) {
      const i2 = new Aw(), [r3, o3] = jM(t4.color);
      return i2.beginFill(r3, o3), i2.drawRect(0, 0, e4, n3), i2.endFill(), i2;
    }(t3, e3, n2) : t3.fillType === "gradientFill" ? function(t4, e4, n3) {
      let i2 = null;
      const r3 = new ty();
      if (t4.stopList.sort((t5, e5) => t5.pos - e5.pos), !t4.stopList.find((t5) => t5.pos === 0)) {
        const e5 = t4.stopList[0];
        t4.stopList.unshift({ pos: 0, color: e5.color });
      }
      if (!t4.stopList.find((t5) => t5.pos === 1)) {
        const e5 = t4.stopList[t4.stopList.length - 1];
        t4.stopList.push({ pos: 1, color: e5.color });
      }
      const o3 = (t5) => {
        const e5 = [];
        for (let n4 = 0, i3 = t5.length; n4 < i3 - 1; n4++) {
          const i4 = t5[n4], r4 = t5[n4 + 1], o4 = i4.pos + 0.5 * (r4.pos - i4.pos), s3 = XM(i4.color, r4.color, 0.5), a2 = 2 * n4;
          e5[a2] = i4, e5[a2 + 1] = { color: s3, pos: o4 }, e5[a2 + 2] = r4;
        }
        return e5;
      };
      t4.stopList = o3(t4.stopList), t4.stopList = o3(t4.stopList), i2 = t4.line ? YM(t4, e4, n3) : t4.path ? function(t5, e5, n4) {
        var i3, r4, o4;
        const s3 = [], a2 = { x: 0, y: 0 };
        if (((i3 = t5.path) === null || i3 === void 0 ? void 0 : i3.path) === "circle" || ((r4 = t5.path) === null || r4 === void 0 ? void 0 : r4.path) === "rect" || ((o4 = t5.path) === null || o4 === void 0 ? void 0 : o4.path) === "shape") {
          const i4 = e5 / 2, r5 = n4 / 2, o5 = Math.sqrt(i4 * i4 + r5 * r5);
          t5.stopList.forEach((t6) => {
            if (t6.pos === 0)
              s3.push({ point: { x: 0, y: 0 }, color: t6.color });
            else {
              const e6 = o5 * t6.pos, n5 = new xc();
              n5.absellipse(0, 0, e6, e6, 0, 2 * Math.PI, false, 0), n5.getPoints(50).forEach((e7) => {
                s3.push({ point: { x: e7.x, y: e7.y }, color: t6.color });
              });
            }
            a2.x = i4, a2.y = r5;
          });
        }
        return { points: s3, position: a2 };
      }(t4, e4, n3) : YM(t4, e4, n3);
      if (i2) {
        const t5 = [], o4 = [], { position: s3, points: a2 } = i2, l2 = LM.from(a2, (t6) => t6.point.x, (t6) => t6.point.y);
        for (let e5 = 0; e5 < l2.triangles.length; e5 += 3)
          t5.push(a2[l2.triangles[e5]].point.x, a2[l2.triangles[e5]].point.y), t5.push(a2[l2.triangles[e5 + 1]].point.x, a2[l2.triangles[e5 + 1]].point.y), t5.push(a2[l2.triangles[e5 + 2]].point.x, a2[l2.triangles[e5 + 2]].point.y), o4.push(...VM(a2[l2.triangles[e5]].color)), o4.push(...VM(a2[l2.triangles[e5 + 1]].color)), o4.push(...VM(a2[l2.triangles[e5 + 2]].color));
        const u2 = new Jy();
        u2.addAttribute("aVertexPosition", t5, 2), u2.addAttribute("aColor", o4, 4);
        const h2 = Ux.from("\n        precision mediump float;\n        attribute vec2 aVertexPosition;\n        attribute vec4 aColor;\n        uniform mat3 translationMatrix;\n        uniform mat3 projectionMatrix;\n        varying vec4 vColor;\n        void main() {\n            vColor = aColor;\n            gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n        }", "precision mediump float;    \n        varying vec4 vColor;\n        void main() {\n            float alpha = vColor.a;\n            vec4 color = vColor;\n            color.a = 1.0;\n            gl_FragColor = color * alpha;\n        }\n    "), c2 = new Aw();
        c2.drawRect(0, 0, e4 + 1, n3 + 1), r3.mask = c2, r3.addChild(c2);
        const d2 = new vS(u2, h2);
        d2.position.x = s3.x, d2.position.y = s3.y, r3.addChild(d2);
      }
      return r3;
    }(t3, e3, n2) : null;
  }
  function YM(t3, e3, n2) {
    const i2 = e3 / 2, r3 = n2 / 2, o3 = [{ x: -i2, y: r3 }, { x: -i2, y: -r3 }, { x: i2, y: r3 }, { x: i2, y: -r3 }], s3 = [nM.fromPointSlope({ x: -i2, y: 0 }, Math.PI / 2), nM.fromPointSlope({ x: 0, y: r3 }, 0), nM.fromPointSlope({ x: i2, y: 0 }, Math.PI / 2), nM.fromPointSlope({ x: 0, y: -r3 }, 0)], a2 = [], l2 = t3.stopList.slice(1, t3.stopList.length - 1).map((o4) => {
      var l3, u3, h3;
      const c3 = 2 * Math.PI;
      let d3 = (u3 = (l3 = t3.line) === null || l3 === void 0 ? void 0 : l3.ang) !== null && u3 !== void 0 ? u3 : 0;
      for (; d3 > c3; )
        d3 -= c3;
      for (; d3 < 0; )
        d3 += c3;
      const p3 = { x: 0, y: 0 };
      tM(d3, Math.PI / 2) ? (p3.x = 0, p3.y = n2 / 2 - o4.pos * n2) : tM(d3, 0) ? (p3.x = o4.pos * e3 - e3 / 2, p3.y = 0) : (p3.x = o4.pos * e3 - e3 / 2, p3.y = n2 / 2 - o4.pos * n2), d3 > Math.PI / 2 && d3 <= Math.PI && (p3.x *= -1), d3 > Math.PI && d3 <= 2 * Math.PI && (p3.y *= -1);
      const f2 = nM.fromPointSlope(p3, Math.PI / 2 - (((h3 = t3.line) === null || h3 === void 0 ? void 0 : h3.ang) || 0)), m2 = s3.map((t4) => f2.crossPoint(t4)).filter((t4) => t4 && t4.x <= i2 && t4.x >= -i2 && t4.y <= r3 && t4.y >= -r3).map((t4) => ({ point: t4, color: o4.color })).sort((t4, e4) => e4.point.y - t4.point.y);
      a2.push(...m2);
      let g2 = Math.abs(m2[1].point.x - m2[0].point.x) / 10;
      for (let t4 = 20; t4--; ) {
        const e4 = t4 % 2 == 0 ? 1 : -1, n3 = p3.x + e4 * g2, s4 = f2.resolveY(n3);
        n3 <= i2 && n3 >= -i2 && s4 <= r3 && s4 >= -r3 && a2.push({ point: { x: n3, y: s4 }, color: o4.color }), g2 += g2;
      }
      return f2;
    });
    let u2 = [], h2 = [];
    t:
      for (let e4 = 0; e4 < o3.length; e4++) {
        const n3 = o3[e4];
        for (let e5 = 0; e5 < l2.length - 1; e5++) {
          const i4 = l2[e5], r5 = l2[e5 + 1], o4 = i4.distanceToLinearEquation(r5), s5 = i4.distanceToPoint(n3), u3 = r5.distanceToPoint(n3);
          if (s5 < o4 && u3 < o4) {
            const i5 = t3.stopList.slice(1, t3.stopList.length - 1)[e5], r6 = t3.stopList.slice(1, t3.stopList.length - 1)[e5 + 1], l3 = XM(i5.color, r6.color, s5 / o4);
            a2.splice(e5 + 1, 0, { point: n3, color: l3 });
            continue t;
          }
        }
        const i3 = l2[0], r4 = l2[l2.length - 1], s4 = i3.distanceToPoint(n3), c3 = r4.distanceToPoint(n3);
        s4 <= c3 ? u2.push({ point: n3, dis: s4 }) : h2.push({ point: n3, dis: c3 });
      }
    u2 = u2.sort((t4, e4) => e4.dis - t4.dis);
    const c2 = u2.map((e4, n3) => {
      if (n3 === 0)
        return { point: e4.point, color: t3.stopList[0].color };
      {
        const n4 = t3.stopList[0].color, i3 = t3.stopList[1].color;
        return { point: e4.point, color: XM(n4, i3, 1 - (u2[0].dis === 0 ? 1 : e4.dis / u2[0].dis)) };
      }
    }).sort((t4, e4) => e4.point.y - t4.point.y);
    h2 = h2.sort((t4, e4) => e4.dis - t4.dis);
    const d2 = h2.map((e4, n3) => {
      if (n3 === 0)
        return { point: e4.point, color: t3.stopList[t3.stopList.length - 1].color };
      {
        const n4 = t3.stopList[t3.stopList.length - 2].color, i3 = t3.stopList[t3.stopList.length - 1].color;
        return { point: e4.point, color: XM(n4, i3, h2[0].dis === 0 ? 0 : e4.dis / h2[0].dis) };
      }
    }).sort((t4, e4) => e4.point.y - t4.point.y), p2 = c2.concat(...a2).concat(d2);
    for (let t4 = 0; t4 < p2.length; t4++)
      p2[t4].point.x += i2, p2[t4].point.y = -p2[t4].point.y + r3;
    return { points: p2, position: { x: 0, y: 0 } };
  }
  const ZM = "\nvec3 rgb2hsl(vec3 rgb) {\n    float cMax = max(max(rgb.r, rgb.g), rgb.b);\n    float cMin = min(min(rgb.r, rgb.g), rgb.b);\n    float delta = cMax - cMin;\n    \n    float h = 0.0;\n    if (delta == 0.0) {\n        h = 0.0;\n    } else if (cMax == rgb.r) {\n        h = 60.0 * mod(((rgb.g - rgb.b) / delta), 6.0);\n    } else if (cMax == rgb.g ) {\n        h = 60.0 * ((rgb.b - rgb.r) / delta + 2.0);\n    } else if (cMax == rgb.b) {\n        h = 60.0 * ((rgb.r - rgb.g) / delta + 4.0);\n    }\n    \n    float l = (cMax + cMin) / 2.0;\n    \n    float s = 0.0;\n    if (delta == 0.0) {\n        s = 0.0;\n    } else {\n        s = delta / (1.0 - abs(2.0 * l - 1.0));\n    }\n    \n    return vec3(h, s, l);\n}\n", JM = [ZM], $M = { biLevel: "\nvec4 transform(vec4 texColor, float arg) {\n    vec3 hsl = rgb2hsl(texColor.rgb);\n    mat3 rgb2yuv = mat3(\n        0.2126, 0.7152, 0.0722,\n        -0.09991, -0.33609, 0.43600,\n        0.615, -0.5586, -0.05639\n    );\n    vec3 yuv = texColor.rgb * rgb2yuv;\n    if (yuv.x >= 0.49 || texColor.a < 0.9) {\n        return vec4(1.0, 1.0, 1.0, 1.0) * texColor.a;\n    } else {\n        return vec4(0.0, 0.0, 0.0, 1.0) * texColor.a;\n    }\n}\n", alphaModFix: "\nvec4 transform(vec4 texColor, float arg) {\n   return texColor * arg;\n}\n" };
  class KM extends Gx {
    constructor(t3, e3) {
      var n2;
      super(void 0, (n2 = $M[t3], `
varying vec2 vTextureCoord;

uniform float arg;
uniform sampler2D uSampler;

${JM.map((t4) => t4 + "\n").join("\n")}

${n2}

void main(void){
    vec4 texColor = texture2D(uSampler, vTextureCoord);
    gl_FragColor = transform(texColor, arg);
}
`), { arg: e3 });
    }
  }
  const QM = [ZM], tA = { clrChange: "\nvec4 transform(vec4 texColor, vec4 arg1, vec4 arg2) {\n    float epsilon = 0.001;\n    vec3 colorDiff = arg1.rgb - (texColor.rgb / max(texColor.a, 0.0000000001));\n    float colorDistance = length(colorDiff);\n    if (colorDistance < epsilon) {\n        arg2.rgb *= arg2.a;\n        return arg2;\n    } else {\n        return texColor;\n    }\n}\n", changeBulletColor: "\nvec4 transform(vec4 texColor, vec4 arg1, vec4 arg2) {\n    float epsilon = 0.4;\n    vec3 colorDiff = arg1.rgb - (texColor.rgb / max(texColor.a, 0.0000000001));\n    float colorDistance = length(colorDiff);\n    if (colorDistance < epsilon) {\n        arg2.rgb *= ceil(texColor.a);\n        return arg2;\n    } else {\n        return texColor;\n    }\n}\n" };
  class eA extends Gx {
    constructor(t3, e3, n2) {
      var i2;
      super(void 0, (i2 = tA[t3], `
varying vec2 vTextureCoord;

uniform vec4 arg1;
uniform vec4 arg2;
uniform sampler2D uSampler;

${QM.map((t4) => t4 + "\n").join("\n")}

${i2}

void main(void){
    vec4 texColor = texture2D(uSampler, vTextureCoord);
    gl_FragColor = transform(texColor, arg1, arg2);
}
`), { arg1: Float32Array.from(e3), arg2: Float32Array.from(n2) });
    }
  }
  const nA = [ZM], iA = { lum: "\nvec4 transform(vec4 texColor, float arg1, float arg2) {\n    if (arg1 > 0.0) {\n        texColor.r += (1.0 - texColor.r) * arg1;\n        texColor.g += (1.0 - texColor.g) * arg1;\n        texColor.b += (1.0 - texColor.b) * arg1;\n    } else if (arg1 < 0.0) {\n        texColor.r -= texColor.r * arg1;\n        texColor.g -= texColor.g * arg1;\n        texColor.b -= texColor.b * arg1;\n    }\n    // todo \u5BF9\u6BD4\u5EA6\n    texColor.rgb *= texColor.a;\n    return texColor;\n}\n" };
  class rA extends Gx {
    constructor(t3, e3, n2) {
      var i2;
      super(void 0, (i2 = iA[t3], `
varying vec2 vTextureCoord;

uniform float arg1;
uniform float arg2;
uniform sampler2D uSampler;

${nA.map((t4) => t4 + "\n").join("\n")}

${i2}

void main(void){
    vec4 texColor = texture2D(uSampler, vTextureCoord);
    gl_FragColor = transform(texColor, arg1, arg2);
}
`), { arg1: e3, arg2: n2 });
    }
  }
  var oA = function(t3, e3, n2, i2) {
    return new (n2 || (n2 = Promise))(function(r3, o3) {
      function s3(t4) {
        try {
          l2(i2.next(t4));
        } catch (t5) {
          o3(t5);
        }
      }
      function a2(t4) {
        try {
          l2(i2.throw(t4));
        } catch (t5) {
          o3(t5);
        }
      }
      function l2(t4) {
        var e4;
        t4.done ? r3(t4.value) : (e4 = t4.value, e4 instanceof n2 ? e4 : new n2(function(t5) {
          t5(e4);
        })).then(s3, a2);
      }
      l2((i2 = i2.apply(t3, e3 || [])).next());
    });
  };
  class sA {
    constructor(t3, e3, n2, i2, r3, o3) {
      this.taskId = t3, this.slideIndex = e3, this.microTaskManager = n2, this.renderer = i2, this.spriteTextures = r3, this.cache = o3, this.renderContainers = [], this.renderTextures = [], this.textures = Object.create(null), this.fillStyles = [], this.idToHashMap = Object.create(null), this.hashToIdMap = Object.create(null);
    }
    addTexture(t3, e3) {
      this.textures[t3] = { texture: e3, pivot: { x: 0, y: 0 } };
    }
    render(t3, e3) {
      const { items: n2, width: i2, height: r3 } = t3, o3 = new ty();
      n2.forEach((t4) => {
        if (t4.item.blipFillObject) {
          const { width: e4, height: n3 } = t4;
          t4.item.blipFillObject.position.x += t4.x + e4 / 2, t4.item.blipFillObject.position.y += t4.y + n3 / 2, t4.item.blipFillObject.anchor.x = 0.5, t4.item.blipFillObject.anchor.y = 0.5, t4.item.blipFillObject.rotation = t4.item.rotate / 180 * Math.PI, o3.addChild(t4.item.blipFillObject);
        } else {
          const e4 = qM(t4.item.fill, t4.width - 4, t4.height - 4);
          if (e4)
            e4.position.x += t4.x + 2, e4.position.y += t4.y + 2, o3.addChild(e4);
          else {
            const e5 = new Aw();
            e5.drawRect(0, 0, t4.width - 4, t4.height - 4), o3.addChild(e5);
          }
        }
        if (t4.item.name) {
          const e4 = new Vw(t4.item.name, { fontFamily: "Arial", fontSize: 12, fill: 16715792, align: "center" });
          e4.position.x = t4.x + 2, e4.position.y = t4.y + 2, o3.addChild(e4);
        }
      });
      const s3 = new Aw();
      s3.drawRect(0, 0, Math.ceil(i2), Math.ceil(r3)), o3.addChild(s3);
      const a2 = Hy.create({ width: i2, height: r3, resolution: Math.ceil(this.renderer.resolution) });
      KR.textureCacheSize += i2 * r3 * Math.ceil(this.renderer.resolution), this.renderTextures.push(a2), this.renderContainers.push(o3), this.renderer.render(o3, { renderTexture: a2 });
      const l2 = {}, u2 = {};
      if (n2.forEach((t4) => {
        const e4 = new ky(a2.baseTexture, new d_(t4.x + 2, t4.y + 2, t4.width - 4, t4.height - 4));
        this.textures[t4.item.hash] = { texture: e4, pivot: t4.item.pivot }, l2[t4.item.hash] = { x: t4.x + 2, y: t4.y + 2, w: t4.width - 4, h: t4.height - 4, pivot: t4.item.pivot }, u2[t4.item.hash] = this.hashToIdMap[t4.item.hash];
      }), this.cache) {
        const t4 = new _M();
        t4.addMTask(() => oA(this, void 0, void 0, function* () {
          var t5, n3, i3;
          if (this.fillStyles.length > 0) {
            const r4 = this.renderer.plugins.extract.base64(o3);
            yield (t5 = this.cache) === null || t5 === void 0 ? void 0 : t5.setItem(`${this.slideIndex}-texture-${e3}`, r4), yield (n3 = this.cache) === null || n3 === void 0 ? void 0 : n3.setItem(`${this.slideIndex}-json-${e3}`, l2), yield (i3 = this.cache) === null || i3 === void 0 ? void 0 : i3.setItem(`${this.slideIndex}-map-${e3}`, u2);
          }
        })), this.microTaskManager.addTask(t4);
      }
    }
    getTexture(t3) {
      const e3 = this.idToHashMap[t3], n2 = this.textures[e3], i2 = this.spriteTextures.getTexture(e3);
      return n2 || (i2 ? { texture: i2, pivot: { x: 0, y: 0 } } : { texture: null, pivot: { x: 0, y: 0 } });
    }
    getGifFrames(t3) {
      return this.spriteTextures.getGifFrames(t3);
    }
    addFill(t3, e3, n2, i2, r3, o3 = false) {
      var s3;
      const a2 = JSON.stringify(e3) + n2 + i2, l2 = hM()(a2);
      if (this.idToHashMap[t3] = l2, this.hashToIdMap[l2] || (this.hashToIdMap[l2] = []), this.hashToIdMap[l2].push(t3), !(this.textures[l2] || this.fillStyles.findIndex((t4) => t4.hash === l2) >= 0))
        if (e3.fillType !== "blipFill") {
          const t4 = { x: 0, y: 0 };
          e3.fillType === "solidFill" && (n2 += 2, i2 += 2, t4.x = 1, t4.y = 1), this.fillStyles.push({ fill: e3, width: n2, height: i2, hash: l2, name: r3, pivot: t4 });
        } else {
          const t4 = this.spriteTextures.getTexture(e3.src), n3 = this.spriteTextures.getFrameData(e3.src);
          if (t4) {
            const i3 = new Ow();
            i3.texture = t4, e3.filters.length > 0 && o3 && (i3.filters = function(t5) {
              const e4 = [];
              return t5.forEach((t6) => {
                if (t6.type === "biLevel")
                  e4.push(new KM("biLevel", t6.args[0]));
                else if (t6.type === "clrChange" || t6.type === "changeBulletColor") {
                  const n4 = VM(t6.args[0]), i4 = VM(t6.args[1]);
                  e4.push(new eA(t6.type, n4, i4));
                } else
                  t6.type === "alphaModFix" ? e4.push(new KM(t6.type, t6.args[0])) : t6.type === "lum" && e4.push(new rA(t6.type, t6.args[0], t6.args[1]));
              }), e4;
            }(e3.filters)), this.fillStyles.push({ fill: e3, width: (n3 == null ? void 0 : n3.rotate) ? t4.height : t4.width, height: (n3 == null ? void 0 : n3.rotate) ? t4.width : t4.height, hash: l2, blipFillObject: i3, pivot: { x: 0, y: 0 }, rotate: (s3 = n3 == null ? void 0 : n3.rotate) !== null && s3 !== void 0 ? s3 : 0 });
          }
        }
    }
    hasLocalCache() {
      return oA(this, void 0, void 0, function* () {
        if (!this.cache)
          return false;
        try {
          const t3 = yield this.cache.getItem(this.slideIndex + "-length");
          if (t3) {
            const e3 = yield this.cache.keys(), n2 = new RegExp(`^${this.slideIndex}-texture`);
            return e3.filter((t4) => n2.test(t4)).length === t3;
          }
          return false;
        } catch (t3) {
          return false;
        }
      });
    }
    setCacheLength(t3) {
      return this.cache ? this.cache.setItem(this.slideIndex + "-length", t3) : Promise.resolve(0);
    }
    getTextureKeys() {
      return oA(this, void 0, void 0, function* () {
        if (!this.cache)
          return [];
        const t3 = yield this.cache.keys(), e3 = new RegExp(`^${this.slideIndex}-texture`);
        return t3.filter((t4) => e3.test(t4));
      });
    }
    loadFromCache(t3) {
      return oA(this, void 0, void 0, function* () {
        if (!this.cache)
          return;
        const e3 = yield this.cache.getItem(t3), n2 = new wy(e3), i2 = yield this.cache.getItem(t3.replace("texture", "json")), r3 = yield this.cache.getItem(t3.replace("texture", "map"));
        Object.keys(r3).forEach((t4) => {
          this.hashToIdMap[t4] = r3[t4], r3[t4].forEach((e4) => {
            this.idToHashMap[e4] = t4;
          });
        }), Object.keys(i2).forEach((t4) => {
          const e4 = i2[t4], r4 = new ky(n2, new d_(e4.x, e4.y, e4.w, e4.h));
          this.textures[t4] = { texture: r4, pivot: e4.pivot };
        });
      });
    }
    pack() {
      const t3 = this.fillStyles.filter((t4) => !(!t4.fill.fillType || t4.fill.fillType === "noFill" || t4.width === 0 || t4.height === 0) || (this.textures[t4.hash] = { texture: null, pivot: { x: 0, y: 0 } }, false));
      t3.forEach((t4) => {
        t4.width += 4, t4.height += 4;
      });
      return rM(t3);
    }
    destroy() {
      Object.keys(this.textures).forEach((t3) => {
        var e3;
        (e3 = this.textures[t3].texture) === null || e3 === void 0 || e3.destroy();
      }), this.textures = Object.create(null), this.fillStyles = [], this.renderTextures.forEach((t3) => t3.destroy(true)), this.renderTextures = [], this.renderContainers.forEach((t3) => t3.destroy({ children: true })), this.renderContainers = [], this.spriteTextures.destroy(), this.idToHashMap = Object.create(null), this.hashToIdMap = Object.create(null);
    }
  }
  class aA {
    constructor() {
      this.runningTimeNodes = {};
    }
    addRunningTimeNode(t3, e3, n2) {
      const i2 = `${e3}_${t3}`;
      if (this.runningTimeNodes[i2])
        try {
          this.runningTimeNodes[i2].dispose(true);
        } catch (t4) {
        }
      this.runningTimeNodes[i2] = n2;
    }
  }
  class lA {
    constructor(t3) {
      this.eventHub = t3, this.targets = Object.create(null);
    }
    addTarget(t3, e3) {
      this.targets[t3] = e3;
    }
    getTargetById(t3) {
      return this.targets[t3];
    }
    getTarget(t3, e3, n2 = { type: "el", index: 0, id: "" }) {
      var i2, r3;
      let o3 = this.targets[t3.id];
      return t3.type !== "shape" ? o3 : (t3.type === "shape" && t3.txEl && (o3 = (i2 = o3 == null ? void 0 : o3.getTextElement(t3.txEl.type, t3.txEl.range)) !== null && i2 !== void 0 ? i2 : null), t3.type === "shape" && t3.bg && n2.index === 0 && (e3 = false, o3 = (r3 = o3 == null ? void 0 : o3.getBgElement()) !== null && r3 !== void 0 ? r3 : null, this.eventHub.emit("IterateTimeNodeEnd", n2.id)), e3 && o3 ? o3.getIterateEntry(n2.type, n2.index, n2.id) : o3);
    }
    clearTargets() {
      this.targets = Object.create(null);
    }
  }
  class uA {
    constructor(t3) {
      this.target = t3;
    }
    get color() {
      return this.target.strokeColorFilter.currentColor;
    }
    set color(t3) {
      this.target.strokeColorFilter.color = t3;
    }
    get on() {
      return this.target.strokeActive ? "true" : "false";
    }
    set on(t3) {
      this.target.strokeActive = t3 === "true";
    }
  }
  class hA {
    constructor(t3) {
      this.target = t3;
    }
    applyCommand(t3, e3) {
      this.target.applyCommand(t3, e3);
    }
  }
  class cA {
    constructor(t3) {
      this.target = t3;
    }
    get color() {
      return this.target.fillColorFilter.currentColor;
    }
    set color(t3) {
      this.target.fillActive && (this.target.fillColorFilter.color = t3);
    }
    get on() {
      return this.target.fillActive ? "true" : "false";
    }
    set on(t3) {
      this.target.fillActive = t3 === "true";
    }
  }
  class dA {
    constructor(t3, e3) {
      this.hardHidden = false, this.target = t3, e3 === true && (this.hardHidden = true);
    }
    get opacity() {
      return this.target.alpha;
    }
    set opacity(t3) {
      this.target.alpha = t3;
    }
    get rotation() {
      return this.target.rotation / Math.PI * 180;
    }
    set rotation(t3) {
      this.target.rotation = t3 / 180 * Math.PI;
    }
    get visibility() {
      return this.target.visible ? "visible" : "hidden";
    }
    set visibility(t3) {
      this.visibility === t3 || this.hardHidden || (this.target.visible = t3 === "visible");
    }
  }
  class pA {
    constructor(t3, e3) {
      this.actions = [], this.ctx = e3, this.object = t3, this.object.interactive = true;
    }
    reset(t3) {
      this.object.interactive = false, this.object.removeAllListeners(), this.object = t3, this.object.interactive = true;
    }
    addAction(t3, e3) {
      this.actions.push([t3, e3]), e3 === "click" ? (this.object.addListener("click", () => this.handleAction(t3)), this.object.cursor = "pointer") : e3 === "hover" && this.object.addListener("mouseover", () => this.handleAction(t3));
    }
    addProxy(t3) {
      this.proxy = t3, this.hitArea = this.getOriginHitArea(), this.proxy.interactive = true, this.actions.forEach(([t4, e3]) => {
        var n2, i2;
        e3 === "click" ? (n2 = this.proxy) === null || n2 === void 0 || n2.addListener("click", (e4) => this.handleProxyAction(e4, t4)) : e3 === "hover" && ((i2 = this.proxy) === null || i2 === void 0 || i2.addListener("mouseover", (e4) => this.handleProxyAction(e4, t4)));
      });
    }
    handleProxyAction(t3, e3) {
      var n2;
      const i2 = t3.data.global, r3 = this.object.getGlobalPosition(), o3 = i2.x - r3.x + this.object.pivot.x, s3 = i2.y - r3.y + this.object.pivot.y;
      ((n2 = this.hitArea) === null || n2 === void 0 ? void 0 : n2.contains(o3, s3)) && this.object.visible && this.handleAction(e3, true);
    }
    getOriginHitArea() {
      return this.object.hitArea ? this.object.hitArea : new g_(0, 0, this.object.width, this.object.height);
    }
    handleAction(t3, e3 = false) {
      this.proxy && !e3 || (this.ctx.eventHub.emit($R.hyperlinkTrigger, t3), this.execAction(t3));
    }
    execAction(t3) {
      var e3;
      if (t3.action === "ppaction://hlinksldjump") {
        const n2 = ((e3 = t3 == null ? void 0 : t3.target) !== null && e3 !== void 0 ? e3 : "").match(/slide(\d+)\.xml/);
        n2 && n2[1] && this.ctx.eventHub.emit($R.requestGotoSlide, Number(n2[1]));
      } else if (t3.action === "ppaction://hlinkshowjump?jump=nextslide")
        this.ctx.eventHub.emit($R.requestNextSlide);
      else if (t3.action === "ppaction://hlinkshowjump?jump=previousslide")
        this.ctx.eventHub.emit($R.requestPrevSlide);
      else if (t3.action === "ppaction://hlinkshowjump?jump=firstslide")
        this.ctx.eventHub.emit($R.requestGotoSlide, 1);
      else if (t3.action === "ppaction://hlinkshowjump?jump=lastslide")
        this.ctx.eventHub.emit($R.requestGotoSlide, -1);
      else if (t3.action === "ppaction://hlinkshowjump?jump=lastslideviewed") {
        const t4 = this.ctx.lastViewedIndex;
        this.ctx.eventHub.emit($R.requestGotoSlide, t4);
      } else
        t3.action === "ppaction://hlinkshowjump?jump=endshow" && this.ctx.eventHub.emit($R.requestGotoSlide, -1);
    }
  }
  class fA {
    constructor(t3, e3, n2) {
      var i2, r3, o3, s3, a2, l2;
      this.scaleExt = { x: 1, y: 1 }, this.scaleOrigin = { x: 1, y: 1 }, this.designScale = { x: 1, y: 1 }, this.bound = new d_(0, 0, 1, 1), this.pptX = 0, this.pptY = 0, this.presetSubType = 0, this.designWidth = 0, this.designHeight = 0, this.designX = 0, this.designY = 0, this.hasPreset = false, this.container = new ty(), this.ctx = e3, this.style = new dA(this.container, t3.hardHidden), this.designGlobalPosition = { x: n2.x + ((r3 = (i2 = t3.position) === null || i2 === void 0 ? void 0 : i2.x) !== null && r3 !== void 0 ? r3 : 0), y: n2.y + ((s3 = (o3 = t3.position) === null || o3 === void 0 ? void 0 : o3.y) !== null && s3 !== void 0 ? s3 : 0) }, (t3.hlinkClick || t3.hlinkHover) && (this.hyperlink = new pA(this.container, this.ctx), t3.hlinkHover && ((a2 = this.hyperlink) === null || a2 === void 0 || a2.addAction(t3.hlinkHover, "hover")), t3.hlinkClick && ((l2 = this.hyperlink) === null || l2 === void 0 || l2.addAction(t3.hlinkClick, "click")));
    }
    updateScale() {
      this.container && (this.container.scale.x = this.designScale.x * this.scaleExt.x * this.scaleOrigin.x, this.container.scale.y = this.designScale.y * this.scaleExt.y * this.scaleOrigin.y);
    }
    updateTransform(t3) {
      var e3, n2, i2, r3, o3, s3, a2, l2;
      this.designWidth = t3.width, this.designHeight = t3.height, this.designX = (n2 = (e3 = t3.position) === null || e3 === void 0 ? void 0 : e3.x) !== null && n2 !== void 0 ? n2 : 0, this.designY = (r3 = (i2 = t3.position) === null || i2 === void 0 ? void 0 : i2.y) !== null && r3 !== void 0 ? r3 : 0;
      const u2 = this.designWidth / 2, h2 = this.designHeight / 2;
      this.container.width = this.designWidth, this.container.height = this.designHeight, this.container.pivot.x = u2, this.container.pivot.y = h2;
      const c2 = (s3 = (o3 = t3.position) === null || o3 === void 0 ? void 0 : o3.x) !== null && s3 !== void 0 ? s3 : 0, d2 = (l2 = (a2 = t3.position) === null || a2 === void 0 ? void 0 : a2.y) !== null && l2 !== void 0 ? l2 : 0;
      this.container.x = c2 + u2, this.container.y = d2 + h2, t3.scale && (this.designScale = { x: t3.scale.x, y: t3.scale.y }, this.container.scale.x = t3.scale.x, this.container.scale.y = t3.scale.y), t3.rotation && (this.container.rotation = t3.rotation);
      const p2 = new Aw();
      p2.drawRect(0, 0, this.designWidth, this.designHeight), this.container.addChild(p2), this.json.hardHidden && (this.container.visible = false), this.bound.x = c2, this.bound.y = d2, this.bound.width = this.designWidth, this.bound.height = this.designHeight;
    }
    get scale() {
      return this.scaleOrigin;
    }
    set scale(t3) {
      this.scaleOrigin.x = t3.x, this.scaleOrigin.y = t3.y, this.updateScale();
    }
    get design_ppt_w() {
      return eM(this.designWidth / this.ctx.stageWidth);
    }
    get design_ppt_h() {
      return eM((this.designHeight || this.container.height) / this.ctx.stageHeight);
    }
    get design_ppt_x() {
      return eM(this.designX / this.ctx.stageWidth);
    }
    get design_ppt_y() {
      return eM(this.designY / this.ctx.stageHeight);
    }
    get ppt_w() {
      return this.scaleExt.x * this.scaleOrigin.x * this.designWidth / this.ctx.stageWidth;
    }
    set ppt_w(t3) {
      this.scaleExt.x = t3 * this.ctx.stageWidth / this.designWidth, this.updateScale();
    }
    get ppt_h() {
      const t3 = this.designHeight || this.container.height;
      return this.scaleExt.y * this.scaleOrigin.y * t3 / this.ctx.stageHeight;
    }
    set ppt_h(t3) {
      const e3 = this.designHeight || this.container.height;
      this.scaleExt.y = t3 * this.ctx.stageHeight / e3, this.updateScale();
    }
    get ppt_x() {
      return (this.container.position.x - this.container.pivot.x) / this.ctx.stageWidth;
    }
    set ppt_x(t3) {
      this.pptX = t3;
      const e3 = this.presetSubType === 544 ? this.scaleExt.x : 1;
      this.container.position.x = t3 * this.ctx.stageWidth + this.container.pivot.x * e3;
    }
    get ppt_y() {
      return (this.container.position.y - this.container.pivot.y) / this.ctx.stageHeight;
    }
    set ppt_y(t3) {
      this.pptY = t3;
      const e3 = this.presetSubType === 544 ? this.scaleExt.y : 1;
      this.container.position.y = t3 * this.ctx.stageHeight + this.container.pivot.y * e3;
    }
    get r() {
      return this.container.rotation;
    }
    set r(t3) {
      this.container.rotation = t3;
    }
  }
  class mA extends Gx {
    constructor() {
      super(void 0, "\nvarying vec2 vTextureCoord;\n\nuniform vec4 color;\nuniform sampler2D uSampler;\n\nvoid main(void){\n    vec4 texColor = texture2D(uSampler, vTextureCoord);\n\n    if (texColor.a > 0.0) {\n        vec4 resultColor = color;\n        resultColor = resultColor * texColor.a;\n        gl_FragColor = resultColor;\n    } else {\n        gl_FragColor = texColor;\n    }\n}\n", { color: new Float32Array([0, 0, 0, 0]), active: 0 }), this.currentColor = "#FFFFFFFF";
    }
    set color(t3) {
      this.currentColor = t3;
      const e3 = VM(t3);
      this.uniforms.color = Float32Array.from(e3);
    }
    get color() {
      return this.currentColor;
    }
  }
  const gA = new VE.ColorMatrixFilter();
  gA.matrix = [1, 0, 0, 0, -0.2, 0, 1, 0, 0, -0.2, 0, 0, 1, 0, -0.2, 0, 0, 0, 1, 0];
  const vA = new VE.ColorMatrixFilter();
  vA.matrix = [1, 0, 0, 0, -0.1, 0, 1, 0, 0, -0.1, 0, 0, 1, 0, -0.1, 0, 0, 0, 1, 0];
  const _A = new VE.ColorMatrixFilter();
  _A.matrix = [1, 0, 0, 0, 0.2, 0, 1, 0, 0, 0.2, 0, 0, 1, 0, 0.2, 0, 0, 0, 1, 0];
  const yA = new VE.ColorMatrixFilter();
  yA.matrix = [1, 0, 0, 0, 0.1, 0, 1, 0, 0, 0.1, 0, 0, 1, 0, 0.1, 0, 0, 0, 1, 0];
  const xA = { darken: gA, darkenLess: vA, lightenLess: yA, lighten: _A };
  class bA extends fA {
    constructor(t3, e3, n2) {
      super({ position: { x: t3.x, y: t3.y }, width: t3.width, height: t3.height }, e3, n2), this.fillColorFilter = new mA(), this.fill = new cA(this), this.json = t3, this.ctx = e3, this.parentGlobalPos = n2, this.global = { x: n2.x + t3.x, y: n2.y + t3.y }, this.updateTransform({ position: { x: t3.x, y: t3.y }, width: t3.width, height: t3.height });
    }
    get fillActive() {
      var t3, e3;
      return ((e3 = (t3 = this.container.filters) === null || t3 === void 0 ? void 0 : t3.length) !== null && e3 !== void 0 ? e3 : -1) > 0;
    }
    set fillActive(t3) {
      var e3, n2;
      t3 ? ((n2 = (e3 = this.container.filters) === null || e3 === void 0 ? void 0 : e3.indexOf(this.fillColorFilter)) !== null && n2 !== void 0 ? n2 : -1) < 0 && (this.container.filters = [this.fillColorFilter]) : this.container.filters = [];
    }
    get renderContainer() {
      return this.container;
    }
    get interactiveContainer() {
      return this.container;
    }
    clearOnSlideChange() {
    }
    getTextElement() {
      return null;
    }
    getBgElement() {
      return null;
    }
    get ppt_x() {
      return this.global.x / this.ctx.stageWidth;
    }
    set ppt_x(t3) {
      const e3 = t3 * this.ctx.stageWidth - this.global.x, n2 = this.presetSubType === 544 ? this.scaleExt.x : 1;
      this.container.position.x = this.designX + e3 + this.container.pivot.x * n2;
    }
    get ppt_y() {
      return this.global.y / this.ctx.stageHeight;
    }
    set ppt_y(t3) {
      const e3 = t3 * this.ctx.stageHeight - this.global.y, n2 = this.presetSubType === 544 ? this.scaleExt.y : 1;
      this.container.position.y = this.designY + e3 + this.container.pivot.y * n2;
    }
    get design_ppt_x() {
      return eM(this.global.x / this.ctx.stageWidth);
    }
    get design_ppt_y() {
      return eM(this.global.y / this.ctx.stageHeight);
    }
  }
  class TA {
    constructor(t3, e3, n2, i2, r3) {
      this.renderContainer = new ty(), this.ctx = t3, this.ghcTextureId = `${e3}-text-p${n2}-l${i2}-u${r3}-underLine`;
    }
    render() {
      if (this.ghcTextureId) {
        const t3 = this.ctx.graphicsTexture.getGraphicsData(this.ghcTextureId);
        t3 && (this.sprite = new Ow(), this.sprite.pivot.x = t3.pivot.x, this.sprite.texture = t3.texture);
      }
    }
    destroy() {
      var t3;
      (t3 = this.sprite) === null || t3 === void 0 || t3.destroy();
    }
  }
  var wA = function(t3, e3, n2, i2) {
    return new (n2 || (n2 = Promise))(function(r3, o3) {
      function s3(t4) {
        try {
          l2(i2.next(t4));
        } catch (t5) {
          o3(t5);
        }
      }
      function a2(t4) {
        try {
          l2(i2.throw(t4));
        } catch (t5) {
          o3(t5);
        }
      }
      function l2(t4) {
        var e4;
        t4.done ? r3(t4.value) : (e4 = t4.value, e4 instanceof n2 ? e4 : new n2(function(t5) {
          t5(e4);
        })).then(s3, a2);
      }
      l2((i2 = i2.apply(t3, e3 || [])).next());
    });
  };
  class SA extends bA {
    constructor(t3, e3, n2, i2) {
      super(t3, e3, n2), this.fillMaskSprite = new Ow(), this.fillSprite = new Ow(), this.strokeMaskSprite = new Ow(), this.strokeSprite = new Ow(), this.textureContainer = new ty(), this.underline = null, this.cacheSprite = new Ow();
      const { shapeId: r3, paragraphIndex: o3, lineIndex: s3, unitIndex: a2 } = t3, { underLine: l2 } = this.json;
      l2 && (this.underline = new TA(e3, r3, o3, s3, a2)), this.shapeCacheAsBitMap = i2, this.fillTextureId = `${r3}-text-p${o3}-l${s3}-u${a2}-fill`, this.fillBgId = `${r3}-text-p${o3}-l${s3}-u${a2}-fill-bg`, this.strokeTextureId = `${r3}-text-p${o3}-l${s3}-u${a2}-stroke`, this.strokeBgId = `${r3}-text-p${o3}-l${s3}-u${a2}-stroke-bg`;
    }
    getIterateEntry() {
      return null;
    }
    getBgElement() {
      return null;
    }
    updateTransform(t3) {
      var e3, n2, i2, r3;
      const { isHorz: o3 } = this.json;
      t3.position = { x: o3 && (n2 = (e3 = t3.position) === null || e3 === void 0 ? void 0 : e3.x) !== null && n2 !== void 0 ? n2 : 0, y: o3 ? 0 : (r3 = (i2 = t3.position) === null || i2 === void 0 ? void 0 : i2.y) !== null && r3 !== void 0 ? r3 : 0 }, t3.width = o3 ? this.json.width : this.json.lineWidth, t3.height = o3 ? this.json.lineHeight : this.json.height, super.updateTransform(t3);
    }
    preRender() {
    }
    render(t3) {
      t3.push(() => wA(this, void 0, void 0, function* () {
        this.doRenderer();
      }));
    }
    doRenderer() {
      var t3;
      const { lineWidth: e3, lineHeight: n2, baseLine: i2, isHorz: r3, underline: o3, height: s3, width: a2, highlightColor: l2, x: u2, y: h2, content: c2, fillLineHeight: d2 } = this.json;
      if (l2) {
        const t4 = new Aw(), [i3, o4] = jM(l2);
        t4.beginFill(i3, o4), t4.drawRect(0, 0, r3 ? a2 : e3, r3 ? n2 : s3), t4.endFill(), this.textureContainer.addChild(t4);
      }
      if (this.fillBgId && this.fillTextureId) {
        const t4 = this.ctx.fillTexture.getTexture(this.fillTextureId);
        (t4 == null ? void 0 : t4.texture) && (this.fillMaskSprite.texture = t4.texture, this.fillMaskSprite.scale.x = 0.5, this.fillMaskSprite.scale.y = 0.5);
        const e4 = this.ctx.fillTexture.getTexture(this.fillBgId);
        e4.texture && (this.fillSprite.texture = e4.texture, this.fillSprite.mask = this.fillMaskSprite, this.fillSprite.addChild(this.fillMaskSprite), r3 ? this.fillSprite.position.y = h2 > 0 ? h2 : 0 : this.fillSprite.position.x = u2, this.textureContainer.addChild(this.fillSprite));
      }
      if (this.strokeBgId && this.strokeTextureId) {
        const t4 = this.ctx.fillTexture.getTexture(this.strokeTextureId);
        (t4 == null ? void 0 : t4.texture) && (this.strokeMaskSprite.texture = t4.texture, this.strokeMaskSprite.scale.x = 0.5, this.strokeMaskSprite.scale.y = 0.5);
        const e4 = this.ctx.fillTexture.getTexture(this.strokeBgId);
        (e4 == null ? void 0 : e4.texture) && (this.strokeSprite.texture = e4.texture, this.strokeSprite.mask = this.strokeMaskSprite, this.strokeSprite.addChild(this.strokeMaskSprite), r3 ? this.strokeSprite.position.y = h2 > 0 ? h2 : 0 : this.strokeSprite.position.x = u2, this.textureContainer.addChild(this.strokeSprite));
      }
      if (this.underline && (this.underline.render(), this.underline.sprite && this.fillMaskSprite)) {
        let e4 = null;
        this.fillBgId && (e4 = this.ctx.fillTexture.getTexture(this.fillBgId)), this.underline.sprite.position.y = o3 ? o3 - n2 / 16 : i2, this.underline.sprite.position.x = 0;
        const r4 = new Ow();
        r4.texture = (t3 = e4 == null ? void 0 : e4.texture) !== null && t3 !== void 0 ? t3 : null, r4.mask = this.underline.sprite, r4.addChild(this.underline.sprite), this.textureContainer.addChild(r4);
      }
      if (this.shapeCacheAsBitMap)
        this.container.addChild(this.textureContainer);
      else {
        const t4 = Hy.create({ width: r3 ? a2 : e3, height: r3 ? Math.max(d2, n2) : s3, resolution: 2 });
        KR.textureCacheSize += t4.width * t4.height * 2, this.ctx.renderer.render(this.textureContainer, { renderTexture: t4 }), this.cacheSprite.texture = t4, r3 && h2 < 0 && (this.cacheSprite.position.y = h2), this.container.addChild(this.cacheSprite);
      }
      this.container.name = c2;
    }
    destroy() {
      this.cacheSprite.texture.destroy(true), this.cacheSprite.destroy({ texture: true, baseTexture: true }), this.textureContainer.destroy({ texture: true }), this.container.destroy({ children: true, texture: true });
    }
  }
  var EA = function(t3, e3, n2, i2) {
    return new (n2 || (n2 = Promise))(function(r3, o3) {
      function s3(t4) {
        try {
          l2(i2.next(t4));
        } catch (t5) {
          o3(t5);
        }
      }
      function a2(t4) {
        try {
          l2(i2.throw(t4));
        } catch (t5) {
          o3(t5);
        }
      }
      function l2(t4) {
        var e4;
        t4.done ? r3(t4.value) : (e4 = t4.value, e4 instanceof n2 ? e4 : new n2(function(t5) {
          t5(e4);
        })).then(s3, a2);
      }
      l2((i2 = i2.apply(t3, e3 || [])).next());
    });
  };
  class MA extends bA {
    constructor(t3, e3, n2, i2) {
      super(t3, e3, n2), this.units = [], this.isHorz = true, this.shapeCacheAsBitMap = i2;
    }
    getIterateElements() {
      return this.units;
    }
    getIterateEntry(t3, e3, n2) {
      return this.units[e3] ? this.units[e3] : (this.ctx.eventHub.emit("IterateTimeNodeEnd", n2), null);
    }
    preRender() {
    }
    createUnits(t3, e3, n2) {
      for (let i2 = 0, r3 = this.json.textUnits.length; i2 < r3; i2++) {
        const r4 = this.json.textUnits[i2];
        if (!r4.content)
          continue;
        const { height: o3, width: s3, fillHeight: a2, baseline: l2, y: u2, underline: h2 } = this.json, c2 = new SA(Object.assign(Object.assign({}, r4), { lineHeight: o3, lineWidth: s3, baseLine: l2 - u2, underline: h2, fillLineHeight: a2 || o3, isHorz: this.isHorz, shapeId: t3, paragraphIndex: e3, lineIndex: n2, unitIndex: i2 }), this.ctx, this.global, this.shapeCacheAsBitMap);
        c2.preRender(), this.units.push(c2);
      }
    }
    render(t3) {
      for (const e3 of this.units.reverse())
        e3.render(t3), t3.push(() => EA(this, void 0, void 0, function* () {
          this.container.addChild(e3.container);
        }));
    }
    destroy() {
      this.units.forEach((t3) => {
        t3.destroy();
      }), this.container.destroy({ children: false });
    }
  }
  var AA = function(t3, e3, n2, i2) {
    return new (n2 || (n2 = Promise))(function(r3, o3) {
      function s3(t4) {
        try {
          l2(i2.next(t4));
        } catch (t5) {
          o3(t5);
        }
      }
      function a2(t4) {
        try {
          l2(i2.throw(t4));
        } catch (t5) {
          o3(t5);
        }
      }
      function l2(t4) {
        var e4;
        t4.done ? r3(t4.value) : (e4 = t4.value, e4 instanceof n2 ? e4 : new n2(function(t5) {
          t5(e4);
        })).then(s3, a2);
      }
      l2((i2 = i2.apply(t3, e3 || [])).next());
    });
  };
  class RA extends bA {
    constructor(t3, e3, n2, i2) {
      super(t3, e3, n2), this.iterateElements = [], this.lines = [], this.isHorz = true, this.shapeCacheAsBitMap = i2;
    }
    getIterateElements() {
      if (this.iterateElements.length > 0)
        return this.iterateElements;
      const t3 = this.lines.reduce((t4, e3) => t4 = t4.concat(e3.getIterateElements()), []);
      return this.iterateElements = t3, t3;
    }
    getIterateEntry(t3, e3, n2) {
      const i2 = this.getIterateElements();
      return i2[e3] ? i2[e3] : (this.ctx.eventHub.emit("IterateTimeNodeEnd", n2), null);
    }
    preRender() {
    }
    createLines(t3, e3) {
      for (let n2 = 0, i2 = this.json.lines.length; n2 < i2; n2++) {
        const i3 = this.json.lines[n2], r3 = new MA(i3, this.ctx, this.global, this.shapeCacheAsBitMap);
        r3.isHorz = this.isHorz, r3.container.name = "line-" + n2, r3.createUnits(t3, e3, n2), this.lines.push(r3);
      }
    }
    render(t3) {
      for (const e3 of this.lines)
        e3.render(t3), t3.push(() => AA(this, void 0, void 0, function* () {
          this.container.addChild(e3.container);
        }));
    }
    destroy() {
      this.lines.forEach((t3) => {
        t3.destroy();
      }), this.container.destroy({ children: false });
    }
  }
  var PA = function(t3, e3, n2, i2) {
    return new (n2 || (n2 = Promise))(function(r3, o3) {
      function s3(t4) {
        try {
          l2(i2.next(t4));
        } catch (t5) {
          o3(t5);
        }
      }
      function a2(t4) {
        try {
          l2(i2.throw(t4));
        } catch (t5) {
          o3(t5);
        }
      }
      function l2(t4) {
        var e4;
        t4.done ? r3(t4.value) : (e4 = t4.value, e4 instanceof n2 ? e4 : new n2(function(t5) {
          t5(e4);
        })).then(s3, a2);
      }
      l2((i2 = i2.apply(t3, e3 || [])).next());
    });
  };
  class CA {
    constructor(t3, e3, n2, i2, r3) {
      this.iterateElements = [], this.paragraphs = [], this.container = new ty(), this.json = t3, this.ctx = e3, this.parentGlobalPos = i2, this.shapeCacheAsBitMap = r3, this.iterateType = n2, this.container.name = "textBody", this.global = { x: this.parentGlobalPos.x + t3.position.x, y: this.parentGlobalPos.y + t3.position.y }, this.container.position.x = t3.position.x, this.container.position.y = t3.position.y, this.container.scale.x = t3.scale.x, this.container.scale.y = t3.scale.y;
      const o3 = new Aw();
      o3.drawRect(0, 0, t3.width, t3.height), this.container.addChild(o3);
    }
    get width() {
      return this.json.width;
    }
    get height() {
      return this.json.height;
    }
    get x() {
      return this.json.position.x;
    }
    get y() {
      return this.json.position.y;
    }
    getTextElement(t3, e3) {
      return t3 === "paragraph" ? this.paragraphs[e3[0]] : null;
    }
    getIterateEntry(t3, e3) {
      return this.iterateElements[t3] ? this.iterateElements[t3] : (this.ctx.eventHub.emit("IterateTimeNodeEnd", e3), null);
    }
    destroy() {
      this.paragraphs.forEach((t3) => {
        t3.destroy();
      });
    }
    createParagraphs(t3) {
      var e3;
      for (let n2 = 0, i2 = this.json.paragraphs.length; n2 < i2; n2++) {
        const i3 = this.json.paragraphs[n2], r3 = new RA(i3, this.ctx, this.global, this.shapeCacheAsBitMap);
        r3.isHorz = (e3 = this.json.isHorz) === null || e3 === void 0 || e3, r3.createLines(t3, n2), this.iterateElements = this.iterateElements.concat(r3.getIterateElements()), r3.container.name = "\u6BB5\u843D-" + n2, this.paragraphs.push(r3);
      }
    }
    render(t3) {
      for (const e3 of this.paragraphs)
        e3.render(t3), t3.push(() => PA(this, void 0, void 0, function* () {
          this.container.addChild(e3.container);
        }));
      t3.push(() => PA(this, void 0, void 0, function* () {
        const { width: t4 } = this.container;
        this.container.scale.x < 0 && (this.container.x += -1 * t4);
      }));
    }
  }
  var IA = n(48), OA = n.n(IA), LA = n(49), NA = n.n(LA);
  const DA = { Reflection: class extends Gx {
    constructor(t3) {
      super(OA.a, NA.a, { uShapeFilterArea: new Float32Array([0, 0, 0, 0]), uStartAlpha: t3.startAlpha, uEndAlpha: t3.endAlpha, uBlur: 0 }), this.json = t3;
    }
  } };
  class FA {
    constructor(t3) {
      this.scaleX = 1, this.scaleY = 1, this.pivot = { x: 0, y: 0 }, this.paths = [], this.hash = "", this.width = 0, this.height = 0, this.graphicsId = "", this.textureId = "", this.id = t3.id, this.type = t3.type, this.heightSize = t3.heightSize, this.widthSize = t3.widthSize, this.fillStyle = t3.fillStyle || { fillType: "solidFill", color: "#ffffffff" }, this.lineWidth = t3.lineWidth || 1, this.position = t3.position || { x: 0, y: 0 }, this.rotate = t3.rotation || 1, this.path = this.getUnitPath(), this.setScaleFromLineWidth(), this.setScaleFromSize(), this.generatePaths(), this.setPivot();
    }
    setPivot() {
      switch (this.type) {
        case "oval":
        case "diamond":
          this.pivot = { x: this.width / 2, y: this.height / 2 };
          break;
        case "arrow":
        case "stealth":
        case "triangle":
        default:
          this.pivot = { x: this.width, y: this.height / 2 };
      }
    }
    generatePaths() {
      this.hash = "arrow-" + hM()(this.path + this.scaleX + this.scaleY), this.paths = [{ id: this.id, path: this.path, fill: "norm", hasStroke: false, hash: this.hash, scale: { x: this.scaleX, y: this.scaleY } }];
    }
    getUnitPath() {
      switch (this.type) {
        case "stealth":
          return "M 0,0 L 95250,47625 L 0,95250 L 28575,47625 C C";
        case "oval":
          return "M 0,47625 A 47625,47625,-3.14159265,6.2831853 C C";
        case "diamond":
          return "M 47625,0 L 95250,47625 L 47625,95250 L 0,47625 C C";
        case "arrow":
          return "M 9525,0 L 95250,47625 L 9525,95250 L 0,85725 L 68389.5,47625 L 0,9525 C C";
        case "triangle":
          return "M 0,0 L 95250,47625 L 0,95250 C C";
        default:
          return "";
      }
    }
    setScaleFromLineWidth() {
      switch (this.type) {
        case "stealth":
        case "oval":
        case "diamond":
        case "arrow":
        case "triangle":
          this.scaleX *= 0.29 * this.lineWidth + 0.7, this.scaleY *= 0.29 * this.lineWidth + 0.7;
          break;
        default:
          throw new Error("can't match any arrow type!");
      }
    }
    setScaleFromSize() {
      switch (this.type) {
        case "stealth":
        case "oval":
        case "diamond":
        case "arrow":
        case "triangle":
          this.scaleX *= 1, this.scaleY *= 1;
          break;
        default:
          throw new Error("can't match any arrow type!");
      }
      switch (this.widthSize) {
        case "sm":
          this.scaleX *= 3 / 4;
          break;
        case "lg":
          this.scaleX *= 1.25;
          break;
        case "med":
          this.scaleX *= 1;
      }
      switch (this.heightSize) {
        case "sm":
          this.scaleY *= 3 / 4;
          break;
        case "lg":
          this.scaleY *= 1.25;
          break;
        case "med":
          this.scaleY *= 1;
      }
      this.width = 10 * this.scaleX, this.height = 10 * this.scaleY;
    }
  }
  var BA = function(t3, e3, n2, i2) {
    return new (n2 || (n2 = Promise))(function(r3, o3) {
      function s3(t4) {
        try {
          l2(i2.next(t4));
        } catch (t5) {
          o3(t5);
        }
      }
      function a2(t4) {
        try {
          l2(i2.throw(t4));
        } catch (t5) {
          o3(t5);
        }
      }
      function l2(t4) {
        var e4;
        t4.done ? r3(t4.value) : (e4 = t4.value, e4 instanceof n2 ? e4 : new n2(function(t5) {
          t5(e4);
        })).then(s3, a2);
      }
      l2((i2 = i2.apply(t3, e3 || [])).next());
    });
  };
  const UA = { pivot: { x: 0, y: 0 }, width: 0, height: 0 };
  class kA extends fA {
    constructor(t3, e3, n2) {
      var i2, r3, o3;
      super(t3, e3, n2), this.renderContainer = new ty(), this.cacheSprite = new Ow(), this.bgSprite = new Ow(), this.filterAreaJustifies = [], this.backgroundMask = new Ow(), this.pathSprite = new Ow(), this.pathMask = new Ow(), this.arrowList = [], this.fillColorFilter = new mA(), this.strokeColorFilter = new mA(), this.id = "", this.fill = new cA(this), this.stroke = new uA(this), this.updateFilterArea = () => {
        const t4 = this.renderContainer.getBounds(false), e4 = this.filterAreaJustifies.map((e5) => e5(t4)), n3 = e4.map((t5) => t5.width), i3 = e4.map((t5) => t5.height), r4 = new d_(t4.x, t4.y, Math.max(...n3), Math.max(...i3));
        this.renderContainer.filterArea = r4, (this.renderContainer.filters || []).forEach((t5) => {
          t5.uniforms.uShapeFilterArea = new Float32Array(4), t5.uniforms.uShapeFilterArea[0] = r4.x, t5.uniforms.uShapeFilterArea[1] = r4.y, t5.uniforms.uShapeFilterArea[2] = r4.width, t5.uniforms.uShapeFilterArea[3] = r4.height;
        });
      }, this.json = t3, this.id = t3.id, this.container.name = t3.id, this.renderContainer.name = t3.id + "-render-container", this.fillStyle = t3.fillStyle, this.lineStyle = t3.lineStyle, this.pathMaskTextureId = t3.id + "-path-graphics", this.backgroundMaskTextureId = t3.id + "-bg-graphics", this.geometry = t3.geometry, this.bgTextureId = t3.id + "-bg-fill", this.pathStrokeTextureId = t3.id + "-path-fill", this.ctx.timingTargets.addTarget(this.id, this), ((i2 = this.fillStyle) === null || i2 === void 0 ? void 0 : i2.fillType) === "solidFill" && (this.fillColorFilter.currentColor = this.fillStyle.color), ((o3 = (r3 = this.lineStyle) === null || r3 === void 0 ? void 0 : r3.fill) === null || o3 === void 0 ? void 0 : o3.fillType) === "solidFill" && (this.strokeColorFilter.currentColor = this.lineStyle.fill.color), this.pathSprite.name = "path-fill", this.pathMask.name = "path-mask", this.bgSprite.name = "bg-fill", this.backgroundMask.name = "bg-mask", this.updateTransform(this.json), t3.textBody && (this.text = new CA(t3.textBody, this.ctx, t3.textBody.iterateType, { x: this.designGlobalPosition.x, y: this.designGlobalPosition.y }, !!this.json.cacheAsBitMap)), this.container.hitArea = new g_(1, 1, this.json.width, this.json.height);
    }
    get interactiveContainer() {
      return this.renderContainer;
    }
    get strokeActive() {
      var t3, e3;
      return ((e3 = (t3 = this.pathSprite.filters) === null || t3 === void 0 ? void 0 : t3.length) !== null && e3 !== void 0 ? e3 : -1) > 0;
    }
    set strokeActive(t3) {
      var e3, n2;
      t3 ? ((n2 = (e3 = this.pathSprite.filters) === null || e3 === void 0 ? void 0 : e3.indexOf(this.strokeColorFilter)) !== null && n2 !== void 0 ? n2 : -1) < 0 && (this.pathSprite.filters = [this.strokeColorFilter]) : this.pathSprite.filters = [];
    }
    get fillActive() {
      var t3, e3;
      return ((e3 = (t3 = this.bgSprite.filters) === null || t3 === void 0 ? void 0 : t3.length) !== null && e3 !== void 0 ? e3 : -1) > 0;
    }
    set fillActive(t3) {
      var e3, n2;
      t3 ? ((n2 = (e3 = this.bgSprite.filters) === null || e3 === void 0 ? void 0 : e3.indexOf(this.fillColorFilter)) !== null && n2 !== void 0 ? n2 : -1) < 0 && (this.bgSprite.filters = [this.fillColorFilter]) : this.bgSprite.filters = [];
    }
    getTextElement(t3, e3) {
      var n2, i2;
      return (i2 = (n2 = this.text) === null || n2 === void 0 ? void 0 : n2.getTextElement(t3, e3)) !== null && i2 !== void 0 ? i2 : null;
    }
    getBgElement() {
      return this;
    }
    getIterateEntry(t3, e3, n2) {
      return t3 === "el" || e3 === 0 ? this : this.text ? this.text.getIterateEntry(e3 - 1, n2) || null : (this.ctx.eventHub.emit("IterateTimeNodeEnd", n2), null);
    }
    createBackgroundMask() {
      const t3 = this.ctx.graphicsTexture.getGraphicsData(this.backgroundMaskTextureId);
      t3 && (this.backgroundMask.texture = t3.texture, this.backgroundMask.pivot.x = t3.pivot.x, this.backgroundMask.pivot.y = t3.pivot.y);
    }
    createBackground() {
      var t3, e3, n2, i2, r3, o3, s3, a2, l2;
      const { pivot: u2, width: h2, height: c2 } = ((t3 = this.geometry) === null || t3 === void 0 ? void 0 : t3.fillTransform) || UA;
      if (this.json.useBgFill && this.ctx.bgTexture)
        return this.bgSprite.texture = this.ctx.bgTexture, this.bgSprite.mask = this.backgroundMask, this.container.addChild(this.backgroundMask), this.container.addChild(this.bgSprite), this.bgSprite.x = u2.x, this.bgSprite.y = u2.y, this.bgSprite.pivot.x = ((e3 = this.json.position) === null || e3 === void 0 ? void 0 : e3.x) || 0, void (this.bgSprite.pivot.y = ((n2 = this.json.position) === null || n2 === void 0 ? void 0 : n2.y) || 0);
      if (((i2 = this.fillStyle) === null || i2 === void 0 ? void 0 : i2.fillType) === "gifFill") {
        const t4 = this.ctx.fillTexture.getGifFrames(this.fillStyle.src), e4 = t4.map((t5, e5) => ({ texture: t5, time: this.fillStyle.delays[e5] || 20 }));
        this.bgSprite = new jE(e4, true), this.bgSprite.play();
        let n3 = 1;
        const i3 = this.fillStyle.loop;
        this.bgSprite.onLoop = () => {
          n3 += 1, i3 > 0 && n3 > i3 && this.bgSprite.gotoAndStop(t4.length - 1);
        }, this.bgSprite.height = c2 || this.designHeight, this.bgSprite.width = h2 || this.designWidth, this.bgSprite.mask = this.backgroundMask, this.bgSprite.x = u2.x, this.bgSprite.y = u2.y, this.container.addChild(this.backgroundMask), this.container.addChild(this.bgSprite);
      } else if (((r3 = this.fillStyle) === null || r3 === void 0 ? void 0 : r3.fillType) === "groupFill") {
        if (this.groupFillTextureId) {
          const t4 = this.ctx.fillTexture.getTexture(this.groupFillTextureId);
          t4.texture && (this.bgSprite.texture = t4.texture, this.bgSprite.mask = this.backgroundMask, this.bgSprite.x = -1 * ((s3 = (o3 = this.json.position) === null || o3 === void 0 ? void 0 : o3.x) !== null && s3 !== void 0 ? s3 : 0), this.bgSprite.y = -1 * ((l2 = (a2 = this.json.position) === null || a2 === void 0 ? void 0 : a2.y) !== null && l2 !== void 0 ? l2 : 0), this.container.addChild(this.bgSprite), this.container.addChild(this.backgroundMask));
        }
      } else {
        const t4 = this.ctx.fillTexture.getTexture(this.bgTextureId);
        t4.texture && (this.bgSprite.texture = t4.texture, this.bgSprite.mask = this.backgroundMask, this.container.addChild(this.backgroundMask), this.container.addChild(this.bgSprite), this.bgSprite.x = u2.x, this.bgSprite.y = u2.y, this.bgSprite.pivot.x = t4.pivot.x, this.bgSprite.pivot.y = t4.pivot.y);
      }
    }
    createPathFill() {
      const t3 = this.ctx.fillTexture.getTexture(this.pathStrokeTextureId);
      t3.texture && (this.pathSprite.texture = t3.texture, this.pathSprite.pivot.x = this.pathMask.pivot.x, this.pathSprite.pivot.y = this.pathMask.pivot.y, this.pathMask.pivot.x = 0, this.pathMask.pivot.y = 0, this.pathSprite.mask = this.pathMask, this.pathSprite.addChild(this.pathMask), this.container.addChild(this.pathSprite));
    }
    createPathMask() {
      const t3 = this.ctx.graphicsTexture.getGraphicsData(this.pathMaskTextureId);
      if (t3) {
        const { texture: e3, pivot: n2 } = t3;
        this.pathMask.texture = e3, this.pathMask.pivot.x = n2.x, this.pathMask.pivot.y = n2.y, this.pathMask.texture = e3;
      }
    }
    createFilledPathMask() {
      var t3, e3;
      const n2 = ((e3 = (t3 = this.geometry) === null || t3 === void 0 ? void 0 : t3.paths) === null || e3 === void 0 ? void 0 : e3.filter((t4) => t4.fill !== "none" && t4.fill !== "norm")) || [];
      for (const t4 of n2) {
        const e4 = this.ctx.graphicsTexture.getGraphicsData(t4.id);
        if (e4) {
          const n3 = new Ow(e4.texture);
          n3.pivot.x = e4.pivot.x, n3.pivot.y = e4.pivot.y;
          const i2 = new Ow(this.bgSprite.texture);
          i2.pivot.x = this.bgSprite.pivot.x, i2.pivot.y = this.bgSprite.pivot.y, i2.mask = n3, i2.filters = [xA[t4.fill]], this.container.addChild(i2), this.container.addChild(n3);
        }
      }
    }
    createArrow() {
      this.arrowList.forEach((t3) => {
        const e3 = this.ctx.graphicsTexture.getGraphicsData(t3.graphicsId), n2 = this.ctx.fillTexture.getTexture(t3.textureId);
        if (e3 && n2.texture) {
          const { texture: i2, pivot: r3 } = e3, o3 = new Ow(i2);
          o3.pivot.x = r3.x, o3.pivot.y = r3.y;
          const s3 = new Ow(n2.texture);
          s3.addChild(o3), s3.mask = o3, s3.position.x = t3.position.x, s3.position.y = t3.position.y, s3.pivot.x = t3.pivot.x + n2.pivot.x, s3.pivot.y = t3.pivot.y + n2.pivot.y, s3.rotation = t3.rotate / 180 * Math.PI, t3.sprite = s3, this.container.addChild(s3);
        }
      });
    }
    preRender() {
      var t3, e3;
      const { lineArrowList: n2, lineStyle: i2, id: r3 } = this.json;
      (t3 = n2 || []) === null || t3 === void 0 || t3.forEach((t4, e4) => {
        var n3;
        const o3 = new FA(Object.assign(Object.assign({}, t4), { fillStyle: i2 == null ? void 0 : i2.fill, lineWidth: (n3 = i2 == null ? void 0 : i2.width) !== null && n3 !== void 0 ? n3 : 0 }));
        o3.graphicsId = `${r3}-arrow-${e4}-graphics`, o3.textureId = `${r3}-arrow-${e4}-fill`, this.arrowList.push(o3);
      }), (e3 = this.text) === null || e3 === void 0 || e3.createParagraphs(this.json.id);
    }
    subClassRender() {
    }
    setupEffect() {
      const { effectList: t3 } = this.json;
      if (t3 && t3.length > 0) {
        const e3 = [];
        return t3.forEach((t4) => {
          t4.type === "reflection" && (this.filterAreaJustifies.push((t5) => (t5.height *= 2, t5)), e3.push(new DA.Reflection(t4)));
        }), this.ctx.ticker.add(this.updateFilterArea, void 0, -20), this.renderContainer.filters = e3, true;
      }
      return false;
    }
    render(t3) {
      t3.push(() => BA(this, void 0, void 0, function* () {
        this.createBackgroundMask(), this.createBackground(), this.subClassRender(), this.createFilledPathMask(), this.createPathMask(), this.createPathFill(), this.createArrow();
      })), this.text && this.text.render(t3), t3.push(() => BA(this, void 0, void 0, function* () {
        var t4, e3, n2, i2, r3, o3;
        if (((t4 = this.json.textBody) === null || t4 === void 0 ? void 0 : t4.iterateType) === "wd" || ((e3 = this.json.textBody) === null || e3 === void 0 ? void 0 : e3.iterateType) === "lt")
          this.renderContainer.addChild(this.container), this.text && (this.text.container.position.x = ((i2 = (n2 = this.json.position) === null || n2 === void 0 ? void 0 : n2.x) !== null && i2 !== void 0 ? i2 : 0) + this.text.x, this.text.container.position.y = ((o3 = (r3 = this.json.position) === null || r3 === void 0 ? void 0 : r3.y) !== null && o3 !== void 0 ? o3 : 0) + this.text.y, this.renderContainer.addChild(this.text.container));
        else {
          if (this.text) {
            if (Object(l.isBoolean)(this.json.textRotateWithShape) && !this.json.textRotateWithShape) {
              const t5 = this.json.rotation || 0;
              this.text.container.rotation = -t5;
              const { width: e4 } = this.text;
              this.text.container.position.x = e4;
            }
            this.container.addChild(this.text.container);
          }
          this.renderContainer.addChild(this.container);
        }
        if (this.renderContainer.cacheAsBitmap = !!this.json.cacheAsBitMap, this.json.id === "background") {
          const t5 = Hy.create({ width: this.json.width, height: this.json.height, resolution: Math.ceil(this.ctx.renderer.resolution) });
          KR.textureCacheSize += this.json.width * this.json.height * Math.ceil(this.ctx.renderer.resolution), this.ctx.renderer.render(this.renderContainer, { renderTexture: t5 }), this.ctx.bgTexture = t5;
        }
      }));
    }
    clearOnSlideChange() {
    }
    destroy() {
      var t3;
      (t3 = this.text) === null || t3 === void 0 || t3.destroy(), this.bgSprite.destroy(), this.backgroundMask.destroy({ texture: true, baseTexture: true }), this.pathSprite.destroy(), this.pathMask.destroy({ texture: true, baseTexture: true }), this.fillColorFilter.destroy(), this.strokeColorFilter.destroy(), this.renderContainer.destroy({ texture: true, baseTexture: true }), this.cacheSprite.destroy({ texture: true, baseTexture: true }), this.arrowList.forEach((t4) => {
        var e3;
        (e3 = t4.sprite) === null || e3 === void 0 || e3.destroy();
      });
    }
  }
  var GA = function(t3, e3, n2, i2) {
    return new (n2 || (n2 = Promise))(function(r3, o3) {
      function s3(t4) {
        try {
          l2(i2.next(t4));
        } catch (t5) {
          o3(t5);
        }
      }
      function a2(t4) {
        try {
          l2(i2.throw(t4));
        } catch (t5) {
          o3(t5);
        }
      }
      function l2(t4) {
        var e4;
        t4.done ? r3(t4.value) : (e4 = t4.value, e4 instanceof n2 ? e4 : new n2(function(t5) {
          t5(e4);
        })).then(s3, a2);
      }
      l2((i2 = i2.apply(t3, e3 || [])).next());
    });
  };
  function HA(t3, e3) {
    for (const n2 in e3)
      t3.style[n2] = e3[n2];
  }
  class zA {
    constructor(t3) {
      var e3, n2;
      this.progress = document.createElement("div"), this.totalTime = document.createElement("span"), this.playButton = document.createElement("div"), this.pauseButton = document.createElement("div"), this.currentTime = document.createElement("span"), this.mediaController = document.createElement("div"), this.currentProgress = document.createElement("div"), this.medianIsEnd = false, this.playCallBackList = [], this.duration = 0, this.start = 0, this.end = 0, this.changeMediaProgress = (t4) => {
        t4.stopPropagation();
        const e4 = t4.offsetX / this.progress.clientWidth * this.duration;
        this.jumpToTime(e4), this.medianIsEnd = false, this.ctx.eventHub.emit($R.mediaSeek, { id: this.targetId, time: this.media.currentTime - this.start, isPlaying: this.media.isPlaying });
      }, this.jumpToTime = (t4 = 0) => {
        const e4 = Math.floor(t4) + this.start;
        this.media.currentTime !== e4 && (this.media.currentTime = e4);
      }, this.showController = (t4) => {
        t4.stopPropagation(), this.show();
      }, this.getMediaDuration = () => {
        this.duration && !Number.isNaN(this.duration) || (this.duration = this.media.duration, this.start && (this.duration -= this.start, this.jumpToTime()), this.end && (this.duration -= this.end)), this.totalTime.innerText = zA.formatTime(this.duration);
      }, this.playMedia = () => GA(this, void 0, void 0, function* () {
        this.playButton.style.display = "none", this.pauseButton.style.display = "block", yield this.media.play(), this.medianIsEnd && (this.medianIsEnd = false, this.jumpToTime()), this.playCallBackList.forEach((t4) => {
          t4();
        });
      }), this.pauseMedia = () => GA(this, void 0, void 0, function* () {
        this.playButton.style.display = "block", this.pauseButton.style.display = "none", yield this.media.pause();
      }), this.onMouseOut = (t4) => {
        t4.stopPropagation(), this.mediaController.style.display = "none";
      }, this.mediaTimeUpdate = () => GA(this, void 0, void 0, function* () {
        const t4 = this.media.currentTime - this.start;
        this.duration > 0 && (t4 > this.duration || this.media.ended) && (yield this.pauseMedia(), this.medianIsEnd = true), this.currentTime.innerText = zA.formatTime(t4), this.currentProgress.style.flex = (t4 / this.duration).toString();
      }), this.onPauseMedia = () => {
        this.playButton.style.display = "block", this.pauseButton.style.display = "none";
      }, this.onPlayMedia = () => {
        this.playButton.style.display = "none", this.pauseButton.style.display = "block", this.playCallBackList.forEach((t4) => {
          t4();
        });
      }, this.playMediaFromCtrl = () => {
        this.ctx.eventHub.emit($R.mediaPlay, { id: this.targetId, time: this.media.currentTime }), this.playMedia();
      }, this.pauseMediaFromCtrl = () => {
        this.ctx.eventHub.emit($R.mediaPause, { id: this.targetId, time: this.media.currentTime }), this.pauseMedia();
      }, this.targetId = t3.targetId, this.ctx = t3.ctx, this.height = t3.height, this.width = t3.width, this.sprite = t3.sprite, this.media = t3.media, this.info = t3.info, this.canvasElement = t3.canvasElement, this.getMedianContainer(), this.createMediaController(), this.info.cut && (this.start = (e3 = this.info.cut.start) !== null && e3 !== void 0 ? e3 : 0, this.end = (n2 = this.info.cut.end) !== null && n2 !== void 0 ? n2 : 0);
    }
    getMedianContainer() {
      var t3;
      let e3 = (t3 = this.canvasElement.parentElement) === null || t3 === void 0 ? void 0 : t3.querySelector(".median-container");
      e3 || (e3 = document.createElement("div"), e3.className = "median-container", this.canvasElement.parentElement.appendChild(e3)), this.container = e3;
    }
    static formatTime(t3) {
      let e3 = "00:00";
      if (t3) {
        const n2 = Math.floor(t3 / 60), i2 = String(n2 < 0 ? 0 : n2).padStart(2, "0"), r3 = Math.floor(t3 % 60);
        e3 = `${i2}:${String(r3 < 0 ? 0 : r3).padStart(2, "0")}`;
      }
      return e3;
    }
    createButton() {
      const t3 = { marginLeft: "15px", marginRight: "10px", fontSize: "0", height: "20px" };
      HA(this.playButton, Object.assign(Object.assign({}, t3), { display: "block" }));
      const e3 = document.createElement("img");
      HA(e3, { height: "20px" }), e3.src = "https://convertcdn.netless.link/publicFiles/icon/play.png", this.playButton.appendChild(e3), HA(this.pauseButton, Object.assign(Object.assign({}, t3), { display: "none" }));
      const n2 = document.createElement("img");
      HA(n2, { height: "20px" }), n2.src = "https://convertcdn.netless.link/publicFiles/icon/pause.png", this.pauseButton.appendChild(n2);
    }
    createTimer() {
      const t3 = document.createElement("div");
      HA(t3, { width: "100px" }), this.currentTime.innerText = "00:00";
      const e3 = document.createElement("span");
      return e3.innerText = "/", t3.append(this.currentTime, e3, this.totalTime), t3;
    }
    createProgress() {
      HA(this.progress, { flex: "1", position: "relative", marginRight: "10px" });
      const t3 = document.createElement("div");
      HA(t3, { background: "#D9D9D9", position: "relative", height: "10px", display: "flex" }), this.progress.appendChild(t3), HA(this.currentProgress, { background: "#4F4F4F", top: "0px", left: "0", height: "10px", flex: "0" }), t3.appendChild(this.currentProgress);
    }
    bindEvent() {
      this.mediaController.addEventListener("mouseover", this.showController, false), this.mediaController.addEventListener("mouseout", this.onMouseOut, false), this.progress.addEventListener("mousedown", this.changeMediaProgress, false), this.playButton.addEventListener("click", this.playMediaFromCtrl, false), this.pauseButton.addEventListener("click", this.pauseMediaFromCtrl, false), this.media.on("durationchange", this.getMediaDuration, false), this.media.on("timeupdate", this.mediaTimeUpdate, false), this.media.on("pause", this.onPauseMedia, false), this.media.on("play", this.onPlayMedia, false);
    }
    setControllerPosition() {
      var t3;
      const { sprite: e3 } = this, { stageWidth: n2, stageHeight: i2 } = this.ctx, r3 = e3.getGlobalPosition(), o3 = 1 / Number((t3 = this.container) === null || t3 === void 0 ? void 0 : t3.getAttribute("data-scale"));
      r3.y = r3.y + this.height - 50, r3.x = Math.max(r3.x, 0), r3.x = Math.min(r3.x, n2 - 300 * o3), r3.y = Math.max(r3.y, 0), r3.y = Math.min(r3.y, i2 - 50), HA(this.mediaController, { height: "50px", borderRadius: "25px", width: "300px", flexDirection: "row", alignItems: "center", position: "absolute", left: r3.x + "px", top: r3.y + "px", display: "none", background: "#fff", zIndex: "2", border: "1px solid #ccc", transform: `scale(${o3})`, transformOrigin: "0 100%" });
    }
    createMediaController() {
      this.setControllerPosition(), this.createButton();
      const t3 = this.createTimer();
      this.createProgress(), this.mediaController.append(this.playButton, this.pauseButton, t3, this.progress), this.container.appendChild(this.mediaController), this.bindEvent();
    }
    addPlayCallBack(t3) {
      this.playCallBackList.push(t3);
    }
    unbindEvent() {
      this.mediaController.removeEventListener("mouseover", this.showController, false), this.progress.removeEventListener("mousedown", this.changeMediaProgress, false), this.playButton.removeEventListener("click", () => this.playMedia(), false), this.pauseButton.removeEventListener("click", () => this.pauseMedia(), false), this.media.removeListener("durationchange", this.getMediaDuration, false), this.media.removeListener("timeupdate", this.mediaTimeUpdate, false), this.media.removeListener("pause", this.onPauseMedia, false), this.media.removeListener("play", this.onPlayMedia, false);
    }
    show() {
      this.setControllerPosition(), this.mediaController.style.display = "flex";
    }
    hide() {
      this.mediaController.style.display = "none";
    }
    destroy() {
      var t3;
      this.unbindEvent(), this.playCallBackList = [], (t3 = this.container) === null || t3 === void 0 || t3.removeChild(this.mediaController);
    }
  }
  var jA = function(t3, e3, n2, i2) {
    return new (n2 || (n2 = Promise))(function(r3, o3) {
      function s3(t4) {
        try {
          l2(i2.next(t4));
        } catch (t5) {
          o3(t5);
        }
      }
      function a2(t4) {
        try {
          l2(i2.throw(t4));
        } catch (t5) {
          o3(t5);
        }
      }
      function l2(t4) {
        var e4;
        t4.done ? r3(t4.value) : (e4 = t4.value, e4 instanceof n2 ? e4 : new n2(function(t5) {
          t5(e4);
        })).then(s3, a2);
      }
      l2((i2 = i2.apply(t3, e3 || [])).next());
    });
  };
  class VA extends a.a {
    constructor(t3) {
      var e3, n2;
      super(), this.type = "video", this.sprite = new Ow(), this.isPlaying = false, this.id = t3.id, this.video = t3.video, this.start = (e3 = t3.video.cut) === null || e3 === void 0 ? void 0 : e3.start, this.end = (n2 = t3.video.cut) === null || n2 === void 0 ? void 0 : n2.end, this.container = t3.container, this.ctx = t3.ctx, this.ctx.medias[this.id] = this, this.videoResource = new Iy(this.video.src, { autoLoad: true, autoPlay: false, updateFPS: 30, crossorigin: true });
      const { video: i2, width: r3, height: o3, sprite: s3 } = t3;
      this.controller = new zA({ targetId: t3.id, ctx: t3.ctx, width: r3, height: o3, sprite: s3, media: this, info: i2, canvasElement: t3.canvasElement }), this.controller.addPlayCallBack(() => {
        this.sprite.width = r3, this.sprite.height = o3, this.ctx.clock.setTimeout(() => {
          this.sprite.visible = true;
        }, 50);
      });
      const a2 = new wy(null, { height: o3, width: r3 });
      a2.resource = this.videoResource, this.videoResource.bind(a2), this.sprite = new Ow(), this.sprite.visible = false, this.sprite.texture = new ky(a2), this.sprite.interactive = true, this.container.addChild(this.sprite), this.sprite.on("mouseover", (t4) => {
        t4.stopPropagation(), this.controller.show();
      }), this.sprite.on("mouseout", (t4) => {
        t4.stopPropagation(), this.controller.hide();
      }), ["durationchange", "timeupdate", "pause", "play"].forEach((t4) => {
        this.videoResource.source.addEventListener(t4, () => {
          t4 !== "timeupdate" || this.isPlaying || this.pause(), this.emit(t4);
        });
      });
    }
    get currentTime() {
      var t3, e3;
      return (e3 = (t3 = this.videoResource.source) === null || t3 === void 0 ? void 0 : t3.currentTime) !== null && e3 !== void 0 ? e3 : 0;
    }
    set currentTime(t3) {
      this.videoResource.source && (this.videoResource.source.currentTime = t3);
    }
    get paused() {
      var t3, e3;
      return (e3 = (t3 = this.videoResource.source) === null || t3 === void 0 ? void 0 : t3.paused) === null || e3 === void 0 || e3;
    }
    get ended() {
      var t3, e3;
      return (e3 = (t3 = this.videoResource.source) === null || t3 === void 0 ? void 0 : t3.ended) === null || e3 === void 0 || e3;
    }
    get duration() {
      var t3, e3;
      return (e3 = (t3 = this.videoResource.source) === null || t3 === void 0 ? void 0 : t3.duration) !== null && e3 !== void 0 ? e3 : 0;
    }
    showController() {
      this.controller.show();
    }
    hideController() {
      this.controller.hide();
    }
    play() {
      var t3;
      return jA(this, void 0, void 0, function* () {
        this.isPlaying = true, yield this.load(), yield this.ctx.clock.waitUntil(() => {
          const t4 = this.videoResource.source;
          return !!(t4 && t4.videoWidth > 0);
        }, 3e3);
        const e3 = this.videoResource.source;
        e3 && e3.videoWidth <= 0 || (yield (t3 = this.videoResource.source) === null || t3 === void 0 ? void 0 : t3.play());
      });
    }
    load() {
      return this.videoResource.load();
    }
    pause() {
      var t3;
      this.isPlaying = false, (t3 = this.videoResource.source) === null || t3 === void 0 || t3.pause();
    }
    togglePause() {
      this.isPlaying ? this.pause() : this.play();
    }
    seek(t3) {
      this.controller.jumpToTime(t3);
    }
    stop() {
      this.seek(0), this.pause();
    }
    destroy() {
      var t3;
      this.sprite.interactive = false, this.sprite.destroy({ texture: true, baseTexture: true }), (t3 = this.videoResource) === null || t3 === void 0 || t3.destroy(), this.controller.destroy();
    }
  }
  var WA = function(t3, e3, n2, i2) {
    return new (n2 || (n2 = Promise))(function(r3, o3) {
      function s3(t4) {
        try {
          l2(i2.next(t4));
        } catch (t5) {
          o3(t5);
        }
      }
      function a2(t4) {
        try {
          l2(i2.throw(t4));
        } catch (t5) {
          o3(t5);
        }
      }
      function l2(t4) {
        var e4;
        t4.done ? r3(t4.value) : (e4 = t4.value, e4 instanceof n2 ? e4 : new n2(function(t5) {
          t5(e4);
        })).then(s3, a2);
      }
      l2((i2 = i2.apply(t3, e3 || [])).next());
    });
  };
  class XA extends a.a {
    constructor(t3) {
      super(), this.type = "audio", this.isPlaying = false, this.id = t3.id, this.audio = t3.audio, this.container = t3.container, this.audioEl = document.createElement("audio"), this.audioEl.src = this.audio.src, t3.audio.cut && (this.start = t3.audio.cut.start, this.end = t3.audio.cut.end), this.ctx = t3.ctx, this.ctx.medias[this.id] = this;
      const { width: e3, height: n2, sprite: i2 } = t3;
      this.controller = new zA({ targetId: t3.id, ctx: t3.ctx, height: n2, width: e3, sprite: i2, media: this, info: this.audio, canvasElement: t3.canvasElement }), ["durationchange", "timeupdate", "pause", "play"].forEach((t4) => {
        this.audioEl.addEventListener(t4, () => {
          this.emit(t4);
        });
      });
    }
    get currentTime() {
      return this.audioEl.currentTime;
    }
    set currentTime(t3) {
      this.audioEl.currentTime = t3;
    }
    get paused() {
      return this.audioEl.paused;
    }
    get ended() {
      return this.audioEl.ended;
    }
    get duration() {
      return this.audioEl.duration;
    }
    load() {
      return Promise.resolve();
    }
    showController() {
      this.controller.show();
    }
    hideController() {
      this.controller.hide();
    }
    play() {
      return WA(this, void 0, void 0, function* () {
        this.isPlaying = true;
        try {
          yield this.audioEl.play();
        } catch (t3) {
          console.debug("[PPT Player]: refuse to play()");
        }
      });
    }
    pause() {
      this.isPlaying = false, this.audioEl.pause();
    }
    togglePause() {
      this.isPlaying ? this.pause() : this.play();
    }
    seek(t3) {
      this.controller.jumpToTime(t3);
    }
    stop() {
      this.seek(0), this.pause();
    }
    destroy() {
      this.audioEl.pause(), this.controller.destroy();
    }
  }
  class qA extends kA {
    constructor(t3, e3, n2) {
      super(Object.assign(Object.assign({}, t3), { type: "Shape", useBgFill: false, textRotateWithShape: true }), e3, n2), this.picSprite = new Ow(), this.picMask = new Ow(), this.cmd = new hA(this), this.picFill = t3.picFill, this.media = t3 == null ? void 0 : t3.media, this.picTextureId = t3.id + "-pic-fill";
    }
    applyCommand(t3, e3) {
      var n2, i2, r3, o3, s3;
      if (e3 === "call")
        if (/playFrom\(([0-9.]+)\)/.test(t3)) {
          const e4 = t3.match(/playFrom\(([0-9.]+)\)/), i3 = Number(e4[1] || "0");
          (n2 = this.mediaPlayer) === null || n2 === void 0 || n2.play().then(() => {
            var t4;
            (t4 = this.mediaPlayer) === null || t4 === void 0 || t4.seek(i3);
          });
        } else
          t3 === "custom-pause" ? (i2 = this.mediaPlayer) === null || i2 === void 0 || i2.pause() : t3 === "togglePause" ? (r3 = this.mediaPlayer) === null || r3 === void 0 || r3.togglePause() : t3 === "stop" && ((o3 = this.mediaPlayer) === null || o3 === void 0 || o3.pause(), (s3 = this.mediaPlayer) === null || s3 === void 0 || s3.seek(0));
    }
    renderPic() {
      var t3, e3, n2;
      const i2 = this.ctx.fillTexture.getTexture(this.picTextureId);
      i2.texture && (this.picSprite.texture = i2.texture), this.picMask.texture = this.backgroundMask.texture, this.picSprite.mask = this.picMask, this.picSprite.width = this.designWidth, this.picSprite.height = this.designHeight, this.container.addChild(this.picSprite), this.container.addChild(this.picMask), ((t3 = this.media) === null || t3 === void 0 ? void 0 : t3.type) === "video" && this.media.src ? (this.mediaPlayer = new VA({ id: this.json.id + "-video", ctx: this.ctx, video: this.media, height: this.designHeight, width: this.designWidth, sprite: this.picSprite, container: this.container, canvasElement: this.ctx.view }), ((e3 = this.mediaPlayer) === null || e3 === void 0 ? void 0 : e3.sprite) && (this.mediaPlayer.sprite.mask = this.picMask)) : ((n2 = this.media) === null || n2 === void 0 ? void 0 : n2.type) === "audio" && this.media.src && (this.mediaPlayer = new XA({ id: this.json.id + "-audio", ctx: this.ctx, audio: this.media, height: this.designHeight, width: this.designWidth, sprite: this.picSprite, container: this.container, canvasElement: this.ctx.view })), this.mediaPlayer && (this.picSprite.interactive = true, this.picSprite.on("mouseover", () => {
        this.mediaPlayer.showController();
      }), this.picSprite.on("mouseout", () => {
        this.mediaPlayer.hideController();
      }, false));
    }
    preRender() {
      if (super.preRender(), this.picFill.fillType === "gifFill") {
        let t3 = 1;
        const e3 = this.ctx.fillTexture.getGifFrames(this.picFill.src), n2 = e3.map((t4, e4) => ({ texture: t4, time: this.picFill.delays[e4] || 20 }));
        this.picSprite = new jE(n2, true), this.picSprite.play();
        const i2 = this.picFill.loop;
        this.picSprite.onLoop = () => {
          t3 += 1, i2 > 0 && t3 > i2 && this.picSprite.gotoAndStop(e3.length - 1);
        };
      }
    }
    subClassRender() {
      this.renderPic();
    }
    clearOnSlideChange() {
      super.clearOnSlideChange(), this.mediaPlayer && (this.picSprite.interactive = false, this.mediaPlayer.stop());
    }
    destroy() {
      this.mediaPlayer && (this.picSprite.interactive = false, this.mediaPlayer.destroy(), this.mediaPlayer = void 0), this.picSprite.destroy(), this.picMask.destroy();
    }
  }
  var YA = function(t3, e3, n2, i2) {
    return new (n2 || (n2 = Promise))(function(r3, o3) {
      function s3(t4) {
        try {
          l2(i2.next(t4));
        } catch (t5) {
          o3(t5);
        }
      }
      function a2(t4) {
        try {
          l2(i2.throw(t4));
        } catch (t5) {
          o3(t5);
        }
      }
      function l2(t4) {
        var e4;
        t4.done ? r3(t4.value) : (e4 = t4.value, e4 instanceof n2 ? e4 : new n2(function(t5) {
          t5(e4);
        })).then(s3, a2);
      }
      l2((i2 = i2.apply(t3, e3 || [])).next());
    });
  };
  class ZA extends fA {
    constructor(t3, e3, n2) {
      var i2, r3, o3, s3;
      super(t3, e3, n2), this.children = [], this.cacheSprite = new Ow(), this.cacheContainer = new ty(), this.json = t3, this.container.name = t3.id, this.fillTextureId = t3.id + "-bg-fill", this.cacheContainer.name = t3.id + "-cache-container", this.ctx.timingTargets.addTarget(t3.id, this);
      const a2 = { x: (r3 = (i2 = t3.position) === null || i2 === void 0 ? void 0 : i2.x) !== null && r3 !== void 0 ? r3 : 0, y: (s3 = (o3 = t3.position) === null || o3 === void 0 ? void 0 : o3.y) !== null && s3 !== void 0 ? s3 : 0 };
      t3.children.forEach((t4) => {
        let e4 = null;
        (t4 == null ? void 0 : t4.type) === "Shape" ? e4 = new kA(t4, this.ctx, a2) : (t4 == null ? void 0 : t4.type) === "Picture" ? e4 = new qA(t4, this.ctx, a2) : (t4 == null ? void 0 : t4.type) === "Container" && (e4 = new ZA(t4, this.ctx, a2)), e4 && this.children.push(e4);
      }), this.updateTransform(this.json);
    }
    get interactiveContainer() {
      return this.container;
    }
    get renderContainer() {
      return this.container;
    }
    preRender() {
      this.json.fillStyle && this.json.fillStyle.fillType === "groupFill" && (this.fillTextureId = this.groupFillTextureId);
      for (const t3 of this.children)
        t3.groupFillTextureId = this.fillTextureId, t3.preRender();
    }
    getBgElement() {
      return null;
    }
    getIterateEntry(t3, e3, n2) {
      return e3 === 0 ? this : (this.ctx.eventHub.emit("IterateTimeNodeEnd", n2), null);
    }
    getTextElement() {
      return null;
    }
    render(t3) {
      for (const e3 of this.children)
        e3.render(t3), t3.push(() => YA(this, void 0, void 0, function* () {
          var t4;
          e3.renderContainer && this.cacheContainer.addChild(e3.renderContainer), (e3.json.hlinkHover || e3.json.hlinkClick) && ((t4 = e3.hyperlink) === null || t4 === void 0 || t4.addProxy(this.container));
        }));
      t3.push(() => YA(this, void 0, void 0, function* () {
        this.container.addChild(this.cacheContainer), this.json.cacheAsTexture && (!function(t4, e3, n2, i2, r3) {
          const o3 = t4.getBounds(), s3 = Math.min(o3.x, e3.x, o3.x + o3.width, e3.x + e3.width), a2 = Math.max(o3.x, e3.x, o3.x + o3.width, e3.x + e3.width), l2 = Math.min(o3.y, e3.y, o3.y + o3.height, e3.y + e3.height), u2 = a2 - s3, h2 = Math.max(o3.y, e3.y, o3.y + o3.height, e3.y + e3.height) - l2;
          let c2 = eM(e3.x - o3.x), d2 = eM(e3.y - o3.y);
          r3 || (c2 = Math.max(0, c2), d2 = Math.max(0, d2));
          const p2 = Hy.create({ width: u2, height: h2, resolution: Math.ceil(i2.renderer.resolution) });
          KR.textureCacheSize += u2 * h2 * Math.ceil(i2.renderer.resolution), t4.position.x = c2, t4.position.y = d2, i2.renderer.render(t4, { renderTexture: p2 }), n2.texture = p2, n2.position.x = -c2, n2.position.y = -d2;
        }(this.cacheContainer, new d_(this.designX, this.designY, this.designWidth, this.designHeight), this.cacheSprite, this.ctx, false), this.container.addChild(this.cacheSprite), this.cacheContainer.position.x = 0, this.cacheContainer.position.y = 0, this.cacheContainer.visible = false);
      }));
    }
    clearOnSlideChange() {
      this.children.forEach((t3) => t3.clearOnSlideChange());
    }
    destroy() {
      this.cacheSprite && this.cacheSprite.destroy({ texture: true }), this.children.forEach((t3) => t3.destroy()), this.container.destroy(), this.cacheContainer.destroy({ children: true, texture: true, baseTexture: true });
    }
  }
  class JA extends a.a {
    constructor(t3, e3, n2, i2) {
      super(), this.cond = {}, this.timeoutIds = [], this.condHandle = (t4) => {
        if (t4)
          if (t4.delay && t4.delay > 0) {
            const e4 = this.ctx.clock.setTimeout(() => {
              t4.event && (this.cond[t4.event] = true, this.detectTrigger());
            }, t4.delay);
            this.timeoutIds.push(e4);
          } else
            this.cond[t4.event] = true, this.detectTrigger();
        else
          this.detectTrigger();
      }, this.id = t3, this.ctx = i2, this.eventHubs = n2, e3.forEach((t4) => {
        this.addCond(t4);
      });
    }
    setTriggerParams(t3) {
      this.triggerParams = t3;
    }
    addCond(t3) {
      const e3 = () => this.condHandle(t3);
      t3.event && (/^shape/.test(t3.event) || /^time/.test(t3.event) ? (this.cond[t3.event] = false, this.eventHubs.global.addListener(t3.event, e3)) : /^runtime/.test(t3.event) ? (this.cond[t3.event] = false, this.eventHubs.runtime.addListener(t3.event, e3)) : /^self/.test(t3.event) ? t3.delay && t3.delay > 0 && (this.cond[t3.event] = false, this.eventHubs.runtime.addListener(t3.event, e3)) : this.cond[t3.event] = false);
    }
    isTrigger() {
      return Object.keys(this.cond).every((t3) => !!this.cond[t3]);
    }
    isTriggerWithoutParent() {
      return Object.keys(this.cond).filter((t3) => t3 !== "self").every((t3) => !!this.cond[t3]);
    }
    detectTrigger() {
      if (Object.keys(this.cond).every((t3) => !!this.cond[t3])) {
        Object.keys(this.cond).forEach((t4) => {
          this.cond[t4] = false;
        });
        const t3 = this.triggerParams;
        this.triggerParams = void 0, this.emit("active", t3);
      }
    }
    reset() {
      Object.keys(this.cond).forEach((t3) => {
        this.cond[t3] = false;
      }), this.timeoutIds.forEach((t3) => this.ctx.clock.clearTimeout(t3));
    }
  }
  class $A extends a.a {
    constructor(t3) {
      super(), this.interactiveListeners = [], this.runtimeNodeEventHub = new a.a(), this._currentSeqIndex = 0, this._currentSeqState = "idle", this.isForward = true, this.autoPlay = false, this.handlePrev = () => {
        var t4, e4, n3, i3, r4, o4;
        this.hasPrev() || !this.isMainSeq ? this.currentSeqState === "idle" ? (this.decrSeqIndex(), (t4 = this.commonTimeNode.children[this.currentSeqIndex]) === null || t4 === void 0 || t4.commonTimeNode.seekToStart(), (e4 = this.commonTimeNode.children[this.currentSeqIndex]) === null || e4 === void 0 || e4.commonTimeNode.clearSubList(), this.currentSeqState = "idle") : this.currentSeqState === "running" ? ((n3 = this.commonTimeNode.children[this.currentSeqIndex]) === null || n3 === void 0 || n3.commonTimeNode.seekToStart(), (i3 = this.commonTimeNode.children[this.currentSeqIndex]) === null || i3 === void 0 || i3.commonTimeNode.clearSubList(), this.currentSeqState = "idle") : this.currentSeqState === "end" && (this.currentSeqIndex >= this.commonTimeNode.children.length && (this.currentSeqIndex = this.commonTimeNode.children.length - 1), (r4 = this.commonTimeNode.children[this.currentSeqIndex]) === null || r4 === void 0 || r4.commonTimeNode.seekToStart(), (o4 = this.commonTimeNode.children[this.currentSeqIndex]) === null || o4 === void 0 || o4.commonTimeNode.clearSubList(), this.currentSeqState = "idle") : this.globalEventHub.emit("c:prev slide");
      }, this.handleNext = () => {
        var t4, e4, n3, i3;
        this.hasNext() || !this.isMainSeq ? this.currentSeqState === "idle" ? (t4 = this.commonTimeNode.children[this.currentSeqIndex]) === null || t4 === void 0 || t4.commonTimeNode.startTimeNodeForce() : this.currentSeqState === "running" ? ((e4 = this.commonTimeNode.children[this.currentSeqIndex]) === null || e4 === void 0 || e4.commonTimeNode.seekToEnd(false, true), this.currentSeqState = "end", this.incrSeqIndex(), (n3 = this.commonTimeNode.children[this.currentSeqIndex]) === null || n3 === void 0 || n3.commonTimeNode.startTimeNodeForce()) : this.currentSeqState === "end" && (this.incrSeqIndex(), (i3 = this.commonTimeNode.children[this.currentSeqIndex]) === null || i3 === void 0 || i3.commonTimeNode.startTimeNodeForce()) : this.globalEventHub.emit("c:next slide");
      };
      const { json: e3, iterateType: n2, isIterate: i2, isSub: r3, parent: o3, ctx: s3, eventHub: l2, iterateIndex: u2, iterateId: h2 } = t3;
      this.isMainSeq = e3.ctn.nodeType === "mainSeq", this.isInteractiveSeq = e3.ctn.nodeType === "interactiveSeq", this.id = e3.ctn.id, this.isIterate = i2, this.json = e3, this.ctx = s3, this.globalEventHub = l2, this.commonTimeNode = new MR({ json: e3.ctn, isSub: r3, eventHubs: { global: l2, runtime: this.runtimeNodeEventHub }, ctx: s3, parent: o3, isIterate: false, iterateType: n2, iterateIndex: u2, iterateId: h2 }), this.bindShapeEvent(), this.nextConds = new JA("mainSeq", e3.nextCondLst, { global: l2, runtime: this.runtimeNodeEventHub }, this.ctx), this.prevConds = new JA("mainSeq", e3.preCondLst, { global: l2, runtime: this.runtimeNodeEventHub }, this.ctx), this.commonTimeNode.on("timeNodeRestart", () => {
        this.currentSeqIndex = 0, this.currentSeqState = "idle";
      }), this.commonTimeNode.on("childTimeNodeStart", (t4) => {
        const e4 = this.commonTimeNode.children.findIndex((e5) => e5.commonTimeNode.uuid === t4.id);
        e4 >= 0 && (this.currentSeqIndex = e4), this.currentSeqState = "running", this.isMainSeq && this.ctx.eventHub.emit($R.mainSeqStepStart, e4);
      }), this.commonTimeNode.on("childTimeNodeEnd", (t4) => {
        const e4 = this.commonTimeNode.children.findIndex((e5) => e5.commonTimeNode.uuid === t4.id);
        e4 >= 0 && (this.currentSeqIndex = e4), this.currentSeqState = "end", this.autoPlay && this.ctx.clock.setTimeout(() => {
          this.handleNext();
        }), this.isMainSeq && this.ctx.eventHub.emit($R.mainSeqStepEnd, e4);
      }), this.commonTimeNode.on("timeNodeEndSync", () => {
        this.commonTimeNode.resetForRepeat(), this.ctx.clock.setTimeout(() => {
          this.currentSeqState = "idle", this.currentSeqIndex = 0;
        });
      }), this.commonTimeNode.on("timeNodeDestroy", () => {
        this.interactiveListeners.forEach(([t4, e4]) => {
          t4 && e4 && t4.container.removeListener("pointerdown", e4);
        }), this.interactiveListeners = [];
      }), this.nextConds.on("active", () => {
        this.handleNext();
      }), this.prevConds.on("active", this.handlePrev);
    }
    get currentSeqIndex() {
      return this._currentSeqIndex;
    }
    set currentSeqIndex(t3) {
      this._currentSeqIndex = t3, this.isMainSeq ? this.ctx.eventHub.emit($R.mainSeqStepChange, t3) : this.isInteractiveSeq && this.ctx.eventHub.emit($R.interactiveSeqStateChange, { id: this.json.ctn.id, state: { step: t3, state: this._currentSeqState } });
    }
    get currentSeqState() {
      return this._currentSeqState;
    }
    set currentSeqState(t3) {
      this._currentSeqState = t3, this.isMainSeq ? this.ctx.eventHub.emit($R.mainSeqStateChange, t3) : this.isInteractiveSeq && this.ctx.eventHub.emit($R.interactiveSeqStateChange, { id: this.json.ctn.id, state: { step: this._currentSeqIndex, state: t3 } });
    }
    get stepLength() {
      return this.commonTimeNode.children.length;
    }
    get currentStep() {
      return this.currentSeqIndex;
    }
    get currentState() {
      return this.currentSeqState;
    }
    startAutoPlay() {
      this.autoPlay = true, this.commonTimeNode.children[0].commonTimeNode.startTimeNodeForce();
    }
    incrSeqIndex() {
      this.currentSeqIndex + 1 <= this.commonTimeNode.children.length && (this.currentSeqIndex += 1);
    }
    decrSeqIndex() {
      this.currentSeqIndex - 1 >= -1 && (this.currentSeqIndex -= 1);
    }
    hasPrev() {
      return !(this.currentSeqIndex <= 0 && this.currentSeqState === "idle");
    }
    hasNext() {
      return !(this.currentSeqIndex >= this.commonTimeNode.children.length || this.currentSeqIndex === this.commonTimeNode.children.length - 1 && this.currentSeqState === "end");
    }
    bindShapeEvent() {
      this.json.ctn.nodeType === "interactiveSeq" && this.json.nextCondLst.forEach((t3) => {
        if (/^shape/.test(t3.event)) {
          const e3 = t3.event.split(" ")[1];
          if (e3) {
            const t4 = this.ctx.timingTargets.getTargetById(e3);
            if (t4) {
              t4.interactiveContainer.interactive = true, t4.interactiveContainer.cursor = "pointer";
              const n2 = () => {
                const t5 = `shape ${e3} onClick`, { mode: n3 } = this.ctx;
                n3 !== "interactive" && n3 !== "sync" || this.ctx.eventHub.emit($R.interactiveSeqAction, { action: t5, seqId: this.json.ctn.id }), n3 !== "sync" && n3 !== "local" || this.globalEventHub.emit(t5);
              };
              t4.interactiveContainer.on("pointerdown", n2), this.interactiveListeners.push([t4, n2]);
            }
          }
        }
      });
    }
    setCurrentStep(t3, e3) {
      let n2 = t3;
      this.commonTimeNode.seekToStart();
      const { length: i2 } = this.commonTimeNode.children;
      if (n2 === -1 && (n2 = i2 - 1), n2 >= 0 && n2 < i2)
        for (let t4 = 0; t4 <= n2; t4++) {
          const i3 = this.commonTimeNode.children[t4];
          t4 !== n2 ? i3.commonTimeNode.seekToEnd(false, true) : e3 === "start" ? i3.commonTimeNode.seekToStart() : e3 === "end" && i3.commonTimeNode.seekToEnd(false, true);
        }
      this.currentSeqIndex = n2, this.currentSeqState = e3 === "start" ? "idle" : "end";
    }
  }
  function KA(t3, e3, n2) {
    const i2 = e3.split(".");
    i2.reduce((r3, o3, s3) => {
      if (r3)
        return s3 !== i2.length - 1 ? r3[o3] : void (r3[o3] = n2);
      console.warn(`${t3} not support ${e3}`);
    }, t3);
  }
  function QA(t3, e3) {
    if (!e3)
      return null;
    return e3.split(".").reduce((n2, i2) => {
      if (n2)
        return n2[i2];
      console.warn(`${t3} not support ${e3}`);
    }, t3);
  }
  class tR {
    constructor(t3) {
      this.timingTarget = null, this.runtimeNodeEventHub = new a.a(), this.onTimeLineStart = () => {
        if (this.isConflict) {
          const { target: t4 } = this.json.cBhvr;
          if (this.activeWhenConflict === "next") {
            let e4 = t4.id;
            t4.type === "shape" && t4.txEl && (e4 = `${e4}-txEl-${t4.txEl.range[0]}`), this.commonTimeNode.isIterate && (e4 = `${e4}-iterate-${this.commonTimeNode.iterateIndex}`), this.ctx.conflictTimeNodeManager.addRunningTimeNode(e4, this.modifyAttrKey, this.commonTimeNode);
          } else
            this.activeWhenConflict === "prev" && this.commonTimeNode.dispose();
        }
      };
      const { isIterate: e3, isSub: n2, json: i2, ctx: r3, parent: o3, eventHub: s3, iterateType: l2, iterateIndex: u2, iterateId: h2 } = t3;
      this.json = i2, this.id = i2.cBhvr.ctn.id, this.ctx = r3, this.globalEventHub = s3, this.commonTimeNode = new MR({ json: i2.cBhvr.ctn, isSub: n2, eventHubs: { global: s3, runtime: this.runtimeNodeEventHub }, ctx: r3, parent: o3, isIterate: e3, iterateType: l2, iterateIndex: u2, iterateId: h2 }), this.timingTarget = this.ctx.timingTargets.getTarget(i2.cBhvr.target, e3, { type: l2, index: u2, id: h2 }), this.commonTimeNode.on("seekToStart", () => this.onSeekToStart()), this.commonTimeNode.on("seekToEnd", () => this.onSeekToEnd()), this.commonTimeNode.on("timelineStart", this.onTimeLineStart);
    }
  }
  class eR extends tR {
    constructor(t3) {
      super(t3), this.isConflict = false, this.activeWhenConflict = "next", this.startVal = null, this.updateStartValue = () => {
        this.timingTarget && (this.startVal = QA(this.timingTarget, this.json.cBhvr.attrList[0]));
      }, this.onSeekToStart = () => {
        const t4 = this.json.cBhvr.attrList[0];
        this.startVal !== null && this.timingTarget && KA(this.timingTarget, t4, this.startVal);
      }, this.onSeekToEnd = () => {
        const t4 = this.json.cBhvr.attrList[0], e3 = this.json.cBhvr.to || this.json.to;
        e3 && this.timingTarget && KA(this.timingTarget, t4, e3);
      }, this.commonTimeNode.on("timeNodeStart", this.updateStartValue), this.commonTimeNode.on("timeNodeCreate", this.updateStartValue), this.commonTimeNode.on("timeUpdate", ({ duration: t4, delta: e3 }) => {
        if (e3 / t4 >= 1) {
          const t5 = this.json.cBhvr.attrList[0];
          this.json.cBhvr.attrList.length > 1 && console.warn("this.json.cBhvr.attrList.length > 0");
          const e4 = this.json.cBhvr.to || this.json.to;
          e4 && this.timingTarget && KA(this.timingTarget, t5, e4);
        }
      });
    }
    get modifyAttrKey() {
      return this.json.cBhvr.attrList[0];
    }
  }
  class nR {
    constructor(t3, e3) {
      this.math = { pi: Math.PI, e: Math.E, abs: Math.abs, acos: Math.acos, asin: Math.asin, atan: Math.atan, ceil: Math.ceil, cos: Math.cos, cosh: Math.cosh, deg: (t4) => t4 / Math.PI * 180, exp: Math.exp, floor: Math.floor, ln: Math.log, max: Math.max, min: Math.min, rad: (t4) => t4 / 180 * Math.PI, rand: Math.random, sin: Math.sin, sinh: Math.sinh, sqrt: Math.sqrt, tan: Math.tan, tanh: Math.tanh }, this.timingTarget = e3, this.val = t3.val.value, this.time = t3.time, t3.fmla && (this.fmla = this.parseFmla(t3.fmla));
    }
    parseFmla(t3) {
      let e3 = t3.replace(/#ppt_h/g, `(${this.timingTarget.design_ppt_h})`);
      return e3 = e3.replace(/#ppt_w/g, `(${this.timingTarget.design_ppt_w})`), e3 = e3.replace(/#ppt_x/g, `(${this.timingTarget.design_ppt_x})`), e3 = e3.replace(/#ppt_y/g, `(${this.timingTarget.design_ppt_y})`), e3 = e3.replace(/ppt_w/g, "vars.ppt_w"), e3 = e3.replace(/ppt_h/g, "vars.ppt_h"), e3 = e3.replace(/ppt_x/g, "vars.ppt_x"), e3 = e3.replace(/ppt_y/g, "vars.ppt_y"), e3 = e3.replace(/#/g, "vars."), ["abs", "acos", "asin", "atan", "ceil", "cos", "cosh", "deg", "exp", "floor", "ln", "max", "min", "rad", "rand", "sin", "sinh", "sqrt", "tan", "tanh", "pi", "e"].forEach((t4) => {
        const n2 = new RegExp(`([^a-z])${t4}([^a-z])`, "g");
        e3 = e3.replace(n2, (e4, n3, i2) => `${n3}math.${t4}${i2}`);
      }), new Function("vars", "math", "$", "return " + e3);
    }
  }
  class iR extends nR {
    constructor(t3, e3, n2) {
      super(t3, e3), this.value = t3.val.value, n2 && (this.fmla = this.parseFmla(n2));
    }
    resolveValue() {
      return this.value;
    }
    interpolationFrom(t3, e3, n2) {
      const i2 = t3.resolveValue(n2), r3 = i2 + (this.resolveValue() - i2) * e3;
      return t3.fmla ? t3.fmla(n2, this.math, r3) : r3;
    }
  }
  class rR extends nR {
    constructor(t3, e3) {
      var n2;
      super(t3, e3), this.value = (n2 = t3.val) === null || n2 === void 0 ? void 0 : n2.value;
    }
    interpolationFrom(t3, e3, n2) {
      let i2 = t3.resolveValue(n2);
      return e3 > this.time && (i2 = this.resolveValue()), i2;
    }
    resolveValue() {
      return this.value || "";
    }
  }
  class oR extends nR {
    constructor(t3, e3) {
      super(t3, e3), this.fn = this.parseFmla(this.val);
    }
    resolveValue(t3) {
      return this.fn(t3, this.math, 1);
    }
    interpolationFrom(t3, e3, n2) {
      const i2 = t3.resolveValue(n2), r3 = i2 + (this.resolveValue(n2) - i2) * e3;
      return t3.fmla ? t3.fmla(n2, this.math, r3) : r3;
    }
  }
  class sR extends nR {
    constructor(t3, e3) {
      super(t3, e3), this.value = t3.val.value;
    }
    interpolationFrom(t3, e3) {
      return XM(t3.resolveValue(), this.value, e3);
    }
    resolveValue() {
      return this.value;
    }
  }
  class aR extends tR {
    constructor(t3) {
      super(t3), this.isConflict = true, this.activeWhenConflict = "next", this.startVal = null, this.vars = { ppt_x: 0, ppt_y: 0, ppt_w: 0, ppt_h: 0 }, this.keyFrames = [], this.isColorAnim = false, this.onTimeNodeStart = () => {
        this.timingTarget && (this.startVal = QA(this.timingTarget, this.json.cBhvr.attrList[0]));
      }, this.updateVars = () => {
        var t4, e3, n2, i2;
        ((t4 = this.timingTarget) === null || t4 === void 0 ? void 0 : t4.ppt_h) && (this.vars.ppt_h = this.timingTarget.ppt_h), ((e3 = this.timingTarget) === null || e3 === void 0 ? void 0 : e3.ppt_w) && (this.vars.ppt_w = this.timingTarget.ppt_w), ((n2 = this.timingTarget) === null || n2 === void 0 ? void 0 : n2.ppt_x) && (this.vars.ppt_x = this.timingTarget.ppt_x), ((i2 = this.timingTarget) === null || i2 === void 0 ? void 0 : i2.ppt_y) && (this.vars.ppt_y = this.timingTarget.ppt_y), this.isColorAnim;
      }, this.onTimeUpdate = ({ duration: t4, delta: e3 }) => {
        const n2 = e3 / t4, i2 = this.keyFrames.findIndex((t5) => n2 <= t5[0]), { attrList: r3 } = this.json.cBhvr;
        if (i2 < 0) {
          const t5 = this.keyFrames[this.keyFrames.length - 1];
          return void (this.timingTarget && r3 && r3[0] && KA(this.timingTarget, r3[0], t5[1].resolveValue(this.vars)));
        }
        const o3 = i2 - 1, s3 = this.keyFrames[i2], a2 = this.keyFrames[o3] || s3, l2 = s3[0] - a2[0] == 0 ? 1 : (n2 - a2[0]) / (s3[0] - a2[0]), u2 = s3[1].interpolationFrom(a2[1], l2, this.vars);
        this.timingTarget && r3 && r3[0] && KA(this.timingTarget, r3[0], u2);
      }, this.onSeekToStart = () => {
        this.startVal !== null && this.timingTarget && KA(this.timingTarget, this.json.cBhvr.attrList[0], this.startVal);
      }, this.onSeekToEnd = () => {
        this.onTimeUpdate({ duration: 1, delta: 1, isReverse: false });
      }, this.initKeyFrames(), this.commonTimeNode.on("timeUpdate", this.onTimeUpdate), this.commonTimeNode.on("timelineStart", this.updateVars), this.commonTimeNode.on("timeNodeStart", this.onTimeNodeStart), this.commonTimeNode.on("timeNodeCreate", this.onTimeNodeStart);
    }
    get modifyAttrKey() {
      return this.json.cBhvr.attrList[0];
    }
    initKeyFrames() {
      var t3;
      const { valueType: e3 } = this.json;
      if (this.json.tavLst.length <= 0) {
        if (this.json.to) {
          if (this.json.from || this.startVal) {
            const t5 = { time: 0, val: { type: "string", value: this.json.from || this.startVal.toString() }, fmla: "" };
            if (e3 === "num" && this.timingTarget) {
              const e4 = new oR(t5, this.timingTarget);
              this.keyFrames.push([t5.time, e4]);
            }
          }
          const t4 = { time: 1, val: { type: "string", value: this.json.to }, fmla: "" };
          if (e3 === "num" && this.timingTarget) {
            const e4 = new oR(t4, this.timingTarget);
            this.keyFrames.push([t4.time, e4]);
          }
        } else if (this.json.by) {
          const n2 = { time: 0, val: { type: "string", value: this.json.cBhvr.attrList[0] }, fmla: "" };
          if (e3 === "num" && this.timingTarget) {
            const t4 = new oR(n2, this.timingTarget);
            this.keyFrames.push([n2.time, t4]);
          }
          const i2 = { time: 1, val: { type: "string", value: (((t3 = n2.val) === null || t3 === void 0 ? void 0 : t3.value) || "") + "+" + this.json.by }, fmla: "" };
          if (e3 === "num" && this.timingTarget) {
            const t4 = new oR(i2, this.timingTarget);
            this.keyFrames.push([i2.time, t4]);
          }
        }
      }
      if (this.json.tavLst.length > 0) {
        for (const t4 of this.json.tavLst)
          if (t4.val && this.timingTarget) {
            let n2 = null;
            t4.val.type === "string" ? e3 === "num" ? n2 = new oR(t4, this.timingTarget) : e3 === "str" && (n2 = new rR(t4, this.timingTarget)) : t4.val.type === "number" ? n2 = new iR(t4, this.timingTarget) : t4.val.type === "color" ? (this.isColorAnim = true, n2 = new sR(t4, this.timingTarget)) : t4.val.type === "boolean" && console.warn("not implements"), n2 && this.keyFrames.push([t4.time, n2]);
          }
      }
    }
  }
  var lR = n(50), uR = n.n(lR), hR = n(51), cR = n.n(hR);
  class dR extends Gx {
    constructor() {
      super(cR.a, uR.a, { percent: 0, direction: 1, transition: 0 });
    }
    set transition(t3) {
      this.uniforms.transition = t3;
    }
    set percent(t3) {
      this.uniforms.percent = t3;
    }
    set direction(t3) {
      this.uniforms.direction = t3;
    }
  }
  var pR = n(52), fR = n.n(pR);
  class mR extends Gx {
    constructor() {
      super(void 0, fR.a, { percent: 0, transition: 1 });
    }
    set transition(t3) {
      this.uniforms.transition = Math.pow(t3, t3);
    }
    set percent(t3) {
      this.uniforms.percent = t3;
    }
  }
  class gR extends tR {
    constructor(t3) {
      var e3;
      super(t3), this.filterType = "", this.isConflict = true, this.activeWhenConflict = "prev", this.onTimeUpdate = ({ duration: t4, delta: e4 }) => {
        const n3 = e4 / t4;
        this.filter && (this.filter.percent = n3), n3 >= 1 && this.timingTarget && this.ctx.clock.setTimeout(() => {
          this.timingTarget && (this.timingTarget.container.filters = []);
        });
      }, this.onSeekToStart = () => {
        this.timingTarget && (this.timingTarget.container.filters = []);
      }, this.onSeekToEnd = () => {
        this.timingTarget && (this.timingTarget.container.filters = []);
      }, this.commonTimeNode.on("timelineStart", () => {
        this.filter && this.timingTarget && (this.timingTarget.container.filters = [this.filter]);
      }), this.commonTimeNode.on("timeUpdate", this.onTimeUpdate);
      let n2 = 0;
      t3.json.transition === "out" ? n2 = -1 : t3.json.transition === "in" && (n2 = 1);
      const i2 = (e3 = t3.json.filter) === null || e3 === void 0 ? void 0 : e3.match(/^([a-zA-Z]+)(\((.+)\))?/);
      if (i2) {
        const t4 = i2[1], e4 = i2[3];
        if (t4 === "wipe") {
          const n3 = new dR();
          e4 === "up" ? n3.direction = 1 : e4 === "down" ? n3.direction = 2 : e4 === "left" ? n3.direction = 3 : e4 === "right" && (n3.direction = 4), this.filter = n3, this.filterType = `${t4}-${e4}`;
        } else if (t4 === "fade") {
          const e5 = new mR();
          this.filter = e5, this.filterType = "" + t4;
        }
        this.filter && (this.filter.transition = n2);
      }
    }
    get modifyAttrKey() {
      return this.filterType;
    }
  }
  class vR extends tR {
    constructor(t3) {
      super(t3), this.isConflict = true, this.activeWhenConflict = "next", this.onTimeUpdate = ({ duration: t4, delta: e3 }) => {
        var n2;
        const i2 = e3 / t4, r3 = (n2 = this.path) === null || n2 === void 0 ? void 0 : n2.getPoint(i2);
        this.timingTarget && r3 && (this.timingTarget.ppt_x = r3.x + this.timingTarget.design_ppt_x, this.timingTarget.ppt_y = r3.y + +this.timingTarget.design_ppt_y);
      }, this.onSeekToStart = () => {
        var t4, e3, n2;
        const i2 = (e3 = (t4 = this.commonTimeNode.json) === null || t4 === void 0 ? void 0 : t4.spd) !== null && e3 !== void 0 ? e3 : 1, r3 = (n2 = this.path) === null || n2 === void 0 ? void 0 : n2.getPoint(i2 > 0 ? 0 : 1);
        this.timingTarget && r3 && (this.timingTarget.ppt_x = r3.x + this.timingTarget.design_ppt_x, this.timingTarget.ppt_y = r3.y + this.timingTarget.design_ppt_y);
      }, this.onSeekToEnd = () => {
        var t4, e3, n2;
        const i2 = (e3 = (t4 = this.commonTimeNode.json) === null || t4 === void 0 ? void 0 : t4.spd) !== null && e3 !== void 0 ? e3 : 1, r3 = (n2 = this.path) === null || n2 === void 0 ? void 0 : n2.getPoint(i2 > 0 ? 1 : 0);
        this.timingTarget && r3 && (this.timingTarget.ppt_x = r3.x + this.timingTarget.design_ppt_x, this.timingTarget.ppt_y = r3.y + this.timingTarget.design_ppt_y);
      }, this.commonTimeNode.on("timeUpdate", this.onTimeUpdate), this.createPath();
    }
    get modifyAttrKey() {
      return "motion";
    }
    createPath() {
      var t3;
      const e3 = new xc(), n2 = (t3 = this.json.path) === null || t3 === void 0 ? void 0 : t3.match(/[MLCmlc][^MLCmlc]+/g);
      if (n2)
        for (const t4 of n2) {
          const [n3, ...i2] = t4.trim().replace(/\s+/g, " ").split(" ");
          if (n3 === "M") {
            const [t5, n4] = i2.map((t6) => Number(t6));
            e3.moveTo(t5, n4);
          } else if (n3 === "L") {
            const [t5, n4] = i2.map((t6) => Number(t6));
            e3.lineTo(t5, n4);
          } else if (n3 === "C") {
            const [t5, n4, r3, o3, s3, a2] = i2.map((t6) => Number(t6));
            e3.bezierCurveTo(t5, n4, r3, o3, s3, a2);
          } else if (n3 === "Z")
            e3.closePath();
          else if (n3 === "E")
            console.warn("not implements");
          else if (n3 === "c") {
            const [t5, n4, r3, o3, s3, a2] = i2.map((t6) => Number(t6)), l2 = e3.currentPoint;
            e3.bezierCurveTo(t5 + l2.x, n4 + l2.y, r3 + l2.x, o3 + l2.y, s3 + l2.x, a2 + l2.y);
          } else if (n3 === "l") {
            const t5 = e3.currentPoint, [n4, r3] = i2.map((t6) => Number(t6));
            e3.lineTo(n4 + t5.x, r3 + t5.y);
          } else if (n3 === "m") {
            const t5 = e3.currentPoint, [n4, r3] = i2.map((t6) => Number(t6));
            e3.moveTo(n4 + t5.x, r3 + t5.y);
          }
        }
      this.path = e3;
    }
  }
  class _R extends tR {
    constructor(t3) {
      super(t3), this.isConflict = true, this.activeWhenConflict = "next", this.startVal = null, this.onTimelineStart = (t4) => {
        t4.isReverse || this.updateCurrentValue();
      }, this.onTimeUpdate = ({ duration: t4, delta: e3 }) => {
        var n2, i2, r3, o3, s3;
        const a2 = e3 / t4, l2 = { x: 1, y: 1 };
        if (this.to) {
          const t5 = (n2 = this.from) !== null && n2 !== void 0 ? n2 : { x: (r3 = (i2 = this.startVal) === null || i2 === void 0 ? void 0 : i2.x) !== null && r3 !== void 0 ? r3 : 1, y: (s3 = (o3 = this.startVal) === null || o3 === void 0 ? void 0 : o3.y) !== null && s3 !== void 0 ? s3 : 1 };
          l2.x = t5.x + (this.to.x - t5.x) * a2, l2.y = t5.y + (this.to.y - t5.y) * a2;
        } else if (this.by) {
          const t5 = { x: this.by.x, y: this.by.y };
          l2.x = 1 + (t5.x - 1) * a2, l2.y = 1 + (t5.y - 1) * a2;
        }
        this.timingTarget && (this.timingTarget.scale = l2);
      }, this.onTimeNodeStart = () => {
        this.timingTarget && (this.startVal = { x: this.timingTarget.scale.x, y: this.timingTarget.scale.y });
      }, this.onSeekToStart = () => {
        this.timingTarget && this.startVal && (this.timingTarget.scale = this.startVal);
      }, this.onSeekToEnd = () => {
        this.onTimeUpdate({ duration: 1, delta: 1, isReverse: false });
      }, this.from = t3.json.from, this.to = t3.json.to, this.by = t3.json.by, this.commonTimeNode.on("timelineStart", this.onTimelineStart), this.commonTimeNode.on("timeNodeCreate", this.onTimeNodeStart), this.commonTimeNode.on("timeUpdate", this.onTimeUpdate), this.commonTimeNode.on("timeNodeStart", this.onTimeNodeStart);
    }
    get modifyAttrKey() {
      return "scale";
    }
    updateCurrentValue() {
      this.timingTarget && (this.current = { x: this.timingTarget.scale.x, y: this.timingTarget.scale.y });
    }
  }
  class yR extends tR {
    constructor(t3) {
      super(t3), this.isConflict = false, this.activeWhenConflict = "next", this.startColorString = null, this.currentColorString = "#FFFFFFFF", this.onTimelineStart = (t4) => {
        this.from.isInit() || this.from.fromHexString(this.currentColorString), this.to.isInit() || this.from.by(this.by, this.to), t4.isReverse || this.updateCurrentValue();
        const [e3] = this.json.cBhvr.attrList[0].split(".");
        KA(this.timingTarget, e3 + ".on", "true");
      }, this.onTimeNodeEnd = () => {
        if (this.json.cBhvr.ctn.fill === "remove") {
          const [t4] = this.json.cBhvr.attrList[0].split(".");
          KA(this.timingTarget, t4 + ".on", "false");
        }
      }, this.onSeekToStart = () => {
        if (this.timingTarget) {
          const [t4] = this.json.cBhvr.attrList[0].split(".");
          KA(this.timingTarget, t4 + ".on", "false");
        }
      }, this.onTimeNodeStart = () => {
        if (this.timingTarget) {
          const t4 = QA(this.timingTarget, this.json.cBhvr.attrList[0]);
          t4 && (this.startColorString = t4);
        }
      }, this.onTimeUpdate = ({ delta: t4, duration: e3 }) => {
        const n2 = t4 / e3;
        this.to.interpolationFrom(this.from, n2, this.target), this.timingTarget && KA(this.timingTarget, this.json.cBhvr.attrList[0], this.target.toHexString());
      }, this.onSeekToEnd = () => {
        this.onTimeUpdate({ duration: 1, delta: 1 });
      }, this.json.clrSpc === "rgb" ? (this.from = new zM(this.json.from), this.to = new zM(this.json.to), this.by = new zM(this.json.by), this.target = new zM()) : (this.from = new HM(this.json.from), this.to = new HM(this.json.to), this.by = new HM(this.json.by), this.target = new HM()), this.commonTimeNode.on("timeNodeStart", this.onTimeNodeStart), this.commonTimeNode.on("timeNodeCreate", this.onTimeNodeStart), this.commonTimeNode.on("timelineStart", this.onTimelineStart), this.commonTimeNode.on("timeNodeEnd", this.onTimeNodeEnd), this.commonTimeNode.on("timeUpdate", this.onTimeUpdate);
    }
    get modifyAttrKey() {
      return this.json.cBhvr.attrList[0];
    }
    updateCurrentValue() {
      if (this.timingTarget) {
        const t3 = QA(this.timingTarget, this.json.cBhvr.attrList[0]);
        t3 && (this.currentColorString = t3);
      }
    }
  }
  class xR extends tR {
    constructor(t3) {
      super(t3), this.isConflict = false, this.activeWhenConflict = "next", this.startVal = null, this.lastVal = null, this.onTimelineStart = (t4) => {
        this.lastVal = null, t4.isReverse || this.updateCurrentValue();
      }, this.onTimeUpdate = ({ duration: t4, delta: e3 }) => {
        const n2 = e3 / t4;
        let i2 = 0, r3 = 0;
        if (this.from !== void 0 && this.to !== void 0) {
          i2 = this.from, r3 = this.to;
          const t5 = i2 + (r3 - i2) * n2;
          this.timingTarget && (this.timingTarget.r = t5);
        } else if (this.by !== void 0) {
          this.lastVal || (this.lastVal = 0);
          const t5 = this.by * n2 - this.lastVal;
          this.lastVal = this.by * n2, this.timingTarget && (this.timingTarget.r += t5);
        }
      }, this.onTimeNodeStart = () => {
        var t4;
        Object(l.isNumber)((t4 = this.timingTarget) === null || t4 === void 0 ? void 0 : t4.r) && (this.startVal = this.timingTarget.r);
      }, this.onSeekToStart = () => {
        this.timingTarget && this.startVal !== null && (this.timingTarget.r = this.startVal);
      }, this.onSeekToEnd = () => {
        this.onTimeUpdate({ duration: 1, delta: 1, isReverse: false });
      }, this.from = this.json.from, this.to = this.json.to, this.by = this.json.by, this.by ? this.isConflict = false : this.isConflict = true, this.commonTimeNode.on("timeNodeStart", this.onTimeNodeStart), this.commonTimeNode.on("timeNodeCreate", this.onTimeNodeStart), this.commonTimeNode.on("timelineStart", this.onTimelineStart), this.commonTimeNode.on("timeUpdate", this.onTimeUpdate);
    }
    get modifyAttrKey() {
      return "rotate";
    }
    updateCurrentValue() {
      var t3;
      this.currentVal = (t3 = this.timingTarget) === null || t3 === void 0 ? void 0 : t3.r;
    }
  }
  class bR extends tR {
    constructor(t3) {
      super(t3), this.isConflict = false, this.activeWhenConflict = "next", this.isApplied = false, this.onTimeUpdate = () => {
        var t4, e3;
        const { cmd: n2, cmdType: i2 } = this.json;
        !this.isApplied && n2 && i2 && (this.isApplied = true, (e3 = (t4 = this.timingTarget) === null || t4 === void 0 ? void 0 : t4.cmd) === null || e3 === void 0 || e3.applyCommand(n2, i2));
      }, this.onSeekToStart = () => {
        var t4, e3;
        (e3 = (t4 = this.timingTarget) === null || t4 === void 0 ? void 0 : t4.cmd) === null || e3 === void 0 || e3.applyCommand("custom-pause", "call");
      }, this.onSeekToEnd = () => {
      }, this.commonTimeNode.on("timeNodeStart", () => {
        this.isApplied = false;
      }), this.commonTimeNode.on("timeNodeEnd", () => {
        this.isApplied = false;
      }), this.commonTimeNode.on("timeUpdate", this.onTimeUpdate);
    }
    get modifyAttrKey() {
      var t3, e3, n2, i2;
      return ((e3 = (t3 = this.json) === null || t3 === void 0 ? void 0 : t3.cmd) !== null && e3 !== void 0 ? e3 : "") + ((i2 = (n2 = this.json) === null || n2 === void 0 ? void 0 : n2.cmdType) !== null && i2 !== void 0 ? i2 : "");
    }
  }
  var TR = n(53);
  class wR {
    constructor(t3) {
      wR.useRtc || (this.howl = new TR.Howl({ src: [t3] }));
    }
    play() {
      var t3;
      (t3 = this.howl) === null || t3 === void 0 || t3.play();
    }
    pause() {
      var t3;
      (t3 = this.howl) === null || t3 === void 0 || t3.pause();
    }
    stop() {
      var t3;
      (t3 = this.howl) === null || t3 === void 0 || t3.stop();
    }
    destroy() {
      var t3;
      (t3 = this.howl) === null || t3 === void 0 || t3.unload();
    }
  }
  wR.useRtc = false;
  class SR {
    constructor(t3) {
      this.runtimeNodeEventHub = new a.a(), this.stopAudio = () => {
        this.audio.stop();
      }, this.destroy = () => {
        this.stopAudio(), this.audio.destroy();
      };
      const { json: e3, isIterate: n2, isSub: i2, eventHub: r3, ctx: o3, parent: s3, iterateType: l2, iterateIndex: u2, iterateId: h2 } = t3;
      this.json = e3, this.id = e3.cMediaNode.ctn.id, this.commonTimeNode = new MR({ json: e3.cMediaNode.ctn, isSub: i2, eventHubs: { global: r3, runtime: this.runtimeNodeEventHub }, ctx: o3, parent: s3, isIterate: n2, iterateType: l2, iterateIndex: u2, iterateId: h2 }), this.audio = new wR(e3.cMediaNode.tgtEl), this.commonTimeNode.on("timelineStart", () => {
        this.audio.play();
      }), this.commonTimeNode.on("seekToStart", this.stopAudio), this.commonTimeNode.on("seekToEnd", this.stopAudio), this.commonTimeNode.on("timeNodeDestroy", this.destroy);
    }
  }
  var ER = function(t3, e3, n2, i2) {
    return new (n2 || (n2 = Promise))(function(r3, o3) {
      function s3(t4) {
        try {
          l2(i2.next(t4));
        } catch (t5) {
          o3(t5);
        }
      }
      function a2(t4) {
        try {
          l2(i2.throw(t4));
        } catch (t5) {
          o3(t5);
        }
      }
      function l2(t4) {
        var e4;
        t4.done ? r3(t4.value) : (e4 = t4.value, e4 instanceof n2 ? e4 : new n2(function(t5) {
          t5(e4);
        })).then(s3, a2);
      }
      l2((i2 = i2.apply(t3, e3 || [])).next());
    });
  };
  class MR extends a.a {
    constructor(t3) {
      super(), this.uuid = Date.now().toString(32) + Math.random().toString(32).substring(2), this.isSub = false, this.isShadow = false, this.startCount = 0, this.applyCount = 0, this.isReverse = false, this.isConflictDispose = false, this.isIterateEnd = false, this.parentTimeNode = null, this.isActive = false, this.isDestroy = false, this.shouldSeekOnStart = false, this.repeatTimeoutId = "", this.iterateShadows = [], this.isEndEventsEmitted = false, this.isIterate = false, this.iterateType = "el", this.iterateIndex = 0, this.children = [], this.subList = [], this.duration = 0, this.timeDelta = 0, this.isNegativeSpeed = false, this.handleEndCond = () => {
        this.isActive && (this.isActive = false, this.dispose());
      }, this.handleActive = (t4 = true) => {
        if (this.isActive = true, this.applyCount += 1, this.json.iterate || this.emit("timeNodeStart", { id: this.uuid, activeCount: this.applyCount, isReverse: this.isReverse }), this.startCount > 0 && this.json.restart) {
          if (this.json.restart === "never")
            return;
          this.json.restart !== "whenNotActive" && this.json.restart !== "always" || (this.seekToStart(), this.emit("timeNodeRestart", { id: this.uuid, activeCount: this.applyCount, isReverse: this.isReverse }), this.startTimeLine(t4));
        } else
          this.startTimeLine(t4);
      }, this.updateTimeLine = (t4) => {
        const e4 = t4 / (mv.TARGET_FPMS || 0.06);
        this.timeDelta += e4, this.duration - this.timeDelta <= e4 && (this.timeDelta = this.duration), this.timeDelta < this.duration ? this.emit("timeUpdate", { delta: this.isReverse || this.isNegativeSpeed ? this.duration - this.timeDelta : this.timeDelta, duration: this.duration, isReverse: this.isReverse }) : (this.emit("timeUpdate", { delta: this.isReverse || this.isNegativeSpeed ? 0 : this.duration, duration: this.duration, isReverse: this.isReverse }), this.onTimeLineEnd());
      }, this.handleEnd = (t4 = false) => {
        (this.isTimeNodeEnd() || t4) && (this.isActive = false, this.isSub && this.destroy(), this.emitEndEvents());
      };
      const { isSub: e3, isIterate: n2, ctx: i2, eventHubs: r3, parent: o3, json: s3, iterateType: a2, iterateId: l2, iterateIndex: u2 } = t3;
      this.isSub = e3, this.isIterate = n2, this.parentTimeNode = o3, this.json = s3, this.ctx = i2, this.iterateIndex = u2, this.eventHubs = r3, this.iterateType = a2, this.iterateId = l2;
      const h2 = Number(this.json.dur), c2 = this.json.spd || 1;
      this.isNegativeSpeed = c2 < 0, Number.isNaN(h2) || (this.duration = h2 / Math.abs(c2)), this.uuid += "--" + this.json.id, this.setPreStyle(), s3.childTnLst && this.createChildren(s3.childTnLst), this.startConds = new JA(this.json.id || "", s3.stCondLst, r3, this.ctx), this.endConds = new JA(this.json.id || "", s3.endCondLst, r3, this.ctx), s3.endSync && (this.endSync = new JA(this.json.id || "", [s3.endSync], r3, this.ctx), this.endSync.on("active", () => {
        var t4;
        this.json.nodeType === "interactiveSeq" && (this.isActive = false, this.shouldSeekOnStart = true, this.emit("timeNodeEndSync"), (t4 = this.endSync) === null || t4 === void 0 || t4.reset());
      })), this.startConds.on("active", (t4) => {
        this.isActive || (this.shouldSeekOnStart && (this.shouldSeekOnStart = false, this.seekToStart()), this.handleActive(t4));
      }), this.endConds.on("active", () => {
        this.handleEndCond(), this.children.forEach((t4) => t4.commonTimeNode.handleEndCond());
      }), this.parentTimeNode && this.parentTimeNode.on("timeNodeStart", () => {
        this.applyCount = 0;
      }), this.isSub && this.json.masterRel === "nextClick" && this.startConds.addCond({ event: "shape slide onNext" }), this.json.iterate && this.isIterate === false && this.createIterateShadow();
    }
    createIterateShadow() {
      const t3 = iM();
      let e3 = true, n2 = 0;
      const i2 = (n3) => {
        n3 === t3 && (e3 = false, this.ctx.eventHub.removeListener("IterateTimeNodeEnd", i2));
      };
      for (this.ctx.eventHub.on("IterateTimeNodeEnd", i2); e3; ) {
        const e4 = JSON.parse(JSON.stringify(this.json)), i3 = new MR({ json: e4, isSub: false, eventHubs: this.eventHubs, ctx: this.ctx, parent: null, isIterate: true, iterateType: e4.iterate.type, iterateIndex: n2, iterateId: t3 });
        this.iterateShadows[n2] = i3, n2 += 1;
      }
    }
    isInfiniteRepeat() {
      return this.json.repeatCount > 999999998;
    }
    getReverse() {
      return this.isReverse;
    }
    setReverse(t3) {
      this.isReverse = t3;
    }
    createTimeNode(t3, e3) {
      let n2 = null;
      const i2 = { json: t3, isSub: e3, isIterate: this.isIterate, eventHub: this.eventHubs.global, ctx: this.ctx, parent: this, iterateType: this.iterateType, iterateIndex: this.iterateIndex, iterateId: this.iterateId };
      return t3.type === "seq" ? n2 = new $A(i2) : t3.type === "par" ? n2 = new AR(i2) : t3.type === "set" ? n2 = new eR(i2) : t3.type === "anim" ? n2 = new aR(i2) : t3.type === "animEffect" ? n2 = new gR(i2) : t3.type === "animMotion" ? n2 = new vR(i2) : t3.type === "animScale" ? n2 = new _R(i2) : t3.type === "animClr" ? n2 = new yR(i2) : t3.type === "animRot" ? n2 = new xR(i2) : t3.type === "cmd" ? n2 = new bR(i2) : t3.type === "audio" && (n2 = new SR(i2)), n2;
    }
    createSubList(t3) {
      this.subList = [], t3.forEach((t4) => {
        const e3 = this.createTimeNode(t4, true);
        e3 && this.subList.push(e3);
      });
    }
    bindCommonTimeNodeEvent(t3) {
      t3.commonTimeNode.on("timeNodeStart", (t4) => {
        this.emit("childTimeNodeStart", t4);
      }), t3.commonTimeNode.on("timeNodeEnd", (t4) => {
        this.emit("childTimeNodeEnd", t4), this.children.every((t5) => t5.commonTimeNode.isTimeNodeEnd()) && (this.json.iterate || this.allChildrenEndHandle());
      });
    }
    createChildren(t3) {
      function e3(t4) {
        return (e4 = t4, function(t5) {
          var e5;
          return !!((e5 = t5) === null || e5 === void 0 ? void 0 : e5.cBhvr);
        }(e4) ? e4.cBhvr.ctn : function(t5) {
          var e5, n2;
          return !!((n2 = (e5 = t5) === null || e5 === void 0 ? void 0 : e5.cMediaNode) === null || n2 === void 0 ? void 0 : n2.ctn);
        }(e4) ? e4.cMediaNode.ctn : e4.ctn).presetOrder;
        var e4;
      }
      if (t3 && t3[0] && e3(t3[0])) {
        [...t3].sort((t4, n2) => {
          var i2, r3;
          return ((i2 = e3(t4)) !== null && i2 !== void 0 ? i2 : 0) - ((r3 = e3(n2)) !== null && r3 !== void 0 ? r3 : 0);
        }).forEach((e4) => {
          const n2 = t3.findIndex((t4) => t4 === e4), i2 = this.createTimeNode(e4, false);
          i2 && (this.bindCommonTimeNodeEvent(i2), this.children[n2] = i2);
        });
      } else
        t3.forEach((t4) => {
          const e4 = this.createTimeNode(t4, false);
          e4 && (this.bindCommonTimeNodeEvent(e4), this.children.push(e4));
        });
    }
    playReverse() {
      this.isReverse = true, this.startReverseTimeLine(), this.children.forEach((t3) => t3.commonTimeNode.playReverse());
    }
    allChildrenEndHandle() {
      if (!this.isDestroy) {
        if (this.json.autoRev && !this.isReverse)
          return this.isReverse = true, void this.playReverse();
        this.isReverse && (this.isReverse = false), this.json.repeatCount && this.json.repeatCount > this.applyCount ? this.repeatTimeoutId = this.ctx.clock.setTimeout(() => {
          this.seekToStart(false), this.resetForRepeat(), this.startTimeNodeRepeat();
        }) : (this.json.iterate && !this.isIterate && (this.isIterateEnd = true), this.eventHubs.runtime.emit("runtime all end"), this.startSubList(), this.handleEnd());
      }
    }
    resetForRepeat() {
      this.timeDelta = 0, this.children.forEach((t3) => t3.commonTimeNode.resetForRepeat());
    }
    startSubList() {
      this.subList.forEach((t3) => t3.commonTimeNode.startTimeNode());
    }
    startReverseTimeLine() {
      this.timeDelta = 0;
      const t3 = 1e3 / this.ctx.ticker.maxFPS;
      this.duration <= t3 && this.duration > 0 ? (this.emit("timeUpdate", { delta: this.duration, duration: this.duration, isReverse: this.isReverse }), this.ctx.eventHub.emit($R.animateEnd), this.ctx.ticker.remove(this.updateTimeLine)) : this.duration > t3 && (this.ctx.eventHub.emit($R.animateStart), this.ctx.ticker.add(this.updateTimeLine));
    }
    startTimeLine(t3 = true) {
      if (t3 && (this.isEndEventsEmitted = false, this.eventHubs.global.emit(`time ${this.json.id} begin`), this.eventHubs.global.emit(`time ${this.json.id} onBegin`), this.eventHubs.runtime.emit(`runtime ${this.json.id} begin`)), this.json.iterate)
        return void this.startIterate();
      this.timeDelta = 0, this.emit("timelineStart", { id: this.uuid, activeCount: this.applyCount, isReverse: this.isReverse });
      const e3 = 1e3 / this.ctx.ticker.maxFPS;
      this.duration <= e3 && this.duration > 0 ? (this.timeDelta = this.isReverse ? 0 : this.duration, this.emit("timeUpdate", { delta: this.timeDelta, duration: this.duration, isReverse: this.isReverse }), this.emit("timelineEnd", { id: this.uuid, activeCount: this.applyCount, isReverse: this.isReverse }), this.ctx.ticker.addOnce(() => {
        this.onTimeLineEnd();
      })) : this.duration > e3 && (this.ctx.eventHub.emit($R.animateStart), this.updateTimeLine(0), this.ctx.ticker.add(this.updateTimeLine));
    }
    startIterate() {
      return ER(this, void 0, void 0, function* () {
        if (this.json.iterate) {
          this.isIterateEnd = false;
          for (const t3 of this.iterateShadows) {
            if (this.isIterateEnd)
              break;
            t3.children.forEach((t4) => {
              t4.commonTimeNode.startTimeNode();
            }), t3.applyCount += 1, yield this.ctx.clock.delay(this.json.iterate.interval);
          }
          this.onTimeLineEnd();
        }
      });
    }
    isNatureTimeEnd() {
      return this.duration >= 0 && this.timeDelta >= this.duration;
    }
    setPreStyle() {
      if (!this.json.presetClass)
        return;
      const t3 = [], e3 = (n2) => {
        n2.forEach((n3) => {
          var i2, r3, o3;
          n3.cBhvr && n3.cBhvr.target && t3.findIndex((t4) => t4.id === n3.cBhvr.target.id) < 0 && t3.push(n3.cBhvr.target), ((r3 = (i2 = n3 == null ? void 0 : n3.cBhvr) === null || i2 === void 0 ? void 0 : i2.ctn) === null || r3 === void 0 ? void 0 : r3.childTnLst) && n3.cBhvr.ctn.childTnLst.length > 0 && e3(n3.cBhvr.ctn.childTnLst), ((o3 = n3 == null ? void 0 : n3.ctn) === null || o3 === void 0 ? void 0 : o3.childTnLst) && n3.ctn.childTnLst.length > 0 && e3(n3.ctn.childTnLst);
        });
      };
      e3(this.json.childTnLst || []), t3.forEach((t4) => {
        if (this.json.iterate) {
          let e4 = 0, n2 = true;
          for (; n2; ) {
            const i2 = this.ctx.timingTargets.getTarget(t4, true, { type: this.json.iterate.type, index: e4, id: "" });
            i2 && (this.setPreStyleForTarget(i2), e4 += 1), n2 = !!i2;
          }
        } else {
          const e4 = this.ctx.timingTargets.getTarget(t4, false);
          e4 && this.setPreStyleForTarget(e4);
        }
      });
    }
    setPreStyleForTarget(t3) {
      var e3, n2;
      if (t3 && this.json.presetSubtype && (t3.presetSubType = this.json.presetSubtype), t3 && !t3.hasPreset)
        if (this.json.presetClass === "entr") {
          const i2 = (n2 = (e3 = this.json) === null || e3 === void 0 ? void 0 : e3.childTnLst) === null || n2 === void 0 ? void 0 : n2.filter((t4) => t4.type === "set" && t4.to === "visible");
          (i2 == null ? void 0 : i2.length) && (t3.hasPreset = true, t3.style.visibility = "hidden");
        } else
          (this.json.presetClass === "exit" || this.json.presetClass === "path") && (t3.hasPreset = true, t3.style.visibility = "visible");
    }
    startTimeNodeRepeat() {
      this.timeDelta = 0, this.isActive = true, this.applyCount += 1, this.startTimeLine(false), this.json.iterate || this.emit("timeNodeRepeat", { id: this.uuid, activeCount: this.applyCount, isReverse: this.isReverse });
    }
    startTimeNodeForce() {
      this.json.subTnLst && this.createSubList(this.json.subTnLst), this.timeDelta = 0, this.isActive = true, this.handleActive(false);
    }
    startTimeNode(t3 = true) {
      if (this.isDestroy)
        return;
      this.collectStartValue(), this.timeDelta = 0, this.isReverse = false, this.json.subTnLst && this.createSubList(this.json.subTnLst), this.startConds.setTriggerParams(t3);
      const e3 = this.json.stCondLst.filter((t4) => /^self/.test(t4.event || ""))[0];
      e3 && this.startConds.condHandle(e3);
      const n2 = this.json.endCondLst.filter((t4) => /^self/.test(t4.event || ""))[0];
      n2 && this.endConds.condHandle(n2), this.startConds.condHandle();
    }
    onTimeLineEnd() {
      this.dispose(), (this.children.length === 0 || this.json.iterate) && this.allChildrenEndHandle();
    }
    clearSubList() {
      this.subList.forEach((t3) => t3.commonTimeNode.destroy()), this.subList = [], this.children.forEach((t3) => {
        t3.commonTimeNode.clearSubList();
      });
    }
    seekToStart(t3 = true) {
      if (this.isEndEventsEmitted = false, this.isActive = false, this.dispose(), this.timeDelta = 0, this.emit("seekToStart"), this.json.iterate && !this.isIterate)
        return this.isIterateEnd = true, void this.iterateShadows.forEach((e3) => e3.seekToStart(t3));
      if (t3)
        for (let t4 = this.subList.length - 1; t4 >= 0; t4--) {
          const e3 = this.subList[t4];
          e3 == null || e3.commonTimeNode.seekToStart();
        }
      for (let t4 = this.children.length - 1; t4 >= 0; t4--) {
        const e3 = this.children[t4];
        e3 == null || e3.commonTimeNode.seekToStart();
      }
      for (let t4 = this.children.length - 1; t4 >= 0; t4--) {
        const e3 = this.children[t4];
        e3 == null || e3.commonTimeNode.seekToStart();
      }
    }
    dispose(t3 = false) {
      this.isConflictDispose = t3, this.ctx.clock.clearTimeout(this.repeatTimeoutId), this.ctx.eventHub.emit($R.animateEnd), this.ctx.ticker.remove(this.updateTimeLine), this.startConds.reset(), this.endConds.reset();
    }
    seekToEnd(t3, e3 = false) {
      if (this.isInfiniteRepeat())
        return;
      !this.isActive && this.applyCount <= 0 && this.collectStartValue(), this.applyCount = this.json.repeatCount, this.json.autoRev && (this.isReverse = true), this.timeDelta = this.duration, this.isActive = false, this.dispose();
      const n2 = this.json.autoRev || t3;
      if (n2 ? this.emit("seekToStart") : this.emit("seekToEnd"), this.json.iterate && !this.isIterate)
        return this.isIterateEnd = true, void this.iterateShadows.forEach((t4) => t4.seekToEnd(n2, e3));
      this.children.length === 0 && (this.eventHubs.runtime.emit("runtime all end"), this.handleEnd()), this.children.forEach((t4) => t4.commonTimeNode.seekToEnd(n2, e3)), e3 && this.json.subTnLst && (this.subList.length <= 0 && this.createSubList(this.json.subTnLst), this.subList.forEach((t4) => t4.commonTimeNode.seekToEnd(false)), this.clearSubList());
    }
    isTimeNodeEnd() {
      let t3 = true;
      return this.children.length > 0 && (t3 = t3 && this.children.every((t4) => t4.commonTimeNode.isTimeNodeEnd())), this.json.repeatCount && (t3 = t3 && this.applyCount >= this.json.repeatCount), this.json.autoRev && (t3 = t3 && !this.isReverse), t3 = t3 && this.isNatureTimeEnd(), !!this.isConflictDispose || (!(!this.isIterateEnd || !this.json.iterate) || t3);
    }
    emitEndEvents() {
      this.isEndEventsEmitted || (this.isEndEventsEmitted = true, this.eventHubs.global.emit(`time ${this.json.id} end`), this.eventHubs.global.emit(`time ${this.json.id} onEnd`), this.eventHubs.runtime.emit(`runtime ${this.json.id} end`), this.emit("timeNodeEnd", { id: this.uuid, activeCount: this.applyCount, isReverse: this.isReverse }));
    }
    collectStartValue() {
      this.emit("timeNodeCreate"), this.children.forEach((t3) => t3.commonTimeNode.collectStartValue());
    }
    destroy() {
      this.emit("timeNodeDestroy"), this.isDestroy = true, this.dispose(), this.startConds.removeAllListeners(), this.endConds.removeAllListeners(), this.children.forEach((t3) => t3.commonTimeNode.destroy()), this.clearSubList();
    }
  }
  class AR extends a.a {
    constructor(t3) {
      super(), this.isRunning = false, this.runtimeNodeEventHub = new a.a();
      const { json: e3, iterateType: n2, isIterate: i2, isSub: r3, parent: o3, ctx: s3, eventHub: l2, iterateIndex: u2, iterateId: h2 } = t3;
      this.id = e3.ctn.id, this.json = e3, this.ctx = s3, this.isIterate = i2, this.globalEventHub = l2, this.commonTimeNode = new MR({ json: e3.ctn, isSub: r3, eventHubs: { global: l2, runtime: this.runtimeNodeEventHub }, ctx: s3, parent: o3, isIterate: false, iterateType: n2, iterateIndex: u2, iterateId: h2 }), this.commonTimeNode.on("timeNodeStart", () => {
        this.commonTimeNode.children.forEach((t4) => {
          t4.commonTimeNode.setReverse(this.commonTimeNode.getReverse()), t4.commonTimeNode.startTimeNode();
        }), this.isRunning || (this.isRunning = true, this.globalEventHub.emit(`runtime ${this.id} begin`), this.emit("begin"));
      }), this.commonTimeNode.on("timeNodeRepeat", () => {
        this.commonTimeNode.children.forEach((t4) => {
          t4.commonTimeNode.startTimeNode(false);
        });
      }), this.commonTimeNode.on("timeNodeEnd", () => {
        this.commonTimeNode.isTimeNodeEnd() && this.isRunning && (this.isRunning = false, this.globalEventHub.emit(`runtime ${this.id} end`), this.emit("end"));
      });
    }
  }
  var RR = function(t3, e3, n2, i2) {
    return new (n2 || (n2 = Promise))(function(r3, o3) {
      function s3(t4) {
        try {
          l2(i2.next(t4));
        } catch (t5) {
          o3(t5);
        }
      }
      function a2(t4) {
        try {
          l2(i2.throw(t4));
        } catch (t5) {
          o3(t5);
        }
      }
      function l2(t4) {
        var e4;
        t4.done ? r3(t4.value) : (e4 = t4.value, e4 instanceof n2 ? e4 : new n2(function(t5) {
          t5(e4);
        })).then(s3, a2);
      }
      l2((i2 = i2.apply(t3, e3 || [])).next());
    });
  };
  class PR {
    constructor(t3, e3, n2) {
      this.json = t3, this.ctx = n2, this.globalEventHub = e3;
      const i2 = t3.timeNodeList.find((t4) => t4.type === "par" && t4.ctn.nodeType === "tmRoot");
      i2 && (this.tmRoot = new AR({ json: i2, isSub: false, isIterate: false, eventHub: e3, ctx: n2, parent: null, iterateType: "el", iterateIndex: 0, iterateId: "" }), this.mainSeq = this.tmRoot.commonTimeNode.children.find((t4) => {
        var e4, n3, i3;
        return ((e4 = t4.json) === null || e4 === void 0 ? void 0 : e4.type) === "seq" && ((i3 = (n3 = t4.json) === null || n3 === void 0 ? void 0 : n3.ctn) === null || i3 === void 0 ? void 0 : i3.nodeType) === "mainSeq";
      }));
    }
    findSeq(t3) {
      var e3;
      return (e3 = this.tmRoot) === null || e3 === void 0 ? void 0 : e3.commonTimeNode.children.find((e4) => {
        var n2, i2, r3;
        return ((n2 = e4.json) === null || n2 === void 0 ? void 0 : n2.type) === "seq" && ((r3 = (i2 = e4.json) === null || i2 === void 0 ? void 0 : i2.ctn) === null || r3 === void 0 ? void 0 : r3.id) === t3;
      });
    }
    start() {
      var t3, e3;
      return RR(this, void 0, void 0, function* () {
        this.json.autoPlayMainSeq ? (yield this.ctx.clock.delay(16), (t3 = this.mainSeq) === null || t3 === void 0 || t3.commonTimeNode.startTimeNode()) : (e3 = this.mainSeq) === null || e3 === void 0 || e3.commonTimeNode.startTimeNode();
      });
    }
    setMainSeqApplied() {
      this.mainSeq && (this.mainSeq.commonTimeNode.applyCount = 1);
    }
    collectMainSeqStartValue() {
      var t3;
      (t3 = this.mainSeq) === null || t3 === void 0 || t3.commonTimeNode.collectStartValue();
    }
    setMainSeqStep(t3, e3) {
      var n2;
      t3 === -1 && this.mainSeq && (this.mainSeq.commonTimeNode.applyCount = 1), (n2 = this.mainSeq) === null || n2 === void 0 || n2.setCurrentStep(t3, e3);
    }
    destroy() {
      var t3;
      this.globalEventHub.removeAllListeners(), (t3 = this.tmRoot) === null || t3 === void 0 || t3.commonTimeNode.destroy();
    }
    hasMainSeq() {
      return !!this.mainSeq && this.mainSeq.commonTimeNode.children.length > 0;
    }
    currentMainSeqState() {
      return this.mainSeq ? this.mainSeq.currentState : null;
    }
    currentMainSeqStep() {
      return this.mainSeq ? this.mainSeq.currentStep : 0;
    }
    currentMainSeqLength() {
      return this.mainSeq ? this.mainSeq.stepLength : 0;
    }
    mainSeqHasNextStep() {
      return !!this.mainSeq && this.mainSeq.hasNext();
    }
    mainSeqHasPrevStep() {
      return !!this.mainSeq && this.mainSeq.hasPrev();
    }
    seekInteractiveSeqToEnd(t3) {
      const e3 = this.findSeq(t3);
      e3 && e3.commonTimeNode.seekToEnd(false, true);
    }
    setInteractiveSeqState(t3, e3, n2) {
      const i2 = this.findSeq(t3);
      i2 && i2.setCurrentStep(e3, n2);
    }
    resetAllInteractiveSeq() {
      var t3;
      ((t3 = this.tmRoot) === null || t3 === void 0 ? void 0 : t3.commonTimeNode.children.filter((t4) => {
        var e3, n2, i2;
        return ((e3 = t4.json) === null || e3 === void 0 ? void 0 : e3.type) === "seq" && ((i2 = (n2 = t4.json) === null || n2 === void 0 ? void 0 : n2.ctn) === null || i2 === void 0 ? void 0 : i2.nodeType) === "interactiveSeq";
      })).forEach((t4) => {
        t4.setCurrentStep(0, "start");
      });
    }
    applyInteractiveAction(t3) {
      this.globalEventHub.emit(t3);
    }
  }
  var CR = function(t3, e3, n2, i2) {
    return new (n2 || (n2 = Promise))(function(r3, o3) {
      function s3(t4) {
        try {
          l2(i2.next(t4));
        } catch (t5) {
          o3(t5);
        }
      }
      function a2(t4) {
        try {
          l2(i2.throw(t4));
        } catch (t5) {
          o3(t5);
        }
      }
      function l2(t4) {
        var e4;
        t4.done ? r3(t4.value) : (e4 = t4.value, e4 instanceof n2 ? e4 : new n2(function(t5) {
          t5(e4);
        })).then(s3, a2);
      }
      l2((i2 = i2.apply(t3, e3 || [])).next());
    });
  };
  class IR extends ZA {
    constructor(t3, e3, n2) {
      super({ id: "stage", width: t3.width, height: t3.height, type: "Container", children: t3.children }, e3, n2), this.isRendered = false, this.isTimingStartValueCollected = false, this.globalEventHub = new a.a(), this.json = t3, this.container.visible = false, this.ctx = e3;
      const i2 = new Aw();
      i2.drawRect(0, 0, t3.width, t3.height), this.container.addChild(i2);
    }
    initOnReuse() {
      this.globalEventHub.on("c:prev slide", () => {
        this.ctx.eventHub.emit($R.requestPrevSlide);
      }), this.globalEventHub.on("c:next slide", () => {
        this.ctx.eventHub.emit($R.requestNextSlide);
      });
    }
    get interactiveContainer() {
      return this.container;
    }
    render(t3) {
      this.isRendered || (this.isRendered = true, super.render(t3), t3.push(() => CR(this, void 0, void 0, function* () {
        this.ctx.eventHub.emit("StageRenderEnd");
      })));
    }
    createTiming() {
      this.json.timing && !this.timing && (this.timing = new PR(this.json.timing, this.globalEventHub, this.ctx));
    }
    startTiming() {
      var t3;
      return ((t3 = this.timing) === null || t3 === void 0 ? void 0 : t3.start()) || Promise.resolve();
    }
    setMainSeqApplied() {
      var t3;
      (t3 = this.timing) === null || t3 === void 0 || t3.setMainSeqApplied();
    }
    setMainSeqStep(t3, e3) {
      var n2;
      (n2 = this.timing) === null || n2 === void 0 || n2.setMainSeqStep(t3, e3);
    }
    collectMainSeqStartValue() {
      var t3;
      this.isTimingStartValueCollected || (this.isTimingStartValueCollected = true, (t3 = this.timing) === null || t3 === void 0 || t3.collectMainSeqStartValue());
    }
    hasTiming() {
      return !!this.timing;
    }
    clearOnSlideChange() {
      var t3, e3;
      this.ctx.eventHub.removeAllListeners(), this.globalEventHub.removeAllListeners(), (t3 = this.timing) === null || t3 === void 0 || t3.resetAllInteractiveSeq(), (e3 = this.timing) === null || e3 === void 0 || e3.destroy(), this.timing = void 0, super.clearOnSlideChange();
    }
    destroy() {
      var t3, e3;
      this.isTimingStartValueCollected = false, this.isRendered = false, this.ctx.eventHub.removeAllListeners(), this.ctx.graphicsTexture.destroy(), this.ctx.fillTexture.destroy(), (t3 = this.ctx.bgTexture) === null || t3 === void 0 || t3.destroy(true), this.globalEventHub.removeAllListeners(), (e3 = this.timing) === null || e3 === void 0 || e3.destroy(), this.timing = void 0, super.destroy();
    }
    mainSeqStep() {
      var t3, e3;
      return (e3 = (t3 = this.timing) === null || t3 === void 0 ? void 0 : t3.currentMainSeqStep()) !== null && e3 !== void 0 ? e3 : 0;
    }
    mainSeqLength() {
      var t3, e3;
      return (e3 = (t3 = this.timing) === null || t3 === void 0 ? void 0 : t3.currentMainSeqLength()) !== null && e3 !== void 0 ? e3 : 0;
    }
    mainSeqHasNextStep() {
      var t3, e3;
      return (e3 = (t3 = this.timing) === null || t3 === void 0 ? void 0 : t3.mainSeqHasNextStep()) !== null && e3 !== void 0 && e3;
    }
    mainSeqHasPrevStep() {
      var t3, e3;
      return (e3 = (t3 = this.timing) === null || t3 === void 0 ? void 0 : t3.mainSeqHasPrevStep()) !== null && e3 !== void 0 && e3;
    }
    mainSeqState() {
      return this.timing ? this.timing.currentMainSeqState() : null;
    }
    nextStep() {
      var t3;
      this.hasTiming() && ((t3 = this.timing) === null || t3 === void 0 ? void 0 : t3.hasMainSeq()) ? this.globalEventHub.emit("shape slide onNext") : this.ctx.eventHub.emit($R.requestNextSlide);
    }
    prevStep() {
      var t3;
      this.hasTiming() && ((t3 = this.timing) === null || t3 === void 0 ? void 0 : t3.hasMainSeq()) ? this.globalEventHub.emit("shape slide onPrev") : this.ctx.eventHub.emit($R.requestPrevSlide);
    }
    applyInteractiveAction(t3) {
      var e3;
      (e3 = this.timing) === null || e3 === void 0 || e3.applyInteractiveAction(t3);
    }
    seekInteractiveSeqToEnd(t3) {
      var e3;
      (e3 = this.timing) === null || e3 === void 0 || e3.seekInteractiveSeqToEnd(t3);
    }
    setInteractiveSeqState(t3, e3, n2) {
      var i2;
      (i2 = this.timing) === null || i2 === void 0 || i2.setInteractiveSeqState(t3, e3, n2);
    }
    setMediaState(t3, e3) {
      return CR(this, void 0, void 0, function* () {
        const n2 = this.ctx.medias[t3];
        n2 && (e3 ? yield n2.play() : yield n2.pause());
      });
    }
    setMediaCurrentTime(t3, e3) {
      const n2 = this.ctx.medias[t3];
      n2 && n2.seek(e3);
    }
  }
  class OR {
    constructor(t3) {
      this.ticker = t3, this.tasks = [], this.couldRunning = false, this.applyNext = () => {
        const t4 = this.tasks[0];
        t4 && t4.applyNext();
      }, t3.add(this.applyNext);
    }
    addTask(t3) {
      this.tasks.push(t3), t3.once("task-finish", () => {
        const e3 = this.tasks.indexOf(t3);
        e3 >= 0 && this.tasks.splice(e3, 1);
      });
    }
    start() {
      this.couldRunning = true;
    }
    stop() {
      this.couldRunning = false;
    }
  }
  const LR = { pivot: { x: 0, y: 0 }, width: 0, height: 0 };
  function NR(t3, e3, n2) {
    var i2, r3, o3, s3, a2, l2, u2, h2, c2;
    const { width: d2, height: p2, pivot: f2 } = ((i2 = t3.geometry) === null || i2 === void 0 ? void 0 : i2.lineTransform) || LR, m2 = d2 || t3.width, g2 = p2 || t3.height;
    ((r3 = t3.geometry) === null || r3 === void 0 ? void 0 : r3.paths) && t3.geometry.paths.length > 0 && (e3.graphicsTexture.addGraphics(t3.id + "-path-graphics", (s3 = (o3 = t3.geometry) === null || o3 === void 0 ? void 0 : o3.paths) !== null && s3 !== void 0 ? s3 : [], t3.geometry.hash, f2 || { x: 0, y: 0 }, m2, g2, t3.lineStyle, n2, false), e3.graphicsTexture.addGraphics(t3.id + "-bg-graphics", (l2 = (a2 = t3.geometry) === null || a2 === void 0 ? void 0 : a2.paths) !== null && l2 !== void 0 ? l2 : [], t3.geometry.hash, f2 || { x: 0, y: 0 }, m2, g2, t3.lineStyle, n2, true));
    const v2 = ((h2 = (u2 = t3.geometry) === null || u2 === void 0 ? void 0 : u2.paths) === null || h2 === void 0 ? void 0 : h2.filter((t4) => t4.fill !== "none" && t4.fill !== "norm")) || [];
    for (const i3 of v2)
      e3.graphicsTexture.addGraphics(i3.id, [i3], i3.hash, (((c2 = t3.geometry) === null || c2 === void 0 ? void 0 : c2.lineTransform) || LR).pivot, m2, g2, t3.lineStyle, n2, true);
    t3.textBody && function(t4, e4, n3, i3) {
      for (let r4 = 0, o4 = t4.paragraphs.length; r4 < o4; r4++) {
        const o5 = t4.paragraphs[r4];
        for (let t5 = 0, s4 = o5.lines.length; t5 < s4; t5++) {
          const s5 = o5.lines[t5];
          for (let o6 = 0, a3 = s5.textUnits.length; o6 < a3; o6++) {
            const a4 = s5.textUnits[o6];
            if (!a4.content)
              continue;
            const l3 = s5.height, { width: u3 } = a4;
            if (a4.underLine) {
              const s6 = `M 0,0 L ${9525 * u3},0`, a5 = l3 / 16, h3 = { paths: [{ id: iM(), path: s6, fill: "norm", hasStroke: true, scale: { x: 1, y: 1 }, hash: hM()(s6) }], width: u3, height: a5 }, c3 = h3.paths.reduce((t6, e5) => t6 + e5.hash, ""), d3 = `${e4}-text-p${r4}-l${t5}-u${o6}-underLine`;
              n3.graphicsTexture.addGraphics(d3, h3.paths, c3, { x: 0, y: 0 }, u3, h3.height, { width: a5 }, i3, false);
            }
          }
        }
      }
    }(t3.textBody, t3.id, e3, n2);
  }
  function DR(t3, e3) {
    if (t3.fillStyle && t3.fillStyle.fillType !== "groupFill") {
      const { width: n2, height: i2 } = t3, r3 = t3.id + "-bg-fill";
      e3.fillTexture.addFill(r3, t3.fillStyle, n2, i2);
    }
  }
  function FR(t3, e3, n2) {
    BR(t3, e3, n2), t3.picFill.fillType !== "gifFill" && e3.fillTexture.addFill(t3.id + "-pic-fill", t3.picFill, t3.width, t3.height);
  }
  function BR(t3, e3, n2) {
    var i2, r3, o3, s3, a2, u2, h2, c2;
    if (t3.fillStyle && t3.fillStyle.fillType !== "gifFill" && t3.fillStyle.fillType !== "groupFill") {
      const n3 = ((i2 = t3.geometry) === null || i2 === void 0 ? void 0 : i2.fillTransform) || LR, l2 = (n3 == null ? void 0 : n3.width) || t3.width, u3 = (n3 == null ? void 0 : n3.height) || t3.height;
      e3.fillTexture.addFill(t3.id + "-bg-fill", t3.fillStyle, l2 + ((o3 = (r3 = t3.lineStyle) === null || r3 === void 0 ? void 0 : r3.width) !== null && o3 !== void 0 ? o3 : 0), u3 + ((a2 = (s3 = t3.lineStyle) === null || s3 === void 0 ? void 0 : s3.width) !== null && a2 !== void 0 ? a2 : 0));
    }
    if (((u2 = t3.lineStyle) === null || u2 === void 0 ? void 0 : u2.fill) && t3.lineStyle.fill.fillType !== "gifFill" && t3.lineStyle.fill.fillType !== "groupFill") {
      const { width: n3, height: i3 } = ((h2 = t3.geometry) === null || h2 === void 0 ? void 0 : h2.lineTransform) || LR, r4 = Object(l.isNumber)(t3.lineStyle.width) ? t3.lineStyle.width : 1;
      e3.fillTexture.addFill(t3.id + "-path-fill", t3.lineStyle.fill, (n3 || t3.width) + r4, (i3 || t3.height) + r4);
    }
    (c2 = t3.lineArrowList) === null || c2 === void 0 || c2.forEach((i3, r4) => {
      var o4, s4, a3, l2;
      const u3 = new FA(Object.assign(Object.assign({}, i3), { fillStyle: (o4 = t3.lineStyle) === null || o4 === void 0 ? void 0 : o4.fill, lineWidth: (a3 = (s4 = t3.lineStyle) === null || s4 === void 0 ? void 0 : s4.width) !== null && a3 !== void 0 ? a3 : 0 }));
      u3.graphicsId = `${t3.id}-arrow-${r4}-graphics`, e3.graphicsTexture.addGraphics(u3.graphicsId, (l2 = u3.paths) !== null && l2 !== void 0 ? l2 : [], u3.hash, u3.pivot || { x: 0, y: 0 }, u3.width, u3.height, void 0, n2, true), u3.textureId = `${t3.id}-arrow-${r4}-fill`, e3.fillTexture.addFill(u3.textureId, u3.fillStyle, u3.width, u3.height);
    }), t3.textBody && function(t4, e4, n3) {
      const { isHorz: i3 } = t4;
      for (let r4 = 0, o4 = t4.paragraphs.length; r4 < o4; r4++) {
        const o5 = t4.paragraphs[r4];
        for (let t5 = 0, s4 = o5.lines.length; t5 < s4; t5++) {
          const s5 = o5.lines[t5];
          for (let o6 = 0, a3 = s5.textUnits.length; o6 < a3; o6++) {
            const a4 = s5.textUnits[o6];
            if (!a4.content)
              continue;
            const l2 = s5.fillHeight || s5.height, u3 = s5.height, h3 = s5.width, { fill: c3, stroke: d2, content: p2 } = a4;
            c3 && (n3.fillTexture.addFill(`${e4}-text-p${r4}-l${t5}-u${o6}-fill`, { fillType: "blipFill", src: c3.key, filters: [{ type: "changeBulletColor", args: ["#000000", "#FFA500"] }] }, c3.width, c3.height, void 0, p2 === "\u25FE"), c3.fill && c3.fill.fillType !== "noFill" && (i3 ? n3.fillTexture.addFill(`${e4}-text-p${r4}-l${t5}-u${o6}-fill-bg`, c3.fill, h3, Math.max(l2, u3)) : n3.fillTexture.addFill(`${e4}-text-p${r4}-l${t5}-u${o6}-fill-bg`, c3.fill, l2, u3))), d2 && (n3.fillTexture.addFill(`${e4}-text-p${r4}-l${t5}-u${o6}-stroke`, { fillType: "blipFill", src: d2.key, filters: [] }, d2.width, d2.height), d2.fill && d2.fill.fillType !== "noFill" && n3.fillTexture.addFill(`${e4}-text-p${r4}-l${t5}-u${o6}-stroke-bg`, d2.fill, h3, u3));
          }
        }
      }
    }(t3.textBody, t3.id, e3);
  }
  var UR = n(54);
  const kR = new (n.n(UR)).a(), GR = kR.getDevice(), HR = kR.getBrowser(), zR = kR.getOS(), jR = { isDesktop() {
    let t3 = true;
    return GR.type === "mobile" && (t3 = false), /Samsung/.test(HR.name || "") && (t3 = false), window.__nativeTags && window.__nativeTags.platform && (t3 = false), t3;
  }, isIOS() {
    let t3 = false;
    return window.__nativeTags && window.__nativeTags.platform && /^ios/i.test(window.__nativeTags.platform) && (t3 = true), zR.name && /iOS/.test(zR.name) && (t3 = true), t3;
  }, isAndroid() {
    let t3 = false;
    return window.__nativeTags && window.__nativeTags.platform && /^android/i.test(window.__nativeTags.platform) && (t3 = true), zR.name && /android/i.test(zR.name) && (t3 = true), t3;
  }, isSupportTransaction() {
    var t3, e3;
    const n2 = (e3 = (t3 = window.__nativeTags) === null || t3 === void 0 ? void 0 : t3.platform) !== null && e3 !== void 0 ? e3 : "";
    if (n2) {
      const t4 = n2.split(" ");
      if (t4[1]) {
        if (/^iPad/.test(t4[1])) {
          const e4 = t4[1].match(/^iPad(\d+)/);
          return !!(e4 && e4[1] && parseInt(e4[1], 10) >= 6);
        }
        if (/^iPhone/.test(t4[1])) {
          const e4 = t4[1].match(/^iPhone(\d+)/);
          return !!(e4 && e4[1] && parseInt(e4[1], 10) >= 9);
        }
        return true;
      }
      return true;
    }
    return true;
  } };
  var VR = function(t3, e3, n2, i2) {
    return new (n2 || (n2 = Promise))(function(r3, o3) {
      function s3(t4) {
        try {
          l2(i2.next(t4));
        } catch (t5) {
          o3(t5);
        }
      }
      function a2(t4) {
        try {
          l2(i2.throw(t4));
        } catch (t5) {
          o3(t5);
        }
      }
      function l2(t4) {
        var e4;
        t4.done ? r3(t4.value) : (e4 = t4.value, e4 instanceof n2 ? e4 : new n2(function(t5) {
          t5(e4);
        })).then(s3, a2);
      }
      l2((i2 = i2.apply(t3, e3 || [])).next());
    });
  };
  function WR(t3) {
    return (t3 == null ? void 0 : t3.type) === "Container";
  }
  function XR(t3) {
    return (t3 == null ? void 0 : t3.type) === "Shape";
  }
  function qR(t3) {
    return (t3 == null ? void 0 : t3.type) === "Picture";
  }
  class YR {
    constructor(t3, e3, n2, i2, r3, o3, s3) {
      this.loader = t3, this.mode = e3, this.renderer = n2, this.ticker = i2, this.view = r3, this.clock = o3, this.objPoolGroup = s3, this.currentStageIndex = 0, this.cacheCount = jR.isDesktop() ? 2 : 1, this.stageStates = Object.create(null), this.stageJsons = Object.create(null), this.stageCtxs = Object.create(null), this.stageImpls = Object.create(null), this.taskId = "", this.url = "", this.microTaskManager = new OR(i2);
    }
    setSnapshotCache(t3) {
      this.snapshotCache = t3;
    }
    setResourceData(t3, e3) {
      this.taskId = t3, this.url = e3;
      try {
        this.fillCache = XE.a.createInstance({ name: "_slide_fill_cache_", storeName: this.taskId, driver: XE.a.INDEXEDDB, version: 1 }), ZE.updateActiveTime("_slide_fill_cache_", this.taskId).catch(() => {
        }), this.graphicsCache = XE.a.createInstance({ name: "_slide_graphics_cache_", storeName: this.taskId, driver: XE.a.INDEXEDDB, version: 1 }), ZE.updateActiveTime("_slide_graphics_cache_", this.taskId).catch(() => {
        });
      } catch (t4) {
      }
    }
    createCtx(t3) {
      const { task: e3 } = this.stageStates[t3];
      e3.addMTask(() => {
        const e4 = new lM(this.loader), n2 = new a.a(), i2 = { mode: this.mode, renderer: this.renderer, graphicsTexture: new xM(this.taskId, t3, this.microTaskManager, this.renderer, this.graphicsCache), fillTexture: new sA(this.taskId, t3, this.microTaskManager, this.renderer, e4, this.fillCache), stageWidth: 0, stageHeight: 0, ticker: this.ticker, timingTargets: new lA(n2), eventHub: n2, view: this.view, medias: Object.create(null), lastViewedIndex: 0, conflictTimeNodeManager: new aA(), clock: this.clock, spriteTexture: e4, slideIndex: t3 };
        return this.stageCtxs[t3] = i2, Promise.resolve();
      });
    }
    loadStageJson(t3) {
      const { task: e3 } = this.stageStates[t3];
      e3.addMTask(() => VR(this, void 0, void 0, function* () {
        const e4 = yield this.loader.fetchJson(`${this.url}/${this.taskId}/jsonOutput/slide-${t3}.json`);
        this.stageJsons[t3] = e4, this.stageCtxs[t3].stageWidth = e4.width, this.stageCtxs[t3].stageHeight = e4.height;
      }));
    }
    loadSpriteSheets(t3) {
      const { task: e3 } = this.stageStates[t3];
      e3.addMTask(() => {
        const n2 = this.stageJsons[t3], { spriteTexture: i2 } = this.stageCtxs[t3], { sheets: r3 } = n2;
        if (r3) {
          const t4 = r3.map((t5) => () => i2.loadSpriteSheetItem(this.url, this.taskId, t5));
          e3.addSubMTask(t4);
        }
        return Promise.resolve();
      });
    }
    createStage(t3) {
      const { task: e3 } = this.stageStates[t3];
      e3.addMTask(() => {
        const e4 = this.stageJsons[t3], n2 = this.stageCtxs[t3], i2 = new IR(e4, n2, { x: 0, y: 0 });
        return this.stageImpls[t3] = i2, i2.preRender(), Promise.resolve();
      });
    }
    collectChildren(t3, e3) {
      var n2;
      e3.push(t3), (WR(t3) || ((n2 = t3) == null ? void 0 : n2.type) === "Stage") && t3.children.forEach((t4) => {
        t4 && this.collectChildren(t4, e3);
      });
    }
    addFill(t3) {
      const { task: e3 } = this.stageStates[t3];
      e3.addMTask(() => VR(this, void 0, void 0, function* () {
        const n2 = this.stageJsons[t3], i2 = this.stageCtxs[t3];
        if (yield i2.fillTexture.hasLocalCache())
          return;
        const r3 = [];
        this.collectChildren(n2, r3);
        const o3 = Math.ceil(r3.length / 10), s3 = [];
        for (let t4 = 0; t4 < r3.length; t4 += o3) {
          const e4 = r3.slice(t4, t4 + o3);
          s3.push(() => (e4.forEach((t5) => {
            WR(t5) ? DR(t5, i2) : XR(t5) ? BR(t5, i2, this.objPoolGroup) : qR(t5) && FR(t5, i2, this.objPoolGroup);
          }), Promise.resolve()));
        }
        e3.addSubMTask(s3);
      }));
    }
    addGraphics(t3) {
      const { task: e3 } = this.stageStates[t3];
      e3.addMTask(() => VR(this, void 0, void 0, function* () {
        const n2 = this.stageJsons[t3], i2 = this.stageCtxs[t3];
        if (yield i2.graphicsTexture.hasLocalCache())
          return;
        const r3 = [];
        this.collectChildren(n2, r3);
        const o3 = Math.ceil(r3.length / 10), s3 = [];
        for (let t4 = 0; t4 < r3.length; t4 += o3) {
          const e4 = r3.slice(t4, t4 + o3);
          s3.push(() => (e4.forEach((t5) => {
            (XR(t5) || qR(t5)) && NR(t5, i2, this.objPoolGroup);
          }), Promise.resolve()));
        }
        e3.addSubMTask(s3);
      }));
    }
    createFillTexture(t3) {
      const { task: e3 } = this.stageStates[t3];
      e3.addMTask(() => VR(this, void 0, void 0, function* () {
        const n2 = this.stageCtxs[t3];
        if (yield n2.fillTexture.hasLocalCache()) {
          const t4 = (yield n2.fillTexture.getTextureKeys()).map((t5) => () => n2.fillTexture.loadFromCache(t5));
          return void e3.addSubMTask(t4);
        }
        const i2 = n2.fillTexture.pack();
        yield n2.fillTexture.setCacheLength(i2.length);
        const r3 = i2.map((t4, e4) => () => (n2.fillTexture.render(t4, e4), Promise.resolve()));
        e3.addSubMTask(r3);
      }));
    }
    createGraphicsTexture(t3) {
      const { task: e3 } = this.stageStates[t3];
      e3.addMTask(() => VR(this, void 0, void 0, function* () {
        const n2 = this.stageCtxs[t3];
        if (yield n2.graphicsTexture.hasLocalCache()) {
          const t4 = (yield n2.graphicsTexture.getTextureKeys()).map((t5) => () => n2.graphicsTexture.loadFromCache(t5));
          return void e3.addSubMTask(t4);
        }
        const i2 = n2.graphicsTexture.pack();
        yield n2.graphicsTexture.setCacheLength(i2.length);
        const r3 = i2.map((t4, e4) => () => n2.graphicsTexture.render(t4, e4, this.objPoolGroup));
        e3.addSubMTask(r3);
      }));
    }
    renderStage(t3) {
      const { task: e3 } = this.stageStates[t3];
      e3.addMTask(() => VR(this, void 0, void 0, function* () {
        const n2 = this.stageImpls[t3], i2 = this.stageCtxs[t3], r3 = [];
        yield n2.render(r3);
        const o3 = Math.ceil(r3.length / 10), s3 = [];
        for (let t4 = 0; t4 < r3.length; t4 += o3) {
          const e4 = r3.slice(t4, t4 + o3);
          s3.push(() => VR(this, void 0, void 0, function* () {
            for (const t5 of e4)
              yield t5();
          }));
        }
        s3.push(() => VR(this, void 0, void 0, function* () {
          var e4, r4;
          if (!(yield (e4 = this.snapshotCache) === null || e4 === void 0 ? void 0 : e4.getItem(t3.toString())) && KR.platform.isSupportTransaction()) {
            n2.createTiming(), n2.container.visible = true, n2.collectMainSeqStartValue(), n2.setMainSeqStep(0, "start");
            const e5 = Hy.create({ width: n2.json.width, height: n2.json.height, resolution: 1 });
            KR.textureCacheSize += e5.width * e5.height, i2.renderer.render(n2.container, { renderTexture: e5 });
            const o4 = i2.renderer.plugins.extract.base64(e5, "image/jpeg");
            yield (r4 = this.snapshotCache) === null || r4 === void 0 ? void 0 : r4.setItem(t3.toString() + "-start", o4), n2.container.visible = false, e5.destroy(), n2.timing && (n2.timing.destroy(), n2.timing = void 0);
          }
        })), e3.addSubMTask(s3);
      }));
    }
    destroyStageByIndex(t3) {
      this.stageStates[t3].state === "load" && this.stageStates[t3].task.cancel(), delete this.stageStates[t3];
      this.stageImpls[t3].destroy(), delete this.stageImpls[t3], delete this.stageCtxs[t3];
    }
    destroyStage() {
      Object.keys(this.stageImpls).forEach((t3) => {
        const e3 = parseInt(t3, 10);
        Math.abs(this.currentStageIndex - e3) > this.cacheCount && this.destroyStageByIndex(e3);
      });
    }
    destroyAllStage() {
      Object.keys(this.stageImpls).forEach((t3) => {
        const e3 = parseInt(t3, 10);
        this.destroyStageByIndex(e3);
      });
    }
    preload(t3, e3 = false) {
      if (this.stageImpls[t3] || this.stageStates[t3])
        return Promise.resolve();
      const n2 = new _M();
      return this.stageStates[t3] = { state: "load", task: n2 }, this.createCtx(t3), this.loadStageJson(t3), this.loadSpriteSheets(t3), this.createStage(t3), this.addFill(t3), this.createFillTexture(t3), this.addGraphics(t3), this.createGraphicsTexture(t3), this.renderStage(t3), this.microTaskManager.addTask(n2), e3 ? n2.applyAll() : new Promise((e4) => {
        n2.once("task-finish", () => {
          this.stageStates[t3].state = "finish";
          Object.keys(this.stageStates).length > 2 * this.cacheCount + 1 && this.destroyStage(), e4();
        });
      });
    }
    getStageJson(t3) {
      return this.stageJsons[t3] || null;
    }
    getStage(t3) {
      return VR(this, void 0, void 0, function* () {
        this.currentStageIndex = t3;
        const e3 = this.stageStates[t3];
        return (e3 == null ? void 0 : e3.state) === "finish" && this.stageImpls[t3] ? this.stageImpls[t3] : (e3 == null ? void 0 : e3.state) === "load" ? (yield e3.task.applyAll(), this.stageImpls[t3]) : (yield this.preload(t3, true), this.stageImpls[t3]);
      });
    }
  }
  var ZR = function(t3, e3, n2, i2) {
    return new (n2 || (n2 = Promise))(function(r3, o3) {
      function s3(t4) {
        try {
          l2(i2.next(t4));
        } catch (t5) {
          o3(t5);
        }
      }
      function a2(t4) {
        try {
          l2(i2.throw(t4));
        } catch (t5) {
          o3(t5);
        }
      }
      function l2(t4) {
        var e4;
        t4.done ? r3(t4.value) : (e4 = t4.value, e4 instanceof n2 ? e4 : new n2(function(t5) {
          t5(e4);
        })).then(s3, a2);
      }
      l2((i2 = i2.apply(t3, e3 || [])).next());
    });
  };
  r2.skipHello();
  const JR = { randomBar: "RandomLines", circle: "Shape", ripple: "Ripples", wipe: "Erase", dissolve: "Dissolve", morph: "Smooth", fade: "FadeInOut", push: "Push", split: "Separation", reveal: "Display", pull: "Uncover", cover: "Cover", flash: "Flash", checker: "Checkerboard", blinds: "WindowShades", curtains: "Curtain", fallOver: "Fall", drape: "Suspension", wheel: "Clock", comb: "Combing", warp: "Scale", peelOff: "PeelOff", flip: "Flip" }, $R = { mainSeqStepChange: "mainSeqStepChange", mainSeqStateChange: "mainSeqStateChange", interactiveSeqStateChange: "interactiveSeqStateChange", interactiveSeqAction: "interactiveSeqAction", mainSeqStepStart: "mainSeqStepStart", mainSeqStepEnd: "mainSeqStepEnd", slideChange: "slideChange", renderStart: "renderStart", renderEnd: "renderEnd", hyperlinkTrigger: "hyperlinkTrigger", animateStart: "animateStart", animateEnd: "animateEnd", mediaSeek: "mediaSeek", mediaPlay: "mediaPlay", mediaPause: "mediaPause", requestNextSlide: "requestNextSlide", requestPrevSlide: "requestPrevSlide", requestGotoSlide: "requestGotoSlide" };
  class KR extends a.a {
    constructor(t3, e3 = {}) {
      super(), this.loader = new $E(true), this.transactionPlayer = null, this.transactionSprite = new Ow(), this.isForward = true, this.drawCall = 0, this.scale = 1, this.prevSlideBase64 = null, this.fps = new qE(), this.designWidth = 0, this.designHeight = 0, this.currentIndex = 0, this.slideCount = 0, this.runtime = { drawCall: 0, fps: 0 }, this.mode = t3;
      let n2 = Math.max(window.devicePixelRatio, 2);
      jR.isDesktop() || (n2 = 1), this.config = { minFPS: Object(l.isUndefined)(e3.minFPS) ? 30 : e3.minFPS, maxFPS: Object(l.isUndefined)(e3.maxFPS) ? 40 : e3.maxFPS, resolution: Object(l.isUndefined)(e3.resolution) ? n2 : e3.resolution, autoFPS: !Object(l.isUndefined)(e3.autoFPS) && e3.autoFPS, autoResolution: !Object(l.isUndefined)(e3.autoResolution) && e3.autoResolution, transactionBgColor: Object(l.isUndefined)(e3.transactionBgColor) ? 0 : e3.transactionBgColor }, this.app = new Lb({ antialias: true, autoDensity: false, backgroundColor: 16777215 }), this.updateConfig(this.config), this.app.view.style.zIndex = "1", this.app.stage.sortableChildren = true;
      const i2 = this.app.renderer, { drawElements: r3 } = i2.gl;
      i2.gl.drawElements = (...t4) => {
        r3.call(i2.gl, ...t4), this.drawCall += 1;
      }, this.fps.on("update", (t4) => {
        if (t4 < this.config.minFPS) {
          if (this.config.autoResolution) {
            const t5 = this.scale * this.config.resolution * 0.7, e4 = this.app.renderer.resolution, n3 = Math.max(t5, e4 - 0.1);
            n3 >= t5 && this.updateResolution(n3);
          }
          if (this.config.autoFPS) {
            const t5 = 14, { minFPS: e4, maxFPS: n3 } = this.app.ticker, i3 = Math.max(t5, e4 - 2), r4 = Math.max(t5, n3 - 2);
            i3 >= t5 && r4 >= t5 && (this.app.ticker.minFPS = i3, this.app.ticker.maxFPS = r4);
          }
        } else if (t4 > this.config.maxFPS) {
          if (this.config.autoResolution) {
            const t5 = this.scale * this.config.resolution, e4 = this.app.renderer.resolution, n3 = Math.min(t5, e4 + 0.1);
            n3 <= this.config.resolution && this.updateResolution(n3);
          }
          if (this.config.autoFPS) {
            const t5 = this.config.minFPS, e4 = this.config.maxFPS, { minFPS: n3, maxFPS: i3 } = this.app.ticker, r4 = Math.min(t5, n3 + 2), o3 = Math.min(e4, i3 + 2);
            r4 <= t5 && o3 <= e4 && (this.app.ticker.minFPS = r4, this.app.ticker.maxFPS = o3);
          }
        }
      }), this.app.ticker.add(() => {
        this.runtime.drawCall = this.drawCall, this.runtime.fps = Math.floor(this.app.ticker.minFPS), this.drawCall = 0;
      }, null, ey.LOW), this.clock = new sM(this.app.ticker), this.objPoolGroup = iM(), this.stagePool = new YR(this.loader, this.mode, this.app.renderer, this.app.ticker, this.app.view, this.clock, this.objPoolGroup), jR.isSupportTransaction() && (this.transactionPlayer = new og());
    }
    get view() {
      return this.app.renderer ? this.app.view : null;
    }
    get nextSlideIndex() {
      var t3;
      return ((t3 = this.currentStage) === null || t3 === void 0 ? void 0 : t3.json.nextIndex) ? this.currentStage.json.nextIndex : this.currentIndex + 1;
    }
    get prevSlideIndex() {
      var t3;
      return ((t3 = this.currentStage) === null || t3 === void 0 ? void 0 : t3.json.prevIndex) ? this.currentStage.json.prevIndex : this.currentIndex - 1;
    }
    updateConfig(t3) {
      Object(l.isUndefined)(t3.minFPS) || (this.config.minFPS = t3.minFPS, this.app.ticker.minFPS = t3.minFPS), Object(l.isUndefined)(t3.maxFPS) || (this.config.maxFPS = t3.maxFPS, this.app.ticker.maxFPS = t3.maxFPS), Object(l.isUndefined)(t3.resolution) || (this.config.resolution = t3.resolution, this.updateResolution(this.scale * this.config.resolution)), Object(l.isUndefined)(t3.autoFPS) || (this.config.autoFPS = t3.autoFPS), Object(l.isUndefined)(t3.autoResolution) || (this.config.autoResolution = t3.autoResolution), Object(l.isUndefined)(t3.transactionBgColor) || (this.config.transactionBgColor = t3.transactionBgColor);
    }
    preload(t3) {
      return ZR(this, void 0, void 0, function* () {
        t3 < 1 || t3 > this.slideCount || !this.loader.cache || (yield this.stagePool.preload(t3));
      });
    }
    setResourceData(t3, e3) {
      this.taskId = t3, this.url = e3, this.stagePool.setResourceData(t3, e3), this.loader.bindTask(t3);
      const n2 = this.taskId;
      this.snapshotCache = XE.a.createInstance({ name: "_slide_snapshot_cache_", storeName: n2, driver: XE.a.INDEXEDDB, version: 1 }), ZE.updateActiveTime("_slide_snapshot_cache_", n2).catch(() => {
      }), this.stagePool.setSnapshotCache(this.snapshotCache);
    }
    setInteractive(t3) {
      this.app.stage.interactive = t3, this.app.stage.interactiveChildren = t3;
    }
    translateEvent(t3, e3) {
      e3.forEach((e4) => {
        t3.on(e4, (...t4) => {
          this.emit(e4, ...t4);
        });
      });
    }
    renderSlide(t3, e3 = false) {
      var n2, i2;
      return ZR(this, void 0, void 0, function* () {
        this.emit($R.renderStart, t3);
        const r3 = yield this.stagePool.getStage(t3);
        this.translateEvent(r3.ctx.eventHub, [$R.mainSeqStepChange, $R.mainSeqStateChange, $R.hyperlinkTrigger, $R.interactiveSeqAction, $R.mainSeqStepStart, $R.mainSeqStepEnd, $R.animateStart, $R.animateEnd, $R.mediaPlay, $R.mediaPause, $R.mediaSeek, $R.requestGotoSlide, $R.requestNextSlide, $R.requestPrevSlide, $R.interactiveSeqStateChange]), this.currentIndex = Number(t3);
        const { width: o3, height: s3, slideCount: a2 } = r3.json;
        this.slideCount = a2, this.designWidth = o3, this.designHeight = s3, r3.json.transition && r3.json.transition.type && !this.prevSlideBase64 && this.currentStage && (this.prevSlideBase64 = this.getBase64(this.currentStage)), (n2 = this.currentStage) === null || n2 === void 0 || n2.clearOnSlideChange();
        const l2 = this.currentStage;
        this.currentStage = r3, r3.initOnReuse(), r3.createTiming(), r3.container.visible = true, r3.collectMainSeqStartValue(), this.isForward ? r3.setMainSeqStep(0, "start") : r3.setMainSeqStep(-1, "end");
        let u2 = null;
        if (r3.json.transition && r3.json.transition.type) {
          const n3 = t3.toString() + (this.isForward || e3 ? "-start" : "-end"), r4 = yield (i2 = this.snapshotCache) === null || i2 === void 0 ? void 0 : i2.getItem(n3);
          u2 = r4 || this.getBase64(this.currentStage);
        }
        r3.container.visible = false, this.app.stage.addChild(r3.container), this.prevSlideBase64 && u2 && r3.json.transition && r3.json.transition.type && l2 && r3 && (yield this.playTransaction(this.prevSlideBase64, u2, r3.json.transition, l2, r3), this.prevSlideBase64 = null), this.isForward ? yield r3.startTiming() : r3.setMainSeqApplied(), this.updateResolution(this.config.resolution * this.scale), r3.container.visible = true, l2 && this.app.stage.removeChild(l2.container), this.emit($R.renderEnd, t3), this.emit($R.slideChange, t3), this.preload(t3 + 1).catch(() => {
        }), this.preload(t3 - 1).catch(() => {
        });
      });
    }
    getBase64(t3) {
      const e3 = Hy.create({ width: this.designWidth, height: this.designHeight, resolution: 1 });
      KR.textureCacheSize += e3.width * e3.height, this.app.renderer.render(t3.container, { renderTexture: e3 });
      const n2 = this.app.renderer.plugins.extract.base64(e3, "image/jpeg");
      return e3.destroy(true), n2;
    }
    playTransaction(t3, e3, n2, i2, r3) {
      return ZR(this, void 0, void 0, function* () {
        const o3 = this.app.view.parentElement;
        if (t3 && e3 && o3 && JR[n2.type] && this.transactionPlayer) {
          this.transactionSprite.zIndex = 999, this.transactionSprite.visible = false, this.app.stage.addChild(this.transactionSprite);
          const o4 = this.transactionPlayer.renderer.domElement, s3 = ky.from(o4), a2 = () => s3.update();
          return this.app.ticker.add(a2), this.transactionSprite.texture = s3, setTimeout(() => {
            this.transactionSprite.visible = true;
          }, 100), new Promise((o5) => {
            var s4, l2, u2;
            (s4 = this.transactionPlayer) === null || s4 === void 0 || s4.play({ reverse: !this.isForward, prevTextureUrl: t3, nextTextureUrl: e3, textureWidth: this.designWidth, textureHeight: this.designHeight, presetType: JR[n2.type], stageWidth: this.designWidth, stageHeight: this.designHeight, duration: (u2 = (l2 = this.currentStage) === null || l2 === void 0 ? void 0 : l2.json.transition) === null || u2 === void 0 ? void 0 : u2.dur, delay: 0, clearColor: this.config.transactionBgColor, onTransactionEnd: () => {
              o5(), i2.container.visible = false, r3.container.visible = true, this.app.stage.removeChild(this.transactionSprite), this.app.ticker.remove(a2);
            } });
          });
        }
        return Promise.resolve();
      });
    }
    scaleView(t3, e3 = false) {
      if (this.view && (this.view.style.width = Math.floor(this.designWidth * t3) + "px", this.view.style.height = Math.floor(this.designHeight * t3) + "px"), e3) {
        this.scale = t3;
        const e4 = this.scale * this.config.resolution;
        this.updateResolution(e4);
      }
    }
    updateResolution(t3) {
      this.app.ticker.addOnce(() => {
        const e3 = jR.isDesktop() ? t3 : 1;
        this.app.renderer.resolution = e3, this.app.renderer.plugins.interaction.resolution = this.app.renderer.resolution, this.app.renderer.resize(this.designWidth, this.designHeight);
      });
    }
    nextStep() {
      var t3;
      (t3 = this.currentStage) === null || t3 === void 0 || t3.nextStep();
    }
    prevStep() {
      var t3;
      (t3 = this.currentStage) === null || t3 === void 0 || t3.prevStep();
    }
    mainSeqLength() {
      var t3, e3;
      return (e3 = (t3 = this.currentStage) === null || t3 === void 0 ? void 0 : t3.mainSeqLength()) !== null && e3 !== void 0 ? e3 : 0;
    }
    mainSeqStep() {
      var t3, e3;
      return (e3 = (t3 = this.currentStage) === null || t3 === void 0 ? void 0 : t3.mainSeqStep()) !== null && e3 !== void 0 ? e3 : 0;
    }
    setMainSeqStep(t3, e3) {
      var n2;
      (n2 = this.currentStage) === null || n2 === void 0 || n2.setMainSeqStep(t3, e3);
    }
    mainSeqState() {
      var t3, e3;
      return (e3 = (t3 = this.currentStage) === null || t3 === void 0 ? void 0 : t3.mainSeqState()) !== null && e3 !== void 0 ? e3 : null;
    }
    mainSeqHasNextStep() {
      var t3, e3;
      return (e3 = (t3 = this.currentStage) === null || t3 === void 0 ? void 0 : t3.mainSeqHasNextStep()) !== null && e3 !== void 0 && e3;
    }
    mainSeqHasPrevStep() {
      var t3, e3;
      return (e3 = (t3 = this.currentStage) === null || t3 === void 0 ? void 0 : t3.mainSeqHasPrevStep()) !== null && e3 !== void 0 && e3;
    }
    nextTick(t3) {
      this.app.ticker.addOnce(() => {
        t3();
      }, ey.LOW);
    }
    applyInteractiveAction(t3) {
      var e3;
      (e3 = this.currentStage) === null || e3 === void 0 || e3.applyInteractiveAction(t3);
    }
    seekInteractiveSeqToEnd(t3) {
      var e3;
      (e3 = this.currentStage) === null || e3 === void 0 || e3.seekInteractiveSeqToEnd(t3);
    }
    setInteractiveSeqState(t3, e3, n2) {
      var i2;
      (i2 = this.currentStage) === null || i2 === void 0 || i2.setInteractiveSeqState(t3, e3, n2);
    }
    setMediaState(t3, e3) {
      var n2;
      return ZR(this, void 0, void 0, function* () {
        yield (n2 = this.currentStage) === null || n2 === void 0 ? void 0 : n2.setMediaState(t3, e3);
      });
    }
    setMediaCurrentTime(t3, e3) {
      var n2;
      (n2 = this.currentStage) === null || n2 === void 0 || n2.setMediaCurrentTime(t3, e3);
    }
    pause() {
      this.app.ticker.stop();
    }
    resume() {
      this.app.ticker.start();
    }
    getSnapshot() {
      return this.currentStage ? this.getBase64(this.currentStage) : "";
    }
    createSnapshotForNextSlide() {
      var t3;
      const e3 = this.nextSlideIndex, n2 = this.stagePool.getStageJson(e3);
      n2 && n2.transition && n2.transition.type && this.currentStage && this.transactionPlayer && (this.prevSlideBase64 = this.getBase64(this.currentStage), this.currentStage.timing && !this.currentStage.timing.mainSeqHasNextStep() && ((t3 = this.snapshotCache) === null || t3 === void 0 || t3.setItem(this.currentStage.json.index + "-end", this.prevSlideBase64)));
    }
    destroy() {
      var t3;
      try {
        this.app.renderer.filter.texturePool.clear(true), fM.collectObjectByGroup(this.objPoolGroup), mM.collectObjectByGroup(this.objPoolGroup), (t3 = this.transactionPlayer) === null || t3 === void 0 || t3.destroy(), this.loader.destroy(), this.fps.destroy(), this.stagePool.destroyAllStage();
        try {
          this.app.renderer.gl.getExtension("WEBGL_lose_context").loseContext();
        } catch (t4) {
        }
        this.app.destroy(true, { children: true, texture: true, baseTexture: true });
      } catch (t4) {
      }
    }
  }
  KR.textureCacheSize = 0, KR.storeManager = ZE, KR.platform = jR;
  var QR, tP = [], eP = "ResizeObserver loop completed with undelivered notifications.";
  !function(t3) {
    t3.BORDER_BOX = "border-box", t3.CONTENT_BOX = "content-box", t3.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
  }(QR || (QR = {}));
  var nP, iP = function(t3) {
    return Object.freeze(t3);
  }, rP = function(t3, e3) {
    this.inlineSize = t3, this.blockSize = e3, iP(this);
  }, oP = function() {
    function t3(t4, e3, n2, i2) {
      return this.x = t4, this.y = e3, this.width = n2, this.height = i2, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, iP(this);
    }
    return t3.prototype.toJSON = function() {
      var t4 = this;
      return { x: t4.x, y: t4.y, top: t4.top, right: t4.right, bottom: t4.bottom, left: t4.left, width: t4.width, height: t4.height };
    }, t3.fromRect = function(e3) {
      return new t3(e3.x, e3.y, e3.width, e3.height);
    }, t3;
  }(), sP = function(t3) {
    return t3 instanceof SVGElement && "getBBox" in t3;
  }, aP = function(t3) {
    if (sP(t3)) {
      var e3 = t3.getBBox(), n2 = e3.width, i2 = e3.height;
      return !n2 && !i2;
    }
    var r3 = t3, o3 = r3.offsetWidth, s3 = r3.offsetHeight;
    return !(o3 || s3 || t3.getClientRects().length);
  }, lP = function(t3) {
    var e3, n2;
    if (t3 instanceof Element)
      return true;
    var i2 = (n2 = (e3 = t3) === null || e3 === void 0 ? void 0 : e3.ownerDocument) === null || n2 === void 0 ? void 0 : n2.defaultView;
    return !!(i2 && t3 instanceof i2.Element);
  }, uP = typeof window != "undefined" ? window : {}, hP = new WeakMap(), cP = /auto|scroll/, dP = /^tb|vertical/, pP = /msie|trident/i.test(uP.navigator && uP.navigator.userAgent), fP = function(t3) {
    return parseFloat(t3 || "0");
  }, mP = function(t3, e3, n2) {
    return t3 === void 0 && (t3 = 0), e3 === void 0 && (e3 = 0), n2 === void 0 && (n2 = false), new rP((n2 ? e3 : t3) || 0, (n2 ? t3 : e3) || 0);
  }, gP = iP({ devicePixelContentBoxSize: mP(), borderBoxSize: mP(), contentBoxSize: mP(), contentRect: new oP(0, 0, 0, 0) }), vP = function(t3, e3) {
    if (e3 === void 0 && (e3 = false), hP.has(t3) && !e3)
      return hP.get(t3);
    if (aP(t3))
      return hP.set(t3, gP), gP;
    var n2 = getComputedStyle(t3), i2 = sP(t3) && t3.ownerSVGElement && t3.getBBox(), r3 = !pP && n2.boxSizing === "border-box", o3 = dP.test(n2.writingMode || ""), s3 = !i2 && cP.test(n2.overflowY || ""), a2 = !i2 && cP.test(n2.overflowX || ""), l2 = i2 ? 0 : fP(n2.paddingTop), u2 = i2 ? 0 : fP(n2.paddingRight), h2 = i2 ? 0 : fP(n2.paddingBottom), c2 = i2 ? 0 : fP(n2.paddingLeft), d2 = i2 ? 0 : fP(n2.borderTopWidth), p2 = i2 ? 0 : fP(n2.borderRightWidth), f2 = i2 ? 0 : fP(n2.borderBottomWidth), m2 = c2 + u2, g2 = l2 + h2, v2 = (i2 ? 0 : fP(n2.borderLeftWidth)) + p2, _2 = d2 + f2, y2 = a2 ? t3.offsetHeight - _2 - t3.clientHeight : 0, x2 = s3 ? t3.offsetWidth - v2 - t3.clientWidth : 0, b2 = r3 ? m2 + v2 : 0, T2 = r3 ? g2 + _2 : 0, w2 = i2 ? i2.width : fP(n2.width) - b2 - x2, S2 = i2 ? i2.height : fP(n2.height) - T2 - y2, E2 = w2 + m2 + x2 + v2, M2 = S2 + g2 + y2 + _2, A2 = iP({ devicePixelContentBoxSize: mP(Math.round(w2 * devicePixelRatio), Math.round(S2 * devicePixelRatio), o3), borderBoxSize: mP(E2, M2, o3), contentBoxSize: mP(w2, S2, o3), contentRect: new oP(c2, l2, w2, S2) });
    return hP.set(t3, A2), A2;
  }, _P = function(t3, e3, n2) {
    var i2 = vP(t3, n2), r3 = i2.borderBoxSize, o3 = i2.contentBoxSize, s3 = i2.devicePixelContentBoxSize;
    switch (e3) {
      case QR.DEVICE_PIXEL_CONTENT_BOX:
        return s3;
      case QR.BORDER_BOX:
        return r3;
      default:
        return o3;
    }
  }, yP = function(t3) {
    var e3 = vP(t3);
    this.target = t3, this.contentRect = e3.contentRect, this.borderBoxSize = iP([e3.borderBoxSize]), this.contentBoxSize = iP([e3.contentBoxSize]), this.devicePixelContentBoxSize = iP([e3.devicePixelContentBoxSize]);
  }, xP = function(t3) {
    if (aP(t3))
      return 1 / 0;
    for (var e3 = 0, n2 = t3.parentNode; n2; )
      e3 += 1, n2 = n2.parentNode;
    return e3;
  }, bP = function() {
    var t3 = 1 / 0, e3 = [];
    tP.forEach(function(n3) {
      if (n3.activeTargets.length !== 0) {
        var i3 = [];
        n3.activeTargets.forEach(function(e4) {
          var n4 = new yP(e4.target), r3 = xP(e4.target);
          i3.push(n4), e4.lastReportedSize = _P(e4.target, e4.observedBox), r3 < t3 && (t3 = r3);
        }), e3.push(function() {
          n3.callback.call(n3.observer, i3, n3.observer);
        }), n3.activeTargets.splice(0, n3.activeTargets.length);
      }
    });
    for (var n2 = 0, i2 = e3; n2 < i2.length; n2++) {
      (0, i2[n2])();
    }
    return t3;
  }, TP = function(t3) {
    tP.forEach(function(e3) {
      e3.activeTargets.splice(0, e3.activeTargets.length), e3.skippedTargets.splice(0, e3.skippedTargets.length), e3.observationTargets.forEach(function(n2) {
        n2.isActive() && (xP(n2.target) > t3 ? e3.activeTargets.push(n2) : e3.skippedTargets.push(n2));
      });
    });
  }, wP = function() {
    var t3, e3 = 0;
    for (TP(e3); tP.some(function(t4) {
      return t4.activeTargets.length > 0;
    }); )
      e3 = bP(), TP(e3);
    return tP.some(function(t4) {
      return t4.skippedTargets.length > 0;
    }) && (typeof ErrorEvent == "function" ? t3 = new ErrorEvent("error", { message: eP }) : ((t3 = document.createEvent("Event")).initEvent("error", false, false), t3.message = eP), window.dispatchEvent(t3)), e3 > 0;
  }, SP = [], EP = function(t3) {
    if (!nP) {
      var e3 = 0, n2 = document.createTextNode("");
      new MutationObserver(function() {
        return SP.splice(0).forEach(function(t4) {
          return t4();
        });
      }).observe(n2, { characterData: true }), nP = function() {
        n2.textContent = "" + (e3 ? e3-- : e3++);
      };
    }
    SP.push(t3), nP();
  }, MP = 0, AP = { attributes: true, characterData: true, childList: true, subtree: true }, RP = ["resize", "load", "transitionend", "animationend", "animationstart", "animationiteration", "keyup", "keydown", "mouseup", "mousedown", "mouseover", "mouseout", "blur", "focus"], PP = function(t3) {
    return t3 === void 0 && (t3 = 0), Date.now() + t3;
  }, CP = false, IP = new (function() {
    function t3() {
      var t4 = this;
      this.stopped = true, this.listener = function() {
        return t4.schedule();
      };
    }
    return t3.prototype.run = function(t4) {
      var e3 = this;
      if (t4 === void 0 && (t4 = 250), !CP) {
        CP = true;
        var n2, i2 = PP(t4);
        n2 = function() {
          var n3 = false;
          try {
            n3 = wP();
          } finally {
            if (CP = false, t4 = i2 - PP(), !MP)
              return;
            n3 ? e3.run(1e3) : t4 > 0 ? e3.run(t4) : e3.start();
          }
        }, EP(function() {
          requestAnimationFrame(n2);
        });
      }
    }, t3.prototype.schedule = function() {
      this.stop(), this.run();
    }, t3.prototype.observe = function() {
      var t4 = this, e3 = function() {
        return t4.observer && t4.observer.observe(document.body, AP);
      };
      document.body ? e3() : uP.addEventListener("DOMContentLoaded", e3);
    }, t3.prototype.start = function() {
      var t4 = this;
      this.stopped && (this.stopped = false, this.observer = new MutationObserver(this.listener), this.observe(), RP.forEach(function(e3) {
        return uP.addEventListener(e3, t4.listener, true);
      }));
    }, t3.prototype.stop = function() {
      var t4 = this;
      this.stopped || (this.observer && this.observer.disconnect(), RP.forEach(function(e3) {
        return uP.removeEventListener(e3, t4.listener, true);
      }), this.stopped = true);
    }, t3;
  }())(), OP = function(t3) {
    !MP && t3 > 0 && IP.start(), !(MP += t3) && IP.stop();
  }, LP = function() {
    function t3(t4, e3) {
      this.target = t4, this.observedBox = e3 || QR.CONTENT_BOX, this.lastReportedSize = { inlineSize: 0, blockSize: 0 };
    }
    return t3.prototype.isActive = function() {
      var t4, e3 = _P(this.target, this.observedBox, true);
      return t4 = this.target, sP(t4) || function(t5) {
        switch (t5.tagName) {
          case "INPUT":
            if (t5.type !== "image")
              break;
          case "VIDEO":
          case "AUDIO":
          case "EMBED":
          case "OBJECT":
          case "CANVAS":
          case "IFRAME":
          case "IMG":
            return true;
        }
        return false;
      }(t4) || getComputedStyle(t4).display !== "inline" || (this.lastReportedSize = e3), this.lastReportedSize.inlineSize !== e3.inlineSize || this.lastReportedSize.blockSize !== e3.blockSize;
    }, t3;
  }(), NP = function(t3, e3) {
    this.activeTargets = [], this.skippedTargets = [], this.observationTargets = [], this.observer = t3, this.callback = e3;
  }, DP = new WeakMap(), FP = function(t3, e3) {
    for (var n2 = 0; n2 < t3.length; n2 += 1)
      if (t3[n2].target === e3)
        return n2;
    return -1;
  }, BP = function() {
    function t3() {
    }
    return t3.connect = function(t4, e3) {
      var n2 = new NP(t4, e3);
      DP.set(t4, n2);
    }, t3.observe = function(t4, e3, n2) {
      var i2 = DP.get(t4), r3 = i2.observationTargets.length === 0;
      FP(i2.observationTargets, e3) < 0 && (r3 && tP.push(i2), i2.observationTargets.push(new LP(e3, n2 && n2.box)), OP(1), IP.schedule());
    }, t3.unobserve = function(t4, e3) {
      var n2 = DP.get(t4), i2 = FP(n2.observationTargets, e3), r3 = n2.observationTargets.length === 1;
      i2 >= 0 && (r3 && tP.splice(tP.indexOf(n2), 1), n2.observationTargets.splice(i2, 1), OP(-1));
    }, t3.disconnect = function(t4) {
      var e3 = this, n2 = DP.get(t4);
      n2.observationTargets.slice().forEach(function(n3) {
        return e3.unobserve(t4, n3.target);
      }), n2.activeTargets.splice(0, n2.activeTargets.length);
    }, t3;
  }(), UP = function() {
    function t3(t4) {
      if (arguments.length === 0)
        throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
      if (typeof t4 != "function")
        throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
      BP.connect(this, t4);
    }
    return t3.prototype.observe = function(t4, e3) {
      if (arguments.length === 0)
        throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
      if (!lP(t4))
        throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
      BP.observe(this, t4, e3);
    }, t3.prototype.unobserve = function(t4) {
      if (arguments.length === 0)
        throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
      if (!lP(t4))
        throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
      BP.unobserve(this, t4);
    }, t3.prototype.disconnect = function() {
      BP.disconnect(this);
    }, t3.toString = function() {
      return "function ResizeObserver () { [polyfill code] }";
    }, t3;
  }(), kP = function(t3, e3, n2, i2) {
    return new (n2 || (n2 = Promise))(function(r3, o3) {
      function s3(t4) {
        try {
          l2(i2.next(t4));
        } catch (t5) {
          o3(t5);
        }
      }
      function a2(t4) {
        try {
          l2(i2.throw(t4));
        } catch (t5) {
          o3(t5);
        }
      }
      function l2(t4) {
        var e4;
        t4.done ? r3(t4.value) : (e4 = t4.value, e4 instanceof n2 ? e4 : new n2(function(t5) {
          t5(e4);
        })).then(s3, a2);
      }
      l2((i2 = i2.apply(t3, e3 || [])).next());
    });
  }, GP = function(t3, e3) {
    var n2, i2, r3, o3, s3 = { label: 0, sent: function() {
      if (1 & r3[0])
        throw r3[1];
      return r3[1];
    }, trys: [], ops: [] };
    return o3 = { next: a2(0), throw: a2(1), return: a2(2) }, typeof Symbol == "function" && (o3[Symbol.iterator] = function() {
      return this;
    }), o3;
    function a2(o4) {
      return function(a3) {
        return function(o5) {
          if (n2)
            throw new TypeError("Generator is already executing.");
          for (; s3; )
            try {
              if (n2 = 1, i2 && (r3 = 2 & o5[0] ? i2.return : o5[0] ? i2.throw || ((r3 = i2.return) && r3.call(i2), 0) : i2.next) && !(r3 = r3.call(i2, o5[1])).done)
                return r3;
              switch (i2 = 0, r3 && (o5 = [2 & o5[0], r3.value]), o5[0]) {
                case 0:
                case 1:
                  r3 = o5;
                  break;
                case 4:
                  return s3.label++, { value: o5[1], done: false };
                case 5:
                  s3.label++, i2 = o5[1], o5 = [0];
                  continue;
                case 7:
                  o5 = s3.ops.pop(), s3.trys.pop();
                  continue;
                default:
                  if (!(r3 = s3.trys, (r3 = r3.length > 0 && r3[r3.length - 1]) || o5[0] !== 6 && o5[0] !== 2)) {
                    s3 = 0;
                    continue;
                  }
                  if (o5[0] === 3 && (!r3 || o5[1] > r3[0] && o5[1] < r3[3])) {
                    s3.label = o5[1];
                    break;
                  }
                  if (o5[0] === 6 && s3.label < r3[1]) {
                    s3.label = r3[1], r3 = o5;
                    break;
                  }
                  if (r3 && s3.label < r3[2]) {
                    s3.label = r3[2], s3.ops.push(o5);
                    break;
                  }
                  r3[2] && s3.ops.pop(), s3.trys.pop();
                  continue;
              }
              o5 = e3.call(t3, s3);
            } catch (t4) {
              o5 = [6, t4], i2 = 0;
            } finally {
              n2 = r3 = 0;
            }
          if (5 & o5[0])
            throw o5[1];
          return { value: o5[0] ? o5[1] : void 0, done: true };
        }([o4, a3]);
      };
    }
  }, HP = function() {
    function t3(t4, e3, n2, i2, r3) {
      this.state = "idle", this.index = -1, this.slideIndex = -1, this.fn = n2, this.index = t4, this.slideIndex = e3, this.eventHub = i2, this.id = r3;
    }
    return t3.prototype.apply = function() {
      return kP(this, void 0, void 0, function() {
        var t4;
        return GP(this, function(e3) {
          switch (e3.label) {
            case 0:
              this.eventHub.emit("task-start", this), e3.label = 1;
            case 1:
              return e3.trys.push([1, 3, , 4]), this.state = "start", [4, this.fn()];
            case 2:
              return e3.sent(), this.state = "end", this.eventHub.emit("task-end", this), [3, 4];
            case 3:
              return t4 = e3.sent(), this.eventHub.emit("task-error", { task: this, error: t4 }), [3, 4];
            case 4:
              return [2];
          }
        });
      });
    }, t3;
  }(), zP = function() {
    function t3() {
      var t4 = this;
      this.eventHub = new a.a(), this.tasks = [], this.index = 0, this.eventHub.on("task-end", function(e3) {
        var n2, i2 = t4.tasks.findIndex(function(t5) {
          return t5.index === e3.index;
        }), r3 = i2 + 1;
        r3 >= 0 && ((n2 = t4.tasks[r3]) === null || n2 === void 0 || n2.apply()), i2 >= 0 && (t4.tasks.splice(i2, 1), t4.replaceIdleTask()), t4.eventHub.emit("task-end-" + e3.id);
      }), this.eventHub.on("task-error", function(e3) {
        var n2 = e3.task, i2 = t4.tasks.findIndex(function(t5) {
          return t5.index === n2.index;
        });
        i2 >= 0 && (t4.tasks.splice(i2, 1), t4.replaceIdleTask());
      });
    }
    return t3.prototype.replaceIdleTask = function() {
      for (var t4, e3 = this, n2 = new Set(), i2 = 0, r3 = this.tasks.length; i2 < r3; i2++)
        this.tasks[i2].state === "idle" && ((t4 = this.tasks[i2 + 1]) === null || t4 === void 0 ? void 0 : t4.state) === "idle" && n2.add(i2);
      Array.from(n2).forEach(function(t5) {
        e3.tasks.splice(t5, 1);
      });
    }, t3.prototype.addTask = function(t4, e3, n2) {
      var i2 = new HP(this.index++, e3, t4, this.eventHub, n2);
      this.tasks.push(i2), this.tasks.sort(function(t5, e4) {
        return t5.index - e4.index;
      }), this.replaceIdleTask(), this.tasks.length === 1 && i2.apply();
    }, t3.prototype.hasStartTask = function() {
      return this.tasks.some(function(t4) {
        return t4.state === "start";
      });
    }, t3;
  }();
  function jP(t3, e3) {
    var n2 = t3.__state.conversionName.toString(), i2 = Math.round(t3.r), r3 = Math.round(t3.g), o3 = Math.round(t3.b), s3 = t3.a, a2 = Math.round(t3.h), l2 = t3.s.toFixed(1), u2 = t3.v.toFixed(1);
    if (e3 || n2 === "THREE_CHAR_HEX" || n2 === "SIX_CHAR_HEX") {
      for (var h2 = t3.hex.toString(16); h2.length < 6; )
        h2 = "0" + h2;
      return "#" + h2;
    }
    return n2 === "CSS_RGB" ? "rgb(" + i2 + "," + r3 + "," + o3 + ")" : n2 === "CSS_RGBA" ? "rgba(" + i2 + "," + r3 + "," + o3 + "," + s3 + ")" : n2 === "HEX" ? "0x" + t3.hex.toString(16) : n2 === "RGB_ARRAY" ? "[" + i2 + "," + r3 + "," + o3 + "]" : n2 === "RGBA_ARRAY" ? "[" + i2 + "," + r3 + "," + o3 + "," + s3 + "]" : n2 === "RGB_OBJ" ? "{r:" + i2 + ",g:" + r3 + ",b:" + o3 + "}" : n2 === "RGBA_OBJ" ? "{r:" + i2 + ",g:" + r3 + ",b:" + o3 + ",a:" + s3 + "}" : n2 === "HSV_OBJ" ? "{h:" + a2 + ",s:" + l2 + ",v:" + u2 + "}" : n2 === "HSVA_OBJ" ? "{h:" + a2 + ",s:" + l2 + ",v:" + u2 + ",a:" + s3 + "}" : "unknown format";
  }
  var VP = Array.prototype.forEach, WP = Array.prototype.slice, XP = { BREAK: {}, extend: function(t3) {
    return this.each(WP.call(arguments, 1), function(e3) {
      (this.isObject(e3) ? Object.keys(e3) : []).forEach(function(n2) {
        this.isUndefined(e3[n2]) || (t3[n2] = e3[n2]);
      }.bind(this));
    }, this), t3;
  }, defaults: function(t3) {
    return this.each(WP.call(arguments, 1), function(e3) {
      (this.isObject(e3) ? Object.keys(e3) : []).forEach(function(n2) {
        this.isUndefined(t3[n2]) && (t3[n2] = e3[n2]);
      }.bind(this));
    }, this), t3;
  }, compose: function() {
    var t3 = WP.call(arguments);
    return function() {
      for (var e3 = WP.call(arguments), n2 = t3.length - 1; n2 >= 0; n2--)
        e3 = [t3[n2].apply(this, e3)];
      return e3[0];
    };
  }, each: function(t3, e3, n2) {
    if (t3) {
      if (VP && t3.forEach && t3.forEach === VP)
        t3.forEach(e3, n2);
      else if (t3.length === t3.length + 0) {
        var i2, r3 = void 0;
        for (r3 = 0, i2 = t3.length; r3 < i2; r3++)
          if (r3 in t3 && e3.call(n2, t3[r3], r3) === this.BREAK)
            return;
      } else
        for (var o3 in t3)
          if (e3.call(n2, t3[o3], o3) === this.BREAK)
            return;
    }
  }, defer: function(t3) {
    setTimeout(t3, 0);
  }, debounce: function(t3, e3, n2) {
    var i2 = void 0;
    return function() {
      var r3 = this, o3 = arguments;
      function s3() {
        i2 = null, n2 || t3.apply(r3, o3);
      }
      var a2 = n2 || !i2;
      clearTimeout(i2), i2 = setTimeout(s3, e3), a2 && t3.apply(r3, o3);
    };
  }, toArray: function(t3) {
    return t3.toArray ? t3.toArray() : WP.call(t3);
  }, isUndefined: function(t3) {
    return t3 === void 0;
  }, isNull: function(t3) {
    return t3 === null;
  }, isNaN: function(t3) {
    function e3(e4) {
      return t3.apply(this, arguments);
    }
    return e3.toString = function() {
      return t3.toString();
    }, e3;
  }(function(t3) {
    return isNaN(t3);
  }), isArray: Array.isArray || function(t3) {
    return t3.constructor === Array;
  }, isObject: function(t3) {
    return t3 === Object(t3);
  }, isNumber: function(t3) {
    return t3 === t3 + 0;
  }, isString: function(t3) {
    return t3 === t3 + "";
  }, isBoolean: function(t3) {
    return t3 === false || t3 === true;
  }, isFunction: function(t3) {
    return t3 instanceof Function;
  } }, qP = [{ litmus: XP.isString, conversions: { THREE_CHAR_HEX: { read: function(t3) {
    var e3 = t3.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
    return e3 !== null && { space: "HEX", hex: parseInt("0x" + e3[1].toString() + e3[1].toString() + e3[2].toString() + e3[2].toString() + e3[3].toString() + e3[3].toString(), 0) };
  }, write: jP }, SIX_CHAR_HEX: { read: function(t3) {
    var e3 = t3.match(/^#([A-F0-9]{6})$/i);
    return e3 !== null && { space: "HEX", hex: parseInt("0x" + e3[1].toString(), 0) };
  }, write: jP }, CSS_RGB: { read: function(t3) {
    var e3 = t3.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
    return e3 !== null && { space: "RGB", r: parseFloat(e3[1]), g: parseFloat(e3[2]), b: parseFloat(e3[3]) };
  }, write: jP }, CSS_RGBA: { read: function(t3) {
    var e3 = t3.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
    return e3 !== null && { space: "RGB", r: parseFloat(e3[1]), g: parseFloat(e3[2]), b: parseFloat(e3[3]), a: parseFloat(e3[4]) };
  }, write: jP } } }, { litmus: XP.isNumber, conversions: { HEX: { read: function(t3) {
    return { space: "HEX", hex: t3, conversionName: "HEX" };
  }, write: function(t3) {
    return t3.hex;
  } } } }, { litmus: XP.isArray, conversions: { RGB_ARRAY: { read: function(t3) {
    return t3.length === 3 && { space: "RGB", r: t3[0], g: t3[1], b: t3[2] };
  }, write: function(t3) {
    return [t3.r, t3.g, t3.b];
  } }, RGBA_ARRAY: { read: function(t3) {
    return t3.length === 4 && { space: "RGB", r: t3[0], g: t3[1], b: t3[2], a: t3[3] };
  }, write: function(t3) {
    return [t3.r, t3.g, t3.b, t3.a];
  } } } }, { litmus: XP.isObject, conversions: { RGBA_OBJ: { read: function(t3) {
    return !!(XP.isNumber(t3.r) && XP.isNumber(t3.g) && XP.isNumber(t3.b) && XP.isNumber(t3.a)) && { space: "RGB", r: t3.r, g: t3.g, b: t3.b, a: t3.a };
  }, write: function(t3) {
    return { r: t3.r, g: t3.g, b: t3.b, a: t3.a };
  } }, RGB_OBJ: { read: function(t3) {
    return !!(XP.isNumber(t3.r) && XP.isNumber(t3.g) && XP.isNumber(t3.b)) && { space: "RGB", r: t3.r, g: t3.g, b: t3.b };
  }, write: function(t3) {
    return { r: t3.r, g: t3.g, b: t3.b };
  } }, HSVA_OBJ: { read: function(t3) {
    return !!(XP.isNumber(t3.h) && XP.isNumber(t3.s) && XP.isNumber(t3.v) && XP.isNumber(t3.a)) && { space: "HSV", h: t3.h, s: t3.s, v: t3.v, a: t3.a };
  }, write: function(t3) {
    return { h: t3.h, s: t3.s, v: t3.v, a: t3.a };
  } }, HSV_OBJ: { read: function(t3) {
    return !!(XP.isNumber(t3.h) && XP.isNumber(t3.s) && XP.isNumber(t3.v)) && { space: "HSV", h: t3.h, s: t3.s, v: t3.v };
  }, write: function(t3) {
    return { h: t3.h, s: t3.s, v: t3.v };
  } } } }], YP = void 0, ZP = void 0, JP = function() {
    ZP = false;
    var t3 = arguments.length > 1 ? XP.toArray(arguments) : arguments[0];
    return XP.each(qP, function(e3) {
      if (e3.litmus(t3))
        return XP.each(e3.conversions, function(e4, n2) {
          if (YP = e4.read(t3), ZP === false && YP !== false)
            return ZP = YP, YP.conversionName = n2, YP.conversion = e4, XP.BREAK;
        }), XP.BREAK;
    }), ZP;
  }, $P = void 0, KP = { hsv_to_rgb: function(t3, e3, n2) {
    var i2 = Math.floor(t3 / 60) % 6, r3 = t3 / 60 - Math.floor(t3 / 60), o3 = n2 * (1 - e3), s3 = n2 * (1 - r3 * e3), a2 = n2 * (1 - (1 - r3) * e3), l2 = [[n2, a2, o3], [s3, n2, o3], [o3, n2, a2], [o3, s3, n2], [a2, o3, n2], [n2, o3, s3]][i2];
    return { r: 255 * l2[0], g: 255 * l2[1], b: 255 * l2[2] };
  }, rgb_to_hsv: function(t3, e3, n2) {
    var i2 = Math.min(t3, e3, n2), r3 = Math.max(t3, e3, n2), o3 = r3 - i2, s3 = void 0;
    return r3 === 0 ? { h: NaN, s: 0, v: 0 } : (s3 = t3 === r3 ? (e3 - n2) / o3 : e3 === r3 ? 2 + (n2 - t3) / o3 : 4 + (t3 - e3) / o3, (s3 /= 6) < 0 && (s3 += 1), { h: 360 * s3, s: o3 / r3, v: r3 / 255 });
  }, rgb_to_hex: function(t3, e3, n2) {
    var i2 = this.hex_with_component(0, 2, t3);
    return i2 = this.hex_with_component(i2, 1, e3), i2 = this.hex_with_component(i2, 0, n2);
  }, component_from_hex: function(t3, e3) {
    return t3 >> 8 * e3 & 255;
  }, hex_with_component: function(t3, e3, n2) {
    return n2 << ($P = 8 * e3) | t3 & ~(255 << $P);
  } }, QP = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
    return typeof t3;
  } : function(t3) {
    return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
  }, tC = function(t3, e3) {
    if (!(t3 instanceof e3))
      throw new TypeError("Cannot call a class as a function");
  }, eC = function() {
    function t3(t4, e3) {
      for (var n2 = 0; n2 < e3.length; n2++) {
        var i2 = e3[n2];
        i2.enumerable = i2.enumerable || false, i2.configurable = true, "value" in i2 && (i2.writable = true), Object.defineProperty(t4, i2.key, i2);
      }
    }
    return function(e3, n2, i2) {
      return n2 && t3(e3.prototype, n2), i2 && t3(e3, i2), e3;
    };
  }(), nC = function t3(e3, n2, i2) {
    e3 === null && (e3 = Function.prototype);
    var r3 = Object.getOwnPropertyDescriptor(e3, n2);
    if (r3 === void 0) {
      var o3 = Object.getPrototypeOf(e3);
      return o3 === null ? void 0 : t3(o3, n2, i2);
    }
    if ("value" in r3)
      return r3.value;
    var s3 = r3.get;
    return s3 !== void 0 ? s3.call(i2) : void 0;
  }, iC = function(t3, e3) {
    if (typeof e3 != "function" && e3 !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
    t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
  }, rC = function(t3, e3) {
    if (!t3)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return !e3 || typeof e3 != "object" && typeof e3 != "function" ? t3 : e3;
  }, oC = function() {
    function t3() {
      if (tC(this, t3), this.__state = JP.apply(this, arguments), this.__state === false)
        throw new Error("Failed to interpret color arguments");
      this.__state.a = this.__state.a || 1;
    }
    return eC(t3, [{ key: "toString", value: function() {
      return jP(this);
    } }, { key: "toHexString", value: function() {
      return jP(this, true);
    } }, { key: "toOriginal", value: function() {
      return this.__state.conversion.write(this);
    } }]), t3;
  }();
  function sC(t3, e3, n2) {
    Object.defineProperty(t3, e3, { get: function() {
      return this.__state.space === "RGB" || oC.recalculateRGB(this, e3, n2), this.__state[e3];
    }, set: function(t4) {
      this.__state.space !== "RGB" && (oC.recalculateRGB(this, e3, n2), this.__state.space = "RGB"), this.__state[e3] = t4;
    } });
  }
  function aC(t3, e3) {
    Object.defineProperty(t3, e3, { get: function() {
      return this.__state.space === "HSV" || oC.recalculateHSV(this), this.__state[e3];
    }, set: function(t4) {
      this.__state.space !== "HSV" && (oC.recalculateHSV(this), this.__state.space = "HSV"), this.__state[e3] = t4;
    } });
  }
  oC.recalculateRGB = function(t3, e3, n2) {
    if (t3.__state.space === "HEX")
      t3.__state[e3] = KP.component_from_hex(t3.__state.hex, n2);
    else {
      if (t3.__state.space !== "HSV")
        throw new Error("Corrupted color state");
      XP.extend(t3.__state, KP.hsv_to_rgb(t3.__state.h, t3.__state.s, t3.__state.v));
    }
  }, oC.recalculateHSV = function(t3) {
    var e3 = KP.rgb_to_hsv(t3.r, t3.g, t3.b);
    XP.extend(t3.__state, { s: e3.s, v: e3.v }), XP.isNaN(e3.h) ? XP.isUndefined(t3.__state.h) && (t3.__state.h = 0) : t3.__state.h = e3.h;
  }, oC.COMPONENTS = ["r", "g", "b", "h", "s", "v", "hex", "a"], sC(oC.prototype, "r", 2), sC(oC.prototype, "g", 1), sC(oC.prototype, "b", 0), aC(oC.prototype, "h"), aC(oC.prototype, "s"), aC(oC.prototype, "v"), Object.defineProperty(oC.prototype, "a", { get: function() {
    return this.__state.a;
  }, set: function(t3) {
    this.__state.a = t3;
  } }), Object.defineProperty(oC.prototype, "hex", { get: function() {
    return this.__state.space !== "HEX" && (this.__state.hex = KP.rgb_to_hex(this.r, this.g, this.b), this.__state.space = "HEX"), this.__state.hex;
  }, set: function(t3) {
    this.__state.space = "HEX", this.__state.hex = t3;
  } });
  var lC = function() {
    function t3(e3, n2) {
      tC(this, t3), this.initialValue = e3[n2], this.domElement = document.createElement("div"), this.object = e3, this.property = n2, this.__onChange = void 0, this.__onFinishChange = void 0;
    }
    return eC(t3, [{ key: "onChange", value: function(t4) {
      return this.__onChange = t4, this;
    } }, { key: "onFinishChange", value: function(t4) {
      return this.__onFinishChange = t4, this;
    } }, { key: "setValue", value: function(t4) {
      return this.object[this.property] = t4, this.__onChange && this.__onChange.call(this, t4), this.updateDisplay(), this;
    } }, { key: "getValue", value: function() {
      return this.object[this.property];
    } }, { key: "updateDisplay", value: function() {
      return this;
    } }, { key: "isModified", value: function() {
      return this.initialValue !== this.getValue();
    } }]), t3;
  }(), uC = {};
  XP.each({ HTMLEvents: ["change"], MouseEvents: ["click", "mousemove", "mousedown", "mouseup", "mouseover"], KeyboardEvents: ["keydown"] }, function(t3, e3) {
    XP.each(t3, function(t4) {
      uC[t4] = e3;
    });
  });
  var hC = /(\d+(\.\d+)?)px/;
  function cC(t3) {
    if (t3 === "0" || XP.isUndefined(t3))
      return 0;
    var e3 = t3.match(hC);
    return XP.isNull(e3) ? 0 : parseFloat(e3[1]);
  }
  var dC = { makeSelectable: function(t3, e3) {
    t3 !== void 0 && t3.style !== void 0 && (t3.onselectstart = e3 ? function() {
      return false;
    } : function() {
    }, t3.style.MozUserSelect = e3 ? "auto" : "none", t3.style.KhtmlUserSelect = e3 ? "auto" : "none", t3.unselectable = e3 ? "on" : "off");
  }, makeFullscreen: function(t3, e3, n2) {
    var i2 = n2, r3 = e3;
    XP.isUndefined(r3) && (r3 = true), XP.isUndefined(i2) && (i2 = true), t3.style.position = "absolute", r3 && (t3.style.left = 0, t3.style.right = 0), i2 && (t3.style.top = 0, t3.style.bottom = 0);
  }, fakeEvent: function(t3, e3, n2, i2) {
    var r3 = n2 || {}, o3 = uC[e3];
    if (!o3)
      throw new Error("Event type " + e3 + " not supported.");
    var s3 = document.createEvent(o3);
    switch (o3) {
      case "MouseEvents":
        var a2 = r3.x || r3.clientX || 0, l2 = r3.y || r3.clientY || 0;
        s3.initMouseEvent(e3, r3.bubbles || false, r3.cancelable || true, window, r3.clickCount || 1, 0, 0, a2, l2, false, false, false, false, 0, null);
        break;
      case "KeyboardEvents":
        var u2 = s3.initKeyboardEvent || s3.initKeyEvent;
        XP.defaults(r3, { cancelable: true, ctrlKey: false, altKey: false, shiftKey: false, metaKey: false, keyCode: void 0, charCode: void 0 }), u2(e3, r3.bubbles || false, r3.cancelable, window, r3.ctrlKey, r3.altKey, r3.shiftKey, r3.metaKey, r3.keyCode, r3.charCode);
        break;
      default:
        s3.initEvent(e3, r3.bubbles || false, r3.cancelable || true);
    }
    XP.defaults(s3, i2), t3.dispatchEvent(s3);
  }, bind: function(t3, e3, n2, i2) {
    var r3 = i2 || false;
    return t3.addEventListener ? t3.addEventListener(e3, n2, r3) : t3.attachEvent && t3.attachEvent("on" + e3, n2), dC;
  }, unbind: function(t3, e3, n2, i2) {
    var r3 = i2 || false;
    return t3.removeEventListener ? t3.removeEventListener(e3, n2, r3) : t3.detachEvent && t3.detachEvent("on" + e3, n2), dC;
  }, addClass: function(t3, e3) {
    if (t3.className === void 0)
      t3.className = e3;
    else if (t3.className !== e3) {
      var n2 = t3.className.split(/ +/);
      n2.indexOf(e3) === -1 && (n2.push(e3), t3.className = n2.join(" ").replace(/^\s+/, "").replace(/\s+$/, ""));
    }
    return dC;
  }, removeClass: function(t3, e3) {
    if (e3)
      if (t3.className === e3)
        t3.removeAttribute("class");
      else {
        var n2 = t3.className.split(/ +/), i2 = n2.indexOf(e3);
        i2 !== -1 && (n2.splice(i2, 1), t3.className = n2.join(" "));
      }
    else
      t3.className = void 0;
    return dC;
  }, hasClass: function(t3, e3) {
    return new RegExp("(?:^|\\s+)" + e3 + "(?:\\s+|$)").test(t3.className) || false;
  }, getWidth: function(t3) {
    var e3 = getComputedStyle(t3);
    return cC(e3["border-left-width"]) + cC(e3["border-right-width"]) + cC(e3["padding-left"]) + cC(e3["padding-right"]) + cC(e3.width);
  }, getHeight: function(t3) {
    var e3 = getComputedStyle(t3);
    return cC(e3["border-top-width"]) + cC(e3["border-bottom-width"]) + cC(e3["padding-top"]) + cC(e3["padding-bottom"]) + cC(e3.height);
  }, getOffset: function(t3) {
    var e3 = t3, n2 = { left: 0, top: 0 };
    if (e3.offsetParent)
      do {
        n2.left += e3.offsetLeft, n2.top += e3.offsetTop, e3 = e3.offsetParent;
      } while (e3);
    return n2;
  }, isActive: function(t3) {
    return t3 === document.activeElement && (t3.type || t3.href);
  } }, pC = function(t3) {
    function e3(t4, n2) {
      tC(this, e3);
      var i2 = rC(this, (e3.__proto__ || Object.getPrototypeOf(e3)).call(this, t4, n2)), r3 = i2;
      return i2.__prev = i2.getValue(), i2.__checkbox = document.createElement("input"), i2.__checkbox.setAttribute("type", "checkbox"), dC.bind(i2.__checkbox, "change", function() {
        r3.setValue(!r3.__prev);
      }, false), i2.domElement.appendChild(i2.__checkbox), i2.updateDisplay(), i2;
    }
    return iC(e3, t3), eC(e3, [{ key: "setValue", value: function(t4) {
      var n2 = nC(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "setValue", this).call(this, t4);
      return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), this.__prev = this.getValue(), n2;
    } }, { key: "updateDisplay", value: function() {
      return this.getValue() === true ? (this.__checkbox.setAttribute("checked", "checked"), this.__checkbox.checked = true, this.__prev = true) : (this.__checkbox.checked = false, this.__prev = false), nC(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "updateDisplay", this).call(this);
    } }]), e3;
  }(lC), fC = function(t3) {
    function e3(t4, n2, i2) {
      tC(this, e3);
      var r3 = rC(this, (e3.__proto__ || Object.getPrototypeOf(e3)).call(this, t4, n2)), o3 = i2, s3 = r3;
      if (r3.__select = document.createElement("select"), XP.isArray(o3)) {
        var a2 = {};
        XP.each(o3, function(t5) {
          a2[t5] = t5;
        }), o3 = a2;
      }
      return XP.each(o3, function(t5, e4) {
        var n3 = document.createElement("option");
        n3.innerHTML = e4, n3.setAttribute("value", t5), s3.__select.appendChild(n3);
      }), r3.updateDisplay(), dC.bind(r3.__select, "change", function() {
        var t5 = this.options[this.selectedIndex].value;
        s3.setValue(t5);
      }), r3.domElement.appendChild(r3.__select), r3;
    }
    return iC(e3, t3), eC(e3, [{ key: "setValue", value: function(t4) {
      var n2 = nC(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "setValue", this).call(this, t4);
      return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), n2;
    } }, { key: "updateDisplay", value: function() {
      return dC.isActive(this.__select) ? this : (this.__select.value = this.getValue(), nC(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "updateDisplay", this).call(this));
    } }]), e3;
  }(lC), mC = function(t3) {
    function e3(t4, n2) {
      tC(this, e3);
      var i2 = rC(this, (e3.__proto__ || Object.getPrototypeOf(e3)).call(this, t4, n2)), r3 = i2;
      function o3() {
        r3.setValue(r3.__input.value);
      }
      return i2.__input = document.createElement("input"), i2.__input.setAttribute("type", "text"), dC.bind(i2.__input, "keyup", o3), dC.bind(i2.__input, "change", o3), dC.bind(i2.__input, "blur", function() {
        r3.__onFinishChange && r3.__onFinishChange.call(r3, r3.getValue());
      }), dC.bind(i2.__input, "keydown", function(t5) {
        t5.keyCode === 13 && this.blur();
      }), i2.updateDisplay(), i2.domElement.appendChild(i2.__input), i2;
    }
    return iC(e3, t3), eC(e3, [{ key: "updateDisplay", value: function() {
      return dC.isActive(this.__input) || (this.__input.value = this.getValue()), nC(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "updateDisplay", this).call(this);
    } }]), e3;
  }(lC);
  function gC(t3) {
    var e3 = t3.toString();
    return e3.indexOf(".") > -1 ? e3.length - e3.indexOf(".") - 1 : 0;
  }
  var vC = function(t3) {
    function e3(t4, n2, i2) {
      tC(this, e3);
      var r3 = rC(this, (e3.__proto__ || Object.getPrototypeOf(e3)).call(this, t4, n2)), o3 = i2 || {};
      return r3.__min = o3.min, r3.__max = o3.max, r3.__step = o3.step, XP.isUndefined(r3.__step) ? r3.initialValue === 0 ? r3.__impliedStep = 1 : r3.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(r3.initialValue)) / Math.LN10)) / 10 : r3.__impliedStep = r3.__step, r3.__precision = gC(r3.__impliedStep), r3;
    }
    return iC(e3, t3), eC(e3, [{ key: "setValue", value: function(t4) {
      var n2 = t4;
      return this.__min !== void 0 && n2 < this.__min ? n2 = this.__min : this.__max !== void 0 && n2 > this.__max && (n2 = this.__max), this.__step !== void 0 && n2 % this.__step != 0 && (n2 = Math.round(n2 / this.__step) * this.__step), nC(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "setValue", this).call(this, n2);
    } }, { key: "min", value: function(t4) {
      return this.__min = t4, this;
    } }, { key: "max", value: function(t4) {
      return this.__max = t4, this;
    } }, { key: "step", value: function(t4) {
      return this.__step = t4, this.__impliedStep = t4, this.__precision = gC(t4), this;
    } }]), e3;
  }(lC);
  var _C = function(t3) {
    function e3(t4, n2, i2) {
      tC(this, e3);
      var r3 = rC(this, (e3.__proto__ || Object.getPrototypeOf(e3)).call(this, t4, n2, i2));
      r3.__truncationSuspended = false;
      var o3 = r3, s3 = void 0;
      function a2() {
        o3.__onFinishChange && o3.__onFinishChange.call(o3, o3.getValue());
      }
      function l2(t5) {
        var e4 = s3 - t5.clientY;
        o3.setValue(o3.getValue() + e4 * o3.__impliedStep), s3 = t5.clientY;
      }
      function u2() {
        dC.unbind(window, "mousemove", l2), dC.unbind(window, "mouseup", u2), a2();
      }
      return r3.__input = document.createElement("input"), r3.__input.setAttribute("type", "text"), dC.bind(r3.__input, "change", function() {
        var t5 = parseFloat(o3.__input.value);
        XP.isNaN(t5) || o3.setValue(t5);
      }), dC.bind(r3.__input, "blur", function() {
        a2();
      }), dC.bind(r3.__input, "mousedown", function(t5) {
        dC.bind(window, "mousemove", l2), dC.bind(window, "mouseup", u2), s3 = t5.clientY;
      }), dC.bind(r3.__input, "keydown", function(t5) {
        t5.keyCode === 13 && (o3.__truncationSuspended = true, this.blur(), o3.__truncationSuspended = false, a2());
      }), r3.updateDisplay(), r3.domElement.appendChild(r3.__input), r3;
    }
    return iC(e3, t3), eC(e3, [{ key: "updateDisplay", value: function() {
      var t4, n2, i2;
      return this.__input.value = this.__truncationSuspended ? this.getValue() : (t4 = this.getValue(), n2 = this.__precision, i2 = Math.pow(10, n2), Math.round(t4 * i2) / i2), nC(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "updateDisplay", this).call(this);
    } }]), e3;
  }(vC);
  function yC(t3, e3, n2, i2, r3) {
    return i2 + (t3 - e3) / (n2 - e3) * (r3 - i2);
  }
  var xC = function(t3) {
    function e3(t4, n2, i2, r3, o3) {
      tC(this, e3);
      var s3 = rC(this, (e3.__proto__ || Object.getPrototypeOf(e3)).call(this, t4, n2, { min: i2, max: r3, step: o3 })), a2 = s3;
      function l2(t5) {
        t5.preventDefault();
        var e4 = a2.__background.getBoundingClientRect();
        return a2.setValue(yC(t5.clientX, e4.left, e4.right, a2.__min, a2.__max)), false;
      }
      function u2() {
        dC.unbind(window, "mousemove", l2), dC.unbind(window, "mouseup", u2), a2.__onFinishChange && a2.__onFinishChange.call(a2, a2.getValue());
      }
      function h2(t5) {
        var e4 = t5.touches[0].clientX, n3 = a2.__background.getBoundingClientRect();
        a2.setValue(yC(e4, n3.left, n3.right, a2.__min, a2.__max));
      }
      function c2() {
        dC.unbind(window, "touchmove", h2), dC.unbind(window, "touchend", c2), a2.__onFinishChange && a2.__onFinishChange.call(a2, a2.getValue());
      }
      return s3.__background = document.createElement("div"), s3.__foreground = document.createElement("div"), dC.bind(s3.__background, "mousedown", function(t5) {
        document.activeElement.blur(), dC.bind(window, "mousemove", l2), dC.bind(window, "mouseup", u2), l2(t5);
      }), dC.bind(s3.__background, "touchstart", function(t5) {
        if (t5.touches.length !== 1)
          return;
        dC.bind(window, "touchmove", h2), dC.bind(window, "touchend", c2), h2(t5);
      }), dC.addClass(s3.__background, "slider"), dC.addClass(s3.__foreground, "slider-fg"), s3.updateDisplay(), s3.__background.appendChild(s3.__foreground), s3.domElement.appendChild(s3.__background), s3;
    }
    return iC(e3, t3), eC(e3, [{ key: "updateDisplay", value: function() {
      var t4 = (this.getValue() - this.__min) / (this.__max - this.__min);
      return this.__foreground.style.width = 100 * t4 + "%", nC(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "updateDisplay", this).call(this);
    } }]), e3;
  }(vC), bC = function(t3) {
    function e3(t4, n2, i2) {
      tC(this, e3);
      var r3 = rC(this, (e3.__proto__ || Object.getPrototypeOf(e3)).call(this, t4, n2)), o3 = r3;
      return r3.__button = document.createElement("div"), r3.__button.innerHTML = i2 === void 0 ? "Fire" : i2, dC.bind(r3.__button, "click", function(t5) {
        return t5.preventDefault(), o3.fire(), false;
      }), dC.addClass(r3.__button, "button"), r3.domElement.appendChild(r3.__button), r3;
    }
    return iC(e3, t3), eC(e3, [{ key: "fire", value: function() {
      this.__onChange && this.__onChange.call(this), this.getValue().call(this.object), this.__onFinishChange && this.__onFinishChange.call(this, this.getValue());
    } }]), e3;
  }(lC), TC = function(t3) {
    function e3(t4, n2) {
      tC(this, e3);
      var i2 = rC(this, (e3.__proto__ || Object.getPrototypeOf(e3)).call(this, t4, n2));
      i2.__color = new oC(i2.getValue()), i2.__temp = new oC(0);
      var r3 = i2;
      i2.domElement = document.createElement("div"), dC.makeSelectable(i2.domElement, false), i2.__selector = document.createElement("div"), i2.__selector.className = "selector", i2.__saturation_field = document.createElement("div"), i2.__saturation_field.className = "saturation-field", i2.__field_knob = document.createElement("div"), i2.__field_knob.className = "field-knob", i2.__field_knob_border = "2px solid ", i2.__hue_knob = document.createElement("div"), i2.__hue_knob.className = "hue-knob", i2.__hue_field = document.createElement("div"), i2.__hue_field.className = "hue-field", i2.__input = document.createElement("input"), i2.__input.type = "text", i2.__input_textShadow = "0 1px 1px ", dC.bind(i2.__input, "keydown", function(t5) {
        t5.keyCode === 13 && c2.call(this);
      }), dC.bind(i2.__input, "blur", c2), dC.bind(i2.__selector, "mousedown", function() {
        dC.addClass(this, "drag").bind(window, "mouseup", function() {
          dC.removeClass(r3.__selector, "drag");
        });
      }), dC.bind(i2.__selector, "touchstart", function() {
        dC.addClass(this, "drag").bind(window, "touchend", function() {
          dC.removeClass(r3.__selector, "drag");
        });
      });
      var o3, s3 = document.createElement("div");
      function a2(t5) {
        p2(t5), dC.bind(window, "mousemove", p2), dC.bind(window, "touchmove", p2), dC.bind(window, "mouseup", u2), dC.bind(window, "touchend", u2);
      }
      function l2(t5) {
        f2(t5), dC.bind(window, "mousemove", f2), dC.bind(window, "touchmove", f2), dC.bind(window, "mouseup", h2), dC.bind(window, "touchend", h2);
      }
      function u2() {
        dC.unbind(window, "mousemove", p2), dC.unbind(window, "touchmove", p2), dC.unbind(window, "mouseup", u2), dC.unbind(window, "touchend", u2), d2();
      }
      function h2() {
        dC.unbind(window, "mousemove", f2), dC.unbind(window, "touchmove", f2), dC.unbind(window, "mouseup", h2), dC.unbind(window, "touchend", h2), d2();
      }
      function c2() {
        var t5 = JP(this.value);
        t5 !== false ? (r3.__color.__state = t5, r3.setValue(r3.__color.toOriginal())) : this.value = r3.__color.toString();
      }
      function d2() {
        r3.__onFinishChange && r3.__onFinishChange.call(r3, r3.__color.toOriginal());
      }
      function p2(t5) {
        t5.type.indexOf("touch") === -1 && t5.preventDefault();
        var e4 = r3.__saturation_field.getBoundingClientRect(), n3 = t5.touches && t5.touches[0] || t5, i3 = n3.clientX, o4 = n3.clientY, s4 = (i3 - e4.left) / (e4.right - e4.left), a3 = 1 - (o4 - e4.top) / (e4.bottom - e4.top);
        return a3 > 1 ? a3 = 1 : a3 < 0 && (a3 = 0), s4 > 1 ? s4 = 1 : s4 < 0 && (s4 = 0), r3.__color.v = a3, r3.__color.s = s4, r3.setValue(r3.__color.toOriginal()), false;
      }
      function f2(t5) {
        t5.type.indexOf("touch") === -1 && t5.preventDefault();
        var e4 = r3.__hue_field.getBoundingClientRect(), n3 = 1 - ((t5.touches && t5.touches[0] || t5).clientY - e4.top) / (e4.bottom - e4.top);
        return n3 > 1 ? n3 = 1 : n3 < 0 && (n3 = 0), r3.__color.h = 360 * n3, r3.setValue(r3.__color.toOriginal()), false;
      }
      return XP.extend(i2.__selector.style, { width: "122px", height: "102px", padding: "3px", backgroundColor: "#222", boxShadow: "0px 1px 3px rgba(0,0,0,0.3)" }), XP.extend(i2.__field_knob.style, { position: "absolute", width: "12px", height: "12px", border: i2.__field_knob_border + (i2.__color.v < 0.5 ? "#fff" : "#000"), boxShadow: "0px 1px 3px rgba(0,0,0,0.5)", borderRadius: "12px", zIndex: 1 }), XP.extend(i2.__hue_knob.style, { position: "absolute", width: "15px", height: "2px", borderRight: "4px solid #fff", zIndex: 1 }), XP.extend(i2.__saturation_field.style, { width: "100px", height: "100px", border: "1px solid #555", marginRight: "3px", display: "inline-block", cursor: "pointer" }), XP.extend(s3.style, { width: "100%", height: "100%", background: "none" }), SC(s3, "top", "rgba(0,0,0,0)", "#000"), XP.extend(i2.__hue_field.style, { width: "15px", height: "100px", border: "1px solid #555", cursor: "ns-resize", position: "absolute", top: "3px", right: "3px" }), (o3 = i2.__hue_field).style.background = "", o3.style.cssText += "background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);", o3.style.cssText += "background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", o3.style.cssText += "background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", o3.style.cssText += "background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", o3.style.cssText += "background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", XP.extend(i2.__input.style, { outline: "none", textAlign: "center", color: "#fff", border: 0, fontWeight: "bold", textShadow: i2.__input_textShadow + "rgba(0,0,0,0.7)" }), dC.bind(i2.__saturation_field, "mousedown", a2), dC.bind(i2.__saturation_field, "touchstart", a2), dC.bind(i2.__field_knob, "mousedown", a2), dC.bind(i2.__field_knob, "touchstart", a2), dC.bind(i2.__hue_field, "mousedown", l2), dC.bind(i2.__hue_field, "touchstart", l2), i2.__saturation_field.appendChild(s3), i2.__selector.appendChild(i2.__field_knob), i2.__selector.appendChild(i2.__saturation_field), i2.__selector.appendChild(i2.__hue_field), i2.__hue_field.appendChild(i2.__hue_knob), i2.domElement.appendChild(i2.__input), i2.domElement.appendChild(i2.__selector), i2.updateDisplay(), i2;
    }
    return iC(e3, t3), eC(e3, [{ key: "updateDisplay", value: function() {
      var t4 = JP(this.getValue());
      if (t4 !== false) {
        var e4 = false;
        XP.each(oC.COMPONENTS, function(n3) {
          if (!XP.isUndefined(t4[n3]) && !XP.isUndefined(this.__color.__state[n3]) && t4[n3] !== this.__color.__state[n3])
            return e4 = true, {};
        }, this), e4 && XP.extend(this.__color.__state, t4);
      }
      XP.extend(this.__temp.__state, this.__color.__state), this.__temp.a = 1;
      var n2 = this.__color.v < 0.5 || this.__color.s > 0.5 ? 255 : 0, i2 = 255 - n2;
      XP.extend(this.__field_knob.style, { marginLeft: 100 * this.__color.s - 7 + "px", marginTop: 100 * (1 - this.__color.v) - 7 + "px", backgroundColor: this.__temp.toHexString(), border: this.__field_knob_border + "rgb(" + n2 + "," + n2 + "," + n2 + ")" }), this.__hue_knob.style.marginTop = 100 * (1 - this.__color.h / 360) + "px", this.__temp.s = 1, this.__temp.v = 1, SC(this.__saturation_field, "left", "#fff", this.__temp.toHexString()), this.__input.value = this.__color.toString(), XP.extend(this.__input.style, { backgroundColor: this.__color.toHexString(), color: "rgb(" + n2 + "," + n2 + "," + n2 + ")", textShadow: this.__input_textShadow + "rgba(" + i2 + "," + i2 + "," + i2 + ",.7)" });
    } }]), e3;
  }(lC), wC = ["-moz-", "-o-", "-webkit-", "-ms-", ""];
  function SC(t3, e3, n2, i2) {
    t3.style.background = "", XP.each(wC, function(r3) {
      t3.style.cssText += "background: " + r3 + "linear-gradient(" + e3 + ", " + n2 + " 0%, " + i2 + " 100%); ";
    });
  }
  var EC = function(t3, e3) {
    var n2 = e3 || document, i2 = document.createElement("style");
    i2.type = "text/css", i2.innerHTML = t3;
    var r3 = n2.getElementsByTagName("head")[0];
    try {
      r3.appendChild(i2);
    } catch (t4) {
    }
  }, MC = `<div id="dg-save" class="dg dialogue">

  Here's the new load parameter for your <code>GUI</code>'s constructor:

  <textarea id="dg-new-constructor"></textarea>

  <div id="dg-save-locally">

    <input id="dg-local-storage" type="checkbox"/> Automatically save
    values to <code>localStorage</code> on exit.

    <div id="dg-local-explain">The values saved to <code>localStorage</code> will
      override those passed to <code>dat.GUI</code>'s constructor. This makes it
      easier to work incrementally, but <code>localStorage</code> is fragile,
      and your friends may not see the same values you do.

    </div>

  </div>

</div>`, AC = function(t3, e3) {
    var n2 = t3[e3];
    return XP.isArray(arguments[2]) || XP.isObject(arguments[2]) ? new fC(t3, e3, arguments[2]) : XP.isNumber(n2) ? XP.isNumber(arguments[2]) && XP.isNumber(arguments[3]) ? XP.isNumber(arguments[4]) ? new xC(t3, e3, arguments[2], arguments[3], arguments[4]) : new xC(t3, e3, arguments[2], arguments[3]) : XP.isNumber(arguments[4]) ? new _C(t3, e3, { min: arguments[2], max: arguments[3], step: arguments[4] }) : new _C(t3, e3, { min: arguments[2], max: arguments[3] }) : XP.isString(n2) ? new mC(t3, e3) : XP.isFunction(n2) ? new bC(t3, e3, "") : XP.isBoolean(n2) ? new pC(t3, e3) : null;
  };
  var RC = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(t3) {
    setTimeout(t3, 1e3 / 60);
  }, PC = function() {
    function t3() {
      tC(this, t3), this.backgroundElement = document.createElement("div"), XP.extend(this.backgroundElement.style, { backgroundColor: "rgba(0,0,0,0.8)", top: 0, left: 0, display: "none", zIndex: "1000", opacity: 0, WebkitTransition: "opacity 0.2s linear", transition: "opacity 0.2s linear" }), dC.makeFullscreen(this.backgroundElement), this.backgroundElement.style.position = "fixed", this.domElement = document.createElement("div"), XP.extend(this.domElement.style, { position: "fixed", display: "none", zIndex: "1001", opacity: 0, WebkitTransition: "-webkit-transform 0.2s ease-out, opacity 0.2s linear", transition: "transform 0.2s ease-out, opacity 0.2s linear" }), document.body.appendChild(this.backgroundElement), document.body.appendChild(this.domElement);
      var e3 = this;
      dC.bind(this.backgroundElement, "click", function() {
        e3.hide();
      });
    }
    return eC(t3, [{ key: "show", value: function() {
      var t4 = this;
      this.backgroundElement.style.display = "block", this.domElement.style.display = "block", this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)", this.layout(), XP.defer(function() {
        t4.backgroundElement.style.opacity = 1, t4.domElement.style.opacity = 1, t4.domElement.style.webkitTransform = "scale(1)";
      });
    } }, { key: "hide", value: function() {
      var t4 = this, e3 = function e4() {
        t4.domElement.style.display = "none", t4.backgroundElement.style.display = "none", dC.unbind(t4.domElement, "webkitTransitionEnd", e4), dC.unbind(t4.domElement, "transitionend", e4), dC.unbind(t4.domElement, "oTransitionEnd", e4);
      };
      dC.bind(this.domElement, "webkitTransitionEnd", e3), dC.bind(this.domElement, "transitionend", e3), dC.bind(this.domElement, "oTransitionEnd", e3), this.backgroundElement.style.opacity = 0, this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)";
    } }, { key: "layout", value: function() {
      this.domElement.style.left = window.innerWidth / 2 - dC.getWidth(this.domElement) / 2 + "px", this.domElement.style.top = window.innerHeight / 2 - dC.getHeight(this.domElement) / 2 + "px";
    } }]), t3;
  }();
  EC(function(t3) {
    if (t3 && typeof window != "undefined") {
      var e3 = document.createElement("style");
      return e3.setAttribute("type", "text/css"), e3.innerHTML = t3, document.head.appendChild(e3), t3;
    }
  }(".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n"));
  var CC = function() {
    try {
      return !!window.localStorage;
    } catch (t3) {
      return false;
    }
  }(), IC = void 0, OC = true, LC = void 0, NC = false, DC = [], FC = function t3(e3) {
    var n2 = this, i2 = e3 || {};
    this.domElement = document.createElement("div"), this.__ul = document.createElement("ul"), this.domElement.appendChild(this.__ul), dC.addClass(this.domElement, "dg"), this.__folders = {}, this.__controllers = [], this.__rememberedObjects = [], this.__rememberedObjectIndecesToControllers = [], this.__listening = [], i2 = XP.defaults(i2, { closeOnTop: false, autoPlace: true, width: t3.DEFAULT_WIDTH }), i2 = XP.defaults(i2, { resizable: i2.autoPlace, hideable: i2.autoPlace }), XP.isUndefined(i2.load) ? i2.load = { preset: "Default" } : i2.preset && (i2.load.preset = i2.preset), XP.isUndefined(i2.parent) && i2.hideable && DC.push(this), i2.resizable = XP.isUndefined(i2.parent) && i2.resizable, i2.autoPlace && XP.isUndefined(i2.scrollable) && (i2.scrollable = true);
    var r3, o3 = CC && localStorage.getItem(zC(this, "isLocal")) === "true", s3 = void 0, a2 = void 0;
    if (Object.defineProperties(this, { parent: { get: function() {
      return i2.parent;
    } }, scrollable: { get: function() {
      return i2.scrollable;
    } }, autoPlace: { get: function() {
      return i2.autoPlace;
    } }, closeOnTop: { get: function() {
      return i2.closeOnTop;
    } }, preset: { get: function() {
      return n2.parent ? n2.getRoot().preset : i2.load.preset;
    }, set: function(t4) {
      n2.parent ? n2.getRoot().preset = t4 : i2.load.preset = t4, function(t5) {
        for (var e4 = 0; e4 < t5.__preset_select.length; e4++)
          t5.__preset_select[e4].value === t5.preset && (t5.__preset_select.selectedIndex = e4);
      }(this), n2.revert();
    } }, width: { get: function() {
      return i2.width;
    }, set: function(t4) {
      i2.width = t4, qC(n2, t4);
    } }, name: { get: function() {
      return i2.name;
    }, set: function(t4) {
      i2.name = t4, a2 && (a2.innerHTML = i2.name);
    } }, closed: { get: function() {
      return i2.closed;
    }, set: function(e4) {
      i2.closed = e4, i2.closed ? dC.addClass(n2.__ul, t3.CLASS_CLOSED) : dC.removeClass(n2.__ul, t3.CLASS_CLOSED), this.onResize(), n2.__closeButton && (n2.__closeButton.innerHTML = e4 ? t3.TEXT_OPEN : t3.TEXT_CLOSED);
    } }, load: { get: function() {
      return i2.load;
    } }, useLocalStorage: { get: function() {
      return o3;
    }, set: function(t4) {
      CC && (o3 = t4, t4 ? dC.bind(window, "unload", s3) : dC.unbind(window, "unload", s3), localStorage.setItem(zC(n2, "isLocal"), t4));
    } } }), XP.isUndefined(i2.parent)) {
      if (this.closed = i2.closed || false, dC.addClass(this.domElement, t3.CLASS_MAIN), dC.makeSelectable(this.domElement, false), CC && o3) {
        n2.useLocalStorage = true;
        var l2 = localStorage.getItem(zC(this, "gui"));
        l2 && (i2.load = JSON.parse(l2));
      }
      this.__closeButton = document.createElement("div"), this.__closeButton.innerHTML = t3.TEXT_CLOSED, dC.addClass(this.__closeButton, t3.CLASS_CLOSE_BUTTON), i2.closeOnTop ? (dC.addClass(this.__closeButton, t3.CLASS_CLOSE_TOP), this.domElement.insertBefore(this.__closeButton, this.domElement.childNodes[0])) : (dC.addClass(this.__closeButton, t3.CLASS_CLOSE_BOTTOM), this.domElement.appendChild(this.__closeButton)), dC.bind(this.__closeButton, "click", function() {
        n2.closed = !n2.closed;
      });
    } else {
      i2.closed === void 0 && (i2.closed = true);
      var u2 = document.createTextNode(i2.name);
      dC.addClass(u2, "controller-name"), a2 = BC(n2, u2);
      dC.addClass(this.__ul, t3.CLASS_CLOSED), dC.addClass(a2, "title"), dC.bind(a2, "click", function(t4) {
        return t4.preventDefault(), n2.closed = !n2.closed, false;
      }), i2.closed || (this.closed = false);
    }
    i2.autoPlace && (XP.isUndefined(i2.parent) && (OC && (LC = document.createElement("div"), dC.addClass(LC, "dg"), dC.addClass(LC, t3.CLASS_AUTO_PLACE_CONTAINER), document.body.appendChild(LC), OC = false), LC.appendChild(this.domElement), dC.addClass(this.domElement, t3.CLASS_AUTO_PLACE)), this.parent || qC(n2, i2.width)), this.__resizeHandler = function() {
      n2.onResizeDebounced();
    }, dC.bind(window, "resize", this.__resizeHandler), dC.bind(this.__ul, "webkitTransitionEnd", this.__resizeHandler), dC.bind(this.__ul, "transitionend", this.__resizeHandler), dC.bind(this.__ul, "oTransitionEnd", this.__resizeHandler), this.onResize(), i2.resizable && XC(this), s3 = function() {
      CC && localStorage.getItem(zC(n2, "isLocal")) === "true" && localStorage.setItem(zC(n2, "gui"), JSON.stringify(n2.getSaveObject()));
    }, this.saveToLocalStorageIfPossible = s3, i2.parent || ((r3 = n2.getRoot()).width += 1, XP.defer(function() {
      r3.width -= 1;
    }));
  };
  function BC(t3, e3, n2) {
    var i2 = document.createElement("li");
    return e3 && i2.appendChild(e3), n2 ? t3.__ul.insertBefore(i2, n2) : t3.__ul.appendChild(i2), t3.onResize(), i2;
  }
  function UC(t3) {
    dC.unbind(window, "resize", t3.__resizeHandler), t3.saveToLocalStorageIfPossible && dC.unbind(window, "unload", t3.saveToLocalStorageIfPossible);
  }
  function kC(t3, e3) {
    var n2 = t3.__preset_select[t3.__preset_select.selectedIndex];
    n2.innerHTML = e3 ? n2.value + "*" : n2.value;
  }
  function GC(t3, e3) {
    var n2 = t3.getRoot(), i2 = n2.__rememberedObjects.indexOf(e3.object);
    if (i2 !== -1) {
      var r3 = n2.__rememberedObjectIndecesToControllers[i2];
      if (r3 === void 0 && (r3 = {}, n2.__rememberedObjectIndecesToControllers[i2] = r3), r3[e3.property] = e3, n2.load && n2.load.remembered) {
        var o3 = n2.load.remembered, s3 = void 0;
        if (o3[t3.preset])
          s3 = o3[t3.preset];
        else {
          if (!o3.Default)
            return;
          s3 = o3.Default;
        }
        if (s3[i2] && s3[i2][e3.property] !== void 0) {
          var a2 = s3[i2][e3.property];
          e3.initialValue = a2, e3.setValue(a2);
        }
      }
    }
  }
  function HC(t3, e3, n2, i2) {
    if (e3[n2] === void 0)
      throw new Error('Object "' + e3 + '" has no property "' + n2 + '"');
    var r3 = void 0;
    if (i2.color)
      r3 = new TC(e3, n2);
    else {
      var o3 = [e3, n2].concat(i2.factoryArgs);
      r3 = AC.apply(t3, o3);
    }
    i2.before instanceof lC && (i2.before = i2.before.__li), GC(t3, r3), dC.addClass(r3.domElement, "c");
    var s3 = document.createElement("span");
    dC.addClass(s3, "property-name"), s3.innerHTML = r3.property;
    var a2 = document.createElement("div");
    a2.appendChild(s3), a2.appendChild(r3.domElement);
    var l2 = BC(t3, a2, i2.before);
    return dC.addClass(l2, FC.CLASS_CONTROLLER_ROW), r3 instanceof TC ? dC.addClass(l2, "color") : dC.addClass(l2, QP(r3.getValue())), function(t4, e4, n3) {
      if (n3.__li = e4, n3.__gui = t4, XP.extend(n3, { options: function(e5) {
        if (arguments.length > 1) {
          var i4 = n3.__li.nextElementSibling;
          return n3.remove(), HC(t4, n3.object, n3.property, { before: i4, factoryArgs: [XP.toArray(arguments)] });
        }
        if (XP.isArray(e5) || XP.isObject(e5)) {
          var r5 = n3.__li.nextElementSibling;
          return n3.remove(), HC(t4, n3.object, n3.property, { before: r5, factoryArgs: [e5] });
        }
      }, name: function(t5) {
        return n3.__li.firstElementChild.firstElementChild.innerHTML = t5, n3;
      }, listen: function() {
        return n3.__gui.listen(n3), n3;
      }, remove: function() {
        return n3.__gui.remove(n3), n3;
      } }), n3 instanceof xC) {
        var i3 = new _C(n3.object, n3.property, { min: n3.__min, max: n3.__max, step: n3.__step });
        XP.each(["updateDisplay", "onChange", "onFinishChange", "step", "min", "max"], function(t5) {
          var e5 = n3[t5], r5 = i3[t5];
          n3[t5] = i3[t5] = function() {
            var t6 = Array.prototype.slice.call(arguments);
            return r5.apply(i3, t6), e5.apply(n3, t6);
          };
        }), dC.addClass(e4, "has-slider"), n3.domElement.insertBefore(i3.domElement, n3.domElement.firstElementChild);
      } else if (n3 instanceof _C) {
        var r4 = function(e5) {
          if (XP.isNumber(n3.__min) && XP.isNumber(n3.__max)) {
            var i4 = n3.__li.firstElementChild.firstElementChild.innerHTML, r5 = n3.__gui.__listening.indexOf(n3) > -1;
            n3.remove();
            var o4 = HC(t4, n3.object, n3.property, { before: n3.__li.nextElementSibling, factoryArgs: [n3.__min, n3.__max, n3.__step] });
            return o4.name(i4), r5 && o4.listen(), o4;
          }
          return e5;
        };
        n3.min = XP.compose(r4, n3.min), n3.max = XP.compose(r4, n3.max);
      } else
        n3 instanceof pC ? (dC.bind(e4, "click", function() {
          dC.fakeEvent(n3.__checkbox, "click");
        }), dC.bind(n3.__checkbox, "click", function(t5) {
          t5.stopPropagation();
        })) : n3 instanceof bC ? (dC.bind(e4, "click", function() {
          dC.fakeEvent(n3.__button, "click");
        }), dC.bind(e4, "mouseover", function() {
          dC.addClass(n3.__button, "hover");
        }), dC.bind(e4, "mouseout", function() {
          dC.removeClass(n3.__button, "hover");
        })) : n3 instanceof TC && (dC.addClass(e4, "color"), n3.updateDisplay = XP.compose(function(t5) {
          return e4.style.borderLeftColor = n3.__color.toString(), t5;
        }, n3.updateDisplay), n3.updateDisplay());
      n3.setValue = XP.compose(function(e5) {
        return t4.getRoot().__preset_select && n3.isModified() && kC(t4.getRoot(), true), e5;
      }, n3.setValue);
    }(t3, l2, r3), t3.__controllers.push(r3), r3;
  }
  function zC(t3, e3) {
    return document.location.href + "." + e3;
  }
  function jC(t3, e3, n2) {
    var i2 = document.createElement("option");
    i2.innerHTML = e3, i2.value = e3, t3.__preset_select.appendChild(i2), n2 && (t3.__preset_select.selectedIndex = t3.__preset_select.length - 1);
  }
  function VC(t3, e3) {
    e3.style.display = t3.useLocalStorage ? "block" : "none";
  }
  function WC(t3) {
    var e3 = t3.__save_row = document.createElement("li");
    dC.addClass(t3.domElement, "has-save"), t3.__ul.insertBefore(e3, t3.__ul.firstChild), dC.addClass(e3, "save-row");
    var n2 = document.createElement("span");
    n2.innerHTML = "&nbsp;", dC.addClass(n2, "button gears");
    var i2 = document.createElement("span");
    i2.innerHTML = "Save", dC.addClass(i2, "button"), dC.addClass(i2, "save");
    var r3 = document.createElement("span");
    r3.innerHTML = "New", dC.addClass(r3, "button"), dC.addClass(r3, "save-as");
    var o3 = document.createElement("span");
    o3.innerHTML = "Revert", dC.addClass(o3, "button"), dC.addClass(o3, "revert");
    var s3 = t3.__preset_select = document.createElement("select");
    if (t3.load && t3.load.remembered ? XP.each(t3.load.remembered, function(e4, n3) {
      jC(t3, n3, n3 === t3.preset);
    }) : jC(t3, "Default", false), dC.bind(s3, "change", function() {
      for (var e4 = 0; e4 < t3.__preset_select.length; e4++)
        t3.__preset_select[e4].innerHTML = t3.__preset_select[e4].value;
      t3.preset = this.value;
    }), e3.appendChild(s3), e3.appendChild(n2), e3.appendChild(i2), e3.appendChild(r3), e3.appendChild(o3), CC) {
      var a2 = document.getElementById("dg-local-explain"), l2 = document.getElementById("dg-local-storage");
      document.getElementById("dg-save-locally").style.display = "block", localStorage.getItem(zC(0, "isLocal")) === "true" && l2.setAttribute("checked", "checked"), VC(t3, a2), dC.bind(l2, "change", function() {
        t3.useLocalStorage = !t3.useLocalStorage, VC(t3, a2);
      });
    }
    var u2 = document.getElementById("dg-new-constructor");
    dC.bind(u2, "keydown", function(t4) {
      !t4.metaKey || t4.which !== 67 && t4.keyCode !== 67 || IC.hide();
    }), dC.bind(n2, "click", function() {
      u2.innerHTML = JSON.stringify(t3.getSaveObject(), void 0, 2), IC.show(), u2.focus(), u2.select();
    }), dC.bind(i2, "click", function() {
      t3.save();
    }), dC.bind(r3, "click", function() {
      var e4 = prompt("Enter a new preset name.");
      e4 && t3.saveAs(e4);
    }), dC.bind(o3, "click", function() {
      t3.revert();
    });
  }
  function XC(t3) {
    var e3 = void 0;
    function n2(n3) {
      return n3.preventDefault(), t3.width += e3 - n3.clientX, t3.onResize(), e3 = n3.clientX, false;
    }
    function i2() {
      dC.removeClass(t3.__closeButton, FC.CLASS_DRAG), dC.unbind(window, "mousemove", n2), dC.unbind(window, "mouseup", i2);
    }
    function r3(r4) {
      return r4.preventDefault(), e3 = r4.clientX, dC.addClass(t3.__closeButton, FC.CLASS_DRAG), dC.bind(window, "mousemove", n2), dC.bind(window, "mouseup", i2), false;
    }
    t3.__resize_handle = document.createElement("div"), XP.extend(t3.__resize_handle.style, { width: "6px", marginLeft: "-3px", height: "200px", cursor: "ew-resize", position: "absolute" }), dC.bind(t3.__resize_handle, "mousedown", r3), dC.bind(t3.__closeButton, "mousedown", r3), t3.domElement.insertBefore(t3.__resize_handle, t3.domElement.firstElementChild);
  }
  function qC(t3, e3) {
    t3.domElement.style.width = e3 + "px", t3.__save_row && t3.autoPlace && (t3.__save_row.style.width = e3 + "px"), t3.__closeButton && (t3.__closeButton.style.width = e3 + "px");
  }
  function YC(t3, e3) {
    var n2 = {};
    return XP.each(t3.__rememberedObjects, function(i2, r3) {
      var o3 = {}, s3 = t3.__rememberedObjectIndecesToControllers[r3];
      XP.each(s3, function(t4, n3) {
        o3[n3] = e3 ? t4.initialValue : t4.getValue();
      }), n2[r3] = o3;
    }), n2;
  }
  FC.toggleHide = function() {
    NC = !NC, XP.each(DC, function(t3) {
      t3.domElement.style.display = NC ? "none" : "";
    });
  }, FC.CLASS_AUTO_PLACE = "a", FC.CLASS_AUTO_PLACE_CONTAINER = "ac", FC.CLASS_MAIN = "main", FC.CLASS_CONTROLLER_ROW = "cr", FC.CLASS_TOO_TALL = "taller-than-window", FC.CLASS_CLOSED = "closed", FC.CLASS_CLOSE_BUTTON = "close-button", FC.CLASS_CLOSE_TOP = "close-top", FC.CLASS_CLOSE_BOTTOM = "close-bottom", FC.CLASS_DRAG = "drag", FC.DEFAULT_WIDTH = 245, FC.TEXT_CLOSED = "Close Controls", FC.TEXT_OPEN = "Open Controls", FC._keydownHandler = function(t3) {
    document.activeElement.type === "text" || t3.which !== 72 && t3.keyCode !== 72 || FC.toggleHide();
  }, dC.bind(window, "keydown", FC._keydownHandler, false), XP.extend(FC.prototype, { add: function(t3, e3) {
    return HC(this, t3, e3, { factoryArgs: Array.prototype.slice.call(arguments, 2) });
  }, addColor: function(t3, e3) {
    return HC(this, t3, e3, { color: true });
  }, remove: function(t3) {
    this.__ul.removeChild(t3.__li), this.__controllers.splice(this.__controllers.indexOf(t3), 1);
    var e3 = this;
    XP.defer(function() {
      e3.onResize();
    });
  }, destroy: function() {
    if (this.parent)
      throw new Error("Only the root GUI should be removed with .destroy(). For subfolders, use gui.removeFolder(folder) instead.");
    this.autoPlace && LC.removeChild(this.domElement);
    var t3 = this;
    XP.each(this.__folders, function(e3) {
      t3.removeFolder(e3);
    }), dC.unbind(window, "keydown", FC._keydownHandler, false), UC(this);
  }, addFolder: function(t3) {
    if (this.__folders[t3] !== void 0)
      throw new Error('You already have a folder in this GUI by the name "' + t3 + '"');
    var e3 = { name: t3, parent: this };
    e3.autoPlace = this.autoPlace, this.load && this.load.folders && this.load.folders[t3] && (e3.closed = this.load.folders[t3].closed, e3.load = this.load.folders[t3]);
    var n2 = new FC(e3);
    this.__folders[t3] = n2;
    var i2 = BC(this, n2.domElement);
    return dC.addClass(i2, "folder"), n2;
  }, removeFolder: function(t3) {
    this.__ul.removeChild(t3.domElement.parentElement), delete this.__folders[t3.name], this.load && this.load.folders && this.load.folders[t3.name] && delete this.load.folders[t3.name], UC(t3);
    var e3 = this;
    XP.each(t3.__folders, function(e4) {
      t3.removeFolder(e4);
    }), XP.defer(function() {
      e3.onResize();
    });
  }, open: function() {
    this.closed = false;
  }, close: function() {
    this.closed = true;
  }, hide: function() {
    this.domElement.style.display = "none";
  }, show: function() {
    this.domElement.style.display = "";
  }, onResize: function() {
    var t3 = this.getRoot();
    if (t3.scrollable) {
      var e3 = dC.getOffset(t3.__ul).top, n2 = 0;
      XP.each(t3.__ul.childNodes, function(e4) {
        t3.autoPlace && e4 === t3.__save_row || (n2 += dC.getHeight(e4));
      }), window.innerHeight - e3 - 20 < n2 ? (dC.addClass(t3.domElement, FC.CLASS_TOO_TALL), t3.__ul.style.height = window.innerHeight - e3 - 20 + "px") : (dC.removeClass(t3.domElement, FC.CLASS_TOO_TALL), t3.__ul.style.height = "auto");
    }
    t3.__resize_handle && XP.defer(function() {
      t3.__resize_handle.style.height = t3.__ul.offsetHeight + "px";
    }), t3.__closeButton && (t3.__closeButton.style.width = t3.width + "px");
  }, onResizeDebounced: XP.debounce(function() {
    this.onResize();
  }, 50), remember: function() {
    if (XP.isUndefined(IC) && ((IC = new PC()).domElement.innerHTML = MC), this.parent)
      throw new Error("You can only call remember on a top level GUI.");
    var t3 = this;
    XP.each(Array.prototype.slice.call(arguments), function(e3) {
      t3.__rememberedObjects.length === 0 && WC(t3), t3.__rememberedObjects.indexOf(e3) === -1 && t3.__rememberedObjects.push(e3);
    }), this.autoPlace && qC(this, this.width);
  }, getRoot: function() {
    for (var t3 = this; t3.parent; )
      t3 = t3.parent;
    return t3;
  }, getSaveObject: function() {
    var t3 = this.load;
    return t3.closed = this.closed, this.__rememberedObjects.length > 0 && (t3.preset = this.preset, t3.remembered || (t3.remembered = {}), t3.remembered[this.preset] = YC(this)), t3.folders = {}, XP.each(this.__folders, function(e3, n2) {
      t3.folders[n2] = e3.getSaveObject();
    }), t3;
  }, save: function() {
    this.load.remembered || (this.load.remembered = {}), this.load.remembered[this.preset] = YC(this), kC(this, false), this.saveToLocalStorageIfPossible();
  }, saveAs: function(t3) {
    this.load.remembered || (this.load.remembered = {}, this.load.remembered.Default = YC(this, true)), this.load.remembered[t3] = YC(this), this.preset = t3, jC(this, t3, true), this.saveToLocalStorageIfPossible();
  }, revert: function(t3) {
    XP.each(this.__controllers, function(e3) {
      this.getRoot().load.remembered ? GC(t3 || this.getRoot(), e3) : e3.setValue(e3.initialValue), e3.__onFinishChange && e3.__onFinishChange.call(e3, e3.getValue());
    }, this), XP.each(this.__folders, function(t4) {
      t4.revert(t4);
    }), t3 || kC(this.getRoot(), false);
  }, listen: function(t3) {
    var e3 = this.__listening.length === 0;
    this.__listening.push(t3), e3 && function t4(e4) {
      e4.length !== 0 && RC.call(window, function() {
        t4(e4);
      });
      XP.each(e4, function(t5) {
        t5.updateDisplay();
      });
    }(this.__listening);
  }, updateDisplay: function() {
    XP.each(this.__controllers, function(t3) {
      t3.updateDisplay();
    }), XP.each(this.__folders, function(t3) {
      t3.updateDisplay();
    });
  } });
  var ZC = FC, JC = function() {
    function t3(t4) {
      this.runTime = { fps: 0, resolution: "" }, this.target = t4.target, this.data = t4.params, this.player = t4.player, this.gui = this.createControllerGUI(), this.createStats(), this.addEventListener();
    }
    return t3.prototype.createStats = function() {
      var t4 = this;
      this.stateId = setInterval(function() {
        t4.player.view && (t4.controller.runTimeFps.setValue(t4.player.runtime.fps), t4.controller.runTimeResolution.setValue(t4.player.view.width + "*" + t4.player.view.height));
      }, 500);
    }, t3.prototype.createControllerGUI = function() {
      var t4, e3, n2, i2, r3, o3 = new ZC({ autoPlace: true, closed: true });
      return o3.domElement.style.opacity = ".6", o3.domElement.style.transformOrigin = "100% 0", o3.domElement.style.transform = "scale(1.4)", this.target.appendChild(o3.domElement), o3.domElement.style.position = "absolute", o3.domElement.style.right = "0", o3.domElement.style.top = "0", o3.domElement.style.zIndex = "2", this.controller = { runTimeFps: o3.add({ FPS: 0 }, "FPS", 0), runTimeResolution: o3.add({ "\u5206\u8FA8\u7387": "" }, "\u5206\u8FA8\u7387", ""), autoResolution: o3.add({ "\u81EA\u52A8\u5206\u8FA8\u7387": (t4 = this.data.autoResolution) !== null && t4 !== void 0 && t4 }, "\u81EA\u52A8\u5206\u8FA8\u7387", true), autoFps: o3.add({ "\u81EA\u52A8fps": (e3 = this.data.autoFPS) === null || e3 === void 0 || e3 }, "\u81EA\u52A8fps", true), moreCalculation: o3.add({ "\u989D\u5916\u8BA1\u7B97": 0 }, "\u989D\u5916\u8BA1\u7B97", 0, 100), minFPS: o3.add({ "\u6700\u4F4Efps": (n2 = this.data.minFPS) !== null && n2 !== void 0 ? n2 : 40 }, "\u6700\u4F4Efps", 0, 60), maxFPS: o3.add({ "\u6700\u9AD8fps": (i2 = this.data.maxFPS) !== null && i2 !== void 0 ? i2 : 50 }, "\u6700\u9AD8fps", 0, 60), resolution: o3.add({ "\u76EE\u6807\u5206\u8FA8\u500D\u7387": (r3 = this.data.resolution) !== null && r3 !== void 0 ? r3 : window.devicePixelRatio }, "\u76EE\u6807\u5206\u8FA8\u500D\u7387", 0.5, 4) }, this.controller.runTimeFps.disabled = true, this.controller.runTimeResolution.disabled = true, o3;
    }, t3.prototype.addEventListener = function() {
      var t4, e3 = this;
      this.controller.autoFps.onChange(function(t5) {
        e3.data.autoFPS = t5, e3.player.updateConfig(e3.data);
      }), this.controller.maxFPS.onChange(function(t5) {
        e3.data.maxFPS = t5, e3.player.updateConfig(e3.data);
      }), this.controller.minFPS.onChange(function(t5) {
        e3.data.minFPS = t5, e3.player.updateConfig(e3.data);
      }), this.controller.autoResolution.onChange(function(t5) {
        e3.data.autoResolution = t5, e3.player.updateConfig(e3.data);
      }), this.controller.resolution.onChange(function(t5) {
        e3.data.resolution = t5, e3.player.updateConfig(e3.data);
      }), this.controller.moreCalculation.onChange(function(n2) {
        t4 && e3.player.app.ticker.remove(t4), n2 > 0 && (t4 = function() {
          for (var t5 = ""; t5.length < 8e3 * n2; )
            t5 += Math.random().toString(32).substr(2);
          hM()(t5);
        }, e3.player.app.ticker.add(t4));
      });
    }, t3.prototype.destroy = function() {
      try {
        window.clearInterval(this.stateId), this.target.removeChild(this.gui.domElement), this.gui.destroy();
      } catch (t4) {
      }
    }, t3;
  }(), $C = function() {
    function t3(t4) {
      var e3 = this;
      this.tasks = [], this.schedule = function() {
        var t5 = e3.tasks[0];
        t5 ? e3.fn(t5).then(function() {
          e3.tasks.splice(0, 1), window.requestAnimationFrame(e3.schedule);
        }) : window.requestAnimationFrame(e3.schedule);
      }, this.fn = t4, this.schedule();
    }
    return t3.prototype.addTask = function(t4) {
      this.tasks.push(t4);
    }, t3;
  }(), KC = function() {
    function t3() {
      this.autoUnlock = Object.create(null), this.locks = Object.create(null);
    }
    return t3.prototype.addLock = function(t4, e3) {
      var n2 = this;
      this.locks[t4] = e3, this.autoUnlock[t4] = window.setTimeout(function() {
        delete n2.locks[t4];
      }, 3e3);
    }, t3.prototype.unlock = function(t4, e3) {
      e3 && this.locks[t4] && this.locks[t4] === e3 && (window.clearTimeout(this.autoUnlock[t4]), delete this.locks[t4]);
    }, t3.prototype.isLocked = function(t4) {
      return !!this.locks[t4];
    }, t3;
  }(), QC = function() {
    var t3 = function(e3, n2) {
      return (t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e4) {
        t4.__proto__ = e4;
      } || function(t4, e4) {
        for (var n3 in e4)
          Object.prototype.hasOwnProperty.call(e4, n3) && (t4[n3] = e4[n3]);
      })(e3, n2);
    };
    return function(e3, n2) {
      if (typeof n2 != "function" && n2 !== null)
        throw new TypeError("Class extends value " + String(n2) + " is not a constructor or null");
      function i2() {
        this.constructor = e3;
      }
      t3(e3, n2), e3.prototype = n2 === null ? Object.create(n2) : (i2.prototype = n2.prototype, new i2());
    };
  }(), tI = function() {
    return (tI = Object.assign || function(t3) {
      for (var e3, n2 = 1, i2 = arguments.length; n2 < i2; n2++)
        for (var r3 in e3 = arguments[n2])
          Object.prototype.hasOwnProperty.call(e3, r3) && (t3[r3] = e3[r3]);
      return t3;
    }).apply(this, arguments);
  }, eI = function(t3, e3, n2, i2) {
    return new (n2 || (n2 = Promise))(function(r3, o3) {
      function s3(t4) {
        try {
          l2(i2.next(t4));
        } catch (t5) {
          o3(t5);
        }
      }
      function a2(t4) {
        try {
          l2(i2.throw(t4));
        } catch (t5) {
          o3(t5);
        }
      }
      function l2(t4) {
        var e4;
        t4.done ? r3(t4.value) : (e4 = t4.value, e4 instanceof n2 ? e4 : new n2(function(t5) {
          t5(e4);
        })).then(s3, a2);
      }
      l2((i2 = i2.apply(t3, e3 || [])).next());
    });
  }, nI = function(t3, e3) {
    var n2, i2, r3, o3, s3 = { label: 0, sent: function() {
      if (1 & r3[0])
        throw r3[1];
      return r3[1];
    }, trys: [], ops: [] };
    return o3 = { next: a2(0), throw: a2(1), return: a2(2) }, typeof Symbol == "function" && (o3[Symbol.iterator] = function() {
      return this;
    }), o3;
    function a2(o4) {
      return function(a3) {
        return function(o5) {
          if (n2)
            throw new TypeError("Generator is already executing.");
          for (; s3; )
            try {
              if (n2 = 1, i2 && (r3 = 2 & o5[0] ? i2.return : o5[0] ? i2.throw || ((r3 = i2.return) && r3.call(i2), 0) : i2.next) && !(r3 = r3.call(i2, o5[1])).done)
                return r3;
              switch (i2 = 0, r3 && (o5 = [2 & o5[0], r3.value]), o5[0]) {
                case 0:
                case 1:
                  r3 = o5;
                  break;
                case 4:
                  return s3.label++, { value: o5[1], done: false };
                case 5:
                  s3.label++, i2 = o5[1], o5 = [0];
                  continue;
                case 7:
                  o5 = s3.ops.pop(), s3.trys.pop();
                  continue;
                default:
                  if (!(r3 = s3.trys, (r3 = r3.length > 0 && r3[r3.length - 1]) || o5[0] !== 6 && o5[0] !== 2)) {
                    s3 = 0;
                    continue;
                  }
                  if (o5[0] === 3 && (!r3 || o5[1] > r3[0] && o5[1] < r3[3])) {
                    s3.label = o5[1];
                    break;
                  }
                  if (o5[0] === 6 && s3.label < r3[1]) {
                    s3.label = r3[1], r3 = o5;
                    break;
                  }
                  if (r3 && s3.label < r3[2]) {
                    s3.label = r3[2], s3.ops.push(o5);
                    break;
                  }
                  r3[2] && s3.ops.pop(), s3.trys.pop();
                  continue;
              }
              o5 = e3.call(t3, s3);
            } catch (t4) {
              o5 = [6, t4], i2 = 0;
            } finally {
              n2 = r3 = 0;
            }
          if (5 & o5[0])
            throw o5[1];
          return { value: o5[0] ? o5[1] : void 0, done: true };
        }([o4, a3]);
      };
    }
  };
  window.__slide_local_logger__ || (window.__slide_local_logger__ = o2.createInstance({ name: "_slide_local_log_", driver: o2.INDEXEDDB, version: 1 }));
  var iI = window.__slide_local_logger__, rI = window.ResizeObserver || UP, oI = function(t3) {
    return new Promise(function(e3) {
      return setTimeout(e3, t3);
    });
  };
  function sI(t3, e3) {
    return eI(this, void 0, void 0, function() {
      var n2;
      return nI(this, function(i2) {
        switch (i2.label) {
          case 0:
            n2 = Date.now(), i2.label = 1;
          case 1:
            return !t3() && Date.now() - n2 < e3 ? [4, oI(50)] : [3, 3];
          case 2:
            return i2.sent(), [3, 1];
          case 3:
            return [2];
        }
      });
    });
  }
  var aI = { syncDispatch: "syncDispatch", syncReceive: "syncReceive", renderStart: "renderStart", renderEnd: "renderEnd", renderError: "renderError", slideChange: "slideChange", mainSeqStepStart: "mainSeqStepStart", mainSeqStepEnd: "mainSeqStepEnd", animateStart: "animateStart", animateEnd: "animateEnd", stateChange: "stateChange" }, lI = { taskId: "", url: "", currentSlideIndex: -1, mainSeqStep: -1, mainSeqState: null, mediaState: Object.create(null), interactiveSeqState: Object.create(null) }, uI = "";
  try {
    uI = "0.1.55";
  } catch (t3) {
    uI = "dev";
  }
  var hI = function(t3) {
    function e3(e4) {
      var n2 = t3.call(this) || this;
      return n2.iosResetCache = [], n2.needClearCacheImage = false, n2.version = uI, n2.__slideState = Object(l.cloneDeep)(lI), n2.resize = false, n2.isAnimating = false, n2.renderingTaskManager = new zP(), n2.isLoading = false, n2.interactive = true, n2.frameWidth = 1, n2.frameHeight = 1, n2.frame = document.createElement("div"), n2.medianController = document.createElement("div"), n2.frameResizeObserver = new rI(function() {
        return n2.frameResizeHandler();
      }), n2.timestamp = function() {
        return Date.now();
      }, n2.mode = "local", n2.log = "", n2.logId = "", n2.lastEmitedState = null, n2.playerController = null, n2.lock = new KC(), n2.isInitResized = false, n2.cacheImage = document.createElement("img"), n2.isFrowning = false, n2.isReleasing = false, n2.designWidth = 0, n2.designHeight = 0, n2._slideCount = 0, n2.persistLog = function() {
        return eI(n2, void 0, void 0, function() {
          var t4, e5;
          return nI(this, function(n3) {
            switch (n3.label) {
              case 0:
                if (!iI || !this.logId)
                  return [3, 5];
                n3.label = 1;
              case 1:
                return n3.trys.push([1, 4, , 5]), t4 = this.log, [4, iI.getItem(this.logId)];
              case 2:
                return e5 = n3.sent() || "", [4, iI.setItem(this.logId, e5 + t4)];
              case 3:
                return n3.sent(), this.log = "", [3, 5];
              case 4:
                return n3.sent(), [3, 5];
              case 5:
                return [2];
            }
          });
        });
      }, n2.handleSlideRef = function() {
        console.log(n2), window.__slide = n2;
      }, n2.handleSlideStateLog = function() {
        console.log(n2.logId), console.log(JSON.stringify(n2.slideState, null, 2));
      }, n2.handleLogDownload = function() {
        return eI(n2, void 0, void 0, function() {
          var t4, e5, n3;
          return nI(this, function(i2) {
            switch (i2.label) {
              case 0:
                return t4 = "", iI ? (e5 = t4, [4, iI.getItem(this.logId)]) : [3, 2];
              case 1:
                t4 = e5 + (i2.sent() || ""), i2.label = 2;
              case 2:
                return t4 += this.log, (n3 = document.createElement("a")).setAttribute("href", "data:text/plain;charset=utf-8," + encodeURIComponent(t4)), n3.setAttribute("download", this.logId), n3.style.display = "none", document.body.appendChild(n3), n3.click(), document.body.removeChild(n3), console.log(t4), [2];
            }
          });
        });
      }, n2.receiveSyncHandler = function(t4) {
        return eI(n2, void 0, void 0, function() {
          var e5, n3, i2, r3, o3 = this;
          return nI(this, function(s3) {
            switch (s3.label) {
              case 0:
                return this.log += "=== sync receive [" + new Date().toISOString() + "] ===\n", this.log += JSON.stringify(t4, null, 2), this.log += "\n\n", t4.type !== "nextStep" ? [3, 1] : (this.mainSeqStep !== t4.next - 1 && this.mainSeqStep + 1 !== this.mainSeqLength && this.player ? (this.setMainSeqStep(t4.next, "start"), this.player.nextTick(function() {
                  o3.doNextStep();
                })) : this.doNextStep(), [3, 6]);
              case 1:
                return t4.type !== "prevStep" ? [3, 2] : (this.mainSeqStep === 0 && this.mainSeqState === "idle" || this.mainSeqStep === t4.next + 1 || this.mainSeqStep + 1 === this.mainSeqLength ? this.doPrevStep() : (this.setMainSeqStep(t4.next + 1, "start"), (e5 = this.player) === null || e5 === void 0 || e5.nextTick(function() {
                  o3.doPrevStep();
                })), [3, 6]);
              case 2:
                return t4.type !== "interactiveAnim" ? [3, 3] : (this.player ? this.player.applyInteractiveAction(t4.action) : this.__slideState.interactiveSeqState[t4.seqId].step += 1, [3, 6]);
              case 3:
                return t4.type !== "renderSlide" ? [3, 5] : [4, this.doRenderSlide(t4.index, t4.isForward)];
              case 4:
                return s3.sent(), [3, 6];
              case 5:
                t4.type === "mediaPlay" ? ((n3 = this.player) === null || n3 === void 0 || n3.setMediaState(t4.id, true), this.__slideState.mediaState[t4.id] = t4.state) : t4.type === "mediaPause" ? ((i2 = this.player) === null || i2 === void 0 || i2.setMediaState(t4.id, false), this.__slideState.mediaState[t4.id] = t4.state) : t4.type === "mediaSeek" && ((r3 = this.player) === null || r3 === void 0 || r3.setMediaCurrentTime(t4.id, t4.time), this.__slideState.mediaState[t4.id] = t4.state), s3.label = 6;
              case 6:
                return [2];
            }
          });
        });
      }, n2.handlePrevSlide = function() {
        return eI(n2, void 0, void 0, function() {
          var t4, e5 = this;
          return nI(this, function(n3) {
            return this.player ? (setTimeout(function() {
              var t5;
              (t5 = e5.player) === null || t5 === void 0 || t5.createSnapshotForNextSlide();
            }), (t4 = this.player.prevSlideIndex) >= 1 && this.renderSlide(t4, false), [2]) : [2];
          });
        });
      }, n2.handleNextSlide = function() {
        return eI(n2, void 0, void 0, function() {
          var t4, e5 = this;
          return nI(this, function(n3) {
            return this.player ? (setTimeout(function() {
              var t5;
              (t5 = e5.player) === null || t5 === void 0 || t5.createSnapshotForNextSlide();
            }), (t4 = this.player.nextSlideIndex) <= this.slideCount && this.renderSlide(t4, true), [2]) : [2];
          });
        });
      }, n2.handleGotoSlide = function(t4) {
        if (t4 <= n2.slideCount && t4 >= 1) {
          var e5 = n2.slideState.currentSlideIndex <= t4;
          n2.renderSlide(t4, e5);
        } else
          t4 === -1 && n2.renderSlide(n2.slideCount, true);
      }, e4.timestamp && (n2.timestamp = e4.timestamp), n2.config = e4, n2.syncQueue = new $C(n2.receiveSyncHandler), n2.mode = e4.mode, n2.anchor = e4.anchor, n2.resize = e4.resize || false, n2.interactive = e4.interactive, n2.cacheImage.style.position = "absolute", n2.cacheImage.style.zIndex = "100", n2.frame.style.cssText = "width:100%;height:100%;display:flex;justify-content:center;align-items:center;visibility:hidden;position:relative;z-index:1;", n2.setMedianControllerAttribute(), n2.frame.appendChild(n2.medianController), n2.anchor.appendChild(n2.frame), n2.frameResizeObserver.observe(n2.frame), n2.on(aI.syncReceive, function(t4) {
        n2.lock.unlock(t4.type, t4.uuid), n2.syncQueue.addTask(t4);
      }), n2.renderingTaskManager.eventHub.on("task-error", function(t4) {
        var e5 = t4.error, i2 = t4.task;
        n2.emit(aI.renderError, { error: e5, index: i2.slideIndex });
      }), window.addEventListener("__slide_log__", n2.handleLogDownload), window.addEventListener("__slide_state__", n2.handleSlideStateLog), window.addEventListener("__slide_ref__", n2.handleSlideRef), n2.persistLogId = window.setInterval(n2.persistLog, 5e3), n2.resizeView = Object(l.debounce)(n2.resizeView.bind(n2), 50), n2.player = n2.initPlayer(e4), n2.player.view && n2.frame.appendChild(n2.player.view), n2;
    }
    return QC(e3, t3), e3.prototype.initPlayer = function(t4) {
      var e4 = this, n2 = new KR(this.mode);
      return n2.setInteractive(this.interactive), n2.updateConfig(t4.renderOptions || {}), n2.on($R.renderStart, function(t5) {
        e4.isLoading = true, e4.emit(aI.renderStart, t5);
      }), n2.on($R.renderEnd, function(t5) {
        e4.isLoading = false, e4.player && (e4.designHeight = e4.player.designHeight, e4.designWidth = e4.player.designWidth, e4.cacheImage.style.width = e4.player.designWidth + "px", e4.cacheImage.style.height = e4.player.designHeight + "px", e4._slideCount = e4.player.slideCount), e4.emit(aI.renderEnd, t5);
      }), n2.on($R.slideChange, function(t5) {
        e4.__slideState.currentSlideIndex = t5, e4.emit(aI.slideChange, t5);
      }), n2.on($R.mainSeqStateChange, function(t5) {
        e4.__slideState.mainSeqState = t5, e4.emitStateChange();
      }), n2.on($R.mainSeqStepChange, function(t5) {
        e4.__slideState.mainSeqStep = t5, e4.emitStateChange();
      }), n2.on($R.interactiveSeqStateChange, function(t5) {
        var n3 = t5.id, i2 = t5.state;
        e4.__slideState.interactiveSeqState[n3] = i2, e4.emitStateChange();
      }), n2.on($R.animateStart, function() {
        e4.isAnimating !== true && (e4.isAnimating = true, e4.emit(aI.animateStart));
      }), n2.on($R.animateEnd, function() {
        e4.isAnimating !== false && (e4.isAnimating = false, e4.emit(aI.animateEnd));
      }), n2.on($R.interactiveSeqAction, function(t5) {
        var n3 = t5.action, i2 = t5.seqId;
        e4.emitSyncDispatch({ slideIndex: e4.__slideState.currentSlideIndex, type: "interactiveAnim", action: n3, seqId: i2 }), e4.emitStateChange();
      }), n2.on($R.mainSeqStepStart, function(t5) {
        e4.emit(aI.mainSeqStepStart, t5);
      }), n2.on($R.mainSeqStepEnd, function(t5) {
        e4.emit(aI.mainSeqStepEnd, t5);
      }), n2.on($R.mediaPlay, function(t5) {
        var n3 = { type: "play", time: e4.timestamp() - 1e3 * t5.time };
        e4.__slideState.mediaState[t5.id] = n3, e4.emitSyncDispatch({ slideIndex: e4.__slideState.currentSlideIndex, type: "mediaPlay", id: t5.id, state: n3 }), e4.emitStateChange();
      }), n2.on($R.mediaPause, function(t5) {
        var n3 = { type: "pause", time: t5.time };
        e4.__slideState.mediaState[t5.id] = n3, e4.emitSyncDispatch({ slideIndex: e4.__slideState.currentSlideIndex, type: "mediaPause", id: t5.id, state: n3 }), e4.emitStateChange();
      }), n2.on($R.mediaSeek, function(t5) {
        var n3 = { type: "pause", time: 0 };
        t5.isPlaying ? (n3.type = "play", e4.__slideState.mediaState[t5.id] ? n3.time = e4.__slideState.mediaState[t5.id].time - 1e3 * t5.time : n3.time = e4.timestamp() - 1e3 * t5.time, e4.__slideState.mediaState[t5.id] = n3) : (n3.type = "pause", n3.time = t5.time, e4.__slideState.mediaState[t5.id] = n3), e4.emitSyncDispatch({ slideIndex: e4.__slideState.currentSlideIndex, type: "mediaSeek", id: t5.id, time: t5.time, state: n3 }), e4.emitStateChange();
      }), n2.on($R.requestPrevSlide, this.handlePrevSlide), n2.on($R.requestNextSlide, this.handleNextSlide), n2.on($R.requestGotoSlide, this.handleGotoSlide), (t4 == null ? void 0 : t4.controller) && this.createController(), n2;
    }, e3.prototype.createController = function() {
      this.player && (this.playerController = new JC({ player: this.player, params: this.player.config || {}, target: this.frame }));
    }, e3.prototype.setMedianControllerAttribute = function() {
      this.medianController.className = "median-container", this.medianController.style.position = "absolute", this.medianController.style.left = "0", this.medianController.style.top = "0", this.medianController.style.zIndex = "2";
    }, e3.prototype.frameResizeHandler = function() {
      var t4 = this.frame.getBoundingClientRect(), e4 = t4.width, n2 = t4.height;
      this.frameWidth = e4, this.frameHeight = n2, this.resizeView();
    }, e3.prototype.resizeView = function() {
      var t4, e4, n2 = this, i2 = this.width, r3 = this.height;
      if (i2 > 0 && r3 > 0) {
        var o3 = this.frameWidth / i2, s3 = o3 * r3;
        s3 > this.frameHeight && (o3 *= this.frameHeight / s3), (t4 = this.player) === null || t4 === void 0 || t4.scaleView(o3, this.resize), this.cacheImage.style.transform = "scale(" + o3 + ")", this.medianController.style.transform = "scale(" + o3 + ")", this.medianController.style.top = (this.frameHeight - r3 * o3) / 2 + "px", this.medianController.setAttribute("data-scale", o3.toString()), this.isInitResized || (this.isInitResized = true, (e4 = this.player) === null || e4 === void 0 || e4.clock.setTimeout(function() {
          n2.frame.style.visibility = "visible";
        }, 32));
      }
    }, e3.prototype.setSlideState = function(t4) {
      var e4, n2, i2;
      return eI(this, void 0, void 0, function() {
        var r3, o3 = this;
        return nI(this, function(s3) {
          switch (s3.label) {
            case 0:
              return this.log += "=== stateChange receive [" + new Date().toISOString() + "] ===\n", this.log += JSON.stringify(t4, null, 2), this.log += "\n\n", t4.taskId && t4.taskId !== this.__slideState.taskId && (this.__slideState.taskId = t4.taskId, (e4 = this.player) === null || e4 === void 0 || e4.setResourceData(t4.taskId, this.__slideState.url)), t4.url && t4.url !== this.__slideState.url && (this.__slideState.url = t4.url, (n2 = this.player) === null || n2 === void 0 || n2.setResourceData(this.__slideState.taskId, t4.url)), Number.isInteger(t4.currentSlideIndex) && t4.currentSlideIndex !== this.__slideState.currentSlideIndex ? (this.__slideState.currentSlideIndex = t4.currentSlideIndex, [4, this.doRenderSlide(t4.currentSlideIndex)]) : [3, 2];
            case 1:
              s3.sent(), s3.label = 2;
            case 2:
              return [4, (i2 = this.player) === null || i2 === void 0 ? void 0 : i2.clock.waitUntil(function() {
                var e5, n3;
                return ((e5 = o3.player) === null || e5 === void 0 ? void 0 : e5.currentIndex) === t4.currentSlideIndex && ((n3 = o3.player) === null || n3 === void 0 ? void 0 : n3.currentStage);
              }, 3e3)];
            case 3:
              return s3.sent(), r3 = false, Number.isInteger(t4.mainSeqStep) && t4.mainSeqStep !== this.__slideState.mainSeqStep && (r3 = true, this.__slideState.mainSeqStep = t4.mainSeqStep), t4.mainSeqState && t4.mainSeqState !== this.__slideState.mainSeqState && (r3 = true, this.__slideState.mainSeqState = t4.mainSeqState), r3 && this.setMainSeqStep(this.__slideState.mainSeqStep, this.__slideState.mainSeqState === "idle" ? "start" : "end"), t4.mediaState && (this.initMedia(t4), this.__slideState.mediaState = t4.mediaState), t4.interactiveSeqState && (this.initInteractiveSeq(t4), this.__slideState.interactiveSeqState = t4.interactiveSeqState), [2];
          }
        });
      });
    }, e3.prototype.initInteractiveSeq = function(t4) {
      var e4;
      for (var n2 in t4.interactiveSeqState) {
        var i2 = t4.interactiveSeqState[n2];
        (e4 = this.player) === null || e4 === void 0 || e4.setInteractiveSeqState(n2, i2.step, i2.state === "end" ? "end" : "start");
      }
    }, e3.prototype.initMedia = function(t4) {
      var e4, n2, i2 = this, r3 = function(r4) {
        var s4 = t4.mediaState[r4], a2 = o3.__slideState.mediaState[r4];
        if (a2 && s4.type === a2.type && s4.time === a2.time)
          return "continue";
        s4.type === "play" ? (e4 = o3.player) === null || e4 === void 0 || e4.setMediaState(r4, true).then(function() {
          var t5, e5 = i2.timestamp();
          (t5 = i2.player) === null || t5 === void 0 || t5.setMediaCurrentTime(r4, (e5 - s4.time) / 1e3);
        }) : (n2 = o3.player) === null || n2 === void 0 || n2.setMediaState(r4, false).then(function() {
          var t5;
          (t5 = i2.player) === null || t5 === void 0 || t5.setMediaCurrentTime(r4, s4.time);
        });
      }, o3 = this;
      for (var s3 in t4.mediaState)
        r3(s3);
    }, Object.defineProperty(e3.prototype, "slideCount", { get: function() {
      return this._slideCount;
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "slideState", { get: function() {
      return this.__slideState.mainSeqState = this.mainSeqState, this.__slideState.mainSeqStep = this.mainSeqStep, JSON.parse(JSON.stringify(this.__slideState));
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "mainSeqLength", { get: function() {
      var t4;
      return ((t4 = this.player) === null || t4 === void 0 ? void 0 : t4.mainSeqLength()) || 0;
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "mainSeqStep", { get: function() {
      var t4;
      return ((t4 = this.player) === null || t4 === void 0 ? void 0 : t4.mainSeqStep()) || 0;
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "mainSeqState", { get: function() {
      var t4;
      return ((t4 = this.player) === null || t4 === void 0 ? void 0 : t4.mainSeqState()) || null;
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "renderOptions", { get: function() {
      var t4;
      return ((t4 = this.player) === null || t4 === void 0 ? void 0 : t4.config) || null;
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "drawCall", { get: function() {
      var t4;
      return ((t4 = this.player) === null || t4 === void 0 ? void 0 : t4.runtime.drawCall) || 0;
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "renderFps", { get: function() {
      var t4;
      return ((t4 = this.player) === null || t4 === void 0 ? void 0 : t4.runtime.fps) || 0;
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "runtimeFps", { get: function() {
      var t4;
      return ((t4 = this.player) === null || t4 === void 0 ? void 0 : t4.fps.value) || 0;
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "view", { get: function() {
      var t4;
      return ((t4 = this.player) === null || t4 === void 0 ? void 0 : t4.view) || null;
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "width", { get: function() {
      return this.designWidth;
    }, enumerable: false, configurable: true }), Object.defineProperty(e3.prototype, "height", { get: function() {
      return this.designHeight;
    }, enumerable: false, configurable: true }), e3.prototype.updateRenderOption = function(t4) {
      this.player && (this.player.updateConfig(t4), this.renderOptions && (this.config.renderOptions = this.renderOptions));
    }, e3.prototype.setResource = function(t4, e4) {
      var n2;
      (n2 = this.player) === null || n2 === void 0 || n2.setResourceData(t4, e4), this.__slideState.taskId = t4, this.__slideState.url = e4, this.emitSyncDispatch({ slideIndex: this.__slideState.currentSlideIndex, type: "setResource", taskId: t4, url: e4 }), this.logId = t4 + "-" + Math.random().toString(32).substr(2);
    }, e3.prototype._renderSlide = function(t4) {
      var e4;
      return eI(this, void 0, void 0, function() {
        var n2 = this;
        return nI(this, function(i2) {
          switch (i2.label) {
            case 0:
              return this.player && t4 === this.player.currentIndex ? [2] : ((KR.platform.isIOS() || KR.platform.isAndroid()) && this.iosResetCache.indexOf(t4) < 0 && this.iosResetCache.push(t4), this.isLoading = true, [4, (e4 = this.player) === null || e4 === void 0 ? void 0 : e4.renderSlide(t4)]);
            case 1:
              return i2.sent(), this.__slideState.currentSlideIndex = t4, this.isLoading = false, this.resizeView(), this.emitStateChange(), setTimeout(function() {
                var t5, e5;
                if (((e5 = (t5 = n2.player) === null || t5 === void 0 ? void 0 : t5.view) === null || e5 === void 0 ? void 0 : e5.style.visibility) === "hidden" && (n2.player.view.style.visibility = "visible"), n2.frame.style.visibility === "hidden" && (n2.frame.style.visibility = "visible"), n2.needClearCacheImage)
                  try {
                    n2.frame.removeChild(n2.cacheImage);
                  } catch (t6) {
                  }
              }, 100), [2];
          }
        });
      });
    }, e3.prototype.renderSlide = function(t4, e4) {
      if (e4 === void 0 && (e4 = true), this.player) {
        var n2 = Number(t4);
        (n2 !== this.player.currentIndex || this.renderingTaskManager.hasStartTask()) && (n2 > this.slideCount && this.slideCount > 0 || this.poseRenderSlide(n2, e4));
      }
    }, e3.prototype.needCreateNewPlayer = function() {
      var t4 = KR.platform.isSupportTransaction(), e4 = t4 ? 15 : 7, n2 = t4 ? 600 : 300;
      return (KR.platform.isIOS() || KR.platform.isAndroid()) && (this.iosResetCache.length > e4 || 4 * KR.textureCacheSize / 1048576 > n2);
    }, e3.prototype.poseRenderSlide = function(t4, e4) {
      this.isLoading = true, this.mode === "interactive" ? this.emitSyncDispatch({ slideIndex: this.__slideState.currentSlideIndex, type: "renderSlide", index: t4, isForward: e4 }) : this.mode === "sync" ? (this.doRenderSlide(t4, e4), this.emitSyncDispatch({ slideIndex: this.__slideState.currentSlideIndex, type: "renderSlide", index: t4, isForward: e4 })) : this.doRenderSlide(t4, e4);
    }, e3.prototype.doRenderSlide = function(t4, e4) {
      var n2, i2 = this;
      if (e4 === void 0 && (e4 = true), !this.player)
        return Promise.resolve();
      if (this.needCreateNewPlayer() && (this.iosResetCache = [], KR.textureCacheSize = 0, this.iosNewPlayer = this.initPlayer(this.config), this.iosNewPlayer.setResourceData(this.__slideState.taskId, this.__slideState.url)), this.iosNewPlayer) {
        var r3 = this.player.getSnapshot();
        this.cacheImage.src = r3, this.frame.appendChild(this.cacheImage), this.player.destroy(), this.player = this.iosNewPlayer, this.iosNewPlayer = void 0, this.needClearCacheImage = true, ((n2 = this == null ? void 0 : this.player) === null || n2 === void 0 ? void 0 : n2.view) && (this.player.view.style.visibility = "hidden", this.frame.appendChild(this.player.view));
      }
      var o3 = Math.random().toString(32).substr(2);
      return this.player.isForward = e4, this.renderingTaskManager.addTask(function() {
        return i2._renderSlide(t4);
      }, t4, o3), new Promise(function(t5) {
        i2.renderingTaskManager.eventHub.once("task-end-" + o3, t5);
      });
    }, e3.prototype.nextStep = function() {
      !this.isLoading && this.player && (this.player.mainSeqHasNextStep() ? this.mode === "interactive" ? this.emitSyncDispatch({ slideIndex: this.__slideState.currentSlideIndex, type: "nextStep", next: this.player.mainSeqStep() + 1 }) : this.mode === "sync" ? (this.doNextStep(), this.emitSyncDispatch({ slideIndex: this.__slideState.currentSlideIndex, type: "nextStep", next: this.player.mainSeqStep() })) : this.doNextStep() : this.handleNextSlide());
    }, e3.prototype.doNextStep = function() {
      if (this.player) {
        this.player.nextStep();
        var t4 = this.player.mainSeqStep();
        this.__slideState.mainSeqStep = t4, this.emitStateChange();
      }
    }, e3.prototype.prevStep = function() {
      !this.isLoading && this.player && (this.player.mainSeqHasPrevStep() ? this.mode === "interactive" ? this.emitSyncDispatch({ type: "prevStep", slideIndex: this.__slideState.currentSlideIndex, next: this.player.mainSeqStep() - 1 }) : this.mode === "sync" ? (this.doPrevStep(), this.emitSyncDispatch({ slideIndex: this.__slideState.currentSlideIndex, type: "prevStep", next: this.player.mainSeqStep() })) : this.doPrevStep() : this.handlePrevSlide());
    }, e3.prototype.doPrevStep = function() {
      if (this.player) {
        this.player.prevStep();
        var t4 = this.player.mainSeqStep();
        this.__slideState.mainSeqStep = t4, this.emitStateChange();
      }
    }, e3.prototype.isSlideStateReady = function(t4) {
      return t4.taskId.length > 0 && t4.url.length > 0 && t4.currentSlideIndex > 0;
    }, e3.prototype.emitStateChange = function() {
      if (this.mode !== "local") {
        var t4 = this.slideState;
        !Object(l.isEqual)(this.lastEmitedState, t4) && this.isSlideStateReady(t4) && (this.lastEmitedState = t4, this.emit(aI.stateChange, t4), this.log += "=== stateChange dispatch [" + new Date().toISOString() + "] ===\n", this.log += JSON.stringify(this.slideState, null, 2), this.log += "\n\n");
      }
    }, e3.prototype.emitSyncDispatch = function(t4) {
      if (!this.lock.isLocked(t4.type)) {
        var e4 = Math.random().toString(32).substr(2);
        this.lock.addLock(t4.type, e4), this.emit(aI.syncDispatch, tI(tI({}, t4), { uuid: e4 })), this.log += "=== sync dispatch [" + new Date().toISOString() + "] ===\n", this.log += JSON.stringify(t4, null, 2), this.log += "\n\n";
      }
    }, e3.prototype.setMainSeqStep = function(t4, e4) {
      var n2;
      (n2 = this.player) === null || n2 === void 0 || n2.setMainSeqStep(t4, e4);
    }, e3.prototype.setInteractive = function(t4) {
      var e4;
      this.interactive = t4, (e4 = this.player) === null || e4 === void 0 || e4.setInteractive(t4);
    }, e3.prototype.pause = function() {
      var t4;
      (t4 = this.player) === null || t4 === void 0 || t4.pause();
    }, e3.prototype.resume = function() {
      var t4;
      (t4 = this.player) === null || t4 === void 0 || t4.resume();
    }, e3.prototype.frozen = function() {
      var t4;
      return eI(this, void 0, void 0, function() {
        var e4, n2, i2, r3 = this;
        return nI(this, function(o3) {
          switch (o3.label) {
            case 0:
              return this.isFrowning ? [2, sI(function() {
                return !r3.isFrowning;
              }, 6e4)] : this.view && this.player ? (this.isFrowning = true, [4, this.player.clock.waitUntil(function() {
                return !r3.isLoading;
              }, 6e4)]) : [3, 2];
            case 1:
              for (n2 in o3.sent(), e4 = this.player.getSnapshot() || "", this.cacheImage.src = e4, this.frame.appendChild(this.cacheImage), this.player.destroy(), (t4 = this.playerController) === null || t4 === void 0 || t4.destroy(), this.player = void 0, this.__slideState.mediaState)
                i2 = this.__slideState.mediaState[n2], this.__slideState.mediaState[n2] = tI(tI({}, i2), { frozenTime: this.timestamp() });
              this.isFrowning = false, o3.label = 2;
            case 2:
              return [2];
          }
        });
      });
    }, e3.prototype.release = function() {
      var t4;
      return eI(this, void 0, void 0, function() {
        var e4, n2, i2, r3, o3 = this;
        return nI(this, function(s3) {
          switch (s3.label) {
            case 0:
              if (this.isReleasing)
                return [2, sI(function() {
                  return !o3.isReleasing;
                }, 6e4)];
              for (n2 in this.isReleasing = true, this.player = this.initPlayer(this.config), this.player.view && (this.frame.appendChild(this.player.view), this.player.view.style.visibility = "hidden"), e4 = this.__slideState, this.__slideState = Object(l.cloneDeep)(lI), e4.mediaState)
                (i2 = e4.mediaState[n2]).type === "play" && (r3 = Math.max((t4 = i2.frozenTime) !== null && t4 !== void 0 ? t4 : 0, i2.time), i2.time = this.timestamp() - (r3 - i2.time), i2.frozenTime = void 0);
              return [4, this.setSlideState(e4)];
            case 1:
              return s3.sent(), [4, this.player.clock.delay(333)];
            case 2:
              s3.sent(), this.player.view && (this.player.view.style.visibility = "visible");
              try {
                this.frame.removeChild(this.cacheImage);
              } catch (t5) {
              }
              return this.isReleasing = false, [2];
          }
        });
      });
    }, e3.prototype.destroy = function() {
      var t4, e4, n2, i2;
      this.playerController && this.playerController.destroy(), this.frameResizeObserver.disconnect(), (t4 = this.player) === null || t4 === void 0 || t4.removeAllListeners(), (e4 = this.player) === null || e4 === void 0 || e4.destroy(), (n2 = this.player) === null || n2 === void 0 || n2.removeAllListeners(), window.removeEventListener("__slide_log__", this.handleLogDownload), window.removeEventListener("__slide_state__", this.handleSlideStateLog), window.removeEventListener("__slide_ref__", this.handleSlideRef), window.clearInterval(this.persistLogId), iI && iI.removeItem(this.logId).catch(function() {
      });
      try {
        ((i2 = this.player) === null || i2 === void 0 ? void 0 : i2.view) && this.anchor.removeChild(this.player.view);
      } catch (t5) {
      }
    }, e3.disposeLocalCache = function() {
      KR.storeManager.dispose();
    }, e3;
  }(a.a);
}]);
var colorString = { exports: {} };
var colorName = {
  "aliceblue": [240, 248, 255],
  "antiquewhite": [250, 235, 215],
  "aqua": [0, 255, 255],
  "aquamarine": [127, 255, 212],
  "azure": [240, 255, 255],
  "beige": [245, 245, 220],
  "bisque": [255, 228, 196],
  "black": [0, 0, 0],
  "blanchedalmond": [255, 235, 205],
  "blue": [0, 0, 255],
  "blueviolet": [138, 43, 226],
  "brown": [165, 42, 42],
  "burlywood": [222, 184, 135],
  "cadetblue": [95, 158, 160],
  "chartreuse": [127, 255, 0],
  "chocolate": [210, 105, 30],
  "coral": [255, 127, 80],
  "cornflowerblue": [100, 149, 237],
  "cornsilk": [255, 248, 220],
  "crimson": [220, 20, 60],
  "cyan": [0, 255, 255],
  "darkblue": [0, 0, 139],
  "darkcyan": [0, 139, 139],
  "darkgoldenrod": [184, 134, 11],
  "darkgray": [169, 169, 169],
  "darkgreen": [0, 100, 0],
  "darkgrey": [169, 169, 169],
  "darkkhaki": [189, 183, 107],
  "darkmagenta": [139, 0, 139],
  "darkolivegreen": [85, 107, 47],
  "darkorange": [255, 140, 0],
  "darkorchid": [153, 50, 204],
  "darkred": [139, 0, 0],
  "darksalmon": [233, 150, 122],
  "darkseagreen": [143, 188, 143],
  "darkslateblue": [72, 61, 139],
  "darkslategray": [47, 79, 79],
  "darkslategrey": [47, 79, 79],
  "darkturquoise": [0, 206, 209],
  "darkviolet": [148, 0, 211],
  "deeppink": [255, 20, 147],
  "deepskyblue": [0, 191, 255],
  "dimgray": [105, 105, 105],
  "dimgrey": [105, 105, 105],
  "dodgerblue": [30, 144, 255],
  "firebrick": [178, 34, 34],
  "floralwhite": [255, 250, 240],
  "forestgreen": [34, 139, 34],
  "fuchsia": [255, 0, 255],
  "gainsboro": [220, 220, 220],
  "ghostwhite": [248, 248, 255],
  "gold": [255, 215, 0],
  "goldenrod": [218, 165, 32],
  "gray": [128, 128, 128],
  "green": [0, 128, 0],
  "greenyellow": [173, 255, 47],
  "grey": [128, 128, 128],
  "honeydew": [240, 255, 240],
  "hotpink": [255, 105, 180],
  "indianred": [205, 92, 92],
  "indigo": [75, 0, 130],
  "ivory": [255, 255, 240],
  "khaki": [240, 230, 140],
  "lavender": [230, 230, 250],
  "lavenderblush": [255, 240, 245],
  "lawngreen": [124, 252, 0],
  "lemonchiffon": [255, 250, 205],
  "lightblue": [173, 216, 230],
  "lightcoral": [240, 128, 128],
  "lightcyan": [224, 255, 255],
  "lightgoldenrodyellow": [250, 250, 210],
  "lightgray": [211, 211, 211],
  "lightgreen": [144, 238, 144],
  "lightgrey": [211, 211, 211],
  "lightpink": [255, 182, 193],
  "lightsalmon": [255, 160, 122],
  "lightseagreen": [32, 178, 170],
  "lightskyblue": [135, 206, 250],
  "lightslategray": [119, 136, 153],
  "lightslategrey": [119, 136, 153],
  "lightsteelblue": [176, 196, 222],
  "lightyellow": [255, 255, 224],
  "lime": [0, 255, 0],
  "limegreen": [50, 205, 50],
  "linen": [250, 240, 230],
  "magenta": [255, 0, 255],
  "maroon": [128, 0, 0],
  "mediumaquamarine": [102, 205, 170],
  "mediumblue": [0, 0, 205],
  "mediumorchid": [186, 85, 211],
  "mediumpurple": [147, 112, 219],
  "mediumseagreen": [60, 179, 113],
  "mediumslateblue": [123, 104, 238],
  "mediumspringgreen": [0, 250, 154],
  "mediumturquoise": [72, 209, 204],
  "mediumvioletred": [199, 21, 133],
  "midnightblue": [25, 25, 112],
  "mintcream": [245, 255, 250],
  "mistyrose": [255, 228, 225],
  "moccasin": [255, 228, 181],
  "navajowhite": [255, 222, 173],
  "navy": [0, 0, 128],
  "oldlace": [253, 245, 230],
  "olive": [128, 128, 0],
  "olivedrab": [107, 142, 35],
  "orange": [255, 165, 0],
  "orangered": [255, 69, 0],
  "orchid": [218, 112, 214],
  "palegoldenrod": [238, 232, 170],
  "palegreen": [152, 251, 152],
  "paleturquoise": [175, 238, 238],
  "palevioletred": [219, 112, 147],
  "papayawhip": [255, 239, 213],
  "peachpuff": [255, 218, 185],
  "peru": [205, 133, 63],
  "pink": [255, 192, 203],
  "plum": [221, 160, 221],
  "powderblue": [176, 224, 230],
  "purple": [128, 0, 128],
  "rebeccapurple": [102, 51, 153],
  "red": [255, 0, 0],
  "rosybrown": [188, 143, 143],
  "royalblue": [65, 105, 225],
  "saddlebrown": [139, 69, 19],
  "salmon": [250, 128, 114],
  "sandybrown": [244, 164, 96],
  "seagreen": [46, 139, 87],
  "seashell": [255, 245, 238],
  "sienna": [160, 82, 45],
  "silver": [192, 192, 192],
  "skyblue": [135, 206, 235],
  "slateblue": [106, 90, 205],
  "slategray": [112, 128, 144],
  "slategrey": [112, 128, 144],
  "snow": [255, 250, 250],
  "springgreen": [0, 255, 127],
  "steelblue": [70, 130, 180],
  "tan": [210, 180, 140],
  "teal": [0, 128, 128],
  "thistle": [216, 191, 216],
  "tomato": [255, 99, 71],
  "turquoise": [64, 224, 208],
  "violet": [238, 130, 238],
  "wheat": [245, 222, 179],
  "white": [255, 255, 255],
  "whitesmoke": [245, 245, 245],
  "yellow": [255, 255, 0],
  "yellowgreen": [154, 205, 50]
};
var simpleSwizzle = { exports: {} };
var isArrayish$1 = function isArrayish(obj) {
  if (!obj || typeof obj === "string") {
    return false;
  }
  return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && (obj.splice instanceof Function || Object.getOwnPropertyDescriptor(obj, obj.length - 1) && obj.constructor.name !== "String");
};
var isArrayish2 = isArrayish$1;
var concat = Array.prototype.concat;
var slice = Array.prototype.slice;
var swizzle$1 = simpleSwizzle.exports = function swizzle(args) {
  var results = [];
  for (var i = 0, len = args.length; i < len; i++) {
    var arg = args[i];
    if (isArrayish2(arg)) {
      results = concat.call(results, slice.call(arg));
    } else {
      results.push(arg);
    }
  }
  return results;
};
swizzle$1.wrap = function(fn) {
  return function() {
    return fn(swizzle$1(arguments));
  };
};
var colorNames = colorName;
var swizzle2 = simpleSwizzle.exports;
var hasOwnProperty = Object.hasOwnProperty;
var reverseNames = {};
for (var name in colorNames) {
  if (hasOwnProperty.call(colorNames, name)) {
    reverseNames[colorNames[name]] = name;
  }
}
var cs = colorString.exports = {
  to: {},
  get: {}
};
cs.get = function(string) {
  var prefix = string.substring(0, 3).toLowerCase();
  var val;
  var model;
  switch (prefix) {
    case "hsl":
      val = cs.get.hsl(string);
      model = "hsl";
      break;
    case "hwb":
      val = cs.get.hwb(string);
      model = "hwb";
      break;
    default:
      val = cs.get.rgb(string);
      model = "rgb";
      break;
  }
  if (!val) {
    return null;
  }
  return { model, value: val };
};
cs.get.rgb = function(string) {
  if (!string) {
    return null;
  }
  var abbr = /^#([a-f0-9]{3,4})$/i;
  var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
  var rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
  var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
  var keyword = /^(\w+)$/;
  var rgb = [0, 0, 0, 1];
  var match;
  var i;
  var hexAlpha;
  if (match = string.match(hex)) {
    hexAlpha = match[2];
    match = match[1];
    for (i = 0; i < 3; i++) {
      var i2 = i * 2;
      rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);
    }
    if (hexAlpha) {
      rgb[3] = parseInt(hexAlpha, 16) / 255;
    }
  } else if (match = string.match(abbr)) {
    match = match[1];
    hexAlpha = match[3];
    for (i = 0; i < 3; i++) {
      rgb[i] = parseInt(match[i] + match[i], 16);
    }
    if (hexAlpha) {
      rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
    }
  } else if (match = string.match(rgba)) {
    for (i = 0; i < 3; i++) {
      rgb[i] = parseInt(match[i + 1], 0);
    }
    if (match[4]) {
      if (match[5]) {
        rgb[3] = parseFloat(match[4]) * 0.01;
      } else {
        rgb[3] = parseFloat(match[4]);
      }
    }
  } else if (match = string.match(per)) {
    for (i = 0; i < 3; i++) {
      rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
    }
    if (match[4]) {
      if (match[5]) {
        rgb[3] = parseFloat(match[4]) * 0.01;
      } else {
        rgb[3] = parseFloat(match[4]);
      }
    }
  } else if (match = string.match(keyword)) {
    if (match[1] === "transparent") {
      return [0, 0, 0, 0];
    }
    if (!hasOwnProperty.call(colorNames, match[1])) {
      return null;
    }
    rgb = colorNames[match[1]];
    rgb[3] = 1;
    return rgb;
  } else {
    return null;
  }
  for (i = 0; i < 3; i++) {
    rgb[i] = clamp(rgb[i], 0, 255);
  }
  rgb[3] = clamp(rgb[3], 0, 1);
  return rgb;
};
cs.get.hsl = function(string) {
  if (!string) {
    return null;
  }
  var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
  var match = string.match(hsl);
  if (match) {
    var alpha = parseFloat(match[4]);
    var h = (parseFloat(match[1]) % 360 + 360) % 360;
    var s2 = clamp(parseFloat(match[2]), 0, 100);
    var l = clamp(parseFloat(match[3]), 0, 100);
    var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
    return [h, s2, l, a];
  }
  return null;
};
cs.get.hwb = function(string) {
  if (!string) {
    return null;
  }
  var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
  var match = string.match(hwb);
  if (match) {
    var alpha = parseFloat(match[4]);
    var h = (parseFloat(match[1]) % 360 + 360) % 360;
    var w = clamp(parseFloat(match[2]), 0, 100);
    var b = clamp(parseFloat(match[3]), 0, 100);
    var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
    return [h, w, b, a];
  }
  return null;
};
cs.to.hex = function() {
  var rgba = swizzle2(arguments);
  return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (rgba[3] < 1 ? hexDouble(Math.round(rgba[3] * 255)) : "");
};
cs.to.rgb = function() {
  var rgba = swizzle2(arguments);
  return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ")" : "rgba(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ", " + rgba[3] + ")";
};
cs.to.rgb.percent = function() {
  var rgba = swizzle2(arguments);
  var r2 = Math.round(rgba[0] / 255 * 100);
  var g = Math.round(rgba[1] / 255 * 100);
  var b = Math.round(rgba[2] / 255 * 100);
  return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + r2 + "%, " + g + "%, " + b + "%)" : "rgba(" + r2 + "%, " + g + "%, " + b + "%, " + rgba[3] + ")";
};
cs.to.hsl = function() {
  var hsla = swizzle2(arguments);
  return hsla.length < 4 || hsla[3] === 1 ? "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)" : "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + hsla[3] + ")";
};
cs.to.hwb = function() {
  var hwba = swizzle2(arguments);
  var a = "";
  if (hwba.length >= 4 && hwba[3] !== 1) {
    a = ", " + hwba[3];
  }
  return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a + ")";
};
cs.to.keyword = function(rgb) {
  return reverseNames[rgb.slice(0, 3)];
};
function clamp(num, min, max) {
  return Math.min(Math.max(min, num), max);
}
function hexDouble(num) {
  var str = Math.round(num).toString(16).toUpperCase();
  return str.length < 2 ? "0" + str : str;
}
var ColorString = colorString.exports;
function guessBgColor(el) {
  try {
    const bg = window.getComputedStyle(el).backgroundColor;
    if (bg !== "rgba(0, 0, 0, 0)" && bg !== "transparent") {
      return bg;
    }
    if (el.parentElement) {
      return guessBgColor(el.parentElement);
    }
  } catch {
  }
  return "#ffffff";
}
function toHex(color) {
  const result = ColorString.get(color);
  if (result && result.model === "rgb") {
    const args = result.value;
    const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
    const string = integer.toString(16);
    return "#" + "000000".substring(string.length) + string;
  } else {
    return color;
  }
}
let cachedBgColor = "";
function cachedGetBgColor(el) {
  if (!cachedBgColor) {
    cachedBgColor = toHex(guessBgColor(el));
    log("[Slide] guess bg color", cachedBgColor);
  }
  return cachedBgColor;
}
function createDocsViewerPages(slide) {
  const { width, height, slideCount, slideState } = slide;
  const { taskId, url } = slideState;
  const pages = [];
  for (let i = 1; i <= slideCount; ++i) {
    pages.push({ width, height, thumbnail: `${url}/${taskId}/preview/${i}.png`, src: "ppt" });
  }
  return pages;
}
function syncSceneWithSlide(room, context, slide, baseScenePath) {
  var _a;
  const page = slide.slideState.currentSlideIndex;
  if (!(page > 0) || !context.getIsWritable())
    return;
  const scenePath = [baseScenePath, page].join("/");
  if (room.scenePathType(scenePath) !== "page") {
    room.removeScenes(baseScenePath);
    const count = slide.slideCount;
    const scenes = [];
    for (let i = 1; i <= count; ++i)
      scenes.push({ name: `${i}` });
    room.putScenes(baseScenePath, scenes);
  }
  let currentScenePath;
  if (context.getBox().focus) {
    currentScenePath = room.state.sceneState.scenePath;
  } else {
    currentScenePath = ((_a = context.getView()) == null ? void 0 : _a.focusScenePath) || "";
  }
  if (currentScenePath !== scenePath) {
    context.setScenePath(scenePath);
  }
}
const DefaultUrl = "https://convertcdn.netless.link/dynamicConvert";
const MaxPollCount = 40;
const EmptyAttributes = {
  taskId: "",
  url: "",
  state: null
};
class SlideController {
  constructor({
    context,
    anchor,
    onPageChanged,
    onTransitionStart,
    onTransitionEnd,
    onError
  }) {
    this.sideEffect = new o();
    this.ready = false;
    this.readyPromise = new Promise((resolve) => {
      this.resolveReady = () => setTimeout(() => {
        this.ready = true;
        resolve();
      }, 1e3);
    });
    this.onSyncDispatch = (event) => {
      if (this.context.getIsWritable() && this.room) {
        const payload = {
          type: Slide.SLIDE_EVENTS.syncDispatch,
          payload: event
        };
        log("[Slide] dispatch", event);
        this.room.dispatchMagixEvent(this.channel, payload);
      }
    };
    this.magixEventListener = (ev) => {
      if (ev.event === this.channel && isObj(ev.payload)) {
        const { type, payload } = ev.payload;
        if (type === Slide.SLIDE_EVENTS.syncDispatch) {
          this.syncStateOnce();
          log("[Slide] receive", payload);
          this.slide.emit(Slide.SLIDE_EVENTS.syncReceive, payload);
        }
      }
    };
    this.onStateChange = (state) => {
      if (this.context.getIsWritable()) {
        verbose("[Slide] state change", JSON.stringify(state, null, 2));
        this.context.updateAttributes(["state"], state);
      }
    };
    this.onSeeked = () => {
      const state = this.context.getAttributes().state;
      if (state) {
        this.slide.setSlideState(deepClone(state));
      }
    };
    this.pollCount = 0;
    this.pollReadyState = () => {
      if (this.ready) {
        if (this._toFreeze === 1) {
          this.freeze();
        } else if (this._toFreeze === -1) {
          this.unfreeze();
        }
      } else if (this.pollCount < MaxPollCount) {
        this.pollCount++;
        setTimeout(this.pollReadyState, 500);
      } else {
        this.pollCount = 0;
        log("[Slide] renderSlide (retry after timeout)", 1);
        this.slide.renderSlide(1);
      }
    };
    this._pageCount = 0;
    this.destroyed = false;
    this.timestamp = () => {
      if (this.room && this.room.calibrationTimestamp) {
        return this.room.calibrationTimestamp;
      } else if (this.player) {
        return this.player.beginTimestamp + this.player.progressTime;
      } else {
        return Date.now();
      }
    };
    this.isFrozen = false;
    this._toFreeze = 0;
    this.freezePromise = null;
    this.freeze = () => {
      if (this.ready) {
        log("[Slide] freeze", this.context.appId);
        if (this.freezePromise) {
          this._toFreeze = 1;
        } else if (!this.isFrozen) {
          this._toFreeze = 0;
          this.freezePromise = this.slide.frozen().then(this.afterFreeze.bind(this, 1));
        }
      } else {
        this._toFreeze = 1;
      }
    };
    this.unfreeze = async () => {
      if (this.ready) {
        log("[Slide] unfreeze", this.context.appId);
        if (this.freezePromise) {
          this._toFreeze = -1;
        } else if (this.isFrozen) {
          this._toFreeze = 0;
          this.freezePromise = this.slide.release().then(this.afterFreeze.bind(this, -1));
        }
      } else {
        this._toFreeze = -1;
      }
    };
    this.onPageChanged = onPageChanged;
    this.onTransitionStart = onTransitionStart;
    this.onTransitionEnd = onTransitionEnd;
    this.onError = onError;
    this.context = context;
    this.channel = `channel-${context.appId}`;
    this.room = context.getRoom();
    this.player = this.room ? void 0 : context.getDisplayer();
    this.slide = this.createSlide(anchor);
    this.syncStateOnceFlag = !this.context.isAddApp;
    this.initialize();
  }
  jumpToPage(page) {
    if (this.ready) {
      page = clamp$1(page, 1, this.pageCount);
      this.slide.renderSlide(page);
    }
  }
  initialize() {
    this.registerEventListeners();
    this.kickStart();
  }
  kickStart() {
    const { context, slide } = this;
    const { taskId, url, state } = __spreadValues(__spreadValues({}, EmptyAttributes), this.context.getAttributes());
    slide.setResource(taskId, url || DefaultUrl);
    if (state) {
      log("[Slide] init with state", deepClone(state));
      this.syncStateOnceFlag = false;
      slide.setSlideState(deepClone(state));
    } else if (context.isAddApp) {
      log("[Slide] init by renderSlide", 1);
      slide.renderSlide(1);
    }
    this.pollReadyState();
  }
  registerEventListeners() {
    const { context, slide } = this;
    this.sideEffect.add(() => {
      const disposer = context.mobxUtils.reaction(() => context.getAttributes().state, () => {
        this.syncStateOnce();
        disposer();
      });
      return disposer;
    });
    this.sideEffect.add(() => {
      context.emitter.on("seek", this.onSeeked);
      return () => context.emitter.off("seek", this.onSeeked);
    });
    this.sideEffect.add(() => {
      const displayer = context.getDisplayer();
      displayer.addMagixEventListener(this.channel, this.magixEventListener, {
        fireSelfEventAfterCommit: true
      });
      return () => displayer.removeMagixEventListener(this.channel);
    });
    slide.on(Slide.SLIDE_EVENTS.slideChange, this.onPageChanged);
    slide.on(Slide.SLIDE_EVENTS.renderStart, this.onTransitionStart);
    slide.on(Slide.SLIDE_EVENTS.renderEnd, this.onTransitionEnd);
    slide.on(Slide.SLIDE_EVENTS.mainSeqStepStart, this.onTransitionStart);
    slide.on(Slide.SLIDE_EVENTS.mainSeqStepEnd, this.onTransitionEnd);
    slide.on(Slide.SLIDE_EVENTS.renderError, this.onError);
    slide.on(Slide.SLIDE_EVENTS.stateChange, this.onStateChange);
    slide.on(Slide.SLIDE_EVENTS.syncDispatch, this.onSyncDispatch);
    slide.on(Slide.SLIDE_EVENTS.renderEnd, this.resolveReady);
  }
  syncStateOnce() {
    if (this.syncStateOnceFlag) {
      const { state } = __spreadValues(__spreadValues({}, EmptyAttributes), this.context.getAttributes());
      if (state) {
        log("[Slide] sync with state (once)", deepClone(state));
        this.slide.setSlideState(deepClone(state));
        this.syncStateOnceFlag = false;
      }
    }
  }
  get pageCount() {
    if (this._pageCount > 0)
      return this._pageCount;
    this._pageCount = this.slide.slideCount;
    return this._pageCount;
  }
  get page() {
    return this.slide.slideState.currentSlideIndex;
  }
  createSlide(anchor) {
    var _a, _b;
    const slide = new Slide.Slide({
      anchor,
      interactive: true,
      mode: "interactive",
      resize: true,
      controller: logger.enable,
      renderOptions: {
        minFPS: 25,
        maxFPS: 30,
        autoFPS: true,
        autoResolution: true,
        resolution: (_a = this.context.getAppOptions()) == null ? void 0 : _a.resolution,
        transactionBgColor: ((_b = this.context.getAppOptions()) == null ? void 0 : _b.bgColor) || cachedGetBgColor(anchor)
      },
      timestamp: this.timestamp
    });
    return slide;
  }
  destroy() {
    this.sideEffect.flushAll();
    if (!this.destroyed) {
      log("[Slide] destroy slide (once)");
      this.slide.destroy();
      this.destroyed = true;
    }
  }
  afterFreeze(from) {
    if (from === 1) {
      this.isFrozen = true;
      this.freezePromise = null;
      if (this._toFreeze === -1) {
        this.unfreeze();
      }
    } else if (from === -1) {
      this.isFrozen = false;
      this.freezePromise = null;
      if (this._toFreeze === 1) {
        this.freeze();
      }
    }
  }
}
function sidebarSVG(namespace) {
  const NS = "http://www.w3.org/2000/svg";
  const $svg = document.createElementNS(NS, "svg");
  $svg.setAttribute("class", `${namespace}-footer-icon-sidebar`);
  $svg.setAttribute("viewBox", "0 0 64 64");
  const $path = document.createElementNS(NS, "path");
  $path.setAttribute("fill", "currentColor");
  $path.setAttribute("d", "M50 8H14c-3.309 0-6 2.691-6 6v36c0 3.309 2.691 6 6 6h36c3.309 0 6-2.691 6-6V14c0-3.309-2.691-6-6-6zM12 50V14c0-1.103.897-2 2-2h8v40h-8c-1.103 0-2-.897-2-2zm40 0c0 1.103-.897 2-2 2H26V12h24c1.103 0 2 .897 2 2z");
  $svg.appendChild($path);
  return $svg;
}
function arrowLeftSVG(namespace) {
  const NS = "http://www.w3.org/2000/svg";
  const $svg = document.createElementNS(NS, "svg");
  $svg.setAttribute("class", `${namespace}-footer-icon-arrow-left`);
  $svg.setAttribute("viewBox", "0 0 500 500");
  const $path = document.createElementNS(NS, "path");
  $path.setAttribute("fill", "currentColor");
  $path.setAttribute("d", "M177.81 249.959L337.473 90.295c2.722-2.865 2.651-7.378-.143-10.1-2.793-2.65-7.163-2.65-9.956 0l-164.75 164.75c-2.793 2.793-2.793 7.306 0 10.1l164.75 164.75c2.865 2.722 7.378 2.65 10.099-.143 2.651-2.794 2.651-7.163 0-9.957L177.809 249.959z");
  $svg.appendChild($path);
  return $svg;
}
function arrowRightSVG(namespace) {
  const NS = "http://www.w3.org/2000/svg";
  const $svg = document.createElementNS(NS, "svg");
  $svg.setAttribute("class", `${namespace}-footer-icon-arrow-right`);
  $svg.setAttribute("viewBox", "0 0 500 500");
  const $path = document.createElementNS(NS, "path");
  $path.setAttribute("fill", "currentColor");
  $path.setAttribute("d", "M322.19 250.041L162.527 409.705c-2.722 2.865-2.651 7.378.143 10.1 2.793 2.65 7.163 2.65 9.956 0l164.75-164.75c2.793-2.793 2.793-7.306 0-10.1l-164.75-164.75c-2.865-2.722-7.378-2.65-10.099.143-2.651 2.794-2.651 7.163 0 9.957l159.664 159.736z");
  $svg.appendChild($path);
  return $svg;
}
function playSVG(namespace) {
  const NS = "http://www.w3.org/2000/svg";
  const $svg = document.createElementNS(NS, "svg");
  $svg.setAttribute("class", `${namespace}-footer-icon-play`);
  $svg.setAttribute("viewBox", "0 0 500 500");
  const $path = document.createElementNS(NS, "path");
  $path.setAttribute("fill", "currentColor");
  $path.setAttribute("d", "M418.158 257.419L174.663 413.33c-6.017 3.919-15.708 3.772-21.291-.29-2.791-2.018-4.295-4.483-4.295-7.084V94.109c0-5.65 6.883-10.289 15.271-10.289 4.298 0 8.391 1.307 11.181 3.332l242.629 155.484c6.016 3.917 6.451 10.292.649 14.491-.216.154-.432.154-.649.292zM170.621 391.288l223.116-141.301L170.71 107.753l-.089 283.535z");
  $svg.appendChild($path);
  return $svg;
}
function pauseSVG(namespace) {
  const NS = "http://www.w3.org/2000/svg";
  const $svg = document.createElementNS(NS, "svg");
  $svg.setAttribute("class", `${namespace}-footer-icon-pause`);
  $svg.setAttribute("viewBox", "0 0 500 500");
  const $path = document.createElementNS(NS, "path");
  $path.setAttribute("fill", "currentColor");
  $path.setAttribute("d", "M312.491 78.261c0-6.159 4.893-11.213 11.04-11.213 6.158 0 11.211 5.054 11.211 11.213v343.478c0 6.159-5.053 11.213-11.211 11.213-6.147 0-11.04-5.054-11.04-11.213V78.261zM165.257 78.261c0-6.159 4.893-11.213 11.04-11.213 6.158 0 11.211 5.054 11.211 11.213v343.478c0 6.159-5.053 11.213-11.211 11.213-6.147 0-11.04-5.054-11.04-11.213V78.261z");
  $svg.appendChild($path);
  return $svg;
}
const runningOnBrowser = typeof window !== "undefined";
const isBot = runningOnBrowser && !("onscroll" in window) || typeof navigator !== "undefined" && /(gle|ing|ro)bot|crawl|spider/i.test(navigator.userAgent);
const supportsIntersectionObserver = runningOnBrowser && "IntersectionObserver" in window;
const supportsClassList = runningOnBrowser && "classList" in document.createElement("p");
const isHiDpi = runningOnBrowser && window.devicePixelRatio > 1;
const defaultSettings = {
  elements_selector: ".lazy",
  container: isBot || runningOnBrowser ? document : null,
  threshold: 300,
  thresholds: null,
  data_src: "src",
  data_srcset: "srcset",
  data_sizes: "sizes",
  data_bg: "bg",
  data_bg_hidpi: "bg-hidpi",
  data_bg_multi: "bg-multi",
  data_bg_multi_hidpi: "bg-multi-hidpi",
  data_poster: "poster",
  class_applied: "applied",
  class_loading: "loading",
  class_loaded: "loaded",
  class_error: "error",
  class_entered: "entered",
  class_exited: "exited",
  unobserve_completed: true,
  unobserve_entered: false,
  cancel_on_exit: true,
  callback_enter: null,
  callback_exit: null,
  callback_applied: null,
  callback_loading: null,
  callback_loaded: null,
  callback_error: null,
  callback_finish: null,
  callback_cancel: null,
  use_native: false
};
const getExtendedSettings = (customSettings) => {
  return Object.assign({}, defaultSettings, customSettings);
};
const createInstance = function(classObj, options) {
  let event;
  const eventString = "LazyLoad::Initialized";
  const instance = new classObj(options);
  try {
    event = new CustomEvent(eventString, { detail: { instance } });
  } catch (err) {
    event = document.createEvent("CustomEvent");
    event.initCustomEvent(eventString, false, false, { instance });
  }
  window.dispatchEvent(event);
};
const autoInitialize = (classObj, options) => {
  if (!options) {
    return;
  }
  if (!options.length) {
    createInstance(classObj, options);
  } else {
    for (let i = 0, optionsItem; optionsItem = options[i]; i += 1) {
      createInstance(classObj, optionsItem);
    }
  }
};
const SRC = "src";
const SRCSET = "srcset";
const SIZES = "sizes";
const POSTER = "poster";
const ORIGINALS = "llOriginalAttrs";
const statusLoading = "loading";
const statusLoaded = "loaded";
const statusApplied = "applied";
const statusEntered = "entered";
const statusError = "error";
const statusNative = "native";
const dataPrefix = "data-";
const statusDataName = "ll-status";
const getData = (element, attribute) => {
  return element.getAttribute(dataPrefix + attribute);
};
const setData = (element, attribute, value) => {
  var attrName = dataPrefix + attribute;
  if (value === null) {
    element.removeAttribute(attrName);
    return;
  }
  element.setAttribute(attrName, value);
};
const getStatus = (element) => getData(element, statusDataName);
const setStatus = (element, status) => setData(element, statusDataName, status);
const resetStatus = (element) => setStatus(element, null);
const hasEmptyStatus = (element) => getStatus(element) === null;
const hasStatusLoading = (element) => getStatus(element) === statusLoading;
const hasStatusError = (element) => getStatus(element) === statusError;
const hasStatusNative = (element) => getStatus(element) === statusNative;
const statusesAfterLoading = [statusLoading, statusLoaded, statusApplied, statusError];
const hadStartedLoading = (element) => statusesAfterLoading.indexOf(getStatus(element)) >= 0;
const safeCallback = (callback, arg1, arg2, arg3) => {
  if (!callback) {
    return;
  }
  if (arg3 !== void 0) {
    callback(arg1, arg2, arg3);
    return;
  }
  if (arg2 !== void 0) {
    callback(arg1, arg2);
    return;
  }
  callback(arg1);
};
const addClass = (element, className) => {
  if (supportsClassList) {
    element.classList.add(className);
    return;
  }
  element.className += (element.className ? " " : "") + className;
};
const removeClass = (element, className) => {
  if (supportsClassList) {
    element.classList.remove(className);
    return;
  }
  element.className = element.className.replace(new RegExp("(^|\\s+)" + className + "(\\s+|$)"), " ").replace(/^\s+/, "").replace(/\s+$/, "");
};
const addTempImage = (element) => {
  element.llTempImage = document.createElement("IMG");
};
const deleteTempImage = (element) => {
  delete element.llTempImage;
};
const getTempImage = (element) => element.llTempImage;
const unobserve = (element, instance) => {
  if (!instance)
    return;
  const observer = instance._observer;
  if (!observer)
    return;
  observer.unobserve(element);
};
const resetObserver = (observer) => {
  observer.disconnect();
};
const unobserveEntered = (element, settings, instance) => {
  if (settings.unobserve_entered)
    unobserve(element, instance);
};
const updateLoadingCount = (instance, delta) => {
  if (!instance)
    return;
  instance.loadingCount += delta;
};
const decreaseToLoadCount = (instance) => {
  if (!instance)
    return;
  instance.toLoadCount -= 1;
};
const setToLoadCount = (instance, value) => {
  if (!instance)
    return;
  instance.toLoadCount = value;
};
const isSomethingLoading = (instance) => instance.loadingCount > 0;
const haveElementsToLoad = (instance) => instance.toLoadCount > 0;
const getSourceTags = (parentTag) => {
  let sourceTags = [];
  for (let i = 0, childTag; childTag = parentTag.children[i]; i += 1) {
    if (childTag.tagName === "SOURCE") {
      sourceTags.push(childTag);
    }
  }
  return sourceTags;
};
const forEachPictureSource = (element, fn) => {
  const parent = element.parentNode;
  if (!parent || parent.tagName !== "PICTURE") {
    return;
  }
  let sourceTags = getSourceTags(parent);
  sourceTags.forEach(fn);
};
const forEachVideoSource = (element, fn) => {
  let sourceTags = getSourceTags(element);
  sourceTags.forEach(fn);
};
const attrsSrc = [SRC];
const attrsSrcPoster = [SRC, POSTER];
const attrsSrcSrcsetSizes = [SRC, SRCSET, SIZES];
const hasOriginalAttrs = (element) => !!element[ORIGINALS];
const getOriginalAttrs = (element) => element[ORIGINALS];
const deleteOriginalAttrs = (element) => delete element[ORIGINALS];
const setOriginalsObject = (element, attributes) => {
  if (hasOriginalAttrs(element)) {
    return;
  }
  const originals = {};
  attributes.forEach((attribute) => {
    originals[attribute] = element.getAttribute(attribute);
  });
  element[ORIGINALS] = originals;
};
const saveOriginalBackgroundStyle = (element) => {
  if (hasOriginalAttrs(element)) {
    return;
  }
  element[ORIGINALS] = { backgroundImage: element.style.backgroundImage };
};
const setOrResetAttribute = (element, attrName, value) => {
  if (!value) {
    element.removeAttribute(attrName);
    return;
  }
  element.setAttribute(attrName, value);
};
const restoreOriginalAttrs = (element, attributes) => {
  if (!hasOriginalAttrs(element)) {
    return;
  }
  const originals = getOriginalAttrs(element);
  attributes.forEach((attribute) => {
    setOrResetAttribute(element, attribute, originals[attribute]);
  });
};
const restoreOriginalBgImage = (element) => {
  if (!hasOriginalAttrs(element)) {
    return;
  }
  const originals = getOriginalAttrs(element);
  element.style.backgroundImage = originals.backgroundImage;
};
const manageApplied = (element, settings, instance) => {
  addClass(element, settings.class_applied);
  setStatus(element, statusApplied);
  if (!instance)
    return;
  if (settings.unobserve_completed) {
    unobserve(element, settings);
  }
  safeCallback(settings.callback_applied, element, instance);
};
const manageLoading = (element, settings, instance) => {
  addClass(element, settings.class_loading);
  setStatus(element, statusLoading);
  if (!instance)
    return;
  updateLoadingCount(instance, 1);
  safeCallback(settings.callback_loading, element, instance);
};
const setAttributeIfValue = (element, attrName, value) => {
  if (!value) {
    return;
  }
  element.setAttribute(attrName, value);
};
const setImageAttributes = (element, settings) => {
  setAttributeIfValue(element, SIZES, getData(element, settings.data_sizes));
  setAttributeIfValue(element, SRCSET, getData(element, settings.data_srcset));
  setAttributeIfValue(element, SRC, getData(element, settings.data_src));
};
const setSourcesImg = (imgEl, settings) => {
  forEachPictureSource(imgEl, (sourceTag) => {
    setOriginalsObject(sourceTag, attrsSrcSrcsetSizes);
    setImageAttributes(sourceTag, settings);
  });
  setOriginalsObject(imgEl, attrsSrcSrcsetSizes);
  setImageAttributes(imgEl, settings);
};
const setSourcesIframe = (iframe, settings) => {
  setOriginalsObject(iframe, attrsSrc);
  setAttributeIfValue(iframe, SRC, getData(iframe, settings.data_src));
};
const setSourcesVideo = (videoEl, settings) => {
  forEachVideoSource(videoEl, (sourceEl) => {
    setOriginalsObject(sourceEl, attrsSrc);
    setAttributeIfValue(sourceEl, SRC, getData(sourceEl, settings.data_src));
  });
  setOriginalsObject(videoEl, attrsSrcPoster);
  setAttributeIfValue(videoEl, POSTER, getData(videoEl, settings.data_poster));
  setAttributeIfValue(videoEl, SRC, getData(videoEl, settings.data_src));
  videoEl.load();
};
const setBackground = (element, settings, instance) => {
  const bg1xValue = getData(element, settings.data_bg);
  const bgHiDpiValue = getData(element, settings.data_bg_hidpi);
  const bgDataValue = isHiDpi && bgHiDpiValue ? bgHiDpiValue : bg1xValue;
  if (!bgDataValue)
    return;
  element.style.backgroundImage = `url("${bgDataValue}")`;
  getTempImage(element).setAttribute(SRC, bgDataValue);
  manageLoading(element, settings, instance);
};
const setMultiBackground = (element, settings, instance) => {
  const bg1xValue = getData(element, settings.data_bg_multi);
  const bgHiDpiValue = getData(element, settings.data_bg_multi_hidpi);
  const bgDataValue = isHiDpi && bgHiDpiValue ? bgHiDpiValue : bg1xValue;
  if (!bgDataValue) {
    return;
  }
  element.style.backgroundImage = bgDataValue;
  manageApplied(element, settings, instance);
};
const setSourcesFunctions = {
  IMG: setSourcesImg,
  IFRAME: setSourcesIframe,
  VIDEO: setSourcesVideo
};
const setSourcesNative = (element, settings) => {
  const setSourcesFunction = setSourcesFunctions[element.tagName];
  if (!setSourcesFunction) {
    return;
  }
  setSourcesFunction(element, settings);
};
const setSources = (element, settings, instance) => {
  const setSourcesFunction = setSourcesFunctions[element.tagName];
  if (!setSourcesFunction) {
    return;
  }
  setSourcesFunction(element, settings);
  manageLoading(element, settings, instance);
};
const elementsWithLoadEvent = ["IMG", "IFRAME", "VIDEO"];
const hasLoadEvent = (element) => elementsWithLoadEvent.indexOf(element.tagName) > -1;
const checkFinish = (settings, instance) => {
  if (instance && !isSomethingLoading(instance) && !haveElementsToLoad(instance)) {
    safeCallback(settings.callback_finish, instance);
  }
};
const addEventListener = (element, eventName, handler) => {
  element.addEventListener(eventName, handler);
  element.llEvLisnrs[eventName] = handler;
};
const removeEventListener = (element, eventName, handler) => {
  element.removeEventListener(eventName, handler);
};
const hasEventListeners = (element) => {
  return !!element.llEvLisnrs;
};
const addEventListeners = (element, loadHandler2, errorHandler2) => {
  if (!hasEventListeners(element))
    element.llEvLisnrs = {};
  const loadEventName = element.tagName === "VIDEO" ? "loadeddata" : "load";
  addEventListener(element, loadEventName, loadHandler2);
  addEventListener(element, "error", errorHandler2);
};
const removeEventListeners = (element) => {
  if (!hasEventListeners(element)) {
    return;
  }
  const eventListeners = element.llEvLisnrs;
  for (let eventName in eventListeners) {
    const handler = eventListeners[eventName];
    removeEventListener(element, eventName, handler);
  }
  delete element.llEvLisnrs;
};
const doneHandler = (element, settings, instance) => {
  deleteTempImage(element);
  updateLoadingCount(instance, -1);
  decreaseToLoadCount(instance);
  removeClass(element, settings.class_loading);
  if (settings.unobserve_completed) {
    unobserve(element, instance);
  }
};
const loadHandler = (event, element, settings, instance) => {
  const goingNative = hasStatusNative(element);
  doneHandler(element, settings, instance);
  addClass(element, settings.class_loaded);
  setStatus(element, statusLoaded);
  safeCallback(settings.callback_loaded, element, instance);
  if (!goingNative)
    checkFinish(settings, instance);
};
const errorHandler = (event, element, settings, instance) => {
  const goingNative = hasStatusNative(element);
  doneHandler(element, settings, instance);
  addClass(element, settings.class_error);
  setStatus(element, statusError);
  safeCallback(settings.callback_error, element, instance);
  if (!goingNative)
    checkFinish(settings, instance);
};
const addOneShotEventListeners = (element, settings, instance) => {
  const elementToListenTo = getTempImage(element) || element;
  if (hasEventListeners(elementToListenTo)) {
    return;
  }
  const _loadHandler = (event) => {
    loadHandler(event, element, settings, instance);
    removeEventListeners(elementToListenTo);
  };
  const _errorHandler = (event) => {
    errorHandler(event, element, settings, instance);
    removeEventListeners(elementToListenTo);
  };
  addEventListeners(elementToListenTo, _loadHandler, _errorHandler);
};
const loadBackground = (element, settings, instance) => {
  addTempImage(element);
  addOneShotEventListeners(element, settings, instance);
  saveOriginalBackgroundStyle(element);
  setBackground(element, settings, instance);
  setMultiBackground(element, settings, instance);
};
const loadRegular = (element, settings, instance) => {
  addOneShotEventListeners(element, settings, instance);
  setSources(element, settings, instance);
};
const load = (element, settings, instance) => {
  if (hasLoadEvent(element)) {
    loadRegular(element, settings, instance);
  } else {
    loadBackground(element, settings, instance);
  }
};
const loadNative = (element, settings, instance) => {
  element.setAttribute("loading", "lazy");
  addOneShotEventListeners(element, settings, instance);
  setSourcesNative(element, settings);
  setStatus(element, statusNative);
};
const removeImageAttributes = (element) => {
  element.removeAttribute(SRC);
  element.removeAttribute(SRCSET);
  element.removeAttribute(SIZES);
};
const resetSourcesImg = (element) => {
  forEachPictureSource(element, (sourceTag) => {
    removeImageAttributes(sourceTag);
  });
  removeImageAttributes(element);
};
const restoreImg = (imgEl) => {
  forEachPictureSource(imgEl, (sourceEl) => {
    restoreOriginalAttrs(sourceEl, attrsSrcSrcsetSizes);
  });
  restoreOriginalAttrs(imgEl, attrsSrcSrcsetSizes);
};
const restoreVideo = (videoEl) => {
  forEachVideoSource(videoEl, (sourceEl) => {
    restoreOriginalAttrs(sourceEl, attrsSrc);
  });
  restoreOriginalAttrs(videoEl, attrsSrcPoster);
  videoEl.load();
};
const restoreIframe = (iframeEl) => {
  restoreOriginalAttrs(iframeEl, attrsSrc);
};
const restoreFunctions = {
  IMG: restoreImg,
  IFRAME: restoreIframe,
  VIDEO: restoreVideo
};
const restoreAttributes = (element) => {
  const restoreFunction = restoreFunctions[element.tagName];
  if (!restoreFunction) {
    restoreOriginalBgImage(element);
    return;
  }
  restoreFunction(element);
};
const resetClasses = (element, settings) => {
  if (hasEmptyStatus(element) || hasStatusNative(element)) {
    return;
  }
  removeClass(element, settings.class_entered);
  removeClass(element, settings.class_exited);
  removeClass(element, settings.class_applied);
  removeClass(element, settings.class_loading);
  removeClass(element, settings.class_loaded);
  removeClass(element, settings.class_error);
};
const restore = (element, settings) => {
  restoreAttributes(element);
  resetClasses(element, settings);
  resetStatus(element);
  deleteOriginalAttrs(element);
};
const cancelLoading = (element, entry, settings, instance) => {
  if (!settings.cancel_on_exit)
    return;
  if (!hasStatusLoading(element))
    return;
  if (element.tagName !== "IMG")
    return;
  removeEventListeners(element);
  resetSourcesImg(element);
  restoreImg(element);
  removeClass(element, settings.class_loading);
  updateLoadingCount(instance, -1);
  resetStatus(element);
  safeCallback(settings.callback_cancel, element, entry, instance);
};
const onEnter = (element, entry, settings, instance) => {
  const dontLoad = hadStartedLoading(element);
  setStatus(element, statusEntered);
  addClass(element, settings.class_entered);
  removeClass(element, settings.class_exited);
  unobserveEntered(element, settings, instance);
  safeCallback(settings.callback_enter, element, entry, instance);
  if (dontLoad)
    return;
  load(element, settings, instance);
};
const onExit = (element, entry, settings, instance) => {
  if (hasEmptyStatus(element))
    return;
  addClass(element, settings.class_exited);
  cancelLoading(element, entry, settings, instance);
  safeCallback(settings.callback_exit, element, entry, instance);
};
const tagsWithNativeLazy = ["IMG", "IFRAME", "VIDEO"];
const shouldUseNative = (settings) => settings.use_native && "loading" in HTMLImageElement.prototype;
const loadAllNative = (elements, settings, instance) => {
  elements.forEach((element) => {
    if (tagsWithNativeLazy.indexOf(element.tagName) === -1) {
      return;
    }
    loadNative(element, settings, instance);
  });
  setToLoadCount(instance, 0);
};
const isIntersecting = (entry) => entry.isIntersecting || entry.intersectionRatio > 0;
const getObserverSettings = (settings) => ({
  root: settings.container === document ? null : settings.container,
  rootMargin: settings.thresholds || settings.threshold + "px"
});
const intersectionHandler = (entries, settings, instance) => {
  entries.forEach((entry) => isIntersecting(entry) ? onEnter(entry.target, entry, settings, instance) : onExit(entry.target, entry, settings, instance));
};
const observeElements = (observer, elements) => {
  elements.forEach((element) => {
    observer.observe(element);
  });
};
const updateObserver = (observer, elementsToObserve) => {
  resetObserver(observer);
  observeElements(observer, elementsToObserve);
};
const setObserver = (settings, instance) => {
  if (!supportsIntersectionObserver || shouldUseNative(settings)) {
    return;
  }
  instance._observer = new IntersectionObserver((entries) => {
    intersectionHandler(entries, settings, instance);
  }, getObserverSettings(settings));
};
const toArray = (nodeSet) => Array.prototype.slice.call(nodeSet);
const queryElements = (settings) => settings.container.querySelectorAll(settings.elements_selector);
const excludeManagedElements = (elements) => toArray(elements).filter(hasEmptyStatus);
const hasError = (element) => hasStatusError(element);
const filterErrorElements = (elements) => toArray(elements).filter(hasError);
const getElementsToLoad = (elements, settings) => excludeManagedElements(elements || queryElements(settings));
const retryLazyLoad = (settings, instance) => {
  const errorElements = filterErrorElements(queryElements(settings));
  errorElements.forEach((element) => {
    removeClass(element, settings.class_error);
    resetStatus(element);
  });
  instance.update();
};
const setOnlineCheck = (settings, instance) => {
  if (!runningOnBrowser) {
    return;
  }
  window.addEventListener("online", () => {
    retryLazyLoad(settings, instance);
  });
};
const LazyLoad = function(customSettings, elements) {
  const settings = getExtendedSettings(customSettings);
  this._settings = settings;
  this.loadingCount = 0;
  setObserver(settings, this);
  setOnlineCheck(settings, this);
  this.update(elements);
};
LazyLoad.prototype = {
  update: function(givenNodeset) {
    const settings = this._settings;
    const elementsToLoad = getElementsToLoad(givenNodeset, settings);
    setToLoadCount(this, elementsToLoad.length);
    if (isBot || !supportsIntersectionObserver) {
      this.loadAll(elementsToLoad);
      return;
    }
    if (shouldUseNative(settings)) {
      loadAllNative(elementsToLoad, settings, this);
      return;
    }
    updateObserver(this._observer, elementsToLoad);
  },
  destroy: function() {
    if (this._observer) {
      this._observer.disconnect();
    }
    queryElements(this._settings).forEach((element) => {
      deleteOriginalAttrs(element);
    });
    delete this._observer;
    delete this._settings;
    delete this.loadingCount;
    delete this.toLoadCount;
  },
  loadAll: function(elements) {
    const settings = this._settings;
    const elementsToLoad = getElementsToLoad(elements, settings);
    elementsToLoad.forEach((element) => {
      unobserve(element, this);
      load(element, settings, this);
    });
  },
  restoreAll: function() {
    const settings = this._settings;
    queryElements(settings).forEach((element) => {
      restore(element, settings);
    });
  }
};
LazyLoad.load = (element, customSettings) => {
  const settings = getExtendedSettings(customSettings);
  load(element, settings);
};
LazyLoad.resetStatus = (element) => {
  resetStatus(element);
};
if (runningOnBrowser) {
  autoInitialize(LazyLoad, window.lazyLoadOptions);
}
class DocsViewer {
  constructor({ readonly, onNewPageIndex, onPlay }) {
    this._pages = [];
    this.pageIndex = 0;
    this.setPaused = () => {
      this.$btnPlay.classList.toggle(this.wrapClassName("footer-btn-playing"), false);
    };
    this.setPlaying = () => {
      this.$btnPlay.classList.toggle(this.wrapClassName("footer-btn-playing"), true);
    };
    this.namespace = "netless-app-slide";
    this.isShowPreview = false;
    this.isSmallBox = false;
    this.sideEffect = new o();
    this.readonly = readonly;
    this.onNewPageIndex = onNewPageIndex;
    this.onPlay = onPlay;
    this.render();
  }
  set pages(value) {
    this._pages = value;
    this.refreshPreview();
    this.refreshTotalPage();
    this.refreshBtnSidebar();
  }
  get pages() {
    return this._pages;
  }
  unmount() {
    this.$content.remove();
    this.$footer.remove();
  }
  setReadonly(readonly) {
    this.readonly = readonly;
    this.$content.classList.toggle(this.wrapClassName("readonly"), readonly);
    this.$footer.classList.toggle(this.wrapClassName("readonly"), readonly);
    this.$pageNumberInput.disabled = readonly;
  }
  destroy() {
    this.sideEffect.flushAll();
    this.unmount();
  }
  setPageIndex(pageIndex) {
    if (!Number.isNaN(pageIndex)) {
      this.pageIndex = pageIndex;
      this.$pageNumberInput.value = String(pageIndex + 1);
    }
  }
  refreshTotalPage() {
    if (this.pages.length) {
      this.$totalPage.textContent = " / " + this.pages.length;
    } else {
      this.$totalPage.textContent = "";
    }
  }
  setSmallBox(isSmallBox) {
    if (this.isSmallBox !== isSmallBox) {
      this.isSmallBox = isSmallBox;
      this.$footer.classList.toggle(this.wrapClassName("float-footer"), isSmallBox);
    }
  }
  render() {
    this.renderContent();
    this.renderFooter();
    return this.$content;
  }
  renderContent() {
    if (!this.$content) {
      const $content = document.createElement("div");
      $content.className = this.wrapClassName("content");
      this.$content = $content;
      if (this.readonly) {
        $content.classList.add(this.wrapClassName("readonly"));
      }
      $content.appendChild(this.renderPreviewMask());
      $content.appendChild(this.renderPreview());
    }
    return this.$content;
  }
  renderPreview() {
    if (!this.$preview) {
      const $preview = document.createElement("div");
      $preview.className = this.wrapClassName("preview") + " tele-fancy-scrollbar";
      this.$preview = $preview;
      this.sideEffect.add(() => {
        this.previewLazyLoad = new LazyLoad({
          container: this.$preview,
          elements_selector: `.${this.wrapClassName("preview-page>img")}`
        });
        return () => {
          var _a;
          return (_a = this.previewLazyLoad) == null ? void 0 : _a.destroy();
        };
      });
      this.refreshPreview();
      this.sideEffect.addEventListener($preview, "click", (ev) => {
        var _a;
        if (this.readonly) {
          return;
        }
        const pageIndex = (_a = ev.target.dataset) == null ? void 0 : _a.pageIndex;
        if (pageIndex) {
          ev.preventDefault();
          ev.stopPropagation();
          ev.stopImmediatePropagation();
          this.onNewPageIndex(Number(pageIndex));
          this.togglePreview(false);
        }
      });
    }
    return this.$preview;
  }
  refreshPreview() {
    var _a;
    const { $preview } = this;
    const pageClassName = this.wrapClassName("preview-page");
    const pageNameClassName = this.wrapClassName("preview-page-name");
    while ($preview.firstChild) {
      $preview.firstChild.remove();
    }
    this.pages.forEach((page, i) => {
      var _a2;
      const previewSRC = (_a2 = page.thumbnail) != null ? _a2 : page.src.startsWith("ppt") ? void 0 : page.src;
      if (!previewSRC) {
        return;
      }
      const pageIndex = String(i);
      const $page = document.createElement("a");
      $page.className = pageClassName + " " + this.wrapClassName(`preview-page-${i}`);
      $page.setAttribute("href", "#");
      $page.dataset.pageIndex = pageIndex;
      const $name = document.createElement("span");
      $name.className = pageNameClassName;
      $name.textContent = String(i + 1);
      $name.dataset.pageIndex = pageIndex;
      const $img = document.createElement("img");
      $img.width = page.width;
      $img.height = page.height;
      $img.dataset.src = previewSRC;
      $img.dataset.pageIndex = pageIndex;
      $page.appendChild($img);
      $page.appendChild($name);
      $preview.appendChild($page);
    });
    (_a = this.previewLazyLoad) == null ? void 0 : _a.update();
  }
  renderPreviewMask() {
    if (!this.$previewMask) {
      this.$previewMask = document.createElement("div");
      this.$previewMask.className = this.wrapClassName("preview-mask");
      this.sideEffect.addEventListener(this.$previewMask, "click", (ev) => {
        if (this.readonly) {
          return;
        }
        if (ev.target === this.$previewMask) {
          this.togglePreview(false);
        }
      });
    }
    return this.$previewMask;
  }
  refreshBtnSidebar() {
    this.$btnSidebar.style.display = this.pages.length > 0 ? "" : "none";
  }
  renderFooter() {
    if (!this.$footer) {
      const $footer = document.createElement("div");
      $footer.className = this.wrapClassName("footer");
      this.$footer = $footer;
      if (this.readonly) {
        $footer.classList.add(this.wrapClassName("readonly"));
      }
      if (this.isSmallBox) {
        $footer.classList.add(this.wrapClassName("float-footer"));
      }
      const $btnSidebar = this.renderFooterBtn("btn-sidebar", sidebarSVG(this.namespace));
      this.sideEffect.addEventListener($btnSidebar, "click", () => {
        if (this.readonly) {
          return;
        }
        this.togglePreview();
      });
      this.$btnSidebar = $btnSidebar;
      this.$btnSidebar.style.display = "none";
      this.$footer.appendChild($btnSidebar);
      const $pageJumps = document.createElement("div");
      $pageJumps.className = this.wrapClassName("page-jumps");
      const $btnPageBack = this.renderFooterBtn("btn-page-back", arrowLeftSVG(this.namespace));
      this.sideEffect.addEventListener($btnPageBack, "click", () => {
        if (this.readonly) {
          return;
        }
        this.onNewPageIndex(this.pageIndex - 1);
      });
      $pageJumps.appendChild($btnPageBack);
      if (this.onPlay) {
        const $btnPlay = this.renderFooterBtn("btn-page-play", playSVG(this.namespace), pauseSVG(this.namespace));
        this.$btnPlay = $btnPlay;
        this.sideEffect.addEventListener($btnPlay, "click", () => {
          if (this.readonly) {
            return;
          }
          this.setPlaying();
          if (this.onPlay) {
            this.onPlay();
          }
        });
        $pageJumps.appendChild($btnPlay);
      }
      const $btnPageNext = this.renderFooterBtn("btn-page-next", arrowRightSVG(this.namespace));
      this.sideEffect.addEventListener($btnPageNext, "click", () => {
        if (this.readonly) {
          return;
        }
        this.onNewPageIndex(this.pageIndex + 1);
      });
      $pageJumps.appendChild($btnPageNext);
      const $pageNumber = document.createElement("div");
      $pageNumber.className = this.wrapClassName("page-number");
      const $pageNumberInput = document.createElement("input");
      $pageNumberInput.className = this.wrapClassName("page-number-input");
      $pageNumberInput.value = String(this.pageIndex + 1);
      if (this.readonly) {
        $pageNumberInput.disabled = true;
      }
      this.$pageNumberInput = $pageNumberInput;
      this.sideEffect.addEventListener($pageNumberInput, "change", () => {
        if (this.readonly) {
          return;
        }
        if ($pageNumberInput.value) {
          this.onNewPageIndex(Number($pageNumberInput.value) - 1);
        }
      });
      const $totalPage = document.createElement("span");
      this.$totalPage = $totalPage;
      $pageNumber.appendChild($pageNumberInput);
      $pageNumber.appendChild($totalPage);
      this.$footer.appendChild($pageJumps);
      this.$footer.appendChild($pageNumber);
    }
    return this.$footer;
  }
  renderFooterBtn(className, $icon, $iconActive) {
    const $btn = document.createElement("button");
    $btn.className = this.wrapClassName("footer-btn") + " " + this.wrapClassName(className);
    $btn.appendChild($icon);
    if ($iconActive) {
      $btn.appendChild($iconActive);
    }
    return $btn;
  }
  togglePreview(isShowPreview) {
    this.isShowPreview = isShowPreview != null ? isShowPreview : !this.isShowPreview;
    this.$content.classList.toggle(this.wrapClassName("preview-active"), this.isShowPreview);
    if (this.isShowPreview) {
      const $previewPage = this.$preview.querySelector("." + this.wrapClassName(`preview-page-${this.pageIndex}`));
      if ($previewPage) {
        this.$preview.scrollTo({
          top: $previewPage.offsetTop - 16
        });
      }
    }
  }
  wrapClassName(className) {
    return `${this.namespace}-${className}`;
  }
}
const ClickThroughAppliances = new Set(["clicker"]);
class SlideDocsViewer {
  constructor({ box, view, mountSlideController, mountWhiteboard }) {
    this.slideController = null;
    this.isViewMounted = false;
    this.onError = ({ error }) => {
      this.viewer.setPaused();
      console.warn("[Slide] render error", error);
    };
    this.refreshPages = () => {
      if (this.slideController) {
        this.viewer.pages = createDocsViewerPages(this.slideController.slide);
        this.viewer.setPageIndex(this.getPageIndex(this.slideController.page));
        this.scaleDocsToFit();
      }
    };
    this.scaleDocsToFit = () => {
      if (this.slideController) {
        const { width, height } = this.slideController.slide;
        if (width && height) {
          this.whiteboardView.moveCameraToContain({
            originX: -width / 2,
            originY: -height / 2,
            width,
            height,
            animationMode: "immediately"
          });
          if (!this.isViewMounted) {
            this.isViewMounted = true;
            console.log("[Slide] mount whiteboard view");
            this.mountWhiteboard(this.$whiteboardView);
          }
        }
      }
    };
    this.onPlay = () => {
      if (this.slideController) {
        this.slideController.slide.nextStep();
      }
    };
    this.onNewPageIndex = (index) => {
      if (this.slideController) {
        this.slideController.jumpToPage(index + 1);
      }
    };
    this.sideEffect = new o();
    this.namespace = "netless-app-slide";
    this.box = box;
    this.whiteboardView = view;
    this.mountSlideController = mountSlideController;
    this.mountWhiteboard = mountWhiteboard;
    this.viewer = new DocsViewer({
      readonly: box.readonly,
      onNewPageIndex: this.onNewPageIndex,
      onPlay: this.onPlay
    });
    this.sideEffect.add(() => {
      const handler = (readonly) => {
        this.setReadonly(readonly);
      };
      box.events.on("readonly", handler);
      return () => box.events.off("readonly", handler);
    });
    this.render();
  }
  render() {
    this.viewer.$content.appendChild(this.renderSlideContainer());
    this.viewer.$content.appendChild(this.renderWhiteboardView());
    this.sideEffect.addEventListener(window, "keydown", (ev) => {
      if (this.box.focus && this.slideController) {
        switch (ev.key) {
          case "ArrowUp":
          case "ArrowLeft": {
            this.slideController.slide.prevStep();
            break;
          }
          case "ArrowRight":
          case "ArrowDown": {
            this.slideController.slide.nextStep();
            break;
          }
        }
      }
    });
  }
  renderSlideContainer() {
    if (!this.$slide) {
      const $slide = document.createElement("div");
      $slide.className = this.wrapClassName("slide");
      $slide.dataset.appKind = "Slide";
      this.$slide = $slide;
    }
    return this.$slide;
  }
  renderWhiteboardView() {
    if (!this.$whiteboardView) {
      this.$whiteboardView = document.createElement("div");
      this.$whiteboardView.className = this.wrapClassName("wb-view");
    }
    return this.$whiteboardView;
  }
  mount() {
    this.box.mountContent(this.viewer.$content);
    this.box.mountFooter(this.viewer.$footer);
    this.slideController = this.mountSlideController({
      anchor: this.$slide,
      onTransitionStart: this.viewer.setPlaying,
      onTransitionEnd: this.viewer.setPaused,
      onReady: this.refreshPages,
      onError: this.onError
    });
    this.scaleDocsToFit();
    this.sideEffect.add(() => {
      this.whiteboardView.callbacks.on("onSizeUpdated", this.scaleDocsToFit);
      return () => this.whiteboardView.callbacks.off("onSizeUpdated", this.scaleDocsToFit);
    });
    return this;
  }
  getPageIndex(page) {
    return (page > 0 ? page : 1) - 1;
  }
  unmount() {
    if (this.slideController) {
      this.slideController.destroy();
      this.slideController = null;
    }
    this.viewer.unmount();
    return this;
  }
  setReadonly(readonly) {
    this.viewer.setReadonly(readonly);
  }
  destroy() {
    this.sideEffect.flushAll();
    this.unmount();
    this.viewer.destroy();
  }
  toggleClickThrough(tool) {
    this.$whiteboardView.style.pointerEvents = !tool || ClickThroughAppliances.has(tool) ? "none" : "auto";
  }
  wrapClassName(className) {
    return `${this.namespace}-${className}`;
  }
}
var styles = ".netless-app-slide-content{position:relative;height:100%;overflow:hidden}.netless-app-slide-preview-mask{display:none;position:absolute;z-index:200;top:0;left:0;width:100%;height:100%}.netless-app-slide-preview{display:flex;flex-direction:column;align-items:center;position:absolute;z-index:300;top:0;left:0;width:33%;max-width:200px;height:100%;padding-top:10px;transform:translate(-100%);background:rgba(237,237,240,.9);box-shadow:inset -1px 0 #0000001c;transition:transform .4s}.netless-app-slide-preview-active .netless-app-slide-preview-mask{display:block}.netless-app-slide-preview-active .netless-app-slide-preview{transform:translate(0)}.netless-app-slide-preview-page{position:relative;display:block;width:55%;margin-bottom:10px;font-size:0;color:transparent;outline:none;border:7px solid transparent;border-radius:4px;transition:border-color .3s;user-select:none}.netless-app-slide-preview-page:hover,.netless-app-slide-preview-page.netless-app-slide-preview-page-active{border-color:#444e601a}.netless-app-slide-preview-page>img{width:100%;height:auto;box-sizing:border-box;border:1px solid rgba(0,0,0,.5);border-radius:1px;background-color:#fff;box-shadow:0 2px 8px #0000004d}.netless-app-slide-preview-page-name{position:absolute;top:1px;left:-10px;transform:translate(-100%);text-align:right;font-size:12px;color:#5f5f5f;user-select:none}.netless-app-slide-footer{box-sizing:border-box;height:26px;display:flex;align-items:center;padding:0 16px;border-top:1px solid #eeeef7;color:#191919}.netless-app-slide-float-footer{width:100%;min-height:26px;position:absolute;left:0;bottom:0;z-index:2000;background:rgba(249,249,252,.9);transition:opacity .4s}.netless-app-slide-footer-btn{box-sizing:border-box;width:26px;height:26px;font-size:0;margin:0;padding:3px;border:none;border-radius:1px;outline:none;color:currentColor;background:transparent;transition:background .4s;cursor:pointer;user-select:none;-webkit-tap-highlight-color:rgba(0,0,0,0)}.netless-app-slide-footer-btn:hover{background:rgba(237,237,240,.9)}@media (hover: none){.netless-app-slide-footer-btn:hover{background:transparent!important}}.netless-app-slide-footer-btn>svg{width:100%;height:100%}.netless-app-slide-footer-btn>svg:nth-of-type(2){display:none}.netless-app-slide-footer-btn.netless-app-slide-footer-btn-playing>svg:nth-of-type(1){display:none}.netless-app-slide-footer-btn.netless-app-slide-footer-btn-playing>svg:nth-of-type(2){display:initial}.netless-app-slide-footer-btn~.netless-app-slide-footer-btn{margin-left:15px}.netless-app-slide-page-jumps{flex:1;display:flex;justify-content:center;align-items:center}.netless-app-slide-page-number{margin-left:auto;font-size:13px;user-select:none;white-space:nowrap;word-break:keep-all}.netless-app-slide-page-number-input{border:none;outline:none;width:1.5em;margin:0;padding:0 2px;text-align:right;font-size:13px;line-height:1;font-weight:400;font-family:inherit;border-radius:2px;color:currentColor;background:transparent;transition:background .4s;user-select:text;-webkit-tap-highlight-color:rgba(0,0,0,0)}.netless-app-slide-page-number-input:hover,.netless-app-slide-page-number-input:focus,.netless-app-slide-page-number-input:active{background:#fff;box-shadow:#63636333 0 2px 8px}.netless-app-slide-readonly.netless-app-slide-footer{display:none}.telebox-color-scheme-dark .netless-app-slide-page-number-input{color:#a6a6a8}.telebox-color-scheme-dark .netless-app-slide-page-number-input:active,.telebox-color-scheme-dark .netless-app-slide-page-number-input:focus,.telebox-color-scheme-dark .netless-app-slide-page-number-input:hover{color:#222}.telebox-color-scheme-dark .netless-app-slide-footer{color:#a6a6a8;background:#2d2d33;border-top:none}.telebox-color-scheme-dark .netless-app-slide-footer-btn:hover{background:#212126}.telebox-color-scheme-dark .netless-app-slide-preview{background:rgba(50,50,50,.9)}.netless-app-slide-wb-view{position:absolute;top:0;left:0;width:100%;height:100%;z-index:100;overflow:hidden}.netless-app-slide-slide{width:100%;height:100%;display:flex;align-items:center;justify-content:center}.netless-app-slide-slide canvas{transform:scale(var(--netless-app-slide-scale, 1))}\n";
function previewSlide({
  container,
  taskId,
  url = DefaultUrl,
  debug = false
}) {
  if (!taskId) {
    throw new Error("[Slide] taskId is required");
  }
  container.style.cssText += `display:flex;flex-direction:column`;
  const previewer = new SlidePreviewer({ target: container });
  previewer.debug = !!debug;
  previewer.mount(taskId, url);
  return previewer;
}
class SlidePreviewer {
  constructor(config) {
    this.slide = null;
    this.debug = false;
    this.sideEffect = new o();
    this.ready = false;
    this.readyPromise = new Promise((resolve) => {
      this.resolveReady = () => {
        this.ready = true;
        resolve();
      };
    });
    this.onPageChanged = (page) => {
      this.viewer.setPageIndex(page - 1);
    };
    this.onTransitionStart = () => {
      this.viewer.setPlaying();
    };
    this.onTransitionEnd = () => {
      this.viewer.setPaused();
    };
    this.onError = ({ error }) => {
      this.viewer.setPaused();
      console.warn("[Slide] render error", error);
    };
    this.destroyed = false;
    this.refreshPages = () => {
      if (this.slide) {
        this.viewer.pages = createDocsViewerPages(this.slide);
        this.viewer.setPageIndex(this.getPageIndex(this.slide.slideState.currentSlideIndex));
      }
    };
    this.onPlay = () => {
      if (this.slide) {
        this.slide.nextStep();
      }
    };
    this.onNewPageIndex = (index) => {
      if (this.slide && this.slide.slideCount > 0) {
        this.slide.renderSlide(clamp$1(index + 1, 1, this.slide.slideCount));
      }
    };
    this.namespace = "netless-app-slide";
    this.target = config.target;
    this.bgColor = cachedGetBgColor(this.target);
    this.viewer = new DocsViewer({
      readonly: false,
      onNewPageIndex: this.onNewPageIndex,
      onPlay: this.onPlay
    });
    this.render();
  }
  render() {
    this.viewer.$content.appendChild(this.renderSlideContainer());
    this.sideEffect.addEventListener(window, "keydown", (ev) => {
      if (this.slide) {
        switch (ev.key) {
          case "ArrowUp":
          case "ArrowLeft": {
            this.slide.prevStep();
            break;
          }
          case "ArrowRight":
          case "ArrowDown": {
            this.slide.nextStep();
            break;
          }
        }
      }
    });
  }
  mount(taskId, url) {
    this.target.appendChild(this.renderStyle());
    this.target.appendChild(this.viewer.$content);
    this.target.appendChild(this.viewer.$footer);
    this.slide = new Slide.Slide({
      anchor: this.$slide,
      interactive: false,
      mode: "local",
      resize: true,
      controller: this.debug,
      renderOptions: {
        minFPS: 25,
        maxFPS: 30,
        autoFPS: true,
        autoResolution: true,
        transactionBgColor: this.bgColor
      }
    });
    this.registerEventListeners();
    this.slide.setResource(taskId, url);
    this.slide.renderSlide(1);
  }
  renderStyle() {
    const element = document.createElement("style");
    element.appendChild(document.createTextNode(styles));
    return element;
  }
  registerEventListeners() {
    if (!this.slide)
      return;
    const { slide } = this;
    slide.on(Slide.SLIDE_EVENTS.slideChange, this.onPageChanged);
    slide.on(Slide.SLIDE_EVENTS.renderStart, this.onTransitionStart);
    slide.on(Slide.SLIDE_EVENTS.renderEnd, this.onTransitionEnd);
    slide.on(Slide.SLIDE_EVENTS.mainSeqStepStart, this.onTransitionStart);
    slide.on(Slide.SLIDE_EVENTS.mainSeqStepEnd, this.onTransitionEnd);
    slide.on(Slide.SLIDE_EVENTS.renderError, this.onError);
    slide.on(Slide.SLIDE_EVENTS.renderEnd, this.resolveReady);
    this.readyPromise.then(this.refreshPages);
  }
  destroy() {
    this.sideEffect.flushAll();
    if (this.slide && !this.destroyed) {
      log("[Slide] destroy slide (once)");
      this.slide.destroy();
      this.destroyed = true;
    }
    this.viewer.destroy();
  }
  getPageIndex(page) {
    return (page > 0 ? page : 1) - 1;
  }
  renderSlideContainer() {
    if (!this.$slide) {
      const $slide = document.createElement("div");
      $slide.className = this.wrapClassName("slide");
      $slide.dataset.appKind = "Slide";
      this.$slide = $slide;
    }
    return this.$slide;
  }
  wrapClassName(className) {
    return `${this.namespace}-${className}`;
  }
}
const version = "0.0.52";
const SlideApp = {
  kind: "Slide",
  setup(context) {
    console.log("[Slide] setup @ " + version);
    if (context.getIsWritable()) {
      ensureAttributes(context, EmptyAttributes);
    }
    const attributes = context.getAttributes();
    if (!(attributes == null ? void 0 : attributes.taskId)) {
      throw new Error("[Slide] no taskId");
    }
    const view = context.getView();
    if (!view) {
      throw new Error("[Slide] no view, please set scenePath on addApp()");
    }
    view.disableCameraTransform = true;
    const box = context.getBox();
    box.mountStyles(styles);
    try {
      box.$content.dataset.appSlideVersion = version;
    } catch {
    }
    const baseScenePath = context.getInitScenePath();
    let docsViewer = null;
    const onPageChanged = (page) => {
      const room2 = context.getRoom();
      if (docsViewer && docsViewer.slideController) {
        let synced = false;
        if (room2 && context.getIsWritable()) {
          syncSceneWithSlide(room2, context, docsViewer.slideController.slide, baseScenePath);
          synced = true;
        }
        log("[Slide] page to", page, synced);
        docsViewer.viewer.setPageIndex(page - 1);
      }
    };
    const mountSlideController = (options) => {
      var _a, _b;
      const slideController = new SlideController(__spreadProps(__spreadValues({
        context
      }, options), {
        onPageChanged
      }));
      if (useFreezer)
        apps.set(context.appId, slideController);
      ((_a = logger.apps)[_b = context.appId] || (_a[_b] = {})).controller = slideController;
      slideController.readyPromise.then(options.onReady);
      return slideController;
    };
    docsViewer = new SlideDocsViewer({
      box,
      view,
      mountSlideController,
      mountWhiteboard: context.mountView.bind(context)
    });
    const room = context.getRoom();
    const sideEffect = new o();
    sideEffect.add(() => {
      var _a, _b, _c;
      ((_a = logger.apps)[_b = context.appId] || (_a[_b] = {})).context = context;
      logger.enable = ((_c = context.getAppOptions()) == null ? void 0 : _c.debug) || false;
      logger.level = "debug";
      return () => logger.dispose(context.appId);
    });
    if (room) {
      docsViewer.toggleClickThrough(room.state.memberState.currentApplianceName);
      sideEffect.add(() => {
        const onRoomStateChanged = (e2) => {
          if (e2.memberState && docsViewer) {
            docsViewer.toggleClickThrough(e2.memberState.currentApplianceName);
          }
        };
        room.callbacks.on("onRoomStateChanged", onRoomStateChanged);
        return () => room.callbacks.off("onRoomStateChanged", onRoomStateChanged);
      });
    }
    context.emitter.on("destroy", () => {
      log("[Slide]: destroy");
      if (useFreezer)
        apps.delete(context.appId);
      sideEffect.flushAll();
      if (docsViewer) {
        docsViewer.destroy();
        docsViewer = null;
      }
    });
    docsViewer.mount();
  }
};
export { DefaultUrl, FreezerLength, SlidePreviewer, addHooks, apps, SlideApp as default, previewSlide, version };
//# sourceMappingURL=main.es.js.map
