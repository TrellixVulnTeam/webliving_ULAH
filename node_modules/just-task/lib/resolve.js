"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const resolve_1 = require("resolve");
const path_1 = __importDefault(require("path"));
// It is important to keep this line like this:
// 1. it cannot be an import because TS will try to do type checks which isn't available in @types/yargs
// 2. this breaks a require.cache, which is needed because we need a new instance of yargs to check the config
//    - this is because of the timing of when tasks are defined vs when this resolve is called the first time
//      to figure out config path)
const yargsFn = require('yargs/yargs');
let resolvePaths = [__dirname];
/**
 * Add a path to the list used by `resolve()`.
 * @param pathName Path to add
 */
function addResolvePath(pathName) {
    resolvePaths.push(pathName);
}
exports.addResolvePath = addResolvePath;
/**
 * Reset the list of paths used by `resolve()`.
 */
function resetResolvePaths() {
    resolvePaths = [__dirname];
}
exports.resetResolvePaths = resetResolvePaths;
/**
 * Exported for testing only.
 * @private
 */
function _isFileNameLike(name) {
    return !!name && name.includes('.') && !name.includes('/') && !name.includes('\\');
}
exports._isFileNameLike = _isFileNameLike;
/**
 * Exported for testing only.
 * @private
 */
function _tryResolve(moduleName, basedir) {
    try {
        if (_isFileNameLike(moduleName)) {
            return resolve_1.sync(`./${moduleName}`, { basedir, preserveSymlinks: true });
        }
        else {
            return resolve_1.sync(moduleName, { basedir, preserveSymlinks: true });
        }
    }
    catch (e) {
        return null;
    }
}
exports._tryResolve = _tryResolve;
/**
 * Resolve a module. Resolution will be tried starting from `cwd`, the location of a config file
 * passed using the `--config` command line arg, and any paths added using `addResolvePath`.
 * @param moduleName Module name to resolve. Anything which appears to be a file name (contains .
 * and doesn't contain slashes) will be resolved relative to the working directory.
 * Other names will be resolved within node_modules.
 * @param cwd Working directory in which to start resolution. Defaults to `process.cwd()`.
 * @returns The module path, or null if the module can't be resolved.
 */
function resolve(moduleName, cwd) {
    if (!cwd) {
        cwd = process.cwd();
    }
    const configArg = yargsFn(process.argv.slice(1).filter(a => a !== '--help')).argv.config;
    const configFilePath = configArg ? path_1.default.resolve(path_1.default.dirname(configArg)) : undefined;
    const allResolvePaths = [cwd, ...(configFilePath ? [configFilePath] : []), ...resolvePaths];
    let resolved = null;
    for (const tryPath of allResolvePaths) {
        resolved = _tryResolve(moduleName, tryPath);
        if (resolved) {
            return resolved;
        }
    }
    return null;
}
exports.resolve = resolve;
/**
 * Resolve a module. Resolution will *only* be tried starting from `cwd` (does not respect
 * `--config` arg or `addResolvePath`).
 * @param moduleName Module name to resolve. Anything which appears to be a file name (contains .
 * and doesn't contain slashes) will be resolved relative to the working directory.
 * Other names will be resolved within node_modules.
 * @param cwd Working directory in which to start resolution. Defaults to `process.cwd()`.
 * @returns The module path, or null if the module can't be resolved.
 */
function resolveCwd(moduleName, cwd) {
    if (!cwd) {
        cwd = process.cwd();
    }
    return _tryResolve(moduleName, cwd);
}
exports.resolveCwd = resolveCwd;
