"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const mock_fs_1 = __importDefault(require("mock-fs"));
const yargs_1 = __importDefault(require("./__mocks__/yargs/yargs"));
const resolve_1 = require("../resolve");
describe('_isFileNameLike', () => {
    it('returns false for empty input', () => {
        expect(resolve_1._isFileNameLike('')).toBe(false);
        expect(resolve_1._isFileNameLike(undefined)).toBe(false);
        expect(resolve_1._isFileNameLike(null)).toBe(false);
    });
    it('returns true for filenames', () => {
        expect(resolve_1._isFileNameLike('.')).toBe(true);
        expect(resolve_1._isFileNameLike('.gitignore')).toBe(true);
        expect(resolve_1._isFileNameLike('foo.js')).toBe(true);
    });
    it('returns false for possible non-filenames', () => {
        expect(resolve_1._isFileNameLike('foo')).toBe(false);
    });
    it('returns false for names with separators', () => {
        expect(resolve_1._isFileNameLike('foo/bar')).toBe(false);
        expect(resolve_1._isFileNameLike('foo\\bar')).toBe(false);
        expect(resolve_1._isFileNameLike('foo/bar.txt')).toBe(false);
        expect(resolve_1._isFileNameLike('foo\\bar.txt')).toBe(false);
    });
});
describe('_tryResolve', () => {
    afterEach(() => {
        mock_fs_1.default.restore();
    });
    it('does not throw', () => {
        expect(resolve_1._tryResolve('foo', 'bar')).toBeNull();
        expect(resolve_1._tryResolve(undefined, undefined)).toBeNull();
    });
    it('does not recurse into child dirs', () => {
        mock_fs_1.default({
            a: { 'b.txt': '' }
        });
        expect(resolve_1._tryResolve('b.txt', process.cwd())).toBeNull();
    });
    it('resolves filename relative to basedir', () => {
        mock_fs_1.default({
            a: { 'b.txt': '' },
            'b.txt': '' // wrong
        });
        expect(resolve_1._tryResolve('b.txt', 'a')).toContain('a/b.txt');
    });
    it('resolves non-filename relative to node_modules in basedir', () => {
        mock_fs_1.default({
            a: {
                'b.js': '',
                // eslint-disable-next-line @typescript-eslint/camelcase
                node_modules: { 'b.js': '' } // right
            },
            // eslint-disable-next-line @typescript-eslint/camelcase
            node_modules: { 'b.js': '' } // wrong
        });
        expect(resolve_1._tryResolve('b', 'a')).toContain('a/node_modules/b.js');
    });
    it('resolves path with /', () => {
        mock_fs_1.default({
            // eslint-disable-next-line @typescript-eslint/camelcase
            a: { node_modules: { b: { 'c.js': '' } } }
        });
        expect(resolve_1._tryResolve('b/c', 'a')).toContain('a/node_modules/b/c.js');
    });
});
describe('resolveCwd', () => {
    afterEach(() => {
        mock_fs_1.default.restore();
        resolve_1.resetResolvePaths();
    });
    // Not testing this one extensively since it's basically a pass-through to _tryResolve
    it('defaults to searching relative to process cwd', () => {
        mock_fs_1.default({
            a: { 'b.txt': '' },
            'b.txt': '' // wrong
        });
        jest.spyOn(process, 'cwd').mockReturnValueOnce('a');
        expect(resolve_1.resolveCwd('b.txt')).toContain('a/b.txt');
    });
    it('uses provided cwd', () => {
        mock_fs_1.default({
            a: { 'b.txt': '' },
            'b.txt': '' // wrong
        });
        expect(resolve_1.resolveCwd('b.txt', 'a')).toContain('a/b.txt');
    });
    it('ignores resolvePaths', () => {
        mock_fs_1.default({
            a: { 'b.txt': '' }
        });
        resolve_1.addResolvePath('a');
        expect(resolve_1.resolveCwd('b.txt')).toBeNull();
    });
});
describe('resolve', () => {
    afterEach(() => {
        mock_fs_1.default.restore();
        yargs_1.default.argv.config = undefined;
        resolve_1.resetResolvePaths();
    });
    it('defaults to searching relative to process cwd', () => {
        mock_fs_1.default({
            a: { 'b.txt': '' },
            'b.txt': '' // wrong
        });
        jest.spyOn(process, 'cwd').mockReturnValueOnce('a');
        expect(resolve_1.resolve('b.txt')).toContain('a/b.txt');
    });
    it('uses provided cwd', () => {
        mock_fs_1.default({
            a: { 'b.txt': '' },
            'b.txt': '',
            c: { 'b.txt': '' }
        });
        expect(resolve_1.resolve('b.txt', 'a')).toContain('a/b.txt');
    });
    it('uses dirname of --config arg', () => {
        mock_fs_1.default({
            a: { 'b.txt': '' }
        });
        yargs_1.default.argv.config = 'a/just-task.js';
        expect(resolve_1.resolve('b.txt')).toContain('a/b.txt');
    });
    it('uses resolvePaths for file', () => {
        mock_fs_1.default({
            a: {},
            c: { 'b.txt': '' }
        });
        resolve_1.addResolvePath('a');
        resolve_1.addResolvePath('c');
        expect(resolve_1.resolve('b.txt')).toContain('c/b.txt');
    });
    it('prefers provided cwd', () => {
        mock_fs_1.default({
            a: { 'b.txt': '' },
            c: { 'b.txt': '' },
            d: { 'b.txt': '' },
            'b.txt': '' // wrong
        });
        yargs_1.default.argv.config = 'a/just-task.js';
        resolve_1.addResolvePath('c');
        expect(resolve_1.resolve('b.txt', 'd')).toContain('d/b.txt');
    });
});
