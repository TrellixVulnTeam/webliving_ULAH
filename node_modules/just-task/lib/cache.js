"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const package_deps_hash_1 = require("@microsoft/package-deps-hash");
const option_1 = require("./option");
const resolve_1 = require("./resolve");
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const just_task_logger_1 = require("just-task-logger");
const findDependents_1 = require("./package/findDependents");
const findGitRoot_1 = require("./package/findGitRoot");
const child_process_1 = require("child_process");
const cachedTask = [];
const CacheFileName = 'package-deps.json';
function registerCachedTask(taskName) {
    cachedTask.push(taskName);
}
exports.registerCachedTask = registerCachedTask;
function clearCache() {
    const cachePath = getCachePath();
    const cacheFile = path_1.default.join(cachePath, CacheFileName);
    if (fs_extra_1.default.existsSync(cacheFile)) {
        fs_extra_1.default.removeSync(cacheFile);
    }
}
exports.clearCache = clearCache;
function isCached(taskName) {
    if (cachedTask.indexOf(taskName) < 0) {
        return false;
    }
    const currentHash = getHash(taskName);
    const cachePath = getCachePath();
    const cacheFile = path_1.default.join(cachePath, CacheFileName);
    if (!fs_extra_1.default.existsSync(cacheFile)) {
        return false;
    }
    let shouldCache = false;
    try {
        const cachedHash = JSON.parse(fs_extra_1.default.readFileSync(path_1.default.join(cachePath, CacheFileName)).toString());
        // TODO: make a more robust comparison
        shouldCache = JSON.stringify(currentHash) === JSON.stringify(cachedHash);
    }
    catch (e) {
        just_task_logger_1.logger.warn('Invalid package-deps.json detected');
    }
    return shouldCache;
}
exports.isCached = isCached;
function saveCache(taskName) {
    if (cachedTask.indexOf(taskName) < 0) {
        return;
    }
    const cachePath = getCachePath();
    if (!fs_extra_1.default.pathExistsSync(cachePath)) {
        fs_extra_1.default.mkdirpSync(cachePath);
    }
    const cacheHash = getHash(taskName);
    if (cacheHash) {
        fs_extra_1.default.writeFileSync(path_1.default.join(cachePath, 'package-deps.json'), JSON.stringify(cacheHash, null, 2));
    }
}
exports.saveCache = saveCache;
function getPackageRootPath() {
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const packageJsonFilePath = resolve_1.resolveCwd('package.json');
    return path_1.default.dirname(packageJsonFilePath);
}
function getCachePath() {
    const rootPath = getPackageRootPath();
    return path_1.default.join(rootPath, 'node_modules/.just');
}
function getLockFileHashes() {
    const results = {};
    const lockFiles = ['shrinkwrap.yml', 'package-lock.json', 'yarn.lock', 'pnpmfile.js'];
    const gitRoot = findGitRoot_1.findGitRoot();
    const lsFileResults = child_process_1.spawnSync('git', ['ls-files', ...lockFiles], { cwd: gitRoot });
    if (lsFileResults.status !== 0) {
        return {};
    }
    const foundLockFiles = lsFileResults.stdout
        .toString()
        .split(/\n/)
        .map(l => l.trim());
    const hashResults = child_process_1.spawnSync('git', ['hash-object', ...foundLockFiles], { cwd: gitRoot });
    if (hashResults.status !== 0) {
        return {};
    }
    const hashes = hashResults.stdout
        .toString()
        .split(/\n/)
        .map(l => l.trim());
    foundLockFiles.forEach((foundLockFile, index) => {
        results[foundLockFile] = hashes[index];
    });
    return results;
}
function getHash(taskName) {
    just_task_logger_1.mark('cache:getHash');
    const args = __rest(option_1.argv(), []);
    const packageRootPath = getPackageRootPath();
    const packageDeps = package_deps_hash_1.getPackageDeps(packageRootPath);
    const lockFileHashes = getLockFileHashes();
    packageDeps.files = Object.assign({}, packageDeps.files, lockFileHashes);
    const hash = {
        args,
        taskName,
        hash: packageDeps,
        dependentHashTimestamps: getDependentHashTimestamps()
    };
    just_task_logger_1.logger.perf('cache:getHash');
    return hash;
}
function getDependentHashTimestamps() {
    just_task_logger_1.mark('cache:getDependentHashTimestamps');
    const dependentPkgPaths = findDependents_1.findDependents();
    const timestampsByPackage = {};
    for (const pkgDepInfo of dependentPkgPaths) {
        const pkgPath = pkgDepInfo.path;
        const depHashFile = path_1.default.join(pkgPath, 'node_modules/.just', CacheFileName);
        const depPackageJson = JSON.parse(fs_extra_1.default.readFileSync(path_1.default.join(pkgPath, 'package.json'), 'utf-8'));
        if (fs_extra_1.default.existsSync(depHashFile)) {
            const stat = fs_extra_1.default.statSync(depHashFile);
            timestampsByPackage[pkgDepInfo.name] = stat.mtimeMs;
        }
        else if (depPackageJson.scripts) {
            // always updated if no hash file is found for dependants
            timestampsByPackage[pkgDepInfo.name] = new Date().getTime();
        }
    }
    just_task_logger_1.logger.perf('cache:getDependentHashTimestamps');
    return timestampsByPackage;
}
